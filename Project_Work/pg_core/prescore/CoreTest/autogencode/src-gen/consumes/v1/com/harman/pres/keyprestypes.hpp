/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Wed Jul 05 14:50:50 IST 2017
*/
#ifndef V1_COM_HARMAN_PRES_keyprestypes_HPP_
#define V1_COM_HARMAN_PRES_keyprestypes_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace pres {

struct keyprestypes {
    /**
     * description: structure holding key details interested by a client for subsciption /
     *   unsubscription 	id - unique key id , refer keyinputpres.json 	keyStates -
     *   string based states interested in , refer keyinputpres.json
     */
    struct tKeyStates : CommonAPI::Struct<uint16_t, std::vector<std::string>> {
    	
    	tKeyStates() {
    	}
    	tKeyStates(const uint16_t &_id, const std::vector<std::string> &_keyStates)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _keyStates;
    	}
    	inline const uint16_t &getId() const { return std::get<0>(values_); }
    	inline void setId(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	inline const std::vector<std::string> &getKeyStates() const { return std::get<1>(values_); }
    	inline void setKeyStates(const std::vector<std::string> &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const tKeyStates& _other) const {
                return (getId() == _other.getId() && getKeyStates() == _other.getKeyStates());
        }
    	inline bool operator!=(const tKeyStates &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: structure holding key details interested by a client for subsciption /
     *   unsubscription + priority 	tKeyStates - check details above 	priority - This
     *   is to facilitate multiple clients to receive events based on a priority matrix
     *   		priority matrix needs to be decided a the project level and enabled in the
     *   cfg
     */
    struct tKeyPriority : CommonAPI::Struct<tKeyStates, uint16_t> {
    	
    	tKeyPriority() {
    	}
    	tKeyPriority(const tKeyStates &_keyStates, const uint16_t &_priority)
    	{
    		std::get<0>(values_) = _keyStates;
    		std::get<1>(values_) = _priority;
    	}
    	inline const tKeyStates &getKeyStates() const { return std::get<0>(values_); }
    	inline void setKeyStates(const tKeyStates &_value) { std::get<0>(values_) = _value; }
    	inline const uint16_t &getPriority() const { return std::get<1>(values_); }
    	inline void setPriority(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const tKeyPriority& _other) const {
                return (getKeyStates() == _other.getKeyStates() && getPriority() == _other.getPriority());
        }
    	inline bool operator!=(const tKeyPriority &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: structure holding key details which will be published to clients 	id - unique
     *   key id , refer keyinputpres.json 	keyStates - string based states , refer
     *   keyinputpres.json
     */
    static const CommonAPI::Serial TKEY_SERIAL = 0x32801E56;
    static const CommonAPI::Serial TROTARYKNOBKEY_SERIAL = 0x7BB0A707;
    
    struct tKey : CommonAPI::PolymorphicStruct {
    	static std::shared_ptr<tKey> create(CommonAPI::Serial _serial);
    	CommonAPI::Serial getSerial() const { return TKEY_SERIAL; }
    	
    	tKey() {
    	}
    	tKey(const uint16_t &_id, const std::string &_keyState)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _keyState;
    	}
    	template<class _Input>
    	void readValue(CommonAPI::InputStream<_Input> &_input, const CommonAPI::EmptyDeployment *_depl) {
    		_input.template readValue<CommonAPI::EmptyDeployment>(std::get<0>(values_));
    		_input.template readValue<CommonAPI::EmptyDeployment>(std::get<1>(values_));
    		switch (getSerial()) {
    		case TROTARYKNOBKEY_SERIAL:
    			static_cast<tRotaryKnobKey *>(this)->template readValue<_Input>(_input, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    
    	template<class _Input, class _Deployment>
    	void readValue(CommonAPI::InputStream<_Input> &_input, const _Deployment *_depl) {
    		_input.template readValue<>(std::get<0>(values_), std::get<0>(_depl->values_));
    		_input.template readValue<>(std::get<1>(values_), std::get<1>(_depl->values_));
    		switch (getSerial()) {
    		case TROTARYKNOBKEY_SERIAL:
    			static_cast<tRotaryKnobKey *>(this)->template readValue<>(_input, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    	template<class _Output>
    	void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
    		_output.writeType(std::get<0>(values_), _depl);
    		_output.writeType(std::get<1>(values_), _depl);
    		switch (getSerial()) {
    		case TROTARYKNOBKEY_SERIAL:
    			static_cast<tRotaryKnobKey *>(this)->template writeType<_Output>(_output, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    	template<class _Output, class _Deployment>
    	void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const _Deployment *_depl) {
    		_output.writeType(std::get<0>(values_), std::get<0>(_depl->values_));
    		_output.writeType(std::get<1>(values_), std::get<1>(_depl->values_));
    		switch (getSerial()) {
    		case TROTARYKNOBKEY_SERIAL:
    			static_cast<tRotaryKnobKey *>(this)->template writeType<_Output, _Deployment>(_output, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    
    	template<class _Output>
    	void writeValue(CommonAPI::OutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
    		_output.template writeValue<CommonAPI::EmptyDeployment>(std::get<0>(values_));
    		_output.template writeValue<CommonAPI::EmptyDeployment>(std::get<1>(values_));
    		switch (getSerial()) {
    		case TROTARYKNOBKEY_SERIAL:
    			static_cast<tRotaryKnobKey *>(this)->template writeValue<_Output>(_output, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    
    	template<class _Output, class _Deployment>
    	void writeValue(CommonAPI::OutputStream<_Output> &_output, const _Deployment *_depl) {
    		_output.template writeValue<>(std::get<0>(values_), std::get<0>(_depl->values_));
    		_output.template writeValue<>(std::get<1>(values_), std::get<1>(_depl->values_));
    		switch (getSerial()) {
    		case TROTARYKNOBKEY_SERIAL:
    			static_cast<tRotaryKnobKey *>(this)->template writeValue<>(_output, _depl);
    			break;
    		default:
    			break;
    		}
    	}
    	inline const uint16_t &getId() const { return std::get<0>(values_); }
    	inline void setId(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getKeyState() const { return std::get<1>(values_); }
    	inline void setKeyState(const std::string &_value) { std::get<1>(values_) = _value; }
    	
    	std::tuple<uint16_t, std::string> values_;
    	inline bool operator==(const tKey& _other) const {
                return (getId() == _other.getId() && getKeyState() == _other.getKeyState());
        }
    	inline bool operator!=(const tKey &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Extends the tKey 	steps - 0 to positive step values
     */
    struct tRotaryKnobKey : tKey {
    	CommonAPI::Serial getSerial() const { return TROTARYKNOBKEY_SERIAL; }
    	
    	tRotaryKnobKey() {
    	}
    	tRotaryKnobKey(const uint16_t &_id, const std::string &_keyState, const uint16_t &_steps)
    	: tKey(_id, _keyState)
    	{
    		std::get<0>(values_) = _steps;
    	}
    	template<class _Input>
    	void readValue(CommonAPI::InputStream<_Input> &_input, const CommonAPI::EmptyDeployment *_depl) {
    	    (void) _depl;
    		_input.template readValue<CommonAPI::EmptyDeployment>(std::get<0>(values_));
    	}
    
    	template<class _Input, class _Deployment>
    	void readValue(CommonAPI::InputStream<_Input> &_input, const _Deployment *_depl) {
    		_input.template readValue<>(std::get<0>(values_), std::get<2>(_depl->values_));
    	}
    	template<class _Output>
    	void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
    		_output.writeType(std::get<0>(values_), _depl);
    	}
    	template<class _Output, class _Deployment>
    	void writeType(CommonAPI::TypeOutputStream<_Output> &_output, const _Deployment *_depl) {
    		_output.writeType(std::get<0>(values_), std::get<2>(_depl->values_));
    	}
    
    	template<class _Output>
    	void writeValue(CommonAPI::OutputStream<_Output> &_output, const CommonAPI::EmptyDeployment *_depl) {
    	    (void) _depl;
    		_output.template writeValue<CommonAPI::EmptyDeployment>(std::get<0>(values_));
    	}
    
    	template<class _Output, class _Deployment>
    	void writeValue(CommonAPI::OutputStream<_Output> &_output, const _Deployment *_depl) {
    		_output.template writeValue<>(std::get<0>(values_), std::get<2>(_depl->values_));
    	}
    	inline const uint16_t &getSteps() const { return std::get<0>(values_); }
    	inline void setSteps(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	
    	std::tuple<uint16_t> values_;
    	inline bool operator==(const tRotaryKnobKey& _other) const {
                return (getId() == _other.getId() && getKeyState() == _other.getKeyState() && getSteps() == _other.getSteps());
        }
    	inline bool operator!=(const tRotaryKnobKey &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.pres.keyprestypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 1);
}

}; // struct keyprestypes

} // namespace pres
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
}


namespace std {
}


// Compatibility
namespace v1_1 = v1;

#endif // V1_COM_HARMAN_PRES_keyprestypes_HPP_
