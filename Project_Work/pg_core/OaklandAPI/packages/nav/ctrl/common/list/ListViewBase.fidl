/* 
   Harman/Becker Automotive GmbH
*/

package org.harman.nav.ctrl.common.list

import org.harman.nav.ctrl.CommonTypes.* from "../CommonTypes.fidl"
import org.harman.nav.ctrl.common.list.* from "../list/ListTypes.fidl"


<**
    @description : ListViewBase = This interface offers functions that implement a basic list concept 
    The basic idea of this inteface is the following:
    A client registers a view with a certain size n on a list with a dynamic size m. Please note: during 
    initial call, a view might be bigger than the underlying list. 
    The client uses index - so called ListTypes.ListKey to position the first element of a view to a certain
    element in the list. Please note: the ListKey value must be in a valid range between first (0) and last (m) element.
    Furthermore the client specifies it's anchor point. An anchor is more or less the stable entry in a view which - 
    even in case of a listupdate - stays at a permanent position in the view. It is used to guarantee a stable view
    in case of list changes (sorting changed, inserts/deletes) and furthermore allow a client to realize a smooth
    scrolling - if necessary. For better understanding see the following example: 
    There is a list of 30 elements and a view with a total of 4 entries. The view is positioned at entry 21, which 
    means the view shows the entries [21, 22, 23, 24]. The client specifies the anchor on 22. Now imagine an update 
    occurs (e.g. a new entry will get inserted between 17 and 18). The clients get notified by a broadcast that the
    ListTypes.ListKey of his anchor is now 23 (because the entry 22 is moved on index 23). 
    
    While the base list specifies how to navitation and create a view on a given list, the concrete implementation of 
    a list is responsible for providing the data of a view. This must be realized in the following manner: each
    concrete implementation must provide a getView() function which returns the entries of a current view, the absolute
    key/index of the view and the relative anchor position based on the view position. The provider
    of the list is responsible for providing always the correct elements of a list based on the anchor, the client
    has specified. 
    
    Special case handling: in some cases it might happen, that the specified anchor point get's removed from the list
    and therefore from the view. In this case the list implementation will behave like the following: If possible,
    the anchor will be replaced by the provider with the next element (successor) in the list. If this is not possible
    (anchor already pointed to the last element in list), the previous element (predecessor) is selected as new anchor.
    Anyway - the impact of an update on the anchor will be indicated by appropriate enum. 
**>
interface ListViewBase {
    
      version {
        major 1
        minor 0
    }   

	
     <**
        @description : get the current number of contained elements in the given list. 
    **>
    method getListSize {
        in {
            ListTypes.ListId list
        }
        out {
            ListTypes.ListSize size
        }
        error ListTypes.ListError
    }
    
     <**
        @description : create a new view to the mother array. 
        This view will be maintained until the client uses destroyView, 
        unsubscribes or service/proxy exit. 
        After creating a view the client must receive an update.
        Only one created view is allowed to modify the list entries.
        Please note: a valid usecase is to specify a viewSize which is 
        bigger than the inital list size
    **>
    method createView {
        in {

            <**
                @description : list to create the view upon.
            **>
            ListTypes.ListId list

            <**
                @description : individual size of the requested view. 
            **>
            ListTypes.ViewSize viewsize
           
        }
        out {

            <**
                @description : view identification used to distinguish several instances of a view for one client. 
                It is never changed by the service nor the client. This id is unique!
            **>
            ListTypes.ViewId view
        }
        error ListTypes.ListError
    }
    
     <**
        @description : delete the given view instance
    **>
    method deleteView {
        in {
            <**
                @description : identifies the view to apply this operation upon.
            **>
            ListTypes.ViewId view
        }
        error ListTypes.ListError
    }
    
    <**
        @description : adjust the view size. It is allowed to set view size to a larger value
        than the actual size of the list, but less or equal than the maximum size of the list. 
        The implementation may limit the maximum view size for resource reasons. 
        After adjusting the window size the client must receive an update.
    **>
    method setViewSize {
        in {
            <**
                @description : identifies the view to apply this operation upon.
            **>
            ListTypes.ViewId view

            <**
                @description : new view size
            **>
            ListTypes.ViewSize new_size
        }
        error ListTypes.ListError
    }
    
     <**
        @description : set the absolute view position to element key. 
        The client should use an available snapshot of a view to maintain focused elements 
        within the view if possible, and change the view position only if an 
        element to be focused is outside of the given view. A snapshot is generated whenever
        querying the data contained in a view. Together with that data, the ViewSnapshotPosition is provided.
        The initial snapshot of the view is always [0, min(viewSize-1, listSize-1)].
        When creating a new view snapshot, the last call of setViewPosition or setViewAnchor (whichever was the last one)
        will be the relevant information to reposition the new view snapshot. If setViewPosition was the last call,
        the view is moved such that the provided key refers to the absolute position on the current snapshot of the view.
        (This becomes important if the current view snapshot is outdated because the list has been updated.)

        The following rules are applied to set the position of the new view snapshot [newFrom, newTo], given a snapshot [from, to]:
        Let elem(k) denote the element at key k in the old snapshot and new(e) denote the key the element e will have 
        (would have if deleted) in the new snapshot (see also examples (1)-(3) below).
        (1) If key is less than from, then newFrom will be set to new(elem(from)) - (from-key).
        (2) If key is contained in [from, to], then newKey will be set to new(elem(key)).
        (3) If key is greater than to, then newFrom will be set to new(elem(to)) + (key-to).
        If any of these calculated values are out of the range of the list [0, listSize-1], they will be truncated to fit into the list.
        (Note that the resulting newFrom is always equal to key if the data wasn't updated, 
        but it doesn't have to be equal to key if the data was updated.)
        After setting the view position the anchor offset will automatically be set to 0.
        There are two special key values to allow scrolling to the top/bottom of the list, independently from the above rules:
        The key value 0xFFFE always positions the view to the top of the list.
        The key value 0xFFFF always positions the view to the bottom of the list.

        As an example for the case in which the data was updated:
        old list {"a", "b", "c", "d", "e", "f"} with view snapshot ["c", "d"] with viewSize 2 and viewKey 2
        new list {"b", "d", "f", "h", "j", "l"}
        (1) setViewPosition(0) => [from, to] is [2, 3], elem(from) is "c", new(elem(from)) is 1
                               => ["b", "d"] with ViewSnapshotPosition {listSize=6, listKey=0, anchorOffset=0}.
        (2) setViewPosition(3) => [from, to] is [2, 3], elem(key) is "d", new(elem(key)) is 1
                               => ["d", "f"] with ViewSnapshotPosition {listSize=6, listKey=1, anchorOffset=0}.
        (3) setViewPosition(4) => [from, to] is [2, 3], elem(to) is "d", new(elem(d)) is 1
                               => ["f", "h"] with ViewSnapshotPosition {listSize=6, listKey=2, anchorOffset=0}.
    **>
    method setViewPosition fireAndForget {
        in {

            <**
                @description : identifies the view to apply this operation upon.
            **>
            ListTypes.ViewId view

            <**
                @description : element to position the view upon, according to view policy.
            **>
            ListTypes.ListKey key
        }
    }

    <** 
        @description : set a stable element inside the current view snapshot.
        The client should use an available snapshot of a view to maintain focused elements 
        within the view if possible, and change the view position only if an 
        element to be focused is outside of the given view. A snapshot is generated whenever
        querying the data contained in a view. Together with that data, the ViewSnapshotPosition is provided.
        The initial snapshot of the view is always [0, min(viewSize-1, listSize-1)] with anchor offset 0.
        When creating a new view snapshot, the last call of setViewPosition or setViewAnchor (whichever was the last one)
        will be the relevant information to reposition the new view snapshot. If setViewAnchor was the last call,
        the anchor element of the old view snapshot is used for repositioning.
        (This method only needs to be used if the current view snapshot is outdated because the list has been updated.)

        The following rules are applied to set the position of the new view snapshot [newFrom, newTo], given a snapshot [from, to]
        and anchor offset aOff:
        Let elem(k) denote the element at key k in the old snapshot and new(e) denote the key the element e will have 
        (would have if deleted) in the new snapshot (see also examples below).
        newFrom is set to new(elem(from+aOff)) - aOff.
        If any of these calculated values are out of the range of the list [0, listSize-1], they will be truncated to fit into the list.
        As a consequence, whenever possible, the anchor element of the old snapshot will be at the same offset within the new snapshot.

        As an example for the case in which the data was updated:
        old list {"a", "b", "c", "d", "e", "f"} with view snapshot ["c", "d"] with viewSize 2 and viewKey 2
        new list {"b", "d", "f", "h", "j", "l"}
        setViewAnchor(0) => elem(from+aOff) is "c", new(elem(from+aOff)) is 1 ("c" would be inserted at index 1)
                         => ["d", "f"] with ViewSnapshotPosition {listSize=6, listKey=1, anchorOffset=0}.
        setViewAnchor(1) => elem(from+aOff) is "d", new(elem(from+aOff)) is 1
                         => ["b", "d"] with ViewSnapshotPosition {listSize=6, listKey=0, anchorOffset=1}.
    **>
    method setViewAnchor fireAndForget {
        in {

            <**
                @description : identifies the view to apply this operation upon.
            **>
            ListTypes.ViewId view

            <**
                @description: relative anchor position in the view, referenced from ListKey
                Please note: only positive values and 0 are allowed
            **>
            ListTypes.AnchorOffset anchor 
        }
    }
    
    <** @description: indicate to the client that the underlying list of a certain view has changed
        Whenever elements get inserted/removed or the content of element gets changed, the size 
        or the sorting order of a list might change. This might influence the current view and
        especially the position of the anchor element in the list. To allow a client to react on such
        changes in an approapriate manner, the viewUpdate broadcast will provide all necessary information
        to its client. 
        It is up to the client to reposition the view to its needs based on the provided information, 
        using the methods setViewPosition or setViewAnchor.
    **>
    broadcast viewUpdate
    {
        out {
            <** @description: unique identifier of a view **>
            ListTypes.ViewId  view
            <** @description: current size of the underlying list **>
            ListTypes.ListSize size
            <** @description: at least one element of the currently active view snapshot has changed **>
            Boolean viewChanged
            <** @description: at least one element of the list has changed (this might lead to a different new view snapshot) **>
            Boolean listChanged
        }
    }
    
    
    <**
        @description: informs the client about changes of the list size. 
    **>
    broadcast listSize {
        out {           
            <**
                @description: list id related to the list size update 
            **> 
            ListTypes.ListId id
             
            <**
                @description: changed list size information 
            **>         
            ListTypes.ListSize size
        }
    }
    
   
        
}

<**
    @description : This interface provides functionality to specify the sort order to views.
    Any interfaces using this interface building block must provide specification on which parts of list elements shall be used for sorting.
    The number of sort orders may be extended by inheritance of data type Order as well if needed. 
**>
interface ListViewSortOrder extends ListViewBase {
    version {
        major 1
        minor 0
    }
    
<**
		@description : getVersion = This method returns the API version implemented by the server application
	**>
	method getVersion {
		out {
			Version ^version
		}
	}
    <**
        @description : configure the sort order of a view instance. Changing the sort order of a view may trigger a view update.
    **>
    method setSortOrder {
        in {

            <**
                @description : identifies the view to apply this operation upon.
            **>
            ListTypes.ViewId view

            <**
                @description : the sort order to use for this view instance.
            **>
            ListTypes.SortOption order
        }
        error ListTypes.ListError
    }

    <**
        @description : retrieve the sort order of a view instance
    **>
    method getSortOrder {
        in {

            <**
                @description : identifies the view to apply this operation upon.
            **>
            ListTypes.ViewId view
        }
        out {

            <**
                @description : the sort order currently used for this view instance.
            **>
            ListTypes.SortOption order
        }
        error ListTypes.ListError
    }
    
    <**
        @description : remove all items which are related to the given List id.
    **>     
    method removeAll {
        in {
            <**
                @description : list to create the view upon.
            **>
            ListTypes.ListId list           
        }
        error ListTypes.ListError
    }

    <**
        @description : remove an item from a list
		@param: ListTypes.ViewId sourceViewId source view id, which is where this item is known from
		@param: ListTypes.ViewKey source item key, which identifies the item which shall be removed
		@param: ListTypes.destinationListId the list from which the item shall be removed
    **>   
    method removeItem {
        in {
            <**
                @description : source view id, which is where this item is known from.
            **>
            ListTypes.ViewId sourceViewId
            
            <**
                @description : source item key, which identifies the item which shall be removed.
            **>
            ListTypes.ViewKey sourceItemKey

			<**
				@description : the list from which the item shall be removed.
				               (If an invalid - with empty name - listId is provided, the item is removed
							   from the list on which the view is defined.)
			**>
			ListTypes.ListId destination
        }
        error ListTypes.ListError
    }
    
     <**
        @description : add a exsisting item to another list.        
        @param: ListTypes.ViewId sourceViewId, the source viewid of the to be added item
        @param: ListTypes.ViewKey sourceItemKey, the key within the given view of the to be added item
        @param: ListTypes.ListId destinationListId, the list where the item should be added.
    **>          
     method addItem {
        in {                                                                        
            <**
                @description : source view id which is where this source item comes from.
            **>
            ListTypes.ViewId sourceViewId
            
            <**
                @description : source item key which has to be added
            **>
            ListTypes.ViewKey sourceItemKey
            
            <**
                @description : destination list where this item place to
            **>
            ListTypes.ListId destinationListId      
            
        }
        error ListTypes.ListError
    }

}
