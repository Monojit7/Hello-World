package org.harman.nav.ctrl
	
import org.harman.nav.ctrl.CommonTypes.* from "../common/CommonTypes.fidl"
import org.harman.nav.ctrl.GuidanceTypes.* from "GuidanceTypes.fidl"
import org.harman.nav.ctrl.traffic.TrafficInformationTypes.* from "../traffic/TrafficInformationTypes.fidl"

<**
	@description : Guidance = This interface offers functions that implement the route-guidance functionality of a navigation system
**>

interface Guidance {
	version { major 0 minor 4 }

    <**
        @description : Information about the waypoints (destinations) along the route.
    **>
    attribute WaypointInfoList waypoints readonly


	<**
		@description : startGuidance = This method starts the guidance for a given route
	**>
	method startGuidance {
		in {
			<**
				@description : routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle routeHandle
		}
	}

	<**
		@description : stopGuidance = This method stops the guidance
	**>
	method stopGuidance {
	}

	<**
		@description : setVoiceGuidance = This method switch on/off the voice guidance
	**>
	method setVoiceGuidance {
		in {

			<**
				@description : activation of the voice guidance
			**>
			Boolean activate

			<**
				@description : kind of voice (to be defined)
			**>
			String voice
		}
	}

	<**
		@description : getGuidanceDetails = This method retrieves guidance information 
	**>
	method getGuidanceDetails {
		out {

			<**
				@description : voiceGuidance = if TRUE voice guidance is active
			**>
			Boolean voiceGuidance

			<**
				@description : vehicleOnTheRoad = if TRUE the vehicle is located on the road network
			**>
			Boolean vehicleOnTheRoad

			<**
				@description : isDestinationReached = if TRUE the destination has been reached
			**>
			Boolean isDestinationReached

			<**
				@description : maneuver = enum(INVALID,CRUISE,MANEUVER_APPEARED,PRE_ADVICE,ADVICE,PASSED, ... )
			**>
			ManueverPhase maneuver
		}
	}

	<**
		@description : playVoiceManeuver = This method plays or repeats the last voice guidance
	**>
	method playVoiceManeuver {
	}

	<**
		@description : getWaypointInformation = This method retrieves the information on the remaining way points of the route. A point can be the final destination as well as a stage defined by the user. The returned waypoints are ordered by their 'number'.
		@deprecated : Please use waypoints attribute
	**>
	method getWaypointInformation {
		in {

			<**
				@description : requestedNumberOfWaypoints = the number of requested waypoints. If 0, all waypoints will be returned.
			**>
			UInt16 requestedNumberOfWaypoints
		}
		out {

			<**
				@description : numberOfWaypoints = the number of retrieved waypoints(NOTE: the number corresponds to the number of elements in the array)
			**>
			UInt16 numberOfWaypoints
			tWaypointStruct [] waypointsList
		}
	}

	<**
		@description : getDestinationInformation = This method retrieves the information on the final destination
		@deprecated : Please use waypoints attribute and waypointTravelCostsChanged broadcast
	**>
	method getDestinationInformation {
		out {

			<**
				@description : offset = offset of the destination in meter from the beginning of the route
			**>
			UInt32 offset

			<**
				@description : travelTime = time to reach the destination in second
			**>
			UInt32 travelTime

			<**
				@description : direction = direction of the destination in degree relatively to the North. Range [0:360]
			**>
			Int32 direction

			<**
				@description : side = enum(LEFT,RIGHT,NOT_AVAILABLE)
			**>
			UInt16 side

			<**
				@description : timeZone = time zone of the destination. It is expressed as the time difference from the UTC in minutes
			**>
			Int16 timeZone

			<**
				@description : daylightSavingTime = daylight saving time of the destination. It is expressed as the time difference from the UTC in minutes
			**>
			Int16 daylightSavingTime
		}
	}

	<**
		@description : getManeuversList = This method retrieves the list of next maneuvers
      @deprecated : Please maneuverAvailable broadcast and 
	**>
	method getManeuversList {
		in {

			<**
				@description : requestedNumberOfManeuvers = the number of requested maneuvers
			**>
			UInt16 requestedNumberOfManeuvers

			<**
				@description : maneuverOffset = the offset of the first maneuver to retrieve
			**>
			UInt32 maneuverOffset
		}
		out {

			<**
				@description : numberOfManeuvers = the number of retrieved maneuvers
			**>
			UInt16 numberOfManeuvers
			
			Maneuver[] maneuversList
		}
	}

	<**
		@description : setRouteCalculationMode = This method configures the way the navigation application wants the navigation core to behave of reroute trigger
	**>
	method setRouteCalculationMode {
		in {
			<**
				@description : routeCalculationMode = enum(INVALID,ALL_MANUAL,ALL_AUTOMATIC,TRAFFIC_MANUAL,OFF_ROUTE_MANUAL)
			**>
			CalculationMode routeCalculationMode
		}
	}

	<**
		@description : skipNextManeuver = This method allows to jump behind the current maneuver
	**>
	method skipNextManeuver {
	}

	<**
		@description : getGuidanceStatus = This method retrieves the guidance status
	**>
	method getGuidanceStatus {
		out {

			<**
				@description : guidanceStatus = enum(INVALID,ACTIVE,INACTIVE)
			**>
			GuidanceStatus guidanceStatus

			<**
				@description : routeHandle = Active route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value. Should be ignored when guidanceStatus=INACTIVE
			**>
			Handle routeHandle
		}
	}

	<**
		@description : setVoiceGuidanceSettings = This method sets the voice guidance settings
	**>
	method setVoiceGuidanceSettings {
		in {

			<**
				@description : mode = enum(INVALID,DISABLED_PROMPT,AUTOMATIC_PROMPT,MANUAL_PROMPT, ... )
			**>
			PromptMode promptMode
		}
	}

	<**
		@description : getVoiceGuidanceSettings = This method returns the used voice guidance settings
	**>
	method getVoiceGuidanceSettings {
		out {

			<**
				@description : mode = enum(INVALID,DISABLED_PROMPT,AUTOMATIC_PROMPT,MANUAL_PROMPT, ... )
			**>
			PromptMode promptMode
		}
	}

	<**
		@description : pauseGuidance = This method diables display guidance on the map,
		voice guidance prompts and boradcast events of an active guidance.
		While paused, the guidance remains active in the background, and will recalculate 
		the route if the user diverts from the initial route.
		
		This method should be called when guidance is in active status.
	**>
    method pauseGuidance {
    }

	<**
		@description : pauseGuidance = This method resumes guidance from pasued state to normal state.
		When resumed, display guidance on the map and broadcasts events are enabled, and voice guidance
		prompts are resumed to the original state.
		
		This method should be called when guidance is in active status.
	**>
    method resumeGuidance {
    }

	<**
		@description : selectAlternativeTIRoute = This method selects the given route for semi dynamic rerouting. The routeHandle can be
	    the original guided route or the alternative route. 

		If the user selects the alternative route successfully, Guidance will broadcast the route handle via 
		guidanceStatusChanged.
	**>
	method selectAlternativeTIRoute {
		in {
			<**
				@description : routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value
			**>
			Handle routeHandle
		}
	}
 
	<**
		@description : vehicleLeftTheRoadNetwork = This signal is emitted when the vehicle exits from the road network
	**>
	broadcast vehicleLeftTheRoadNetwork {
	}

	<**
		@description : guidanceStatusChanged = This signal is emitted when the guidance status changes
	**>
	broadcast guidanceStatusChanged {
		out {

			<**
				@description : guidanceStatus = enum(INVALID,ACTIVE,INACTIVE)
			**>
			GuidanceStatus guidanceStatus

			<**
				@description : routeHandle = Active route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value. Should be ignored when guidanceStatus=INACTIVE.
			**>
			Handle routeHandle
		}
	}

	<**
		@description : waypointReached = This signal is emitted when the destination is reached
	**>
	broadcast waypointReached {
		out {

			<**
				@description : isDestination = flag. TRUE means that the way point is the destination
			**>
			Boolean isDestination
		}
	}

	<**
		@description : maneuverChanged = This signal is emitted each time a maneuver event is going
	**>
	broadcast maneuverChanged {
		out {

			<**
				@description : maneuver = enum(INVALID,CRUISE,MANEUVER_APPEARED,PRE_ADVICE,ADVICE,PASSED, ... )
			**>
			ManueverPhase maneuver
		}
	}

	<**
		@description : positionOnRouteChanged = This signal is emitted when the position on the route changes
	**>
	broadcast positionOnRouteChanged {
		out {

			<**
				@description : offsetOnRoute = the current offset on the route in meters from the beginning of the route
			**>
			UInt32 offsetOnRoute
		}
	}

	<**
		@description : vehicleLeftTheRoute = This signal is emitted when the vehicle has left the route
	**>
	broadcast vehicleLeftTheRoute {
	}

	<**
		@description : positionToRouteChanged = This signal is emitted when the vehicle is off-the-road network and either the heading or the distance (or both) to the closest point on the active route changes
	**>
	broadcast positionToRouteChanged {
		out {

			<**
				@description : distance = distance in meters to the closest point on the active route
			**>
			UInt32 distance

			<**
				@description : direction = direction in degrees relatively to the closest point on the active route. Range [0:360]
			**>
			Int32 direction
		}
	}

	<**
		@description : activeRouteChanged = This signal is emitted when the active route changes
	**>
	broadcast activeRouteChanged {
		out {

			<**
				@description : changeCause = enum(INVALID,TRAFFIC,OFF_ROUTE,MANUAL,...)
			**>
			RouteChangedCause changeCause
		}
	}
	
	<**
		@description : guidancePaused = This signal is emitted when guidance is paused
	**>
	broadcast guidancePaused {
	}

	<**
		@description : guidancePaused = This signal is emitted when guidance is resumed
	**>
	broadcast guidanceResumed {
	}

    <**
       @description: alternativeTIRouteAvailable = This signal is emitted when a better TI route is available
    **>
    broadcast alternativeTIRouteAvailable {
        out {
		    <**
		    	@description : costDifference = time and distance differences
		    **>
            CostDifference costDifference
			 
	        <**
	    	    @description : ids = ids of traffic messages causing the delay 
	        **>
            TMessageIds ids
        }
    }
    
    <**
       @description : alternativeTIRouteInvalidated = this signal is emitted when the alternative route is
       invalidated, ex. when the car passes the exit to the alternative route or a new alternative route is
       calculated.
    **>
    broadcast alternativeTIRouteInvalidated {
        out {
            <**
               @description : routeHandle = invalidated alternative route handle. Range(0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value.
            **>
        	Handle routeHandle
        } 	
    }

    <**
        @description : This broadcast is fired whenever a new maneuver group is a available
    **>
    broadcast maneuverAvailable {
        out {

            <**
                @description : A maneuver group usually consists of one maneuver. It conatins more than one maneuver just in case of combined/joined maneuvers.
            **>
            ManeuverGroup group
        }
    }

    <**
        @description : The maneuver phase has changed
    **>
    broadcast maneuverPhaseChanged {
        out {

            <**
                @description : The unique id of the maneuver that has changed
            **>
            UInt64 maneuverID

			<**
				@description : phase = enum(INVALID,CRUISE,MANEUVER_APPEARED,PRE_ADVICE,ADVICE,PASSED, ... )
			**>
			ManueverPhase phase
        }
    }

    <**
        @description : The travel costs to the maneuver have changed
    **>
    broadcast maneuverTravelCostsChanged {
        out {

            <**
                @description : The unique id of the maneuver that has changed
            **>
            UInt64 maneuverID

			<**
				@description : travel costs to the maneuver
			**>
            TravelCosts travelCosts
        }
    }
    
    <**
        @description : The travel costs to the waypoints have changed
    **>    
    broadcast waypointTravelCostsChanged {
    	out {
    		
			<**
				@description : travel costs to the waypoints
			**>
            WaypointCostsList waypointCostsList
    	}
    }
    
    <**
        @description : The lane guiding of the maneuver has changed
    **>
    broadcast laneGuidanceChanged {
        out {
            <**
                @description : The unique id of the maneuver that has been passed
            **>
            UInt64 maneuverID

            <**
                @description : The index of the laneGuidingInfo in ManeuverInfo.laneGuidings
            **>
            Int32 laneGuidanceIndex        	
        }    	
    }
}
