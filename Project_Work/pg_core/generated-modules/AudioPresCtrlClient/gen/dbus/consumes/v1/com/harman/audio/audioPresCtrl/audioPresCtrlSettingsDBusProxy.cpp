/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Oct 04 15:43:40 EDT 2016
*/
/**
 * description: This is a Common API DBUS settings interface of audio presentation controller
 *   for Orinoco 2.0
 * author: AYatheesh
 */
#include <v1/com/harman/audio/audioPresCtrl/audioPresCtrlSettingsDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createaudioPresCtrlSettingsDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<audioPresCtrlSettingsDBusProxy>(_address, _connection);
}

INITIALIZER(registeraudioPresCtrlSettingsDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		audioPresCtrlSettings::getInterface(),
		&createaudioPresCtrlSettingsDBusProxy);
}

audioPresCtrlSettingsDBusProxy::audioPresCtrlSettingsDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		fade_(*this, "onFadeAttributeChanged", "n", "getFadeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		balance_(*this, "onBalanceAttributeChanged", "n", "getBalanceAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		bass_(*this, "onBassAttributeChanged", "n", "getBassAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		mid_(*this, "onMidAttributeChanged", "n", "getMidAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		treble_(*this, "onTrebleAttributeChanged", "n", "getTrebleAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		equalizer_(*this, "onEqualizerAttributeChanged", "s", "getEqualizerAttribute", static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
		clarifi_(*this, "onClarifiAttributeChanged", "b", "getClarifiAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		loudness_(*this, "onLoudnessAttributeChanged", "b", "getLoudnessAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		aVCMode_(*this, "onAVCModeAttributeChanged", "q", "getAVCModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		auxOffsetGain_(*this, "onAuxOffsetGainAttributeChanged", "n", "getAuxOffsetGainAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		midLow_(*this, "onMidLowAttributeChanged", "n", "getMidLowAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		midHigh_(*this, "onMidHighAttributeChanged", "n", "getMidHighAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		a2dpOffsetGain_(*this, "onA2dpOffsetGainAttributeChanged", "n", "getA2dpOffsetGainAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		micGain_(*this, "onMicGainAttributeChanged", "n", "getMicGainAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		activeSrcMute_(*this, "onActiveSrcMuteAttributeChanged", "b", "getActiveSrcMuteAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		masterMute_(*this, "onMasterMuteAttributeChanged", "b", "getMasterMuteAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		micMuteStatus_(*this, "onMicMuteStatusAttributeChanged", "b", "getMicMuteStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		touchBeepSelection_(*this, "onTouchBeepSelectionAttributeChanged", "setTouchBeepSelectionAttribute", "s", "getTouchBeepSelectionAttribute", static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
		keypadBeepSelection_(*this, "onKeypadBeepSelectionAttributeChanged", "setKeypadBeepSelectionAttribute", "s", "getKeypadBeepSelectionAttribute", static_cast<CommonAPI::DBus::StringDeployment*>(nullptr))
,		volumeChange_(*this, "VolumeChange", "(qq)b", std::make_tuple(static_cast<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		sourceMuteState_(*this, "SourceMuteState", "qb", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)))
{
}

      audioPresCtrlSettingsDBusProxy::FadeAttribute& audioPresCtrlSettingsDBusProxy::getFadeAttribute() {
          return fade_;
      }
      audioPresCtrlSettingsDBusProxy::BalanceAttribute& audioPresCtrlSettingsDBusProxy::getBalanceAttribute() {
          return balance_;
      }
      audioPresCtrlSettingsDBusProxy::BassAttribute& audioPresCtrlSettingsDBusProxy::getBassAttribute() {
          return bass_;
      }
      audioPresCtrlSettingsDBusProxy::MidAttribute& audioPresCtrlSettingsDBusProxy::getMidAttribute() {
          return mid_;
      }
      audioPresCtrlSettingsDBusProxy::TrebleAttribute& audioPresCtrlSettingsDBusProxy::getTrebleAttribute() {
          return treble_;
      }
      audioPresCtrlSettingsDBusProxy::EqualizerAttribute& audioPresCtrlSettingsDBusProxy::getEqualizerAttribute() {
          return equalizer_;
      }
      audioPresCtrlSettingsDBusProxy::ClarifiAttribute& audioPresCtrlSettingsDBusProxy::getClarifiAttribute() {
          return clarifi_;
      }
      audioPresCtrlSettingsDBusProxy::LoudnessAttribute& audioPresCtrlSettingsDBusProxy::getLoudnessAttribute() {
          return loudness_;
      }
      audioPresCtrlSettingsDBusProxy::AVCModeAttribute& audioPresCtrlSettingsDBusProxy::getAVCModeAttribute() {
          return aVCMode_;
      }
      audioPresCtrlSettingsDBusProxy::AuxOffsetGainAttribute& audioPresCtrlSettingsDBusProxy::getAuxOffsetGainAttribute() {
          return auxOffsetGain_;
      }
      audioPresCtrlSettingsDBusProxy::MidLowAttribute& audioPresCtrlSettingsDBusProxy::getMidLowAttribute() {
          return midLow_;
      }
      audioPresCtrlSettingsDBusProxy::MidHighAttribute& audioPresCtrlSettingsDBusProxy::getMidHighAttribute() {
          return midHigh_;
      }
      audioPresCtrlSettingsDBusProxy::A2dpOffsetGainAttribute& audioPresCtrlSettingsDBusProxy::getA2dpOffsetGainAttribute() {
          return a2dpOffsetGain_;
      }
      audioPresCtrlSettingsDBusProxy::MicGainAttribute& audioPresCtrlSettingsDBusProxy::getMicGainAttribute() {
          return micGain_;
      }
      audioPresCtrlSettingsDBusProxy::ActiveSrcMuteAttribute& audioPresCtrlSettingsDBusProxy::getActiveSrcMuteAttribute() {
          return activeSrcMute_;
      }
      audioPresCtrlSettingsDBusProxy::MasterMuteAttribute& audioPresCtrlSettingsDBusProxy::getMasterMuteAttribute() {
          return masterMute_;
      }
      audioPresCtrlSettingsDBusProxy::MicMuteStatusAttribute& audioPresCtrlSettingsDBusProxy::getMicMuteStatusAttribute() {
          return micMuteStatus_;
      }
      audioPresCtrlSettingsDBusProxy::TouchBeepSelectionAttribute& audioPresCtrlSettingsDBusProxy::getTouchBeepSelectionAttribute() {
          return touchBeepSelection_;
      }
      audioPresCtrlSettingsDBusProxy::KeypadBeepSelectionAttribute& audioPresCtrlSettingsDBusProxy::getKeypadBeepSelectionAttribute() {
          return keypadBeepSelection_;
      }

audioPresCtrlSettingsDBusProxy::VolumeChangeEvent& audioPresCtrlSettingsDBusProxy::getVolumeChangeEvent() {
    return volumeChange_;
}
audioPresCtrlSettingsDBusProxy::SourceMuteStateEvent& audioPresCtrlSettingsDBusProxy::getSourceMuteStateEvent() {
    return sourceMuteState_;
}
    
    /**
     * description: This method is used to set absolute volume of presently playing source.  	If
     *   interrupt source is active, it changes the volume of active interrupt source
     *   	If no interrupts are active, it changes volume of Entertainment source.
     *   	(at)broadast VolumeChange
     */
    void audioPresCtrlSettingsDBusProxy::SetVolume(const uint16_t &_absoluteVolume, CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_absoluteVolume(_absoluteVolume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "SetVolume",
        "q",
deploy_absoluteVolume,
_internalCallStatus);
}
    /**
     * description: This method is used to set Volume of presently playing source where volume
     *   change is given in steps example -2 or +2 	(at)broadast VolumeChange
     */
    void audioPresCtrlSettingsDBusProxy::SetVolumeStep(const int16_t &_volumeStep, CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_volumeStep(_volumeStep, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "SetVolumeStep",
        "n",
deploy_volumeStep,
_internalCallStatus);
}
    /**
     * description: This method is used to set Volume of any source group 	(at)broadast VolumeChange
     */
    void audioPresCtrlSettingsDBusProxy::SetSourceVolume(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t> deploy_volume(_volume, static_cast<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetSourceVolume",
        "(qq)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_volume,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlSettingsDBusProxy::SetSourceVolumeAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume &_volume, SetSourceVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t> deploy_volume(_volume, static_cast<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetSourceVolume",
        "(qq)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_volume,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to get Volume of any source 	(at)return eAudioPresErrors
     */
    void audioPresCtrlSettingsDBusProxy::GetSourceVolume(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume &_volumeOfSource, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t> deploy_volumeOfSource(static_cast<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume,::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "GetSourceVolume",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID,
_internalCallStatus,
deploy_error,
deploy_volumeOfSource);
_error = deploy_error.getValue();
_volumeOfSource = deploy_volumeOfSource.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlSettingsDBusProxy::GetSourceVolumeAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, GetSourceVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t> deploy_volumeOfSource(static_cast<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume,::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "GetSourceVolume",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceVolumeDeployment_t> _volumeOfSource) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _volumeOfSource.getValue());
        },
        std::make_tuple(deploy_error, deploy_volumeOfSource));
    }
    /**
     * description: This method is used to toggle mute status of currently playing source
     *   	(at)attribute update ActiveSrcMute
     */
    void audioPresCtrlSettingsDBusProxy::ToggleActiveSrcMute(CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "ToggleActiveSrcMute",
        "",
_internalCallStatus);
}
    /**
     * description: This method is used to set mute status of any particular source 	(at)broadcast
     *   SourceMuteState
     */
    void audioPresCtrlSettingsDBusProxy::SetSourceMute(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, const bool &_mute, CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_mute(_mute, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "SetSourceMute",
        "qb",
deploy_sourceID, deploy_mute,
_internalCallStatus);
}
    /**
     * description: This method is used to toggle MIC mute status  	(at)attribute update
     *   MicMuteStatus
     */
    void audioPresCtrlSettingsDBusProxy::ToggleMicMute(CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "ToggleMicMute",
        "",
_internalCallStatus);
}
    /**
     * description: This method is used to get supported EQ preset, Touch tone list and keyboard
     *   tone list 	(at)return eAudioPresErrors
     */
    void audioPresCtrlSettingsDBusProxy::GetList(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption &_listType, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::ListItems &_list, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption, CommonAPI::EmptyDeployment> deploy_listType(_listType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::ListItems, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::ListItemsDeployment_t> deploy_list(static_cast<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::ListItemsDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::ListItems,::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::ListItemsDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "GetList",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_listType,
_internalCallStatus,
deploy_error,
deploy_list);
_error = deploy_error.getValue();
_list = deploy_list.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlSettingsDBusProxy::GetListAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption &_listType, GetListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption, CommonAPI::EmptyDeployment> deploy_listType(_listType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::ListItems, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::ListItemsDeployment_t> deploy_list(static_cast<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::ListItemsDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::ListItems,::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::ListItemsDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "GetList",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_listType,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::ListItems, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::ListItemsDeployment_t> _list) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _list.getValue());
        },
        std::make_tuple(deploy_error, deploy_list));
    }
    /**
     * description: This method is used to get mute status of any particular source 	(at)return
     *   eAudioPresErrors
     */
    void audioPresCtrlSettingsDBusProxy::GetSourceMute(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceId, bool &_mute, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment> deploy_sourceId(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_mute(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "GetSourceMute",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID,
_internalCallStatus,
deploy_error,
deploy_sourceId, deploy_mute);
_error = deploy_error.getValue();
_sourceId = deploy_sourceId.getValue();
_mute = deploy_mute.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlSettingsDBusProxy::GetSourceMuteAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, GetSourceMuteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment> deploy_sourceId(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_mute(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "GetSourceMute",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, CommonAPI::EmptyDeployment> _sourceId, CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> _mute) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _sourceId.getValue(), _mute.getValue());
        },
        std::make_tuple(deploy_error, deploy_sourceId, deploy_mute));
    }
    /**
     * description: This method is used to toggle mute status of complete system 	(at)attribute
     *   update MasterMute
     */
    void audioPresCtrlSettingsDBusProxy::ToggleMasterMute(CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "ToggleMasterMute",
        "",
_internalCallStatus);
}
    /**
     * description: This method is used to set audio settings attributes     You may pass a map of
     *   attributes rather than multiple calls.      For example , the balance and fade
     *   is always a combination 	(at)attribute update
     */
    void audioPresCtrlSettingsDBusProxy::setAudioAttribute(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::mAttribute &_attributesmap, CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::mAttribute, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::mAttributeDeployment_t> deploy_attributesmap(_attributesmap, static_cast<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::mAttributeDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::mAttribute, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::mAttributeDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "setAudioAttribute",
        "a{i(yv)}",
deploy_attributesmap,
_internalCallStatus);
}


void audioPresCtrlSettingsDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace audioPresCtrl
      } // namespace audio
      } // namespace harman
      } // namespace com
      } // namespace v1
