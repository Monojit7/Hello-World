/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Oct 04 15:43:40 EDT 2016
*/
/**
 * description: This is a Common API DBUS control interface of audio presentation controller
 *   for Orinoco 2.0
 * author: AYatheesh
 */
#ifndef V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_DBUS_PROXY_HPP_
#define V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_DBUS_PROXY_HPP_

#include <v1/com/harman/audio/audioPresCtrl/audioPresCtrlControlsProxyBase.hpp>
#include "v1/com/harman/audio/audioPresCtrl/audioPresCtrlControlsDBusDeployment.hpp"

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/DBus/DBusAddress.hpp>
#include <CommonAPI/DBus/DBusFactory.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/DBus/DBusAttribute.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

#include <string>

namespace v1 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

class audioPresCtrlControlsDBusProxy
    : virtual public audioPresCtrlControlsProxyBase, 
      virtual public CommonAPI::DBus::DBusProxy {
public:
    audioPresCtrlControlsDBusProxy(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection);

    virtual ~audioPresCtrlControlsDBusProxy() { }

    virtual ActiveAudioSourceAttribute& getActiveAudioSourceAttribute();
    virtual ActiveEntSrcAttribute& getActiveEntSrcAttribute();
    virtual EntSourceListAttribute& getEntSourceListAttribute();


    /**
     * description: This method is used to set audio entertainment sources 	(at)attribute update
     *   activeAudioSource and activeEntSrc
     */
    virtual void SetEntertainmentSrc(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> SetEntertainmentSrcAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, SetEntertainmentSrcAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is used to switch Audio Context to the source in the given group
     *   	Group needs to be first mentioned in the audiopres.cfg 	Project may choose
     *   any naming strategy as long as it doesnt conflict with another json key in the
     *   cfg 	(at)attribute update activeAudioSource and activeEntSrc if a source
     *   switch has happened 	(at)return eAudioPresErrors
     */
    virtual void SetSourceGroup(const std::string &_sourceGroupName, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> SetSourceGroupAsync(const std::string &_sourceGroupName, SetSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is used to toggle source in the source group 	SetSourceGroup needs
     *   to be invoked in order to select an active group 	(at)attribute update
     *   activeAudioSource and activeEntSrc if a source switch has happened 	(at)return
     *   eAudioPresErrors
     */
    virtual void ToggleInSourceGroup(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> ToggleInSourceGroupAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleInSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is used to toggle source in the order specified in
     *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
     *   toggleNextPreviousStrategy with value is defined , method return an error
     *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
     *   entertainment sources in a project 	(at)attribute update activeAudioSource and
     *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
     */
    virtual void ToggleSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> ToggleSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: to activate interrupt source with given SourceID 	Only touchbeep and keytouch
     *   srcs will be supported through requestinformationsource interface 	as these
     *   are the only sources that will be requested by HMIs 	Other sources will be
     *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
     *   for alt audio sources etc) 	Other sources are kept just so that HMI can track
     *   the active source through attribute activeAudioSource     	(at)return
     *   eAudioPresErrors
     */
    virtual void RequestInformationSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> RequestInformationSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, RequestInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: to deactivate interrupt source with given SourceID 	(at)return eAudioPresErrors
     */
    virtual void ReleaseInformationSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> ReleaseInformationSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, ReleaseInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info);


    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;

private:
   
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<ActiveAudioSourceAttribute>> activeAudioSource_;
    class DBusactiveEntSrc_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<ActiveEntSrcAttribute>> {
    public:
    template <typename... _A>
    	DBusactiveEntSrc_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<ActiveEntSrcAttribute>>(
    			_proxy, arguments...) {}
    };
    DBusactiveEntSrc_Attribute activeEntSrc_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<EntSourceListAttribute, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::EntSourceListDeployment_t>> entSourceList_;


};

} // namespace audioPresCtrl
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v1

#endif // V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_DBUS_PROXY_HPP_

