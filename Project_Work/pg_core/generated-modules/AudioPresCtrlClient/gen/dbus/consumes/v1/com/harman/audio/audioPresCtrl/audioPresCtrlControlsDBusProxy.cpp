/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Oct 04 15:43:40 EDT 2016
*/
/**
 * description: This is a Common API DBUS control interface of audio presentation controller
 *   for Orinoco 2.0
 * author: AYatheesh
 */
#include <v1/com/harman/audio/audioPresCtrl/audioPresCtrlControlsDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createaudioPresCtrlControlsDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<audioPresCtrlControlsDBusProxy>(_address, _connection);
}

INITIALIZER(registeraudioPresCtrlControlsDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		audioPresCtrlControls::getInterface(),
		&createaudioPresCtrlControlsDBusProxy);
}

audioPresCtrlControlsDBusProxy::audioPresCtrlControlsDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		activeAudioSource_(*this, "onActiveAudioSourceAttributeChanged", "q", "getActiveAudioSourceAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		activeEntSrc_(*this, "onActiveEntSrcAttributeChanged", "i", "getActiveEntSrcAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		entSourceList_(*this, "onEntSourceListAttributeChanged", "a{ii}", "getEntSourceListAttribute", static_cast<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::EntSourceListDeployment_t*>(nullptr))
{
}

      audioPresCtrlControlsDBusProxy::ActiveAudioSourceAttribute& audioPresCtrlControlsDBusProxy::getActiveAudioSourceAttribute() {
          return activeAudioSource_;
      }
      audioPresCtrlControlsDBusProxy::ActiveEntSrcAttribute& audioPresCtrlControlsDBusProxy::getActiveEntSrcAttribute() {
          return activeEntSrc_;
      }
      audioPresCtrlControlsDBusProxy::EntSourceListAttribute& audioPresCtrlControlsDBusProxy::getEntSourceListAttribute() {
          return entSourceList_;
      }

    
    /**
     * description: This method is used to set audio entertainment sources 	(at)attribute update
     *   activeAudioSource and activeEntSrc
     */
    void audioPresCtrlControlsDBusProxy::SetEntertainmentSrc(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetEntertainmentSrc",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceId,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::SetEntertainmentSrcAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, SetEntertainmentSrcAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetEntertainmentSrc",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to switch Audio Context to the source in the given group
     *   	Group needs to be first mentioned in the audiopres.cfg 	Project may choose
     *   any naming strategy as long as it doesnt conflict with another json key in the
     *   cfg 	(at)attribute update activeAudioSource and activeEntSrc if a source
     *   switch has happened 	(at)return eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::SetSourceGroup(const std::string &_sourceGroupName, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceGroupName(_sourceGroupName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetSourceGroup",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceGroupName,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::SetSourceGroupAsync(const std::string &_sourceGroupName, SetSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceGroupName(_sourceGroupName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetSourceGroup",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceGroupName,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to toggle source in the source group 	SetSourceGroup needs
     *   to be invoked in order to select an active group 	(at)attribute update
     *   activeAudioSource and activeEntSrc if a source switch has happened 	(at)return
     *   eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::ToggleInSourceGroup(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment> deploy_direction(_direction, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "ToggleInSourceGroup",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_direction,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::ToggleInSourceGroupAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleInSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment> deploy_direction(_direction, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "ToggleInSourceGroup",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_direction,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to toggle source in the order specified in
     *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
     *   toggleNextPreviousStrategy with value is defined , method return an error
     *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
     *   entertainment sources in a project 	(at)attribute update activeAudioSource and
     *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::ToggleSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment> deploy_direction(_direction, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "ToggleSource",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_direction,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::ToggleSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment> deploy_direction(_direction, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "ToggleSource",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_direction,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: to activate interrupt source with given SourceID 	Only touchbeep and keytouch
     *   srcs will be supported through requestinformationsource interface 	as these
     *   are the only sources that will be requested by HMIs 	Other sources will be
     *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
     *   for alt audio sources etc) 	Other sources are kept just so that HMI can track
     *   the active source through attribute activeAudioSource     	(at)return
     *   eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::RequestInformationSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "RequestInformationSource",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::RequestInformationSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, RequestInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "RequestInformationSource",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: to deactivate interrupt source with given SourceID 	(at)return eAudioPresErrors
     */
    void audioPresCtrlControlsDBusProxy::ReleaseInformationSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "ReleaseInformationSource",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlControlsDBusProxy::ReleaseInformationSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, ReleaseInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "ReleaseInformationSource",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }


void audioPresCtrlControlsDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace audioPresCtrl
      } // namespace audio
      } // namespace harman
      } // namespace com
      } // namespace v1
