/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Oct 04 15:43:40 EDT 2016
*/
/**
 * description: This is a Common API DBUS diagnostics interface of audio presentation
 *   controller for Orinoco 2.0
 * author: AYatheesh
 */
#include <v1/com/harman/audio/audioPresCtrl/audioPresCtrlDiagDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createaudioPresCtrlDiagDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<audioPresCtrlDiagDBusProxy>(_address, _connection);
}

INITIALIZER(registeraudioPresCtrlDiagDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		audioPresCtrlDiag::getInterface(),
		&createaudioPresCtrlDiagDBusProxy);
}

audioPresCtrlDiagDBusProxy::audioPresCtrlDiagDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
{
}


    
    /**
     * description: For diagnostic purpose to test one or multiple speakers 	(at)return
     *   eAudioPresErrors
     */
    void audioPresCtrlDiagDBusProxy::TestSpeakerOn(const uint16_t &_speakerMask, const std::string &_testToneName, const float &_frequency, const uint16_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_speakerMask(_speakerMask, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_testToneName(_testToneName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<float, CommonAPI::EmptyDeployment> deploy_frequency(_frequency, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<float, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "TestSpeakerOn",
        "qsdq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_speakerMask, deploy_testToneName, deploy_frequency, deploy_volume,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlDiagDBusProxy::TestSpeakerOnAsync(const uint16_t &_speakerMask, const std::string &_testToneName, const float &_frequency, const uint16_t &_volume, TestSpeakerOnAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_speakerMask(_speakerMask, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_testToneName(_testToneName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<float, CommonAPI::EmptyDeployment> deploy_frequency(_frequency, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<float, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "TestSpeakerOn",
        "qsdq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_speakerMask, deploy_testToneName, deploy_frequency, deploy_volume,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: For diagnostic purpose to turn OFF one or more speakers 	(at)return
     *   eAudioPresErrors
     */
    void audioPresCtrlDiagDBusProxy::TestMultiSpeakersOff(const uint16_t &_speakerMask, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_speakerMask(_speakerMask, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "TestMultiSpeakersOff",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_speakerMask,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlDiagDBusProxy::TestMultiSpeakersOffAsync(const uint16_t &_speakerMask, TestMultiSpeakersOffAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_speakerMask(_speakerMask, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "TestMultiSpeakersOff",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_speakerMask,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This function is used to play a sine signal with sine generator with special
     *   parameters.     (at)return eAudioPresErrors
     */
    void audioPresCtrlDiagDBusProxy::playSineTone(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType &_sampleRate, const int16_t &_frequency, const int16_t &_pauseTime, const int16_t &_pulseTime, const int16_t &_repeatCount, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType, CommonAPI::EmptyDeployment> deploy_sampleRate(_sampleRate, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_frequency(_frequency, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_pauseTime(_pauseTime, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_pulseTime(_pulseTime, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_repeatCount(_repeatCount, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "playSineTone",
        "innnn",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sampleRate, deploy_frequency, deploy_pauseTime, deploy_pulseTime, deploy_repeatCount,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlDiagDBusProxy::playSineToneAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType &_sampleRate, const int16_t &_frequency, const int16_t &_pauseTime, const int16_t &_pulseTime, const int16_t &_repeatCount, PlaySineToneAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType, CommonAPI::EmptyDeployment> deploy_sampleRate(_sampleRate, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_frequency(_frequency, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_pauseTime(_pauseTime, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_pulseTime(_pulseTime, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_repeatCount(_repeatCount, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "playSineTone",
        "innnn",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sampleRate, deploy_frequency, deploy_pauseTime, deploy_pulseTime, deploy_repeatCount,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This function is used to stop playing sine tone for diagnostics purpose    
     *   (at)return eAudioPresErrors
     */
    void audioPresCtrlDiagDBusProxy::StopSineTone(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "StopSineTone",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlDiagDBusProxy::StopSineToneAsync(StopSineToneAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "StopSineTone",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }


void audioPresCtrlDiagDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace audioPresCtrl
      } // namespace audio
      } // namespace harman
      } // namespace com
      } // namespace v1
