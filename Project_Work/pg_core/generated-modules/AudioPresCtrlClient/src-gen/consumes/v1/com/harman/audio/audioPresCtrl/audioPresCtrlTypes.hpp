/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Wed Sep 21 21:11:39 IST 2016
*/
#ifndef V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Types_HPP_
#define V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

struct audioPresCtrlTypes {
    typedef uint16_t SourceId;
    
    struct eEntertainmentSrcs : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SRC_TUNER_FM = 35,
            SRC_TUNER_AM = 36,
            SRC_TUNER_DAB = 37,
            SRC_TUNER_LW = 39,
            SRC_TUNER_MW = 40,
            SRC_TUNER_SW = 41,
            SRC_TUNER_WB = 42,
            SRC_TUNER_SDARS = 43,
            SRC_CDA = 45,
            SRC_DVDA = 48,
            SRC_DVDV = 50,
            SRC_USB1 = 55,
            SRC_USB2 = 56,
            SRC_SD_CARD = 57,
            SRC_AUDIO_AUX = 60,
            SRC_BT_A2DP1 = 65,
            SRC_ENT_UNKNOWN = 91
        };
        
        eEntertainmentSrcs() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SRC_TUNER_FM)) {}
        eEntertainmentSrcs(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SRC_TUNER_FM):
                case static_cast<int32_t>(Literal::SRC_TUNER_AM):
                case static_cast<int32_t>(Literal::SRC_TUNER_DAB):
                case static_cast<int32_t>(Literal::SRC_TUNER_LW):
                case static_cast<int32_t>(Literal::SRC_TUNER_MW):
                case static_cast<int32_t>(Literal::SRC_TUNER_SW):
                case static_cast<int32_t>(Literal::SRC_TUNER_WB):
                case static_cast<int32_t>(Literal::SRC_TUNER_SDARS):
                case static_cast<int32_t>(Literal::SRC_CDA):
                case static_cast<int32_t>(Literal::SRC_DVDA):
                case static_cast<int32_t>(Literal::SRC_DVDV):
                case static_cast<int32_t>(Literal::SRC_USB1):
                case static_cast<int32_t>(Literal::SRC_USB2):
                case static_cast<int32_t>(Literal::SRC_SD_CARD):
                case static_cast<int32_t>(Literal::SRC_AUDIO_AUX):
                case static_cast<int32_t>(Literal::SRC_BT_A2DP1):
                case static_cast<int32_t>(Literal::SRC_ENT_UNKNOWN):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eEntertainmentSrcs &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eEntertainmentSrcs &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eEntertainmentSrcs &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eEntertainmentSrcs &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eEntertainmentSrcs &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eEntertainmentSrcs &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eSourceAvailablity : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            A_UNKNOWN = 0,
            A_AVAILABLE = 1,
            A_UNAVAILABLE = 2,
            A_MAX = 3
        };
        
        eSourceAvailablity() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::A_UNKNOWN)) {}
        eSourceAvailablity(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::A_UNKNOWN):
                case static_cast<int32_t>(Literal::A_AVAILABLE):
                case static_cast<int32_t>(Literal::A_UNAVAILABLE):
                case static_cast<int32_t>(Literal::A_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eSourceAvailablity &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eSourceAvailablity &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eSourceAvailablity &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eSourceAvailablity &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eSourceAvailablity &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eSourceAvailablity &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef std::unordered_map<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSourceAvailablity, CommonAPI::EnumHasher<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs>> EntSourceList;
    
    struct eAudioPresErrors : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SUCCESS = 0,
            FAILURE = 1,
            INVALID_REQUEST = 2,
            SOURCE_UNAVAILABLE = 3,
            SOURCE_ALREADY_ACTIVE = 4
        };
        
        eAudioPresErrors() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SUCCESS)) {}
        eAudioPresErrors(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SUCCESS):
                case static_cast<int32_t>(Literal::FAILURE):
                case static_cast<int32_t>(Literal::INVALID_REQUEST):
                case static_cast<int32_t>(Literal::SOURCE_UNAVAILABLE):
                case static_cast<int32_t>(Literal::SOURCE_ALREADY_ACTIVE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eAudioPresErrors &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eAudioPresErrors &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eAudioPresErrors &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eAudioPresErrors &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eAudioPresErrors &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eAudioPresErrors &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eInterruptSrcs : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SRC_SERVICE_CALL = 1,
            SRC_MICROPHONE = 88,
            SRC_VOICERECORDER = 2,
            SRC_TTS = 4,
            SRC_NAV = 5,
            SRC_ETC_WARNING = 6,
            SRC_ETC_INFO = 7,
            SRC_TEL_HANDSFREE = 8,
            SRC_TEL_RINGING = 9,
            SRC_DIPO_PHONE = 10,
            SRC_DIPO_PHONE_RINGING = 11,
            SRC_DIPO_SIRI = 12,
            SRC_DIPO_ALT = 13,
            SRC_GAL_VOICE = 16,
            SRC_GAL_NAVI = 17,
            SRC_GAL_UI = 18,
            SRC_GAL_VR = 19,
            SRC_CARLIFE_NAVI = 22,
            SRC_CARLIFE_VR = 23,
            SRC_MIRRORLINK_VR = 24,
            SRC_TUNER_TA = 33,
            SRC_TUNER_DAB_TA = 34,
            SRC_TOUCHBEEP = 89,
            SRC_KEYPADTOUCH = 90,
            SRC_INTERRUPT_UNKNOWN = 92
        };
        
        eInterruptSrcs() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SRC_SERVICE_CALL)) {}
        eInterruptSrcs(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SRC_SERVICE_CALL):
                case static_cast<int32_t>(Literal::SRC_MICROPHONE):
                case static_cast<int32_t>(Literal::SRC_VOICERECORDER):
                case static_cast<int32_t>(Literal::SRC_TTS):
                case static_cast<int32_t>(Literal::SRC_NAV):
                case static_cast<int32_t>(Literal::SRC_ETC_WARNING):
                case static_cast<int32_t>(Literal::SRC_ETC_INFO):
                case static_cast<int32_t>(Literal::SRC_TEL_HANDSFREE):
                case static_cast<int32_t>(Literal::SRC_TEL_RINGING):
                case static_cast<int32_t>(Literal::SRC_DIPO_PHONE):
                case static_cast<int32_t>(Literal::SRC_DIPO_PHONE_RINGING):
                case static_cast<int32_t>(Literal::SRC_DIPO_SIRI):
                case static_cast<int32_t>(Literal::SRC_DIPO_ALT):
                case static_cast<int32_t>(Literal::SRC_GAL_VOICE):
                case static_cast<int32_t>(Literal::SRC_GAL_NAVI):
                case static_cast<int32_t>(Literal::SRC_GAL_UI):
                case static_cast<int32_t>(Literal::SRC_GAL_VR):
                case static_cast<int32_t>(Literal::SRC_CARLIFE_NAVI):
                case static_cast<int32_t>(Literal::SRC_CARLIFE_VR):
                case static_cast<int32_t>(Literal::SRC_MIRRORLINK_VR):
                case static_cast<int32_t>(Literal::SRC_TUNER_TA):
                case static_cast<int32_t>(Literal::SRC_TUNER_DAB_TA):
                case static_cast<int32_t>(Literal::SRC_TOUCHBEEP):
                case static_cast<int32_t>(Literal::SRC_KEYPADTOUCH):
                case static_cast<int32_t>(Literal::SRC_INTERRUPT_UNKNOWN):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eInterruptSrcs &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eInterruptSrcs &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eInterruptSrcs &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eInterruptSrcs &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eInterruptSrcs &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eInterruptSrcs &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eToggleDirection : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            PREVIOUS = 0,
            NEXT = 1
        };
        
        eToggleDirection() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::PREVIOUS)) {}
        eToggleDirection(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::PREVIOUS):
                case static_cast<int32_t>(Literal::NEXT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eToggleDirection &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eToggleDirection &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eToggleDirection &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eToggleDirection &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eToggleDirection &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eToggleDirection &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eUserOption : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            EQ_LIST = 0,
            TOUCH_BEEP_LIST = 1,
            KEYPAD_BEEP_LIST = 2
        };
        
        eUserOption() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::EQ_LIST)) {}
        eUserOption(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::EQ_LIST):
                case static_cast<int32_t>(Literal::TOUCH_BEEP_LIST):
                case static_cast<int32_t>(Literal::KEYPAD_BEEP_LIST):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eUserOption &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eUserOption &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eUserOption &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eUserOption &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eUserOption &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eUserOption &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct sSourceType : CommonAPI::Struct<eEntertainmentSrcs, eSourceAvailablity> {
    	
    	sSourceType() {
    	}
    	sSourceType(const eEntertainmentSrcs &_sourceID, const eSourceAvailablity &_availability)
    	{
    		std::get<0>(values_) = _sourceID;
    		std::get<1>(values_) = _availability;
    	}
    	/**
    	 * description: This is the ID of the source, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sourceID_e.
    	 */
    	inline const eEntertainmentSrcs &getSourceID() const { return std::get<0>(values_); }
    	inline void setSourceID(const eEntertainmentSrcs &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The availability of the source.
    	 */
    	inline const eSourceAvailablity &getAvailability() const { return std::get<1>(values_); }
    	inline void setAvailability(const eSourceAvailablity &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const sSourceType& _other) const {
                return (getSourceID() == _other.getSourceID() && getAvailability() == _other.getAvailability());
        }
    	inline bool operator!=(const sSourceType &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct sSourceVolume : CommonAPI::Struct<uint16_t, SourceId> {
    	
    	sSourceVolume() {
    	}
    	sSourceVolume(const uint16_t &_absoluteVolume, const SourceId &_sourceID)
    	{
    		std::get<0>(values_) = _absoluteVolume;
    		std::get<1>(values_) = _sourceID;
    	}
    	/**
    	 * description: Absolute volume of requested Source.
    	 */
    	inline const uint16_t &getAbsoluteVolume() const { return std::get<0>(values_); }
    	inline void setAbsoluteVolume(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the ID of the source, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sourceID_e.
    	 */
    	inline const SourceId &getSourceID() const { return std::get<1>(values_); }
    	inline void setSourceID(const SourceId &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const sSourceVolume& _other) const {
                return (getAbsoluteVolume() == _other.getAbsoluteVolume() && getSourceID() == _other.getSourceID());
        }
    	inline bool operator!=(const sSourceVolume &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct eSampleRateType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            RATE_11025 = 0,
            x0 = 1,
            RATE_22050 = 0,
            x1 = 3,
            RATE_44100 = 0,
            x2 = 5
        };
        
        eSampleRateType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::RATE_11025)) {}
        eSampleRateType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::RATE_11025):
                case static_cast<int32_t>(Literal::x0):
                //case static_cast<int32_t>(Literal::RATE_22050):
                case static_cast<int32_t>(Literal::x1):
                //case static_cast<int32_t>(Literal::RATE_44100):
                case static_cast<int32_t>(Literal::x2):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eSampleRateType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eSampleRateType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eSampleRateType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eSampleRateType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eSampleRateType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eSampleRateType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef std::vector<std::string> ListItems;
    
    struct eAudioAttribute : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            FADE = 0,
            BALANCE = 1,
            BASS = 2,
            MID = 3,
            TREBLE = 4,
            EQUALIZER = 5,
            CLARIFI = 6,
            LOUDNESS = 7,
            AVCMODE = 8,
            AUXOFFSETGAIN = 9,
            MIDLOW = 10,
            MIDHIGH = 11,
            A2DPOFFSET = 12,
            MICGAIN = 13,
            ACTIVESRC_MUTE = 14,
            MASTERMUTE = 15,
            MICMUTE = 16
        };
        
        eAudioAttribute() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::FADE)) {}
        eAudioAttribute(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::FADE):
                case static_cast<int32_t>(Literal::BALANCE):
                case static_cast<int32_t>(Literal::BASS):
                case static_cast<int32_t>(Literal::MID):
                case static_cast<int32_t>(Literal::TREBLE):
                case static_cast<int32_t>(Literal::EQUALIZER):
                case static_cast<int32_t>(Literal::CLARIFI):
                case static_cast<int32_t>(Literal::LOUDNESS):
                case static_cast<int32_t>(Literal::AVCMODE):
                case static_cast<int32_t>(Literal::AUXOFFSETGAIN):
                case static_cast<int32_t>(Literal::MIDLOW):
                case static_cast<int32_t>(Literal::MIDHIGH):
                case static_cast<int32_t>(Literal::A2DPOFFSET):
                case static_cast<int32_t>(Literal::MICGAIN):
                case static_cast<int32_t>(Literal::ACTIVESRC_MUTE):
                case static_cast<int32_t>(Literal::MASTERMUTE):
                case static_cast<int32_t>(Literal::MICMUTE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eAudioAttribute &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eAudioAttribute &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eAudioAttribute &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eAudioAttribute &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eAudioAttribute &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eAudioAttribute &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Holds possible data types of an attribute defined in settings fidl
     */
    typedef CommonAPI::Variant<int16_t, uint16_t, bool, std::string>  uAttributeValue;
    /**
     * description: map consisting of a type and value of attributes to be set
     */
    typedef std::unordered_map<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioAttribute, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::uAttributeValue, CommonAPI::EnumHasher<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioAttribute>> mAttribute;



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.audio.audioPresCtrl.audioPresCtrlTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 0);
}

}; // struct audioPresCtrlTypes

} // namespace audioPresCtrl
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
}


namespace std {
    //Hash for eAudioPresErrors
    template<>
    struct hash<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors> {
        inline size_t operator()(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors& eAudioPresErrors) const {
            return static_cast<int32_t>(eAudioPresErrors);
        }
    };
    //Hash for eEntertainmentSrcs
    template<>
    struct hash<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs> {
        inline size_t operator()(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs& eEntertainmentSrcs) const {
            return static_cast<int32_t>(eEntertainmentSrcs);
        }
    };
    //Hash for eInterruptSrcs
    template<>
    struct hash<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs> {
        inline size_t operator()(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs& eInterruptSrcs) const {
            return static_cast<int32_t>(eInterruptSrcs);
        }
    };
    //Hash for eSourceAvailablity
    template<>
    struct hash<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSourceAvailablity> {
        inline size_t operator()(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSourceAvailablity& eSourceAvailablity) const {
            return static_cast<int32_t>(eSourceAvailablity);
        }
    };
    //Hash for eToggleDirection
    template<>
    struct hash<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection> {
        inline size_t operator()(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection& eToggleDirection) const {
            return static_cast<int32_t>(eToggleDirection);
        }
    };
    //Hash for eUserOption
    template<>
    struct hash<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption> {
        inline size_t operator()(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption& eUserOption) const {
            return static_cast<int32_t>(eUserOption);
        }
    };
    //Hash for eSampleRateType
    template<>
    struct hash<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType> {
        inline size_t operator()(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType& eSampleRateType) const {
            return static_cast<int32_t>(eSampleRateType);
        }
    };
    //Hash for eAudioAttribute
    template<>
    struct hash<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioAttribute> {
        inline size_t operator()(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioAttribute& eAudioAttribute) const {
            return static_cast<int32_t>(eAudioAttribute);
        }
    };
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Types_HPP_
