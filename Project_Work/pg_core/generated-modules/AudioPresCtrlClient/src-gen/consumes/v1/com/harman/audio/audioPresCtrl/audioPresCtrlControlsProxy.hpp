/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Wed Sep 21 21:11:39 IST 2016
*/
/**
 * description: This is a Common API DBUS control interface of audio presentation controller
 *   for Orinoco 2.0
 * author: AYatheesh
 */
#ifndef V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_PROXY_HPP_
#define V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_PROXY_HPP_

#include <v1/com/harman/audio/audioPresCtrl/audioPresCtrlControlsProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

template <typename ... _AttributeExtensions>
class audioPresCtrlControlsProxy
    : virtual public audioPresCtrlControls, 
      virtual public audioPresCtrlControlsProxyBase,
      virtual public _AttributeExtensions... {
public:
    audioPresCtrlControlsProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~audioPresCtrlControlsProxy();

    typedef audioPresCtrlControls InterfaceType;


    /**
     * description: Attribute holding current ative audio source 		This will be updated on every
     *   audiosource change
     */
    /**
     * Returns the wrapper class that provides access to the attribute activeAudioSource.
     */
    virtual ActiveAudioSourceAttribute& getActiveAudioSourceAttribute() {
        return delegate_->getActiveAudioSourceAttribute();
    }
    /**
     * description: Attribute holding current ative entertainment source 		This will be updated on
     *   every audiosource change
     */
    /**
     * Returns the wrapper class that provides access to the attribute activeEntSrc.
     */
    virtual ActiveEntSrcAttribute& getActiveEntSrcAttribute() {
        return delegate_->getActiveEntSrcAttribute();
    }
    /**
     * description: Attribute holding list of entertainment sources with available status 		This
     *   will be update on a status change(available/unavailable/unknown) of any
     *   entertainment source
     */
    /**
     * Returns the wrapper class that provides access to the attribute entSourceList.
     */
    virtual EntSourceListAttribute& getEntSourceListAttribute() {
        return delegate_->getEntSourceListAttribute();
    }


    /**
     * description: This method is used to set audio entertainment sources 	(at)attribute update
     *   activeAudioSource and activeEntSrc
     * Calls SetEntertainmentSrc with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetEntertainmentSrc(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetEntertainmentSrc with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetEntertainmentSrcAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, SetEntertainmentSrcAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to switch Audio Context to the source in the given group
     *   	Group needs to be first mentioned in the audiopres.cfg 	Project may choose
     *   any naming strategy as long as it doesnt conflict with another json key in the
     *   cfg 	(at)attribute update activeAudioSource and activeEntSrc if a source
     *   switch has happened 	(at)return eAudioPresErrors
     * Calls SetSourceGroup with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetSourceGroup(const std::string &_sourceGroupName, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetSourceGroup with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetSourceGroupAsync(const std::string &_sourceGroupName, SetSourceGroupAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to toggle source in the source group 	SetSourceGroup needs
     *   to be invoked in order to select an active group 	(at)attribute update
     *   activeAudioSource and activeEntSrc if a source switch has happened 	(at)return
     *   eAudioPresErrors
     * Calls ToggleInSourceGroup with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ToggleInSourceGroup(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls ToggleInSourceGroup with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ToggleInSourceGroupAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleInSourceGroupAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to toggle source in the order specified in
     *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
     *   toggleNextPreviousStrategy with value is defined , method return an error
     *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
     *   entertainment sources in a project 	(at)attribute update activeAudioSource and
     *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
     * Calls ToggleSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ToggleSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls ToggleSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ToggleSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: to activate interrupt source with given SourceID 	Only touchbeep and keytouch
     *   srcs will be supported through requestinformationsource interface 	as these
     *   are the only sources that will be requested by HMIs 	Other sources will be
     *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
     *   for alt audio sources etc) 	Other sources are kept just so that HMI can track
     *   the active source through attribute activeAudioSource     	(at)return
     *   eAudioPresErrors
     * Calls RequestInformationSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void RequestInformationSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls RequestInformationSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> RequestInformationSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, RequestInformationSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: to deactivate interrupt source with given SourceID 	(at)return eAudioPresErrors
     * Calls ReleaseInformationSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ReleaseInformationSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls ReleaseInformationSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ReleaseInformationSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, ReleaseInformationSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<audioPresCtrlControlsProxyBase> delegate_;
};

typedef audioPresCtrlControlsProxy<> audioPresCtrlControlsProxyDefault;

namespace audioPresCtrlControlsExtensions {
    /**
     * description: Attribute holding current ative audio source 		This will be updated on every
     *   audiosource change
     */
    template <template <typename > class _ExtensionType>
    class ActiveAudioSourceAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlControlsProxyBase::ActiveAudioSourceAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlControlsProxyBase::ActiveAudioSourceAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ActiveAudioSourceAttributeExtension() {}
    #endif
    
        ActiveAudioSourceAttributeExtension(audioPresCtrlControlsProxyBase& proxy): attributeExtension_(proxy.getActiveAudioSourceAttribute()) {
        }
    
        inline extension_type& getActiveAudioSourceAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding current ative entertainment source 		This will be updated on
     *   every audiosource change
     */
    template <template <typename > class _ExtensionType>
    class ActiveEntSrcAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlControlsProxyBase::ActiveEntSrcAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlControlsProxyBase::ActiveEntSrcAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ActiveEntSrcAttributeExtension() {}
    #endif
    
        ActiveEntSrcAttributeExtension(audioPresCtrlControlsProxyBase& proxy): attributeExtension_(proxy.getActiveEntSrcAttribute()) {
        }
    
        inline extension_type& getActiveEntSrcAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding list of entertainment sources with available status 		This
     *   will be update on a status change(available/unavailable/unknown) of any
     *   entertainment source
     */
    template <template <typename > class _ExtensionType>
    class EntSourceListAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlControlsProxyBase::EntSourceListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlControlsProxyBase::EntSourceListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EntSourceListAttributeExtension() {}
    #endif
    
        EntSourceListAttributeExtension(audioPresCtrlControlsProxyBase& proxy): attributeExtension_(proxy.getEntSourceListAttribute()) {
        }
    
        inline extension_type& getEntSourceListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace audioPresCtrlControlsExtensions

//
// audioPresCtrlControlsProxy Implementation
//
template <typename ... _AttributeExtensions>
audioPresCtrlControlsProxy<_AttributeExtensions...>::audioPresCtrlControlsProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<audioPresCtrlControlsProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<audioPresCtrlControlsProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
audioPresCtrlControlsProxy<_AttributeExtensions...>::~audioPresCtrlControlsProxy() {
}

/**
 * description: This method is used to set audio entertainment sources 	(at)attribute update
 *   activeAudioSource and activeEntSrc
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::SetEntertainmentSrc(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_sourceId.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->SetEntertainmentSrc(_sourceId, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::SetEntertainmentSrcAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, SetEntertainmentSrcAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_sourceId.validate()) {
        ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->SetEntertainmentSrcAsync(_sourceId, _callback, _info);
}
/**
 * description: This method is used to switch Audio Context to the source in the given group
 *   	Group needs to be first mentioned in the audiopres.cfg 	Project may choose
 *   any naming strategy as long as it doesnt conflict with another json key in the
 *   cfg 	(at)attribute update activeAudioSource and activeEntSrc if a source
 *   switch has happened 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::SetSourceGroup(const std::string &_sourceGroupName, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SetSourceGroup(_sourceGroupName, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::SetSourceGroupAsync(const std::string &_sourceGroupName, SetSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetSourceGroupAsync(_sourceGroupName, _callback, _info);
}
/**
 * description: This method is used to toggle source in the source group 	SetSourceGroup needs
 *   to be invoked in order to select an active group 	(at)attribute update
 *   activeAudioSource and activeEntSrc if a source switch has happened 	(at)return
 *   eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::ToggleInSourceGroup(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_direction.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->ToggleInSourceGroup(_direction, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::ToggleInSourceGroupAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleInSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_direction.validate()) {
        ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->ToggleInSourceGroupAsync(_direction, _callback, _info);
}
/**
 * description: This method is used to toggle source in the order specified in
 *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
 *   toggleNextPreviousStrategy with value is defined , method return an error
 *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
 *   entertainment sources in a project 	(at)attribute update activeAudioSource and
 *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::ToggleSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_direction.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->ToggleSource(_direction, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::ToggleSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_direction.validate()) {
        ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->ToggleSourceAsync(_direction, _callback, _info);
}
/**
 * description: to activate interrupt source with given SourceID 	Only touchbeep and keytouch
 *   srcs will be supported through requestinformationsource interface 	as these
 *   are the only sources that will be requested by HMIs 	Other sources will be
 *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
 *   for alt audio sources etc) 	Other sources are kept just so that HMI can track
 *   the active source through attribute activeAudioSource     	(at)return
 *   eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::RequestInformationSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_sourceID.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->RequestInformationSource(_sourceID, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::RequestInformationSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, RequestInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_sourceID.validate()) {
        ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->RequestInformationSourceAsync(_sourceID, _callback, _info);
}
/**
 * description: to deactivate interrupt source with given SourceID 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::ReleaseInformationSource(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_sourceID.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->ReleaseInformationSource(_sourceID, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::ReleaseInformationSourceAsync(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, ReleaseInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_sourceID.validate()) {
        ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->ReleaseInformationSourceAsync(_sourceID, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &audioPresCtrlControlsProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool audioPresCtrlControlsProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool audioPresCtrlControlsProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& audioPresCtrlControlsProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& audioPresCtrlControlsProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace audioPresCtrl
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v1::com::harman::audio::audioPresCtrl::audioPresCtrlControlsProxy,
    _AttributeExtension> {
    typedef typename ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlControlsProxy<
            ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlControlsExtensions::ActiveAudioSourceAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlControlsExtensions::ActiveEntSrcAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlControlsExtensions::EntSourceListAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_PROXY_HPP_
