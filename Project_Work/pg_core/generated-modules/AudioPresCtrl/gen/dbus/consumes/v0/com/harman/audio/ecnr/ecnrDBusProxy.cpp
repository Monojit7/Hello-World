/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Sun Oct 16 06:59:52 IST 2016
*/
/**
 * description: This class implements all echo cacellation & noise reduction
 * author: lian zhang
 */
#include <v0/com/harman/audio/ecnr/ecnrDBusProxy.hpp>

namespace v0 {
namespace com {
namespace harman {
namespace audio {
namespace ecnr {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createecnrDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<ecnrDBusProxy>(_address, _connection);
}

INITIALIZER(registerecnrDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		ecnr::getInterface(),
		&createecnrDBusProxy);
}

ecnrDBusProxy::ecnrDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		micMuteChanged_(*this, "micMuteChanged", "ii", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		micGainChanged_(*this, "micGainChanged", "di", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)))
{
}


ecnrDBusProxy::MicMuteChangedEvent& ecnrDBusProxy::getMicMuteChangedEvent() {
    return micMuteChanged_;
}
ecnrDBusProxy::MicGainChangedEvent& ecnrDBusProxy::getMicGainChangedEvent() {
    return micGainChanged_;
}
    
    /**
     * description: This function is used to start one scenario.
     */
    void ecnrDBusProxy::start(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e &_scenario, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e &_err, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e, CommonAPI::EmptyDeployment> deploy_scenario(_scenario, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "start",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_scenario,
_internalCallStatus,
deploy_err);
_err = deploy_err.getValue();
}
    std::future<CommonAPI::CallStatus> ecnrDBusProxy::startAsync(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e &_scenario, StartAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e, CommonAPI::EmptyDeployment> deploy_scenario(_scenario, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "start",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_scenario,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> _err) {
        	if (_callback)
        		_callback(_internalCallStatus, _err.getValue());
        },
        std::make_tuple(deploy_err));
    }
    /**
     * description: This function is used to stop one scenario.
     */
    void ecnrDBusProxy::stop(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e &_scenario, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e &_err, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e, CommonAPI::EmptyDeployment> deploy_scenario(_scenario, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "stop",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_scenario,
_internalCallStatus,
deploy_err);
_err = deploy_err.getValue();
}
    std::future<CommonAPI::CallStatus> ecnrDBusProxy::stopAsync(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e &_scenario, StopAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e, CommonAPI::EmptyDeployment> deploy_scenario(_scenario, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "stop",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_scenario,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> _err) {
        	if (_callback)
        		_callback(_internalCallStatus, _err.getValue());
        },
        std::make_tuple(deploy_err));
    }
    /**
     * description: This function is used to mute mic.
     */
    void ecnrDBusProxy::setMicMute(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e &_muteState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e &_err, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e, CommonAPI::EmptyDeployment> deploy_muteState(_muteState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setMicMute",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_muteState,
_internalCallStatus,
deploy_err);
_err = deploy_err.getValue();
}
    std::future<CommonAPI::CallStatus> ecnrDBusProxy::setMicMuteAsync(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e &_muteState, SetMicMuteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e, CommonAPI::EmptyDeployment> deploy_muteState(_muteState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setMicMute",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_muteState,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> _err) {
        	if (_callback)
        		_callback(_internalCallStatus, _err.getValue());
        },
        std::make_tuple(deploy_err));
    }
    /**
     * description: This function is used to change the microphone gain value of current scenario.
     */
    void ecnrDBusProxy::setMicGain(const float &_gain, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e &_err, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<float, CommonAPI::EmptyDeployment> deploy_gain(_gain, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<float, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setMicGain",
        "d",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_gain,
_internalCallStatus,
deploy_err);
_err = deploy_err.getValue();
}
    std::future<CommonAPI::CallStatus> ecnrDBusProxy::setMicGainAsync(const float &_gain, SetMicGainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<float, CommonAPI::EmptyDeployment> deploy_gain(_gain, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<float, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setMicGain",
        "d",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_gain,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> _err) {
        	if (_callback)
        		_callback(_internalCallStatus, _err.getValue());
        },
        std::make_tuple(deploy_err));
    }
    /**
     * description: This function is used to change the log level.
     */
    void ecnrDBusProxy::logLevel(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_logLevel_e &_level, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e &_err, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_logLevel_e, CommonAPI::EmptyDeployment> deploy_level(_level, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_logLevel_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "logLevel",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_level,
_internalCallStatus,
deploy_err);
_err = deploy_err.getValue();
}
    std::future<CommonAPI::CallStatus> ecnrDBusProxy::logLevelAsync(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_logLevel_e &_level, LogLevelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_logLevel_e, CommonAPI::EmptyDeployment> deploy_level(_level, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_logLevel_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "logLevel",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_level,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> _err) {
        	if (_callback)
        		_callback(_internalCallStatus, _err.getValue());
        },
        std::make_tuple(deploy_err));
    }
    /**
     * description: This function is used to change the tuning mode.
     */
    void ecnrDBusProxy::tuningMode(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_tuningMode_e &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e &_err, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_tuningMode_e, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_tuningMode_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "tuningMode",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mode,
_internalCallStatus,
deploy_err);
_err = deploy_err.getValue();
}
    std::future<CommonAPI::CallStatus> ecnrDBusProxy::tuningModeAsync(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_tuningMode_e &_mode, TuningModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_tuningMode_e, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_tuningMode_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "tuningMode",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> _err) {
        	if (_callback)
        		_callback(_internalCallStatus, _err.getValue());
        },
        std::make_tuple(deploy_err));
    }
    /**
     * description: This function is used to get mute status of mic.
     */
    void ecnrDBusProxy::getMicMute(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e &_muteState, ::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e &_err, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e, CommonAPI::EmptyDeployment> deploy_muteState(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getMicMute",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_muteState, deploy_err);
_muteState = deploy_muteState.getValue();
_err = deploy_err.getValue();
}
    std::future<CommonAPI::CallStatus> ecnrDBusProxy::getMicMuteAsync(GetMicMuteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e, CommonAPI::EmptyDeployment> deploy_muteState(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getMicMute",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e, CommonAPI::EmptyDeployment> _muteState, CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> _err) {
        	if (_callback)
        		_callback(_internalCallStatus, _muteState.getValue(), _err.getValue());
        },
        std::make_tuple(deploy_muteState, deploy_err));
    }
    /**
     * description: This function is used to get the microphone gain value of current scenario.
     */
    void ecnrDBusProxy::getMicGain(CommonAPI::CallStatus &_internalCallStatus, float &_gain, ::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e &_err, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<float, CommonAPI::EmptyDeployment> deploy_gain(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<float,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getMicGain",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_gain, deploy_err);
_gain = deploy_gain.getValue();
_err = deploy_err.getValue();
}
    std::future<CommonAPI::CallStatus> ecnrDBusProxy::getMicGainAsync(GetMicGainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<float, CommonAPI::EmptyDeployment> deploy_gain(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> deploy_err(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<float,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getMicGain",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<float, CommonAPI::EmptyDeployment> _gain, CommonAPI::Deployable<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e, CommonAPI::EmptyDeployment> _err) {
        	if (_callback)
        		_callback(_internalCallStatus, _gain.getValue(), _err.getValue());
        },
        std::make_tuple(deploy_gain, deploy_err));
    }


void ecnrDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 0;
          ownVersionMinor = 1;
      }

      } // namespace ecnr
      } // namespace audio
      } // namespace harman
      } // namespace com
      } // namespace v0
