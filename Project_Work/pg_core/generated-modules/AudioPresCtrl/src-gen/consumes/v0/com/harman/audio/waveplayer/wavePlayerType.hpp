/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Oct 04 15:43:40 EDT 2016
*/
#ifndef V0_COM_HARMAN_AUDIO_WAVEPLAYER_wave_Player_Type_HPP_
#define V0_COM_HARMAN_AUDIO_WAVEPLAYER_wave_Player_Type_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace audio {
namespace waveplayer {

struct wavePlayerType {
    
    struct beepType_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            TYPE_PDC_1 = 0,
            TYPE_PDC_2 = 1,
            TYPE_RINGTONE_1 = 2,
            TYPE_RINGTONE_2 = 3,
            TYPE_BEEP_CONFIRM = 4,
            TYPE_BEEP_CANCEL = 5,
            TYPE_BEEP_TOUCH = 6,
            TYPE_BEEP_TRIGGER = 7,
            TYPE_GONG = 8,
            TYPE_BEEP_PDC_1 = 9
        };
        
        beepType_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::TYPE_PDC_1)) {}
        beepType_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::TYPE_PDC_1):
                case static_cast<int32_t>(Literal::TYPE_PDC_2):
                case static_cast<int32_t>(Literal::TYPE_RINGTONE_1):
                case static_cast<int32_t>(Literal::TYPE_RINGTONE_2):
                case static_cast<int32_t>(Literal::TYPE_BEEP_CONFIRM):
                case static_cast<int32_t>(Literal::TYPE_BEEP_CANCEL):
                case static_cast<int32_t>(Literal::TYPE_BEEP_TOUCH):
                case static_cast<int32_t>(Literal::TYPE_BEEP_TRIGGER):
                case static_cast<int32_t>(Literal::TYPE_GONG):
                case static_cast<int32_t>(Literal::TYPE_BEEP_PDC_1):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const beepType_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const beepType_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const beepType_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const beepType_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const beepType_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const beepType_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct beepGroup_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            GROUP_EMERGENCY_BEEP = 0,
            GROUP_RINGTONE = 1,
            GROUP_ALERT_BEEP = 2
        };
        
        beepGroup_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::GROUP_EMERGENCY_BEEP)) {}
        beepGroup_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::GROUP_EMERGENCY_BEEP):
                case static_cast<int32_t>(Literal::GROUP_RINGTONE):
                case static_cast<int32_t>(Literal::GROUP_ALERT_BEEP):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const beepGroup_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const beepGroup_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const beepGroup_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const beepGroup_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const beepGroup_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const beepGroup_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct wavePlayerState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            PLAYING = 0,
            STOPPED = 1
        };
        
        wavePlayerState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::PLAYING)) {}
        wavePlayerState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::PLAYING):
                case static_cast<int32_t>(Literal::STOPPED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const wavePlayerState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const wavePlayerState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const wavePlayerState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const wavePlayerState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const wavePlayerState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const wavePlayerState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct sampleRateType_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            RATE_11025 = 0,
            RATE_22050 = 1,
            RATE_44100 = 2
        };
        
        sampleRateType_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::RATE_11025)) {}
        sampleRateType_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::RATE_11025):
                case static_cast<int32_t>(Literal::RATE_22050):
                case static_cast<int32_t>(Literal::RATE_44100):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const sampleRateType_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const sampleRateType_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const sampleRateType_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const sampleRateType_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const sampleRateType_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const sampleRateType_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.audio.waveplayer.wavePlayerType";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(0, 1);
}

}; // struct wavePlayerType

} // namespace waveplayer
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
}


namespace std {
    //Hash for beepType_e
    template<>
    struct hash<::v0::com::harman::audio::waveplayer::wavePlayerType::beepType_e> {
        inline size_t operator()(const ::v0::com::harman::audio::waveplayer::wavePlayerType::beepType_e& beepType_e) const {
            return static_cast<int32_t>(beepType_e);
        }
    };
    //Hash for beepGroup_e
    template<>
    struct hash<::v0::com::harman::audio::waveplayer::wavePlayerType::beepGroup_e> {
        inline size_t operator()(const ::v0::com::harman::audio::waveplayer::wavePlayerType::beepGroup_e& beepGroup_e) const {
            return static_cast<int32_t>(beepGroup_e);
        }
    };
    //Hash for wavePlayerState_e
    template<>
    struct hash<::v0::com::harman::audio::waveplayer::wavePlayerType::wavePlayerState_e> {
        inline size_t operator()(const ::v0::com::harman::audio::waveplayer::wavePlayerType::wavePlayerState_e& wavePlayerState_e) const {
            return static_cast<int32_t>(wavePlayerState_e);
        }
    };
    //Hash for sampleRateType_e
    template<>
    struct hash<::v0::com::harman::audio::waveplayer::wavePlayerType::sampleRateType_e> {
        inline size_t operator()(const ::v0::com::harman::audio::waveplayer::wavePlayerType::sampleRateType_e& sampleRateType_e) const {
            return static_cast<int32_t>(sampleRateType_e);
        }
    };
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COM_HARMAN_AUDIO_WAVEPLAYER_wave_Player_Type_HPP_
