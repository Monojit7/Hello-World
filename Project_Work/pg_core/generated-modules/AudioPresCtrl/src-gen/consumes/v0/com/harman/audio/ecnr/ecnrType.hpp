/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Oct 04 15:43:40 EDT 2016
*/
/**
 * description: This class implements all echo cacellation & noise reduction
 * author: lian zhang
 */
#ifndef V0_COM_HARMAN_AUDIO_ECNR_ecnr_Type_HPP_
#define V0_COM_HARMAN_AUDIO_ECNR_ecnr_Type_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace audio {
namespace ecnr {

struct ecnrType {
    
    struct ecnr_scenario_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SCENARIO_UNKNOWN = 0,
            SCENARIO_HANDSFREE_BT_TEL_NB = 1,
            SCENARIO_HANDSFREE_BT_TEL_WB = 2,
            SCENARIO_HANDSFREE_CARPLAY_TEL_NB = 3,
            SCENARIO_HANDSFREE_CARPLAY_TEL_WB = 4,
            SCENARIO_HANDSFREE_CARPLAY_FT_SWB = 5,
            SCENARIO_VR_CARPLAY_SIRI_SWB = 6,
            SCENARIO_VR_GAL = 7,
            SCENARIO_VR_MIRRORLINK = 8,
            SCENARIO_VR_CARLIFE = 9,
            SCENARIO_MAX = 10
        };
        
        ecnr_scenario_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SCENARIO_UNKNOWN)) {}
        ecnr_scenario_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SCENARIO_UNKNOWN):
                case static_cast<int32_t>(Literal::SCENARIO_HANDSFREE_BT_TEL_NB):
                case static_cast<int32_t>(Literal::SCENARIO_HANDSFREE_BT_TEL_WB):
                case static_cast<int32_t>(Literal::SCENARIO_HANDSFREE_CARPLAY_TEL_NB):
                case static_cast<int32_t>(Literal::SCENARIO_HANDSFREE_CARPLAY_TEL_WB):
                case static_cast<int32_t>(Literal::SCENARIO_HANDSFREE_CARPLAY_FT_SWB):
                case static_cast<int32_t>(Literal::SCENARIO_VR_CARPLAY_SIRI_SWB):
                case static_cast<int32_t>(Literal::SCENARIO_VR_GAL):
                case static_cast<int32_t>(Literal::SCENARIO_VR_MIRRORLINK):
                case static_cast<int32_t>(Literal::SCENARIO_VR_CARLIFE):
                case static_cast<int32_t>(Literal::SCENARIO_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ecnr_scenario_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ecnr_scenario_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ecnr_scenario_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ecnr_scenario_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ecnr_scenario_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ecnr_scenario_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ecnr_tuningMode_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            TUNING_UNKNOWN = 0,
            TUNING_ENABLE = 1,
            TUNING_DISABLE = 2,
            TUNING_MAX = 3
        };
        
        ecnr_tuningMode_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::TUNING_UNKNOWN)) {}
        ecnr_tuningMode_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::TUNING_UNKNOWN):
                case static_cast<int32_t>(Literal::TUNING_ENABLE):
                case static_cast<int32_t>(Literal::TUNING_DISABLE):
                case static_cast<int32_t>(Literal::TUNING_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ecnr_tuningMode_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ecnr_tuningMode_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ecnr_tuningMode_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ecnr_tuningMode_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ecnr_tuningMode_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ecnr_tuningMode_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ecnr_logLevel_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            LEVEL_ERROR = 0,
            LEVEL_DEBUG = 1,
            LEVEL_VERBOSE = 2,
            LEVEL_MAX = 3
        };
        
        ecnr_logLevel_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::LEVEL_ERROR)) {}
        ecnr_logLevel_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::LEVEL_ERROR):
                case static_cast<int32_t>(Literal::LEVEL_DEBUG):
                case static_cast<int32_t>(Literal::LEVEL_VERBOSE):
                case static_cast<int32_t>(Literal::LEVEL_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ecnr_logLevel_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ecnr_logLevel_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ecnr_logLevel_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ecnr_logLevel_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ecnr_logLevel_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ecnr_logLevel_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ecnr_mute_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            MS_UNKNOWN = -1,
            MS_UNMUTED = 0,
            MS_MUTED = 1,
            MS_MAX = 3
        };
        
        ecnr_mute_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::MS_UNKNOWN)) {}
        ecnr_mute_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::MS_UNKNOWN):
                case static_cast<int32_t>(Literal::MS_UNMUTED):
                case static_cast<int32_t>(Literal::MS_MUTED):
                case static_cast<int32_t>(Literal::MS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ecnr_mute_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ecnr_mute_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ecnr_mute_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ecnr_mute_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ecnr_mute_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ecnr_mute_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ecnr_Error_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E_OK = 0,
            E_UNKNOWN = 1,
            E_OUT_OF_RANGE = 2,
            E_ALREADY_EXISTS = 3,
            E_NOT_POSSIBLE = 4,
            E_NON_EXISTENT = 5,
            E_ABORTED = 6,
            E_MAX = 7
        };
        
        ecnr_Error_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E_OK)) {}
        ecnr_Error_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E_OK):
                case static_cast<int32_t>(Literal::E_UNKNOWN):
                case static_cast<int32_t>(Literal::E_OUT_OF_RANGE):
                case static_cast<int32_t>(Literal::E_ALREADY_EXISTS):
                case static_cast<int32_t>(Literal::E_NOT_POSSIBLE):
                case static_cast<int32_t>(Literal::E_NON_EXISTENT):
                case static_cast<int32_t>(Literal::E_ABORTED):
                case static_cast<int32_t>(Literal::E_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ecnr_Error_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ecnr_Error_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ecnr_Error_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ecnr_Error_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ecnr_Error_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ecnr_Error_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.audio.ecnr.ecnrType";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(0, 1);
}

}; // struct ecnrType

} // namespace ecnr
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
}


namespace std {
    //Hash for ecnr_scenario_e
    template<>
    struct hash<::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e> {
        inline size_t operator()(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_scenario_e& ecnr_scenario_e) const {
            return static_cast<int32_t>(ecnr_scenario_e);
        }
    };
    //Hash for ecnr_tuningMode_e
    template<>
    struct hash<::v0::com::harman::audio::ecnr::ecnrType::ecnr_tuningMode_e> {
        inline size_t operator()(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_tuningMode_e& ecnr_tuningMode_e) const {
            return static_cast<int32_t>(ecnr_tuningMode_e);
        }
    };
    //Hash for ecnr_logLevel_e
    template<>
    struct hash<::v0::com::harman::audio::ecnr::ecnrType::ecnr_logLevel_e> {
        inline size_t operator()(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_logLevel_e& ecnr_logLevel_e) const {
            return static_cast<int32_t>(ecnr_logLevel_e);
        }
    };
    //Hash for ecnr_mute_e
    template<>
    struct hash<::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e> {
        inline size_t operator()(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_mute_e& ecnr_mute_e) const {
            return static_cast<int32_t>(ecnr_mute_e);
        }
    };
    //Hash for ecnr_Error_e
    template<>
    struct hash<::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e> {
        inline size_t operator()(const ::v0::com::harman::audio::ecnr::ecnrType::ecnr_Error_e& ecnr_Error_e) const {
            return static_cast<int32_t>(ecnr_Error_e);
        }
    };
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COM_HARMAN_AUDIO_ECNR_ecnr_Type_HPP_
