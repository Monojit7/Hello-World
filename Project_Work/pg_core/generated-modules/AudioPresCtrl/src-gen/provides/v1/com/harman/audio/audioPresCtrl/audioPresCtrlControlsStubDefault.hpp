/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Oct 04 15:43:40 EDT 2016
*/
/**
 * description: This is a Common API DBUS control interface of audio presentation controller
 *   for Orinoco 2.0
 * author: AYatheesh
 */
#ifndef V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_STUB_DEFAULT_HPP_
#define V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_STUB_DEFAULT_HPP_


#include <v1/com/harman/audio/audioPresCtrl/audioPresCtrlControlsStub.hpp>
#include <sstream>

namespace v1 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

/**
 * Provides a default implementation for audioPresCtrlControlsStubRemoteEvent and
 * audioPresCtrlControlsStub. Method callbacks have an empty implementation,
 * remote set calls on attributes will always change the value of the attribute
 * to the one received.
 *
 * Override this stub if you only want to provide a subset of the functionality
 * that would be defined for this service, and/or if you do not need any non-default
 * behaviour.
 */
class audioPresCtrlControlsStubDefault
    : public virtual audioPresCtrlControlsStub {
public:
    audioPresCtrlControlsStubDefault();

    audioPresCtrlControlsStubRemoteEvent* initStubAdapter(const std::shared_ptr<audioPresCtrlControlsStubAdapter> &_adapter);

    const CommonAPI::Version& getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client);

    virtual const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId& getActiveAudioSourceAttribute();
    virtual const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId& getActiveAudioSourceAttribute(const std::shared_ptr<CommonAPI::ClientId> _client);
    virtual void setActiveAudioSourceAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId _value);
    virtual const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs& getActiveEntSrcAttribute();
    virtual const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs& getActiveEntSrcAttribute(const std::shared_ptr<CommonAPI::ClientId> _client);
    virtual void setActiveEntSrcAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs _value);
    virtual const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList& getEntSourceListAttribute();
    virtual const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList& getEntSourceListAttribute(const std::shared_ptr<CommonAPI::ClientId> _client);
    virtual void setEntSourceListAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList _value);

    /**
     * description: This method is used to set audio entertainment sources 	(at)attribute update
     *   activeAudioSource and activeEntSrc
     */
    virtual void SetEntertainmentSrc(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs _sourceId, SetEntertainmentSrcReply_t _reply);
    /**
     * description: This method is used to switch Audio Context to the source in the given group
     *   	Group needs to be first mentioned in the audiopres.cfg 	Project may choose
     *   any naming strategy as long as it doesnt conflict with another json key in the
     *   cfg 	(at)attribute update activeAudioSource and activeEntSrc if a source
     *   switch has happened 	(at)return eAudioPresErrors
     */
    virtual void SetSourceGroup(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _sourceGroupName, SetSourceGroupReply_t _reply);
    /**
     * description: This method is used to toggle source in the source group 	SetSourceGroup needs
     *   to be invoked in order to select an active group 	(at)attribute update
     *   activeAudioSource and activeEntSrc if a source switch has happened 	(at)return
     *   eAudioPresErrors
     */
    virtual void ToggleInSourceGroup(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection _direction, ToggleInSourceGroupReply_t _reply);
    /**
     * description: This method is used to toggle source in the order specified in
     *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
     *   toggleNextPreviousStrategy with value is defined , method return an error
     *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
     *   entertainment sources in a project 	(at)attribute update activeAudioSource and
     *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
     */
    virtual void ToggleSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection _direction, ToggleSourceReply_t _reply);
    /**
     * description: to activate interrupt source with given SourceID 	Only touchbeep and keytouch
     *   srcs will be supported through requestinformationsource interface 	as these
     *   are the only sources that will be requested by HMIs 	Other sources will be
     *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
     *   for alt audio sources etc) 	Other sources are kept just so that HMI can track
     *   the active source through attribute activeAudioSource     	(at)return
     *   eAudioPresErrors
     */
    virtual void RequestInformationSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs _sourceID, RequestInformationSourceReply_t _reply);
    /**
     * description: to deactivate interrupt source with given SourceID 	(at)return eAudioPresErrors
     */
    virtual void ReleaseInformationSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs _sourceID, ReleaseInformationSourceReply_t _reply);



protected:
    /**
     * description: Attribute holding current ative audio source 		This will be updated on every
     *   audiosource change
     */
    virtual bool trySetActiveAudioSourceAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId _value);
    virtual bool validateActiveAudioSourceAttributeRequestedValue(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_value);
    /**
     * description: Attribute holding current ative entertainment source 		This will be updated on
     *   every audiosource change
     */
    virtual bool trySetActiveEntSrcAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs _value);
    virtual bool validateActiveEntSrcAttributeRequestedValue(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_value);
    /**
     * description: Attribute holding list of entertainment sources with available status 		This
     *   will be update on a status change(available/unavailable/unknown) of any
     *   entertainment source
     */
    virtual bool trySetEntSourceListAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList _value);
    virtual bool validateEntSourceListAttributeRequestedValue(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList &_value);
    class RemoteEventHandler: public virtual audioPresCtrlControlsStubRemoteEvent {
    public:
        RemoteEventHandler(audioPresCtrlControlsStubDefault *_defaultStub);

        /**
         * description: Attribute holding current ative audio source 		This will be updated on every
         *   audiosource change
         */

        /**
         * description: Attribute holding current ative entertainment source 		This will be updated on
         *   every audiosource change
         */

        /**
         * description: Attribute holding list of entertainment sources with available status 		This
         *   will be update on a status change(available/unavailable/unknown) of any
         *   entertainment source
         */


    private:
        audioPresCtrlControlsStubDefault *defaultStub_;
    };
private:
    audioPresCtrlControlsStubDefault::RemoteEventHandler remoteEventHandler_;

    /**
     * description: Attribute holding current ative audio source 		This will be updated on every
     *   audiosource change
     */
    ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId activeAudioSourceAttributeValue_ {};
    /**
     * description: Attribute holding current ative entertainment source 		This will be updated on
     *   every audiosource change
     */
    ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs activeEntSrcAttributeValue_ {};
    /**
     * description: Attribute holding list of entertainment sources with available status 		This
     *   will be update on a status change(available/unavailable/unknown) of any
     *   entertainment source
     */
    ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList entSourceListAttributeValue_ {};

    CommonAPI::Version interfaceVersion_;
};

} // namespace audioPresCtrl
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v1


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_STUB_DEFAULT
