/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Oct 04 15:43:40 EDT 2016
*/
#include <v1/com/harman/audio/audioPresCtrl/audioPresCtrlControlsStubDefault.hpp>
#include <assert.h>

namespace v1 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

audioPresCtrlControlsStubDefault::audioPresCtrlControlsStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(audioPresCtrlControls::getInterfaceVersion()) {
}

const CommonAPI::Version& audioPresCtrlControlsStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

audioPresCtrlControlsStubRemoteEvent* audioPresCtrlControlsStubDefault::initStubAdapter(const std::shared_ptr<audioPresCtrlControlsStubAdapter> &_adapter) {
    CommonAPI::Stub<audioPresCtrlControlsStubAdapter, audioPresCtrlControlsStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}

const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId& audioPresCtrlControlsStubDefault::getActiveAudioSourceAttribute() {
    return activeAudioSourceAttributeValue_;
}

const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId& audioPresCtrlControlsStubDefault::getActiveAudioSourceAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getActiveAudioSourceAttribute();
}

void audioPresCtrlControlsStubDefault::setActiveAudioSourceAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId _value) {
    const bool valueChanged = trySetActiveAudioSourceAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<audioPresCtrlControlsStubAdapter, audioPresCtrlControlsStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireActiveAudioSourceAttributeChanged(activeAudioSourceAttributeValue_);
    }
}

bool audioPresCtrlControlsStubDefault::trySetActiveAudioSourceAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId _value) {
    if (!validateActiveAudioSourceAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (activeAudioSourceAttributeValue_ != _value);
    activeAudioSourceAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool audioPresCtrlControlsStubDefault::validateActiveAudioSourceAttributeRequestedValue(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_value) {
    (void)_value;
	return true;
}


const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs& audioPresCtrlControlsStubDefault::getActiveEntSrcAttribute() {
    return activeEntSrcAttributeValue_;
}

const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs& audioPresCtrlControlsStubDefault::getActiveEntSrcAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getActiveEntSrcAttribute();
}

void audioPresCtrlControlsStubDefault::setActiveEntSrcAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs _value) {
    const bool valueChanged = trySetActiveEntSrcAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<audioPresCtrlControlsStubAdapter, audioPresCtrlControlsStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireActiveEntSrcAttributeChanged(activeEntSrcAttributeValue_);
    }
}

bool audioPresCtrlControlsStubDefault::trySetActiveEntSrcAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs _value) {
    if (!validateActiveEntSrcAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (activeEntSrcAttributeValue_ != _value);
    activeEntSrcAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool audioPresCtrlControlsStubDefault::validateActiveEntSrcAttributeRequestedValue(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_value) {
    (void)_value;
	return _value.validate();
}


const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList& audioPresCtrlControlsStubDefault::getEntSourceListAttribute() {
    return entSourceListAttributeValue_;
}

const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList& audioPresCtrlControlsStubDefault::getEntSourceListAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getEntSourceListAttribute();
}

void audioPresCtrlControlsStubDefault::setEntSourceListAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList _value) {
    const bool valueChanged = trySetEntSourceListAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<audioPresCtrlControlsStubAdapter, audioPresCtrlControlsStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireEntSourceListAttributeChanged(entSourceListAttributeValue_);
    }
}

bool audioPresCtrlControlsStubDefault::trySetEntSourceListAttribute(::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList _value) {
    if (!validateEntSourceListAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (entSourceListAttributeValue_ != _value);
    entSourceListAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool audioPresCtrlControlsStubDefault::validateEntSourceListAttributeRequestedValue(const ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::EntSourceList &_value) {
    (void)_value;
	return true;
}



/**
 * description: This method is used to set audio entertainment sources 	(at)attribute update
 *   activeAudioSource and activeEntSrc
 */
void audioPresCtrlControlsStubDefault::SetEntertainmentSrc(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs _sourceId, SetEntertainmentSrcReply_t _reply) {
    (void)_client;
    (void) _sourceId;
    ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
    _reply(error);
}

/**
 * description: This method is used to switch Audio Context to the source in the given group
 *   	Group needs to be first mentioned in the audiopres.cfg 	Project may choose
 *   any naming strategy as long as it doesnt conflict with another json key in the
 *   cfg 	(at)attribute update activeAudioSource and activeEntSrc if a source
 *   switch has happened 	(at)return eAudioPresErrors
 */
void audioPresCtrlControlsStubDefault::SetSourceGroup(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _sourceGroupName, SetSourceGroupReply_t _reply) {
    (void)_client;
    (void) _sourceGroupName;
    ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
    _reply(error);
}

/**
 * description: This method is used to toggle source in the source group 	SetSourceGroup needs
 *   to be invoked in order to select an active group 	(at)attribute update
 *   activeAudioSource and activeEntSrc if a source switch has happened 	(at)return
 *   eAudioPresErrors
 */
void audioPresCtrlControlsStubDefault::ToggleInSourceGroup(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection _direction, ToggleInSourceGroupReply_t _reply) {
    (void)_client;
    (void) _direction;
    ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
    _reply(error);
}

/**
 * description: This method is used to toggle source in the order specified in
 *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
 *   toggleNextPreviousStrategy with value is defined , method return an error
 *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
 *   entertainment sources in a project 	(at)attribute update activeAudioSource and
 *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
 */
void audioPresCtrlControlsStubDefault::ToggleSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection _direction, ToggleSourceReply_t _reply) {
    (void)_client;
    (void) _direction;
    ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
    _reply(error);
}

/**
 * description: to activate interrupt source with given SourceID 	Only touchbeep and keytouch
 *   srcs will be supported through requestinformationsource interface 	as these
 *   are the only sources that will be requested by HMIs 	Other sources will be
 *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
 *   for alt audio sources etc) 	Other sources are kept just so that HMI can track
 *   the active source through attribute activeAudioSource     	(at)return
 *   eAudioPresErrors
 */
void audioPresCtrlControlsStubDefault::RequestInformationSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs _sourceID, RequestInformationSourceReply_t _reply) {
    (void)_client;
    (void) _sourceID;
    ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
    _reply(error);
}

/**
 * description: to deactivate interrupt source with given SourceID 	(at)return eAudioPresErrors
 */
void audioPresCtrlControlsStubDefault::ReleaseInformationSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs _sourceID, ReleaseInformationSourceReply_t _reply) {
    (void)_client;
    (void) _sourceID;
    ::v1::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
    _reply(error);
}




audioPresCtrlControlsStubDefault::RemoteEventHandler::RemoteEventHandler(audioPresCtrlControlsStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace audioPresCtrl
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v1
