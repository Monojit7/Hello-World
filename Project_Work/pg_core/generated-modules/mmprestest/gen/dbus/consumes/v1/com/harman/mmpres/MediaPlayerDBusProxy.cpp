/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Sat Nov 05 14:44:28 IST 2016
*/
#include <v1/com/harman/mmpres/MediaPlayerDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace mmpres {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createMediaPlayerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<MediaPlayerDBusProxy>(_address, _connection);
}

INITIALIZER(registerMediaPlayerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		MediaPlayer::getInterface(),
		&createMediaPlayerDBusProxy);
}

MediaPlayerDBusProxy::MediaPlayerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		currentPlayTime_(*this, "onCurrentPlayTimeAttributeChanged", "t", "getCurrentPlayTimeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		totalPlayDuration_(*this, "onTotalPlayDurationAttributeChanged", "t", "getTotalPlayDurationAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		trackState_(*this, "onTrackStateAttributeChanged", "(tt)", "getTrackStateAttribute", static_cast<::v1::com::harman::mmpres::MMPresTypes_::tTrackStateDeployment_t*>(nullptr)),
		nowPlayingData_(*this, "onNowPlayingDataAttributeChanged", "(sssssssssstbtttbi)", "getNowPlayingDataAttribute", static_cast<::v1::com::harman::mmpres::MMPresTypes_::tNowPlayingInfoDeployment_t*>(nullptr)),
		playState_(*this, "onPlayStateAttributeChanged", "i", "getPlayStateAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		speed_(*this, "onSpeedAttributeChanged", "i", "getSpeedAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		repeatMode_(*this, "onRepeatModeAttributeChanged", "i", "getRepeatModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		shuffleMode_(*this, "onShuffleModeAttributeChanged", "i", "getShuffleModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		nowPlayingArtworkStatus_(*this, "onNowPlayingArtworkStatusAttributeChanged", "i", "getNowPlayingArtworkStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		playbackPreview_(*this, "onPlaybackPreviewAttributeChanged", "a(tsbbiia{it}a{is}i)", "getPlaybackPreviewAttribute", static_cast<::v1::com::harman::mmpres::MMPresTypes_::MetadataItemListDeployment_t*>(nullptr)),
		videoPlayStatus_(*this, "onVideoPlayStatusAttributeChanged", "b", "getVideoPlayStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr))
{
}

      MediaPlayerDBusProxy::CurrentPlayTimeAttribute& MediaPlayerDBusProxy::getCurrentPlayTimeAttribute() {
          return currentPlayTime_;
      }
      MediaPlayerDBusProxy::TotalPlayDurationAttribute& MediaPlayerDBusProxy::getTotalPlayDurationAttribute() {
          return totalPlayDuration_;
      }
      MediaPlayerDBusProxy::TrackStateAttribute& MediaPlayerDBusProxy::getTrackStateAttribute() {
          return trackState_;
      }
      MediaPlayerDBusProxy::NowPlayingDataAttribute& MediaPlayerDBusProxy::getNowPlayingDataAttribute() {
          return nowPlayingData_;
      }
      MediaPlayerDBusProxy::PlayStateAttribute& MediaPlayerDBusProxy::getPlayStateAttribute() {
          return playState_;
      }
      MediaPlayerDBusProxy::SpeedAttribute& MediaPlayerDBusProxy::getSpeedAttribute() {
          return speed_;
      }
      MediaPlayerDBusProxy::RepeatModeAttribute& MediaPlayerDBusProxy::getRepeatModeAttribute() {
          return repeatMode_;
      }
      MediaPlayerDBusProxy::ShuffleModeAttribute& MediaPlayerDBusProxy::getShuffleModeAttribute() {
          return shuffleMode_;
      }
      MediaPlayerDBusProxy::NowPlayingArtworkStatusAttribute& MediaPlayerDBusProxy::getNowPlayingArtworkStatusAttribute() {
          return nowPlayingArtworkStatus_;
      }
      MediaPlayerDBusProxy::PlaybackPreviewAttribute& MediaPlayerDBusProxy::getPlaybackPreviewAttribute() {
          return playbackPreview_;
      }
      MediaPlayerDBusProxy::VideoPlayStatusAttribute& MediaPlayerDBusProxy::getVideoPlayStatusAttribute() {
          return videoPlayStatus_;
      }

    
    void MediaPlayerDBusProxy::next(const uint64_t &_step, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "next",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_step,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::nextAsync(const uint64_t &_step, NextAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "next",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_step,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::previous(const uint64_t &_step, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "previous",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_step,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::previousAsync(const uint64_t &_step, PreviousAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "previous",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_step,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::pause(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "pause",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::pauseAsync(PauseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "pause",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::resume(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "resume",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::resumeAsync(ResumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "resume",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::seekToTime(const uint64_t &_timePosition, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_timePosition(_timePosition, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "seekToTime",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_timePosition,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::seekToTimeAsync(const uint64_t &_timePosition, SeekToTimeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_timePosition(_timePosition, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "seekToTime",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_timePosition,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::fastForward(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "fastForward",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::fastForwardAsync(FastForwardAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "fastForward",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::fastReverse(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "fastReverse",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::fastReverseAsync(FastReverseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "fastReverse",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::setRepeat(const ::v1::com::harman::mmpres::MMPresTypes::eRepeatMode &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setRepeat",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mode,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::setRepeatAsync(const ::v1::com::harman::mmpres::MMPresTypes::eRepeatMode &_mode, SetRepeatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setRepeat",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::setShuffle(const ::v1::com::harman::mmpres::MMPresTypes::eShuffleMode &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setShuffle",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mode,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::setShuffleAsync(const ::v1::com::harman::mmpres::MMPresTypes::eShuffleMode &_mode, SetShuffleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setShuffle",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::getNowPlayingAlbumArtInformation(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation &_albumArtInfo, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getNowPlayingAlbumArtInformation",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_albumArtInfo);
_albumArtInfo = deploy_albumArtInfo.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getNowPlayingAlbumArtInformationAsync(GetNowPlayingAlbumArtInformationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getNowPlayingAlbumArtInformation",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> _albumArtInfo) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtInfo.getValue());
        },
        std::make_tuple(deploy_albumArtInfo));
    }
    void MediaPlayerDBusProxy::getNowPlayingAlbumArtPath(const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::string &_path, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getNowPlayingAlbumArtPath",
        "y",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_imageNumber,
_internalCallStatus,
deploy_path);
_path = deploy_path.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getNowPlayingAlbumArtPathAsync(const uint8_t &_imageNumber, GetNowPlayingAlbumArtPathAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getNowPlayingAlbumArtPath",
        "y",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _path) {
        	if (_callback)
        		_callback(_internalCallStatus, _path.getValue());
        },
        std::make_tuple(deploy_path));
    }
    void MediaPlayerDBusProxy::getNowPlayingAlbumArtData(const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::vector<uint8_t> &_albumArtData, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getNowPlayingAlbumArtData",
        "y",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_imageNumber,
_internalCallStatus,
deploy_albumArtData);
_albumArtData = deploy_albumArtData.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getNowPlayingAlbumArtDataAsync(const uint8_t &_imageNumber, GetNowPlayingAlbumArtDataAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getNowPlayingAlbumArtData",
        "y",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _albumArtData) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtData.getValue());
        },
        std::make_tuple(deploy_albumArtData));
    }
    void MediaPlayerDBusProxy::getAlbumArtInformationForTrack(const uint64_t &_trackId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation &_albumArtInfo, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getAlbumArtInformationForTrack",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_trackId,
_internalCallStatus,
deploy_albumArtInfo);
_albumArtInfo = deploy_albumArtInfo.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getAlbumArtInformationForTrackAsync(const uint64_t &_trackId, GetAlbumArtInformationForTrackAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getAlbumArtInformationForTrack",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_trackId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> _albumArtInfo) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtInfo.getValue());
        },
        std::make_tuple(deploy_albumArtInfo));
    }
    void MediaPlayerDBusProxy::getAlbumArtPathForTrack(const uint64_t &_trackId, const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::string &_path, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getAlbumArtPathForTrack",
        "ty",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_trackId, deploy_imageNumber,
_internalCallStatus,
deploy_path);
_path = deploy_path.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getAlbumArtPathForTrackAsync(const uint64_t &_trackId, const uint8_t &_imageNumber, GetAlbumArtPathForTrackAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getAlbumArtPathForTrack",
        "ty",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_trackId, deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _path) {
        	if (_callback)
        		_callback(_internalCallStatus, _path.getValue());
        },
        std::make_tuple(deploy_path));
    }
    void MediaPlayerDBusProxy::getAlbumArtDataForTrack(const uint64_t &_trackId, const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::vector<uint8_t> &_albumArtData, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getAlbumArtDataForTrack",
        "ty",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_trackId, deploy_imageNumber,
_internalCallStatus,
deploy_albumArtData);
_albumArtData = deploy_albumArtData.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getAlbumArtDataForTrackAsync(const uint64_t &_trackId, const uint8_t &_imageNumber, GetAlbumArtDataForTrackAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getAlbumArtDataForTrack",
        "ty",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_trackId, deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _albumArtData) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtData.getValue());
        },
        std::make_tuple(deploy_albumArtData));
    }


void MediaPlayerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace mmpres
      } // namespace harman
      } // namespace com
      } // namespace v1
