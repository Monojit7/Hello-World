/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Wed Oct 26 18:16:09 IST 2016
*/
/**
 * author: lian zhang
 */
#ifndef V3_ORG_GENIVI_am_t_HPP_
#define V3_ORG_GENIVI_am_t_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v3 {
namespace org {
namespace genivi {

struct am_t {
    /**
     * description: A source ID.
     */
    typedef uint16_t am_sourceID_t;
    /**
     * description: A mainConnection ID.
     */
    typedef uint16_t am_mainConnectionID_t;
    /**
     * description: Offset time that is introduced in milliseconds.
     */
    typedef int16_t am_timeSync_t;
    /**
     * description: A sink ID.
     */
    typedef uint16_t am_sinkID_t;
    
    struct am_ConnectionState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            CS_UNKNOWN = 0,
            CS_CONNECTING = 1,
            CS_CONNECTED = 2,
            CS_DISCONNECTING = 3,
            CS_DISCONNECTED = 4,
            CS_SUSPENDED = 5,
            CS_MAX = 6
        };
        
        am_ConnectionState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::CS_UNKNOWN)) {}
        am_ConnectionState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::CS_UNKNOWN):
                case static_cast<int32_t>(Literal::CS_CONNECTING):
                case static_cast<int32_t>(Literal::CS_CONNECTED):
                case static_cast<int32_t>(Literal::CS_DISCONNECTING):
                case static_cast<int32_t>(Literal::CS_DISCONNECTED):
                case static_cast<int32_t>(Literal::CS_SUSPENDED):
                case static_cast<int32_t>(Literal::CS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_ConnectionState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_ConnectionState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_ConnectionState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_ConnectionState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_ConnectionState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_ConnectionState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This type holds all information of connections relevant to the HMI.
     */
    struct am_MainConnectionType_s : CommonAPI::Struct<am_mainConnectionID_t, am_sourceID_t, am_sinkID_t, am_timeSync_t, am_ConnectionState_e> {
    	
    	am_MainConnectionType_s() {
    	}
    	am_MainConnectionType_s(const am_mainConnectionID_t &_mainConnectionID, const am_sourceID_t &_sourceID, const am_sinkID_t &_sinkID, const am_timeSync_t &_delay, const am_ConnectionState_e &_connectionState)
    	{
    		std::get<0>(values_) = _mainConnectionID;
    		std::get<1>(values_) = _sourceID;
    		std::get<2>(values_) = _sinkID;
    		std::get<3>(values_) = _delay;
    		std::get<4>(values_) = _connectionState;
    	}
    	/**
    	 * description: The ID of the main connection.
    	 */
    	inline const am_mainConnectionID_t &getMainConnectionID() const { return std::get<0>(values_); }
    	inline void setMainConnectionID(const am_mainConnectionID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The source ID where the connection starts, we have list all the sourceID
    	 *   enumeration in am_sourceID_e.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<1>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The sink ID where the connection ends, we have list all the sourceID
    	 *   enumeration in am_sinkID_e.
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<2>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The delay of the main connection.
    	 */
    	inline const am_timeSync_t &getDelay() const { return std::get<3>(values_); }
    	inline void setDelay(const am_timeSync_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The current connection state.
    	 */
    	inline const am_ConnectionState_e &getConnectionState() const { return std::get<4>(values_); }
    	inline void setConnectionState(const am_ConnectionState_e &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const am_MainConnectionType_s& _other) const {
                return (getMainConnectionID() == _other.getMainConnectionID() && getSourceID() == _other.getSourceID() && getSinkID() == _other.getSinkID() && getDelay() == _other.getDelay() && getConnectionState() == _other.getConnectionState());
        }
    	inline bool operator!=(const am_MainConnectionType_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_MainConnectionType_s> am_MainConnection_L;
    /**
     * description: Product specific identifier of property.
     */
    typedef uint16_t am_ClassProperty_pe;
    /**
     * description: Describes class properties.
     */
    struct am_ClassProperty_s : CommonAPI::Struct<am_ClassProperty_pe, int16_t> {
    	
    	am_ClassProperty_s() {
    	}
    	am_ClassProperty_s(const am_ClassProperty_pe &_classProperty, const int16_t &_value)
    	{
    		std::get<0>(values_) = _classProperty;
    		std::get<1>(values_) = _value;
    	}
    	/**
    	 * description: The property as enum.
    	 */
    	inline const am_ClassProperty_pe &getClassProperty() const { return std::get<0>(values_); }
    	inline void setClassProperty(const am_ClassProperty_pe &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The value of the property.
    	 */
    	inline const int16_t &getValue() const { return std::get<1>(values_); }
    	inline void setValue(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_ClassProperty_s& _other) const {
                return (getClassProperty() == _other.getClassProperty() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const am_ClassProperty_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_ClassProperty_s> am_ClassProperty_L;
    typedef uint16_t am_sinkClass_t;
    /**
     * description: Struct describing sink classes.
     */
    struct am_SinkClass_s : CommonAPI::Struct<am_sinkClass_t, std::string, am_ClassProperty_L> {
    	
    	am_SinkClass_s() {
    	}
    	am_SinkClass_s(const am_sinkClass_t &_sinkClassID, const std::string &_name, const am_ClassProperty_L &_listClassProperties)
    	{
    		std::get<0>(values_) = _sinkClassID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _listClassProperties;
    	}
    	/**
    	 * description: The ID of the sink class.
    	 */
    	inline const am_sinkClass_t &getSinkClassID() const { return std::get<0>(values_); }
    	inline void setSinkClassID(const am_sinkClass_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the sink class - must be unique in the system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The list of the class properties. These are pairs of a project specific enum
    	 *   describing the type of the value and an integer holding the value.
    	 */
    	inline const am_ClassProperty_L &getListClassProperties() const { return std::get<2>(values_); }
    	inline void setListClassProperties(const am_ClassProperty_L &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const am_SinkClass_s& _other) const {
                return (getSinkClassID() == _other.getSinkClassID() && getName() == _other.getName() && getListClassProperties() == _other.getListClassProperties());
        }
    	inline bool operator!=(const am_SinkClass_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_SinkClass_s> am_SinkClass_L;
    /**
     * description: This is the volume presented on the command interface. It is in the duty of the
     *   controller to change the volumes given here into meaningful values on the
     *   routing interface.
    The range of this type is customer specific.
     */
    typedef int16_t am_mainVolume_t;
    /**
     * description: This project specific value gives the information about reason for source/sink
     *   change.
     */
    typedef uint16_t am_AvailabilityReason_pe;
    
    struct am_Availability_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            A_UNKNOWN = 0,
            A_AVAILABLE = 1,
            A_UNAVAILABLE = 2,
            A_MAX = 3
        };
        
        am_Availability_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::A_UNKNOWN)) {}
        am_Availability_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::A_UNKNOWN):
                case static_cast<int32_t>(Literal::A_AVAILABLE):
                case static_cast<int32_t>(Literal::A_UNAVAILABLE):
                case static_cast<int32_t>(Literal::A_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Availability_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Availability_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Availability_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Availability_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Availability_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Availability_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This describes the availability of a sink or a source together with the latest
     *   change.
     */
    struct am_Availability_s : CommonAPI::Struct<am_Availability_e, am_AvailabilityReason_pe> {
    	
    	am_Availability_s() {
    	}
    	am_Availability_s(const am_Availability_e &_availability, const am_AvailabilityReason_pe &_availabilityReason)
    	{
    		std::get<0>(values_) = _availability;
    		std::get<1>(values_) = _availabilityReason;
    	}
    	/**
    	 * description: The current availability state.
    	 */
    	inline const am_Availability_e &getAvailability() const { return std::get<0>(values_); }
    	inline void setAvailability(const am_Availability_e &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The reason for the last change. now audioManager don't care about it. the user
    	 *   can always set the value as 0.
    	 */
    	inline const am_AvailabilityReason_pe &getAvailabilityReason() const { return std::get<1>(values_); }
    	inline void setAvailabilityReason(const am_AvailabilityReason_pe &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_Availability_s& _other) const {
                return (getAvailability() == _other.getAvailability() && getAvailabilityReason() == _other.getAvailabilityReason());
        }
    	inline bool operator!=(const am_Availability_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct am_MuteState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            MS_UNKNOWN = 0,
            MS_MUTED = 1,
            MS_UNMUTED = 2,
            MS_MAX = 3
        };
        
        am_MuteState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::MS_UNKNOWN)) {}
        am_MuteState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::MS_UNKNOWN):
                case static_cast<int32_t>(Literal::MS_MUTED):
                case static_cast<int32_t>(Literal::MS_UNMUTED):
                case static_cast<int32_t>(Literal::MS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_MuteState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_MuteState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_MuteState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_MuteState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_MuteState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_MuteState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This type holds all information of sinks relevant to the HMI.
     */
    struct am_SinkType_s : CommonAPI::Struct<am_sinkID_t, std::string, am_Availability_s, am_mainVolume_t, am_MuteState_e, am_sinkClass_t> {
    	
    	am_SinkType_s() {
    	}
    	am_SinkType_s(const am_sinkID_t &_sinkID, const std::string &_name, const am_Availability_s &_availability, const am_mainVolume_t &_volume, const am_MuteState_e &_muteState, const am_sinkClass_t &_sinkClassID)
    	{
    		std::get<0>(values_) = _sinkID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _availability;
    		std::get<3>(values_) = _volume;
    		std::get<4>(values_) = _muteState;
    		std::get<5>(values_) = _sinkClassID;
    	}
    	/**
    	 * description: This is the ID of the sink, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sinkID_e.
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<0>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the sink. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This attribute reflects the availability of the sink. There are several reasons
    	 *   why a sink could be not available for the moment: for example the shutdown of
    	 *   a sink because of overtemperature or over- &amp; undervoltage. The
    	 *   availability consists of two pieces of information:
    	- Availablility: the
    	 *   status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
    	-
    	 *   AvailabilityReason: this informs about the last reason for a change in
    	 *   availability. The reasons itself are product specific.
    	 */
    	inline const am_Availability_s &getAvailability() const { return std::get<2>(values_); }
    	inline void setAvailability(const am_Availability_s &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the representation of the Volume for the commandInterface. It is used
    	 *   by the HMI to set the volume of a sink, the AudioManagerController has to
    	 *   transform this into real source and sink volumes.
    	 */
    	inline const am_mainVolume_t &getVolume() const { return std::get<3>(values_); }
    	inline void setVolume(const am_mainVolume_t &_value) { std::get<3>(values_) = _value; }
    	inline const am_MuteState_e &getMuteState() const { return std::get<4>(values_); }
    	inline void setMuteState(const am_MuteState_e &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: The sink class ID references to a sink class. With the help of classification,
    	 *   rules can be setup to define the system behavior. the attribute is not used
    	 *   now.
    	 */
    	inline const am_sinkClass_t &getSinkClassID() const { return std::get<5>(values_); }
    	inline void setSinkClassID(const am_sinkClass_t &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const am_SinkType_s& _other) const {
                return (getSinkID() == _other.getSinkID() && getName() == _other.getName() && getAvailability() == _other.getAvailability() && getVolume() == _other.getVolume() && getMuteState() == _other.getMuteState() && getSinkClassID() == _other.getSinkClassID());
        }
    	inline bool operator!=(const am_SinkType_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_SinkType_s> am_SinkType_L;
    typedef uint16_t am_sourceClass_t;
    /**
     * description: Struct describing source classes.
     */
    struct am_SourceClass_s : CommonAPI::Struct<am_sourceClass_t, std::string, am_ClassProperty_L> {
    	
    	am_SourceClass_s() {
    	}
    	am_SourceClass_s(const am_sourceClass_t &_sourceClassID, const std::string &_name, const am_ClassProperty_L &_listClassProperties)
    	{
    		std::get<0>(values_) = _sourceClassID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _listClassProperties;
    	}
    	/**
    	 * description: The source ID.
    	 */
    	inline const am_sourceClass_t &getSourceClassID() const { return std::get<0>(values_); }
    	inline void setSourceClassID(const am_sourceClass_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the source class - must be unique in the system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The list of the class properties. These are pairs of a project specific enum
    	 *   describing the type of the value and an integer holding the value.
    	 */
    	inline const am_ClassProperty_L &getListClassProperties() const { return std::get<2>(values_); }
    	inline void setListClassProperties(const am_ClassProperty_L &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const am_SourceClass_s& _other) const {
                return (getSourceClassID() == _other.getSourceClassID() && getName() == _other.getName() && getListClassProperties() == _other.getListClassProperties());
        }
    	inline bool operator!=(const am_SourceClass_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_SourceClass_s> am_SourceClass_L;
    /**
     * description: This type holds all information of sources relevant to the HMI.
     */
    struct am_SourceType_s : CommonAPI::Struct<am_sourceID_t, std::string, am_Availability_s, am_sourceClass_t> {
    	
    	am_SourceType_s() {
    	}
    	am_SourceType_s(const am_sourceID_t &_sourceID, const std::string &_name, const am_Availability_s &_availability, const am_sourceClass_t &_sourceClassID)
    	{
    		std::get<0>(values_) = _sourceID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _availability;
    		std::get<3>(values_) = _sourceClassID;
    	}
    	/**
    	 * description: This is the ID of the source, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sourceID_e.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<0>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the source. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The availability of the source.
    	 */
    	inline const am_Availability_s &getAvailability() const { return std::get<2>(values_); }
    	inline void setAvailability(const am_Availability_s &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The source class ID, indicates the class the source is in. the attribute is not
    	 *   used.
    	 */
    	inline const am_sourceClass_t &getSourceClassID() const { return std::get<3>(values_); }
    	inline void setSourceClassID(const am_sourceClass_t &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const am_SourceType_s& _other) const {
                return (getSourceID() == _other.getSourceID() && getName() == _other.getName() && getAvailability() == _other.getAvailability() && getSourceClassID() == _other.getSourceClassID());
        }
    	inline bool operator!=(const am_SourceType_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_SourceType_s> am_SourceType_L;
    /**
     * description: Describes the different system properties. Project specific.
     */
    typedef uint16_t am_SystemPropertyType_pe;
    /**
     * description: Struct describing system properties.
     */
    struct am_SystemProperty_s : CommonAPI::Struct<am_SystemPropertyType_pe, int16_t> {
    	
    	am_SystemProperty_s() {
    	}
    	am_SystemProperty_s(const am_SystemPropertyType_pe &_type, const int16_t &_value)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _value;
    	}
    	/**
    	 * description: The type that is set.
    	 */
    	inline const am_SystemPropertyType_pe &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_SystemPropertyType_pe &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The value.
    	 */
    	inline const int16_t &getValue() const { return std::get<1>(values_); }
    	inline void setValue(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_SystemProperty_s& _other) const {
                return (getType() == _other.getType() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const am_SystemProperty_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_SystemProperty_s> am_SystemProperty_L;
    /**
     * description: A connection ID.
     */
    typedef uint16_t am_connectionID_t;
    typedef std::vector<am_t::am_connectionID_t> am_ConnectionID_L;
    /**
     * description: The unit is 0.1 db steps. The smallest value -3000 (=am_MUTE). The minimum and
     *   maximum can be limited by actual project.
     */
    typedef int16_t am_volume_t;
    /**
     * description: Project specific sound properties.
     */
    typedef uint16_t am_SoundPropertyType_pe;
    /**
     * description: Data type depends of am_EarlyDataType_e:
    sourceID in case of ED_SOURCE_VOLUME,
     *   ED_SOURCE_PROPERTY
    sinkID in case of ED_SINK_VOLUME, ED_SINK_PROPERTY
     */
    typedef CommonAPI::Variant<am_sinkID_t, am_sourceID_t>  am_DataType_u;
    /**
     * description: Struct describing the sound property.
     */
    struct am_SoundProperty_s : CommonAPI::Struct<am_SoundPropertyType_pe, int16_t> {
    	
    	am_SoundProperty_s() {
    	}
    	am_SoundProperty_s(const am_SoundPropertyType_pe &_type, const int16_t &_value)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _value;
    	}
    	/**
    	 * description: The type of the property - a project specific enum.
    	 */
    	inline const am_SoundPropertyType_pe &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_SoundPropertyType_pe &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The current value of the property.
    	 */
    	inline const int16_t &getValue() const { return std::get<1>(values_); }
    	inline void setValue(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_SoundProperty_s& _other) const {
                return (getType() == _other.getType() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const am_SoundProperty_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Data type depends of am_EarlyDataType_e:
    am_volume_t in case of
     *   ED_SOURCE_VOLUME, ED_SINK_VOLUME 
    am_soundProperty_t in case of
     *   ED_SOURCE_PROPERTY, ED_SINK_PROPERTY
     */
    typedef CommonAPI::Variant<am_volume_t, am_SoundProperty_s>  am_EarlyData_u;
    
    struct am_EarlyDataType_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ES_UNKNOWN = 0,
            ED_SOURCE_VOLUME = 1,
            ED_SINK_VOLUME = 2,
            ED_SOURCE_PROPERTY = 3,
            ED_SINK_PROPERTY = 4,
            ED_MAX = 5
        };
        
        am_EarlyDataType_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ES_UNKNOWN)) {}
        am_EarlyDataType_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ES_UNKNOWN):
                case static_cast<int32_t>(Literal::ED_SOURCE_VOLUME):
                case static_cast<int32_t>(Literal::ED_SINK_VOLUME):
                case static_cast<int32_t>(Literal::ED_SOURCE_PROPERTY):
                case static_cast<int32_t>(Literal::ED_SINK_PROPERTY):
                case static_cast<int32_t>(Literal::ED_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_EarlyDataType_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_EarlyDataType_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_EarlyDataType_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_EarlyDataType_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_EarlyDataType_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_EarlyDataType_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct am_EarlyData_s : CommonAPI::Struct<am_EarlyDataType_e, am_DataType_u, am_EarlyData_u> {
    	
    	am_EarlyData_s() {
    	}
    	am_EarlyData_s(const am_EarlyDataType_e &_type, const am_DataType_u &_sinksource, const am_EarlyData_u &_data)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _sinksource;
    		std::get<2>(values_) = _data;
    	}
    	inline const am_EarlyDataType_e &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_EarlyDataType_e &_value) { std::get<0>(values_) = _value; }
    	inline const am_DataType_u &getSinksource() const { return std::get<1>(values_); }
    	inline void setSinksource(const am_DataType_u &_value) { std::get<1>(values_) = _value; }
    	inline const am_EarlyData_u &getData() const { return std::get<2>(values_); }
    	inline void setData(const am_EarlyData_u &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const am_EarlyData_s& _other) const {
                return (getType() == _other.getType() && getSinksource() == _other.getSinksource() && getData() == _other.getData());
        }
    	inline bool operator!=(const am_EarlyData_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_EarlyData_s> am_EarlyData_L;
    
    struct am_CustomSoundPropertyType_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SP_UNKNOWN = 0,
            SP_GENIVI_FADE = 1,
            SP_GENIVI_BALANCE = 2,
            SP_GENIVI_BASS = 3,
            SP_GENIVI_MID_LOW = 12,
            SP_GENIVI_MID = 4,
            SP_GENIVI_MID_HIGH = 13,
            SP_GENIVI_TREBLE = 5,
            SP_GENIVI_EQ = 6,
            SP_GENIVI_CLARI_FI = 7,
            SP_GENIVI_LOUDNESS = 8,
            SP_GENIVI_AVC_MODE = 9,
            SP_GENIVI_A2DP_OFFSET = 14,
            SP_GENIVI_MIC_GAIN = 15,
            SP_GENIVI_AUX_OFFSET = 10,
            SP_GENIVI_SOURCE_VOLUME_STEP = 16,
            SP_GENIVI_SOURCE_MUTE = 17,
            SP_MAX = 18
        };
        
        am_CustomSoundPropertyType_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SP_UNKNOWN)) {}
        am_CustomSoundPropertyType_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SP_UNKNOWN):
                case static_cast<int32_t>(Literal::SP_GENIVI_FADE):
                case static_cast<int32_t>(Literal::SP_GENIVI_BALANCE):
                case static_cast<int32_t>(Literal::SP_GENIVI_BASS):
                case static_cast<int32_t>(Literal::SP_GENIVI_MID_LOW):
                case static_cast<int32_t>(Literal::SP_GENIVI_MID):
                case static_cast<int32_t>(Literal::SP_GENIVI_MID_HIGH):
                case static_cast<int32_t>(Literal::SP_GENIVI_TREBLE):
                case static_cast<int32_t>(Literal::SP_GENIVI_EQ):
                case static_cast<int32_t>(Literal::SP_GENIVI_CLARI_FI):
                case static_cast<int32_t>(Literal::SP_GENIVI_LOUDNESS):
                case static_cast<int32_t>(Literal::SP_GENIVI_AVC_MODE):
                case static_cast<int32_t>(Literal::SP_GENIVI_A2DP_OFFSET):
                case static_cast<int32_t>(Literal::SP_GENIVI_MIC_GAIN):
                case static_cast<int32_t>(Literal::SP_GENIVI_AUX_OFFSET):
                case static_cast<int32_t>(Literal::SP_GENIVI_SOURCE_VOLUME_STEP):
                case static_cast<int32_t>(Literal::SP_GENIVI_SOURCE_MUTE):
                case static_cast<int32_t>(Literal::SP_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_CustomSoundPropertyType_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_CustomSoundPropertyType_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_CustomSoundPropertyType_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_CustomSoundPropertyType_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_CustomSoundPropertyType_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_CustomSoundPropertyType_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Struct describing main sound property.
     */
    struct am_MainSoundProperty_s : CommonAPI::Struct<am_CustomSoundPropertyType_e, int16_t> {
    	
    	am_MainSoundProperty_s() {
    	}
    	am_MainSoundProperty_s(const am_CustomSoundPropertyType_e &_type, const int16_t &_value)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _value;
    	}
    	/**
    	 * description: The type of the property.
    	 */
    	inline const am_CustomSoundPropertyType_e &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_CustomSoundPropertyType_e &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The current value.
    	 */
    	inline const int16_t &getValue() const { return std::get<1>(values_); }
    	inline void setValue(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_MainSoundProperty_s& _other) const {
                return (getType() == _other.getType() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const am_MainSoundProperty_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_MainSoundProperty_s> am_MainSoundProperty_L;
    /**
     * description: Gives the type of the Notification.
     */
    typedef uint16_t am_NotificationType_pe;
    
    struct am_NotificationStatus_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            NS_UNKNOWN = 0,
            NS_OFF = 1,
            NS_PERIODIC = 2,
            NS_MINIMUM = 3,
            NS_MAXIMUM = 4,
            NS_CHANGE = 5,
            NS_MAX = 6
        };
        
        am_NotificationStatus_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::NS_UNKNOWN)) {}
        am_NotificationStatus_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NS_UNKNOWN):
                case static_cast<int32_t>(Literal::NS_OFF):
                case static_cast<int32_t>(Literal::NS_PERIODIC):
                case static_cast<int32_t>(Literal::NS_MINIMUM):
                case static_cast<int32_t>(Literal::NS_MAXIMUM):
                case static_cast<int32_t>(Literal::NS_CHANGE):
                case static_cast<int32_t>(Literal::NS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_NotificationStatus_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_NotificationStatus_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_NotificationStatus_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_NotificationStatus_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_NotificationStatus_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_NotificationStatus_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This struct holds information about the configuration for notifications.
     */
    struct am_NotificationConfiguration_s : CommonAPI::Struct<am_NotificationType_pe, am_NotificationStatus_e, int16_t> {
    	
    	am_NotificationConfiguration_s() {
    	}
    	am_NotificationConfiguration_s(const am_NotificationType_pe &_type, const am_NotificationStatus_e &_status, const int16_t &_parameter)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _status;
    		std::get<2>(values_) = _parameter;
    	}
    	/**
    	 * description: The notification type of the notification.
    	 */
    	inline const am_NotificationType_pe &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_NotificationType_pe &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The Notification status. This can be periodic, min/max value based or even off
    	 *   for example.
    	 */
    	inline const am_NotificationStatus_e &getStatus() const { return std::get<1>(values_); }
    	inline void setStatus(const am_NotificationStatus_e &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This gives additional information to the notification status.
    	
    	Relation between
    	 *   notification status and the value:
    	NS_PERIODIC - the period in ms
    	NS_MINIMUM -
    	 *   the minimum value that triggers the notification
    	NS_MAXIMUM - the maximum
    	 *   value that triggers the notification
    	NS_CHANGE - the resolution of the change
    	 *   value
    	 */
    	inline const int16_t &getParameter() const { return std::get<2>(values_); }
    	inline void setParameter(const int16_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const am_NotificationConfiguration_s& _other) const {
                return (getType() == _other.getType() && getStatus() == _other.getStatus() && getParameter() == _other.getParameter());
        }
    	inline bool operator!=(const am_NotificationConfiguration_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_NotificationConfiguration_s> am_NotificationConfiguration_L;
    typedef std::vector<am_t::am_SoundProperty_s> am_SoundProperty_L;
    /**
     * description: Time in ms.
     */
    typedef int16_t am_time_t;
    /**
     * description: For products, different ramp types can be defined here.
    It is in the
     *   responsibility of the product to make sure that the routing plugins are aware
     *   of the ramp types used.
     */
    typedef uint16_t am_RampType_pe;
    
    struct am_VolumeType_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            VT_UNKNOWN = 0,
            VT_SINK = 1,
            VT_SOURCE = 2,
            VT_MAX = 3
        };
        
        am_VolumeType_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::VT_UNKNOWN)) {}
        am_VolumeType_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::VT_UNKNOWN):
                case static_cast<int32_t>(Literal::VT_SINK):
                case static_cast<int32_t>(Literal::VT_SOURCE):
                case static_cast<int32_t>(Literal::VT_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_VolumeType_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_VolumeType_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_VolumeType_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_VolumeType_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_VolumeType_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_VolumeType_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This types describe a mixed description for source and sinks volumes.
     */
    struct am_Volumes_s : CommonAPI::Struct<am_VolumeType_e, am_DataType_u, am_volume_t, am_RampType_pe, am_time_t> {
    	
    	am_Volumes_s() {
    	}
    	am_Volumes_s(const am_VolumeType_e &_volumeType, const am_DataType_u &_volumeID, const am_volume_t &_volume, const am_RampType_pe &_ramp, const am_time_t &_time)
    	{
    		std::get<0>(values_) = _volumeType;
    		std::get<1>(values_) = _volumeID;
    		std::get<2>(values_) = _volume;
    		std::get<3>(values_) = _ramp;
    		std::get<4>(values_) = _time;
    	}
    	/**
    	 * description: Describes the type of the volume: source or sink.
    	 */
    	inline const am_VolumeType_e &getVolumeType() const { return std::get<0>(values_); }
    	inline void setVolumeType(const am_VolumeType_e &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Either source ID or sink ID.
    	 */
    	inline const am_DataType_u &getVolumeID() const { return std::get<1>(values_); }
    	inline void setVolumeID(const am_DataType_u &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The volume.
    	 */
    	inline const am_volume_t &getVolume() const { return std::get<2>(values_); }
    	inline void setVolume(const am_volume_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The ramp that shall be driven.
    	 */
    	inline const am_RampType_pe &getRamp() const { return std::get<3>(values_); }
    	inline void setRamp(const am_RampType_pe &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The time for the ramp.
    	 */
    	inline const am_time_t &getTime() const { return std::get<4>(values_); }
    	inline void setTime(const am_time_t &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const am_Volumes_s& _other) const {
                return (getVolumeType() == _other.getVolumeType() && getVolumeID() == _other.getVolumeID() && getVolume() == _other.getVolume() && getRamp() == _other.getRamp() && getTime() == _other.getTime());
        }
    	inline bool operator!=(const am_Volumes_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<am_t::am_Volumes_s> am_Volumes_L;
    /**
     * description: This project specific value classifies the format in which data is exchanged
     *   within a connection.
     */
    typedef uint16_t am_ConnectionFormat_pe;
    typedef std::vector<am_t::am_ConnectionFormat_pe> am_ConnectionFormat_L;
    typedef std::vector<bool> am_Convertion_L;
    /**
     * description: A domain ID.
     */
    typedef uint16_t am_domainID_t;
    /**
     * description: A gateway ID.
     */
    typedef uint16_t am_gatewayID_t;
    /**
     * description: A converter ID.
     */
    typedef uint16_t am_converterID_t;
    /**
     * description: A crossfader ID.
     */
    typedef uint16_t am_crossfaderID_t;
    /**
     * description: Speed.
     */
    typedef uint16_t am_speed_t;
    /**
     * description: Here are all sound properties that can be set via the CommandInterface. Product
     *   specific.
     */
    typedef uint16_t am_MainSoundPropertyType_pe;
    
    struct am_HotSink_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            HS_UNKNOWN = 0,
            HS_SINKA = 1,
            HS_SINKB = 2,
            HS_INTERMEDIATE = 3,
            HS_MAX = 4
        };
        
        am_HotSink_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::HS_UNKNOWN)) {}
        am_HotSink_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::HS_UNKNOWN):
                case static_cast<int32_t>(Literal::HS_SINKA):
                case static_cast<int32_t>(Literal::HS_SINKB):
                case static_cast<int32_t>(Literal::HS_INTERMEDIATE):
                case static_cast<int32_t>(Literal::HS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_HotSink_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_HotSink_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_HotSink_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_HotSink_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_HotSink_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_HotSink_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This struct describes the attributes of a crossfader.
     */
    struct am_Crossfader_s : CommonAPI::Struct<am_crossfaderID_t, std::string, am_sinkID_t, am_sinkID_t, am_sourceID_t, am_HotSink_e> {
    	
    	am_Crossfader_s() {
    	}
    	am_Crossfader_s(const am_crossfaderID_t &_crossfaderID, const std::string &_name, const am_sinkID_t &_sinkIDA, const am_sinkID_t &_sinkIDB, const am_sourceID_t &_sourceID, const am_HotSink_e &_hotSink)
    	{
    		std::get<0>(values_) = _crossfaderID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _sinkIDA;
    		std::get<3>(values_) = _sinkIDB;
    		std::get<4>(values_) = _sourceID;
    		std::get<5>(values_) = _hotSink;
    	}
    	/**
    	 * description: This is the ID of the crossfader, it is unique in the system. There are 2 ways,
    	 *   ID can be created: either it is assigned during the registration process (in a
    	 *   dynamic context, uniqueness will be ensured by the AudioManager daemon), or it
    	 *   is a fixed (the project has to ensure the uniqueness of the ID).
    	 */
    	inline const am_crossfaderID_t &getCrossfaderID() const { return std::get<0>(values_); }
    	inline void setCrossfaderID(const am_crossfaderID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the crossfader. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The sink ID of the sink A. Sinks shall be registered before registering the
    	 *   crossfader.
    	 */
    	inline const am_sinkID_t &getSinkIDA() const { return std::get<2>(values_); }
    	inline void setSinkIDA(const am_sinkID_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The sink ID of the sink B. Sinks shall be registered before registering the
    	 *   crossfader.
    	 */
    	inline const am_sinkID_t &getSinkIDB() const { return std::get<3>(values_); }
    	inline void setSinkIDB(const am_sinkID_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The source ID of the crossfader source. The source shall be registered before
    	 *   the crossfader.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<4>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This enum can have 3 states:
    	    HS_SINKA sink A is the current hot one, sink B
    	 *   is not audible
    	    HS_SINKB sink B is the current hot one, sink B is not
    	 *   audible
    	    HS_INTERMEDIATE the fader is stuck in between a cross-fading
    	 *   action. This could be due to an abort or an error. Before using the
    	 *   crossfader, it must be set to either HS_SINKA or HS_SINKB.
    	 */
    	inline const am_HotSink_e &getHotSink() const { return std::get<5>(values_); }
    	inline void setHotSink(const am_HotSink_e &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const am_Crossfader_s& _other) const {
                return (getCrossfaderID() == _other.getCrossfaderID() && getName() == _other.getName() && getSinkIDA() == _other.getSinkIDA() && getSinkIDB() == _other.getSinkIDB() && getSourceID() == _other.getSourceID() && getHotSink() == _other.getHotSink());
        }
    	inline bool operator!=(const am_Crossfader_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct describes the attributes of a gateway.
     */
    struct am_Gateway_s : CommonAPI::Struct<am_gatewayID_t, std::string, am_sinkID_t, am_sourceID_t, am_domainID_t, am_domainID_t, am_domainID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L> {
    	
    	am_Gateway_s() {
    	}
    	am_Gateway_s(const am_gatewayID_t &_gatewayID, const std::string &_name, const am_sinkID_t &_sinkID, const am_sourceID_t &_sourceID, const am_domainID_t &_domainSinkID, const am_domainID_t &_domainSourceID, const am_domainID_t &_controlDomainID, const am_ConnectionFormat_L &_listSourceFormats, const am_ConnectionFormat_L &_listSinkFormats, const am_Convertion_L &_convertionMatrix)
    	{
    		std::get<0>(values_) = _gatewayID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _sinkID;
    		std::get<3>(values_) = _sourceID;
    		std::get<4>(values_) = _domainSinkID;
    		std::get<5>(values_) = _domainSourceID;
    		std::get<6>(values_) = _controlDomainID;
    		std::get<7>(values_) = _listSourceFormats;
    		std::get<8>(values_) = _listSinkFormats;
    		std::get<9>(values_) = _convertionMatrix;
    	}
    	/**
    	 * description: This is the ID of the gateway, it is unique in the system. There are 2 ways, ID
    	 *   can be created: either it is assigned during the registration process (in a
    	 *   dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
    	 *   is a fixed (the project has to ensure the uniqueness of the ID).
    	 */
    	inline const am_gatewayID_t &getGatewayID() const { return std::get<0>(values_); }
    	inline void setGatewayID(const am_gatewayID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the gateway. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The sinkID of the gateway sink-end. The sink is a full blown sink with
    	 *   connectionFormats, sinkClassIDs etc... It makes sense to register the sinks of
    	 *   a gateway as non-visible. Care needs to be taken that the connectionsFormats
    	 *   match with the ones in the conversionMatrix. If the sink is located in the
    	 *   controllingDomain, the ID needs to be retrieved by registering the sink before
    	 *   registering the gateway. In case the sink is in a different domain, the ID
    	 *   needs to be retrieved via peeking.
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<2>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The sourceID of the gateway sink-end. The sink is a full blown source with
    	 *   connectionFormats, sinkClassIDs etc... It makes sense to register the sources
    	 *   of a gateway as non-visible. Care needs to be taken that the
    	 *   connectionsFormats match with the ones in the conversionMatrix. If the source
    	 *   is located in the controllingDomain, the ID needs to be retrieved by
    	 *   registering the source before registering the gateway. In case the source is
    	 *   in a different domain, the ID needs to be retrieved via peeking.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<3>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The ID of the sink. If the domain is the same like the controlling domain, the
    	 *   ID is known due to registration. If the domain is different, the ID needs to
    	 *   be retrieved via peeking.
    	 */
    	inline const am_domainID_t &getDomainSinkID() const { return std::get<4>(values_); }
    	inline void setDomainSinkID(const am_domainID_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: The ID of the source. If the domain is the same like the controlling domain,
    	 *   the ID is known due to registration. If the domain is different, the ID needs
    	 *   to be retrieved via peeking.
    	 */
    	inline const am_domainID_t &getDomainSourceID() const { return std::get<5>(values_); }
    	inline void setDomainSourceID(const am_domainID_t &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This is the ID of the domain that registers the gateway.
    	 */
    	inline const am_domainID_t &getControlDomainID() const { return std::get<6>(values_); }
    	inline void setControlDomainID(const am_domainID_t &_value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: This is the list of available formats on the source side of the gateway. It is
    	 *   not defined during the gateway registration but copied from the source
    	 *   registration.
    	 */
    	inline const am_ConnectionFormat_L &getListSourceFormats() const { return std::get<7>(values_); }
    	inline void setListSourceFormats(const am_ConnectionFormat_L &_value) { std::get<7>(values_) = _value; }
    	/**
    	 * description: This is the list of available formats on the sink side of the gateway. It is
    	 *   not defined during the gateway registration but copied from the sink
    	 *   registration.
    	 */
    	inline const am_ConnectionFormat_L &getListSinkFormats() const { return std::get<8>(values_); }
    	inline void setListSinkFormats(const am_ConnectionFormat_L &_value) { std::get<8>(values_) = _value; }
    	/**
    	 * description: This is matrix holding information about the conversion capability of the
    	 *   gateway, it's length is defined by the length(listSinkFormats) x
    	 *   length(listSourceFormats).
    	If a SinkFormat can be converted into a
    	 *   SourceFormat, the vector will hold a 1, if no conversion is possible, a 0.
    	The
    	 *   data is stored row orientated, where the rows are related to the sinksFormats
    	 *   and the columns to the sourceFormats. The first value will hold the conversion
    	 *   information from the first sourceFormat to the first sinkFormat for example
    	 *   and the seventh value the information about the 3rd sinkFormat to the 1st
    	 *   sourceFormat in case we would have 3 sourceFormats.
    	 */
    	inline const am_Convertion_L &getConvertionMatrix() const { return std::get<9>(values_); }
    	inline void setConvertionMatrix(const am_Convertion_L &_value) { std::get<9>(values_) = _value; }
    	inline bool operator==(const am_Gateway_s& _other) const {
                return (getGatewayID() == _other.getGatewayID() && getName() == _other.getName() && getSinkID() == _other.getSinkID() && getSourceID() == _other.getSourceID() && getDomainSinkID() == _other.getDomainSinkID() && getDomainSourceID() == _other.getDomainSourceID() && getControlDomainID() == _other.getControlDomainID() && getListSourceFormats() == _other.getListSourceFormats() && getListSinkFormats() == _other.getListSinkFormats() && getConvertionMatrix() == _other.getConvertionMatrix());
        }
    	inline bool operator!=(const am_Gateway_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct am_Handle_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            H_UNKNOWN = 0,
            H_CONNECT = 1,
            H_DISCONNECT = 2,
            H_SETSOURCESTATE = 3,
            H_SETSINKVOLUME = 4,
            H_SETSOURCEVOLUME = 5,
            H_SETSINKSOUNDPROPERTY = 6,
            H_SETSOURCESOUNDPROPERTY = 7,
            H_SETSINKSOUNDPROPERTIES = 8,
            H_SETSOURCESOUNDPROPERTIES = 9,
            H_CROSSFADE = 10,
            H_SETVOLUMES = 11,
            H_SETSINKNOTIFICATION = 12,
            H_SETSOURCENOTIFICATION = 13,
            H_MAX = 14
        };
        
        am_Handle_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::H_UNKNOWN)) {}
        am_Handle_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::H_UNKNOWN):
                case static_cast<int32_t>(Literal::H_CONNECT):
                case static_cast<int32_t>(Literal::H_DISCONNECT):
                case static_cast<int32_t>(Literal::H_SETSOURCESTATE):
                case static_cast<int32_t>(Literal::H_SETSINKVOLUME):
                case static_cast<int32_t>(Literal::H_SETSOURCEVOLUME):
                case static_cast<int32_t>(Literal::H_SETSINKSOUNDPROPERTY):
                case static_cast<int32_t>(Literal::H_SETSOURCESOUNDPROPERTY):
                case static_cast<int32_t>(Literal::H_SETSINKSOUNDPROPERTIES):
                case static_cast<int32_t>(Literal::H_SETSOURCESOUNDPROPERTIES):
                case static_cast<int32_t>(Literal::H_CROSSFADE):
                case static_cast<int32_t>(Literal::H_SETVOLUMES):
                case static_cast<int32_t>(Literal::H_SETSINKNOTIFICATION):
                case static_cast<int32_t>(Literal::H_SETSOURCENOTIFICATION):
                case static_cast<int32_t>(Literal::H_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Handle_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Handle_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Handle_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Handle_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Handle_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Handle_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: A handle is used for asynchronous operations and is uniquely assigned for each
     *   of this operations.
     */
    struct am_Handle_s : CommonAPI::Struct<am_Handle_e, uint16_t> {
    	
    	am_Handle_s() {
    	}
    	am_Handle_s(const am_Handle_e &_handleType, const uint16_t &_handle)
    	{
    		std::get<0>(values_) = _handleType;
    		std::get<1>(values_) = _handle;
    	}
    	/**
    	 * description: The handle type.
    	 */
    	inline const am_Handle_e &getHandleType() const { return std::get<0>(values_); }
    	inline void setHandleType(const am_Handle_e &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The handle as value.
    	 */
    	inline const uint16_t &getHandle() const { return std::get<1>(values_); }
    	inline void setHandle(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_Handle_s& _other) const {
                return (getHandleType() == _other.getHandleType() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const am_Handle_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct holds the payload of a notification.
     */
    struct am_NotificationPayload_s : CommonAPI::Struct<am_NotificationType_pe, int16_t> {
    	
    	am_NotificationPayload_s() {
    	}
    	am_NotificationPayload_s(const am_NotificationType_pe &_type, const int16_t &_value)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _value;
    	}
    	/**
    	 * description: This defines the notification type.
    	 */
    	inline const am_NotificationType_pe &getType() const { return std::get<0>(values_); }
    	inline void setType(const am_NotificationType_pe &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the value of the notification. It's meaning depends on the notification
    	 *   type.
    	 */
    	inline const int16_t &getValue() const { return std::get<1>(values_); }
    	inline void setValue(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const am_NotificationPayload_s& _other) const {
                return (getType() == _other.getType() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const am_NotificationPayload_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct describes the attributes of a sink.
     */
    struct am_Sink_s : CommonAPI::Struct<am_sinkID_t, std::string, am_domainID_t, am_sinkClass_t, am_volume_t, bool, am_Availability_s, am_MuteState_e, am_mainVolume_t, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L, am_NotificationConfiguration_L, am_NotificationConfiguration_L> {
    	
    	am_Sink_s() {
    		std::get<5>(values_) = false;
    	}
    	am_Sink_s(const am_sinkID_t &_sinkID, const std::string &_name, const am_domainID_t &_domainID, const am_sinkClass_t &_sinkClassID, const am_volume_t &_volume, const bool &_visible, const am_Availability_s &_available, const am_MuteState_e &_muteState, const am_mainVolume_t &_mainVolume, const am_SoundProperty_L &_listSoundProperties, const am_ConnectionFormat_L &_listConnectionFormats, const am_MainSoundProperty_L &_listMainSoundProperties, const am_NotificationConfiguration_L &_listMainNotificationConfigurations, const am_NotificationConfiguration_L &_listNotificationConfigurations)
    	{
    		std::get<0>(values_) = _sinkID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _domainID;
    		std::get<3>(values_) = _sinkClassID;
    		std::get<4>(values_) = _volume;
    		std::get<5>(values_) = _visible;
    		std::get<6>(values_) = _available;
    		std::get<7>(values_) = _muteState;
    		std::get<8>(values_) = _mainVolume;
    		std::get<9>(values_) = _listSoundProperties;
    		std::get<10>(values_) = _listConnectionFormats;
    		std::get<11>(values_) = _listMainSoundProperties;
    		std::get<12>(values_) = _listMainNotificationConfigurations;
    		std::get<13>(values_) = _listNotificationConfigurations;
    	}
    	/**
    	 * description: This is the ID of the sink, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sinkID_e..
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<0>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the sink. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The domain ID is the domain the sink belongs to. A sink can only be in one
    	 *   domain. domainID only can be getten by registerDomain.
    	 */
    	inline const am_domainID_t &getDomainID() const { return std::get<2>(values_); }
    	inline void setDomainID(const am_domainID_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The sink class ID references to a sink class. With the help of classification,
    	 *   rules can be setup to define the system behavior.
    	 */
    	inline const am_sinkClass_t &getSinkClassID() const { return std::get<3>(values_); }
    	inline void setSinkClassID(const am_sinkClass_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the volume of the sink. It is set by the AudioManagerController.
    	 */
    	inline const am_volume_t &getVolume() const { return std::get<4>(values_); }
    	inline void setVolume(const am_volume_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This Boolean flag indicates whether a sink is visible to the commandInterface
    	 *   or not. If the User must have the possibility to choose the source in the HMI,
    	 *   it must be visible. But there are also good reasons for invisible sinks, for
    	 *   example if the sink is part of a crossfader or gateway. HMI relevant changes
    	 *   in visible sinks will be automatically reported by the daemon to the
    	 *   commandInterface.
    	 */
    	inline const bool &getVisible() const { return std::get<5>(values_); }
    	inline void setVisible(const bool _value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This attribute reflects the availability of the sink. There are several reasons
    	 *   why a sink could be not available for the moment: for example the shutdown of
    	 *   a sink because of overtemperature or over- &amp; undervoltage. The
    	 *   availability consists of two pieces of information:
    	    Availablility: the
    	 *   status itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
    	   
    	 *   AvailabilityReason: this informs about the last reason for a change in
    	 *   availability. The reasons itself are product specific.
    	 */
    	inline const am_Availability_s &getAvailable() const { return std::get<6>(values_); }
    	inline void setAvailable(const am_Availability_s &_value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: This attribute reflects the mute state of the sink. The information is not the
    	 *   "real" state of the sink, but the HMI representation for he commandInterface
    	 *   controlled by the AudioManagerController.
    	 */
    	inline const am_MuteState_e &getMuteState() const { return std::get<7>(values_); }
    	inline void setMuteState(const am_MuteState_e &_value) { std::get<7>(values_) = _value; }
    	/**
    	 * description: This is the representation of the Volume for the commandInterface. It is used
    	 *   by the HMI to set the volume of a sink, the AudioManagerController has to
    	 *   transform this into real source and sink volumes.
    	 */
    	inline const am_mainVolume_t &getMainVolume() const { return std::get<8>(values_); }
    	inline void setMainVolume(const am_mainVolume_t &_value) { std::get<8>(values_) = _value; }
    	/**
    	 * description: This is the list of sound properties, that the sink is capable of. The sound
    	 *   properties itself are project specific. For sinks, a possible sound property
    	 *   could be for example settings.
    	 */
    	inline const am_SoundProperty_L &getListSoundProperties() const { return std::get<9>(values_); }
    	inline void setListSoundProperties(const am_SoundProperty_L &_value) { std::get<9>(values_) = _value; }
    	/**
    	 * description: This list holds information about the formats that the Source is capable of
    	 *   supporting when delivering audio.
    	 */
    	inline const am_ConnectionFormat_L &getListConnectionFormats() const { return std::get<10>(values_); }
    	inline void setListConnectionFormats(const am_ConnectionFormat_L &_value) { std::get<10>(values_) = _value; }
    	/**
    	 * description: This is the list of the available mainsound properties. The principle is the
    	 *   same than with sound properties, but they are only visible to the
    	 *   CommandInterface.
    	 */
    	inline const am_MainSoundProperty_L &getListMainSoundProperties() const { return std::get<11>(values_); }
    	inline void setListMainSoundProperties(const am_MainSoundProperty_L &_value) { std::get<11>(values_) = _value; }
    	/**
    	 * description: This is the list of the MainNotificationConfigurations. These notifications
    	 *   work on the level of command interface.
    	 */
    	inline const am_NotificationConfiguration_L &getListMainNotificationConfigurations() const { return std::get<12>(values_); }
    	inline void setListMainNotificationConfigurations(const am_NotificationConfiguration_L &_value) { std::get<12>(values_) = _value; }
    	/**
    	 * description: This is the list of the NotificationConfigurations. These notifications work on
    	 *   the level of RoutingPlugins.
    	 */
    	inline const am_NotificationConfiguration_L &getListNotificationConfigurations() const { return std::get<13>(values_); }
    	inline void setListNotificationConfigurations(const am_NotificationConfiguration_L &_value) { std::get<13>(values_) = _value; }
    	inline bool operator==(const am_Sink_s& _other) const {
                return (getSinkID() == _other.getSinkID() && getName() == _other.getName() && getDomainID() == _other.getDomainID() && getSinkClassID() == _other.getSinkClassID() && getVolume() == _other.getVolume() && getVisible() == _other.getVisible() && getAvailable() == _other.getAvailable() && getMuteState() == _other.getMuteState() && getMainVolume() == _other.getMainVolume() && getListSoundProperties() == _other.getListSoundProperties() && getListConnectionFormats() == _other.getListConnectionFormats() && getListMainSoundProperties() == _other.getListMainSoundProperties() && getListMainNotificationConfigurations() == _other.getListMainNotificationConfigurations() && getListNotificationConfigurations() == _other.getListNotificationConfigurations());
        }
    	inline bool operator!=(const am_Sink_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct am_InterruptState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            IS_UNKNOWN = 0,
            IS_OFF = 1,
            IS_INTERRUPTED = 2,
            IS_MAX = 3
        };
        
        am_InterruptState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::IS_UNKNOWN)) {}
        am_InterruptState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::IS_UNKNOWN):
                case static_cast<int32_t>(Literal::IS_OFF):
                case static_cast<int32_t>(Literal::IS_INTERRUPTED):
                case static_cast<int32_t>(Literal::IS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_InterruptState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_InterruptState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_InterruptState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_InterruptState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_InterruptState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_InterruptState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_SourceState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SS_UNKNNOWN = 0,
            SS_ON = 1,
            SS_OFF = 2,
            SS_PAUSED = 3,
            SS_MAX = 4
        };
        
        am_SourceState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SS_UNKNNOWN)) {}
        am_SourceState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SS_UNKNNOWN):
                case static_cast<int32_t>(Literal::SS_ON):
                case static_cast<int32_t>(Literal::SS_OFF):
                case static_cast<int32_t>(Literal::SS_PAUSED):
                case static_cast<int32_t>(Literal::SS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_SourceState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_SourceState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_SourceState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_SourceState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_SourceState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_SourceState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This struct describes the attributes of a source.
     */
    struct am_Source_s : CommonAPI::Struct<am_sourceID_t, am_domainID_t, std::string, am_sourceClass_t, am_SourceState_e, am_volume_t, bool, am_Availability_s, am_InterruptState_e, am_SoundProperty_L, am_ConnectionFormat_L, am_MainSoundProperty_L, am_NotificationConfiguration_L, am_NotificationConfiguration_L> {
    	
    	am_Source_s() {
    		std::get<6>(values_) = false;
    	}
    	am_Source_s(const am_sourceID_t &_sourceID, const am_domainID_t &_domainID, const std::string &_name, const am_sourceClass_t &_sourceClassID, const am_SourceState_e &_sourceState, const am_volume_t &_volume, const bool &_visible, const am_Availability_s &_available, const am_InterruptState_e &_interruptState, const am_SoundProperty_L &_listSoundProperties, const am_ConnectionFormat_L &_listConnectionFormats, const am_MainSoundProperty_L &_listMainSoundProperties, const am_NotificationConfiguration_L &_listMainNotificationConfigurations, const am_NotificationConfiguration_L &_listNotificationConfigurations)
    	{
    		std::get<0>(values_) = _sourceID;
    		std::get<1>(values_) = _domainID;
    		std::get<2>(values_) = _name;
    		std::get<3>(values_) = _sourceClassID;
    		std::get<4>(values_) = _sourceState;
    		std::get<5>(values_) = _volume;
    		std::get<6>(values_) = _visible;
    		std::get<7>(values_) = _available;
    		std::get<8>(values_) = _interruptState;
    		std::get<9>(values_) = _listSoundProperties;
    		std::get<10>(values_) = _listConnectionFormats;
    		std::get<11>(values_) = _listMainSoundProperties;
    		std::get<12>(values_) = _listMainNotificationConfigurations;
    		std::get<13>(values_) = _listNotificationConfigurations;
    	}
    	/**
    	 * description: This is the ID of the source, it is unique in the system. we have listed all
    	 *   the sourceID in below am_sourceID_e.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<0>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The domain ID is the domain the source belongs to. A source can only be in one
    	 *   domain. domainID only can be getten by registerDomain.
    	 */
    	inline const am_domainID_t &getDomainID() const { return std::get<1>(values_); }
    	inline void setDomainID(const am_domainID_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The name of the source. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<2>(values_); }
    	inline void setName(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The source class ID, indicates the class the source is in. the attribute is not
    	 *   used now.
    	 */
    	inline const am_sourceClass_t &getSourceClassID() const { return std::get<3>(values_); }
    	inline void setSourceClassID(const am_sourceClass_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The source state is an indication towards the source if it is actively heard or
    	 *   not. The source can use this information to implement features like automatic
    	 *   spin down of CD's in case the CD is not the active source or AF following of a
    	 *   tuner that is not actively heard. The source state is set by the
    	 *   AudioManagerController.There are 3 possible states:
    	    SS_ON: the source is
    	 *   active
    	    SS_OFF: the source is off
    	    SS_PAUSED: the source is paused and
    	 *   not active.
    	 */
    	inline const am_SourceState_e &getSourceState() const { return std::get<4>(values_); }
    	inline void setSourceState(const am_SourceState_e &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is the volume of the source. It is set by the AudioManagerController. It
    	 *   is used to adopt different audio levels in a system and mixing of sources
    	 *   (e.g. navigation hints &amp; music).
    	 */
    	inline const am_volume_t &getVolume() const { return std::get<5>(values_); }
    	inline void setVolume(const am_volume_t &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This Boolean flag indicates whether a source is visible to the commandInterface
    	 *   or not. If the User must have the possibility to choose the source in the HMI,
    	 *   it must be visible. But there are also good reasons for invisible sources, for
    	 *   example if the source is part of a crossfader or gateway. HMI relevant changes
    	 *   in visible sources will be automatically reported by the daemon to the
    	 *   commandInterface.
    	 */
    	inline const bool &getVisible() const { return std::get<6>(values_); }
    	inline void setVisible(const bool _value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: This attribute reflects the availability of the source. There are several
    	 *   reasons why a source could be not available for the moment. For example a CD
    	 *   player which has no CD entered in the slot can be unavailable, or a USB player
    	 *   with no or unreadable stick attached. Other scenarios involve the shutdown of
    	 *   a source because of overtemperature or over- &amp; undervoltage. The
    	 *   availability consists of two information:
    	    Availablility: the status
    	 *   itself, can be A_AVAILABLE, A_UNAVAILABLE or A_UNKNOWN
    	    AvailabilityReason:
    	 *   this informs about the last reason for a change in availability. The reasons
    	 *   itself are product specific.
    	 */
    	inline const am_Availability_s &getAvailable() const { return std::get<7>(values_); }
    	inline void setAvailable(const am_Availability_s &_value) { std::get<7>(values_) = _value; }
    	/**
    	 * description: Some special sources can have special behaviors, the are so called "Low Level
    	 *   Interrupts". Here the current status is documented. The information can be
    	 *   used by the AudioManagerController to react to the changes by for example
    	 *   lowering the volume of the main sources. The two states are
    	    IS_OFF: the
    	 *   interrupt is not active at the moment
    	    IS_INTERRUPTED: the interrupt is
    	 *   playing at the moment.
    	 */
    	inline const am_InterruptState_e &getInterruptState() const { return std::get<8>(values_); }
    	inline void setInterruptState(const am_InterruptState_e &_value) { std::get<8>(values_) = _value; }
    	/**
    	 * description: This is the list of sound properties, that the source is capable of. The sound
    	 *   properties itself are project specific. For sources, a possible sound property
    	 *   could be navigation volume offset, for example.
    	                           for
    	 *   method registerSource, this params is option.
    	 */
    	inline const am_SoundProperty_L &getListSoundProperties() const { return std::get<9>(values_); }
    	inline void setListSoundProperties(const am_SoundProperty_L &_value) { std::get<9>(values_) = _value; }
    	/**
    	 * description: This list holds information about the formats that the Source is capable of
    	 *   supporting when delivering audio.
    	 */
    	inline const am_ConnectionFormat_L &getListConnectionFormats() const { return std::get<10>(values_); }
    	inline void setListConnectionFormats(const am_ConnectionFormat_L &_value) { std::get<10>(values_) = _value; }
    	/**
    	 * description: This is the list of the available main sound properties. The principle is the
    	 *   same than with sound properties, but they are only visible to the
    	 *   CommandInterface.
    	                           for method registerSource, this
    	 *   params is option.
    	 */
    	inline const am_MainSoundProperty_L &getListMainSoundProperties() const { return std::get<11>(values_); }
    	inline void setListMainSoundProperties(const am_MainSoundProperty_L &_value) { std::get<11>(values_) = _value; }
    	/**
    	 * description: The list of MainNotificationConfigurations. These notifications work on the
    	 *   level of CommandInterface.
    	                           for method
    	 *   registerSource, this params is option.
    	 */
    	inline const am_NotificationConfiguration_L &getListMainNotificationConfigurations() const { return std::get<12>(values_); }
    	inline void setListMainNotificationConfigurations(const am_NotificationConfiguration_L &_value) { std::get<12>(values_) = _value; }
    	/**
    	 * description: The list of MainNotificationConfigurations. These notifications work on the
    	 *   level of RoutingInterface.
    	                           for method
    	 *   registerSource, this params is option.
    	 */
    	inline const am_NotificationConfiguration_L &getListNotificationConfigurations() const { return std::get<13>(values_); }
    	inline void setListNotificationConfigurations(const am_NotificationConfiguration_L &_value) { std::get<13>(values_) = _value; }
    	inline bool operator==(const am_Source_s& _other) const {
                return (getSourceID() == _other.getSourceID() && getDomainID() == _other.getDomainID() && getName() == _other.getName() && getSourceClassID() == _other.getSourceClassID() && getSourceState() == _other.getSourceState() && getVolume() == _other.getVolume() && getVisible() == _other.getVisible() && getAvailable() == _other.getAvailable() && getInterruptState() == _other.getInterruptState() && getListSoundProperties() == _other.getListSoundProperties() && getListConnectionFormats() == _other.getListConnectionFormats() && getListMainSoundProperties() == _other.getListMainSoundProperties() && getListMainNotificationConfigurations() == _other.getListMainNotificationConfigurations() && getListNotificationConfigurations() == _other.getListNotificationConfigurations());
        }
    	inline bool operator!=(const am_Source_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct am_DomainState_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DS_UNKNOWN = 0,
            DS_CONTROLLED = 1,
            DS_INDEPENDENT_STARTUP = 2,
            DS_INDEPENDENT_RUNDOWN = 3,
            DS_MAX = 4
        };
        
        am_DomainState_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DS_UNKNOWN)) {}
        am_DomainState_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DS_UNKNOWN):
                case static_cast<int32_t>(Literal::DS_CONTROLLED):
                case static_cast<int32_t>(Literal::DS_INDEPENDENT_STARTUP):
                case static_cast<int32_t>(Literal::DS_INDEPENDENT_RUNDOWN):
                case static_cast<int32_t>(Literal::DS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_DomainState_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_DomainState_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_DomainState_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_DomainState_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_DomainState_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_DomainState_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: This struct describes the attributes of a domain.
     */
    struct am_Domain_s : CommonAPI::Struct<am_domainID_t, std::string, std::string, std::string, bool, bool, am_DomainState_e> {
    	
    	am_Domain_s() {
    		std::get<4>(values_) = false;
    		std::get<5>(values_) = false;
    	}
    	am_Domain_s(const am_domainID_t &_domainID, const std::string &_name, const std::string &_busname, const std::string &_nodename, const bool &_early, const bool &_complete, const am_DomainState_e &_state)
    	{
    		std::get<0>(values_) = _domainID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _busname;
    		std::get<3>(values_) = _nodename;
    		std::get<4>(values_) = _early;
    		std::get<5>(values_) = _complete;
    		std::get<6>(values_) = _state;
    	}
    	/**
    	 * description: The domain ID.it is unique in the system. it is assigned during the
    	 *   registration process (in a dynamic context, uniqueness will be ensured by the
    	 *   AudioManagerDaemon).
    	 */
    	inline const am_domainID_t &getDomainID() const { return std::get<0>(values_); }
    	inline void setDomainID(const am_domainID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the domain.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The busname. it is assigned by the routingPlugin during the registration
    	 *   process. the user don't need to care about it.
    	 */
    	inline const std::string &getBusname() const { return std::get<2>(values_); }
    	inline void setBusname(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The name of the node.
    	 */
    	inline const std::string &getNodename() const { return std::get<3>(values_); }
    	inline void setNodename(const std::string &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: Indicates if the domain is independent of audioManager at startup or not.
    	 */
    	inline const bool &getEarly() const { return std::get<4>(values_); }
    	inline void setEarly(const bool _value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: Indicates if the domain registration is complete or not.
    	 */
    	inline const bool &getComplete() const { return std::get<5>(values_); }
    	inline void setComplete(const bool _value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: The current domain state.
    	 */
    	inline const am_DomainState_e &getState() const { return std::get<6>(values_); }
    	inline void setState(const am_DomainState_e &_value) { std::get<6>(values_) = _value; }
    	inline bool operator==(const am_Domain_s& _other) const {
                return (getDomainID() == _other.getDomainID() && getName() == _other.getName() && getBusname() == _other.getBusname() && getNodename() == _other.getNodename() && getEarly() == _other.getEarly() && getComplete() == _other.getComplete() && getState() == _other.getState());
        }
    	inline bool operator!=(const am_Domain_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: This struct describes the attributes of a converter.
     */
    struct am_Converter_s : CommonAPI::Struct<am_converterID_t, std::string, am_sinkID_t, am_sourceID_t, am_domainID_t, am_ConnectionFormat_L, am_ConnectionFormat_L, am_Convertion_L> {
    	
    	am_Converter_s() {
    	}
    	am_Converter_s(const am_converterID_t &_converterID, const std::string &_name, const am_sinkID_t &_sinkID, const am_sourceID_t &_sourceID, const am_domainID_t &_domainID, const am_ConnectionFormat_L &_listSourceFormats, const am_ConnectionFormat_L &_listSinkFormats, const am_Convertion_L &_convertionMatrix)
    	{
    		std::get<0>(values_) = _converterID;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _sinkID;
    		std::get<3>(values_) = _sourceID;
    		std::get<4>(values_) = _domainID;
    		std::get<5>(values_) = _listSourceFormats;
    		std::get<6>(values_) = _listSinkFormats;
    		std::get<7>(values_) = _convertionMatrix;
    	}
    	/**
    	 * description: This is the ID of the converter, it is unique in the system. There are 2 ways,
    	 *   ID can be created: either it is assigned during the registration process (in a
    	 *   dynamic context, uniqueness will be ensured by the AudioManagerDaemon), or it
    	 *   is a fixed (the project has to ensure the uniqueness of the ID).
    	 */
    	inline const am_converterID_t &getConverterID() const { return std::get<0>(values_); }
    	inline void setConverterID(const am_converterID_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The name of the converter. Must be unique in the whole system.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The sink ID of the converter sink-end. The sink is a full blown sink with
    	 *   connection formats, sink class IDs etc... It makes sense to register the sinks
    	 *   of a gateway as non-visible. Care needs to be taken that the connection
    	 *   formats match with the ones in the conversion matrix. If the sink is located
    	 *   in the controlling domain, the ID needs to be retrieved by registering the
    	 *   sink before registering the gateway. In case the sink is in a different
    	 *   domain, the ID needs to be retrieved via peeking.
    	 */
    	inline const am_sinkID_t &getSinkID() const { return std::get<2>(values_); }
    	inline void setSinkID(const am_sinkID_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: The source ID of the converter sink-end. The sink is a full blown source with
    	 *   connection formats, source class IDs etc... It makes sense to register the
    	 *   sources of a gateway as non-visible. Care needs to be taken that the
    	 *   connection formats match with the ones in the conversion matrix. If the source
    	 *   is located in the controlling domain, the ID needs to be retrieved by
    	 *   registering the source before registering the gateway. In case the source is
    	 *   in a different domain, the ID needs to be retrieved via peeking.
    	 */
    	inline const am_sourceID_t &getSourceID() const { return std::get<3>(values_); }
    	inline void setSourceID(const am_sourceID_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the ID of the domain that registers the converter.
    	 */
    	inline const am_domainID_t &getDomainID() const { return std::get<4>(values_); }
    	inline void setDomainID(const am_domainID_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is the list of available formats on the source side of the converter. It
    	 *   is not defined during the gateway registration but copied from the source
    	 *   registration.
    	 */
    	inline const am_ConnectionFormat_L &getListSourceFormats() const { return std::get<5>(values_); }
    	inline void setListSourceFormats(const am_ConnectionFormat_L &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This is the list of available formats on the sink side of the gateway. It is
    	 *   not defined during the converter registration but copied from the sink
    	 *   registration.
    	 */
    	inline const am_ConnectionFormat_L &getListSinkFormats() const { return std::get<6>(values_); }
    	inline void setListSinkFormats(const am_ConnectionFormat_L &_value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: This is matrix holding information about the conversion capability of the
    	 *   converter, it's length is defined by the length(listSinkFormats) x
    	 *   length(listSourceFormats).
    	If a sink format can be converted into a source
    	 *   format, the vector will hold a 1, if no conversion is possible, a 0.
    	The data
    	 *   is stored row orientated, where the rows are related to the sink formats and
    	 *   the columns to the source formats. The first value will hold the conversion
    	 *   information from the first source format to the first sink format for example
    	 *   and the seventh value the information about the 3rd sink format to the 1st
    	 *   source format in case we would have 3 source formats.
    	 */
    	inline const am_Convertion_L &getConvertionMatrix() const { return std::get<7>(values_); }
    	inline void setConvertionMatrix(const am_Convertion_L &_value) { std::get<7>(values_) = _value; }
    	inline bool operator==(const am_Converter_s& _other) const {
                return (getConverterID() == _other.getConverterID() && getName() == _other.getName() && getSinkID() == _other.getSinkID() && getSourceID() == _other.getSourceID() && getDomainID() == _other.getDomainID() && getListSourceFormats() == _other.getListSourceFormats() && getListSinkFormats() == _other.getListSinkFormats() && getConvertionMatrix() == _other.getConvertionMatrix());
        }
    	inline bool operator!=(const am_Converter_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct am_sourceID_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            eSRC_UNKNOWN = 0,
            eSRC_SERVICE_CALL = 1,
            eSRC_VOICERECORDER = 2,
            eSRC_SDS = 3,
            eSRC_TTS = 4,
            eSRC_NAV = 5,
            eSRC_ETC_WARNING = 6,
            eSRC_ETC_INFO = 7,
            eSRC_TEL_HANDSFREE = 8,
            eSRC_TEL_RINGING = 9,
            eSRC_DIPO_PHONE = 10,
            eSRC_DIPO_PHONE_RINGING = 11,
            eSRC_DIPO_SIRI = 12,
            eSRC_DIPO_ALT = 13,
            eSRC_FU_TEL_HANDSFREE = 14,
            eSRC_FU_TEL_RINGING = 15,
            eSRC_GAL_VOICE = 16,
            eSRC_GAL_NAVI = 17,
            eSRC_GAL_UI = 18,
            eSRC_GAL_VR = 19,
            eSRC_IN_CAR_COM = 20,
            eSRC_UXI_INF = 21,
            eSRC_CARLIFE_NAVI = 22,
            eSRC_CARLIFE_VR = 23,
            eSRC_MIRRORLINK_VR = 24,
            eSRC_TBOX_ECALL = 25,
            eSRC_TBOX_ICALL = 26,
            eSRC_CHIME_CONFIRMATION = 27,
            eSRC_CHIME_INDICATION = 28,
            eSRC_CHIME_WARNING = 29,
            eSRC_CHIME_KEYPAD = 30,
            eSRC_BEEP = 31,
            eSRC_BLUETOOTH_VR = 32,
            eSRC_TUNER_TA = 33,
            eSRC_TUNER_DAB_TA = 34,
            eSRC_TUNER_FM = 35,
            eSRC_TUNER_AM = 36,
            eSRC_TUNER_DAB = 37,
            eSRC_TUNER_DAB_FM = 38,
            eSRC_TUNER_LW = 39,
            eSRC_TUNER_MW = 40,
            eSRC_TUNER_SW = 41,
            eSRC_TUNER_WB = 42,
            eSRC_TUNER_SDARS = 43,
            eSRC_TUNER_TRF = 44,
            eSRC_CDA = 45,
            eSRC_CDA_MC = 46,
            eSRC_CDA_DOWNMIX = 47,
            eSRC_DVDA = 48,
            eSRC_DVDA_MC = 49,
            eSRC_DVDV = 50,
            eSRC_DVDV_MC = 51,
            eSRC_AF = 52,
            eSRC_AF_MC = 53,
            eSRC_HDD = 54,
            eSRC_USB1 = 55,
            eSRC_USB2 = 56,
            eSRC_SD_CARD = 57,
            eSRC_UCI_AF = 58,
            eSRC_UCI_AUXIN = 59,
            eSRC_AUDIO_AUX1 = 60,
            eSRC_AUDIO_AUX2 = 61,
            eSRC_VIDEO_AUX1 = 62,
            eSRC_VIDEO_AUX2 = 63,
            eSRC_TV = 64,
            eSRC_BT_A2DP = 65,
            eSRC_UXI_ENTT = 66,
            eSRC_SAT_SERVICE = 67,
            eSRC_BROWSER = 68,
            eSRC_BROWSER_HP = 69,
            eSRC_BROWSER_FUL = 70,
            eSRC_BROWSER_FUR = 71,
            eSRC_IP_RADIO = 72,
            eSRC_POI = 73,
            eSRC_TUNERBOX = 74,
            eSRC_TUNERBOX_VIDEO = 75,
            eSRC_DIPO_MEDIA = 76,
            eSRC_GAL_MEDIA = 77,
            eSRC_CARLIFE_MEDIA = 78,
            eSRC_MIRRORLINK_MEDIA = 79,
            eSRC_FU_CDA = 80,
            eSRC_FU_DVD_MC = 81,
            eSRC_FU_IPOD = 82,
            eSRC_FU_MP3 = 83,
            eSRC_FU_AUXA = 84,
            eSRC_FU_BTA = 85,
            eSRC_FU_BRO = 86,
            eSRC_MAX = 87
        };
        
        am_sourceID_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::eSRC_UNKNOWN)) {}
        am_sourceID_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::eSRC_UNKNOWN):
                case static_cast<int32_t>(Literal::eSRC_SERVICE_CALL):
                case static_cast<int32_t>(Literal::eSRC_VOICERECORDER):
                case static_cast<int32_t>(Literal::eSRC_SDS):
                case static_cast<int32_t>(Literal::eSRC_TTS):
                case static_cast<int32_t>(Literal::eSRC_NAV):
                case static_cast<int32_t>(Literal::eSRC_ETC_WARNING):
                case static_cast<int32_t>(Literal::eSRC_ETC_INFO):
                case static_cast<int32_t>(Literal::eSRC_TEL_HANDSFREE):
                case static_cast<int32_t>(Literal::eSRC_TEL_RINGING):
                case static_cast<int32_t>(Literal::eSRC_DIPO_PHONE):
                case static_cast<int32_t>(Literal::eSRC_DIPO_PHONE_RINGING):
                case static_cast<int32_t>(Literal::eSRC_DIPO_SIRI):
                case static_cast<int32_t>(Literal::eSRC_DIPO_ALT):
                case static_cast<int32_t>(Literal::eSRC_FU_TEL_HANDSFREE):
                case static_cast<int32_t>(Literal::eSRC_FU_TEL_RINGING):
                case static_cast<int32_t>(Literal::eSRC_GAL_VOICE):
                case static_cast<int32_t>(Literal::eSRC_GAL_NAVI):
                case static_cast<int32_t>(Literal::eSRC_GAL_UI):
                case static_cast<int32_t>(Literal::eSRC_GAL_VR):
                case static_cast<int32_t>(Literal::eSRC_IN_CAR_COM):
                case static_cast<int32_t>(Literal::eSRC_UXI_INF):
                case static_cast<int32_t>(Literal::eSRC_CARLIFE_NAVI):
                case static_cast<int32_t>(Literal::eSRC_CARLIFE_VR):
                case static_cast<int32_t>(Literal::eSRC_MIRRORLINK_VR):
                case static_cast<int32_t>(Literal::eSRC_TBOX_ECALL):
                case static_cast<int32_t>(Literal::eSRC_TBOX_ICALL):
                case static_cast<int32_t>(Literal::eSRC_CHIME_CONFIRMATION):
                case static_cast<int32_t>(Literal::eSRC_CHIME_INDICATION):
                case static_cast<int32_t>(Literal::eSRC_CHIME_WARNING):
                case static_cast<int32_t>(Literal::eSRC_CHIME_KEYPAD):
                case static_cast<int32_t>(Literal::eSRC_BEEP):
                case static_cast<int32_t>(Literal::eSRC_BLUETOOTH_VR):
                case static_cast<int32_t>(Literal::eSRC_TUNER_TA):
                case static_cast<int32_t>(Literal::eSRC_TUNER_DAB_TA):
                case static_cast<int32_t>(Literal::eSRC_TUNER_FM):
                case static_cast<int32_t>(Literal::eSRC_TUNER_AM):
                case static_cast<int32_t>(Literal::eSRC_TUNER_DAB):
                case static_cast<int32_t>(Literal::eSRC_TUNER_DAB_FM):
                case static_cast<int32_t>(Literal::eSRC_TUNER_LW):
                case static_cast<int32_t>(Literal::eSRC_TUNER_MW):
                case static_cast<int32_t>(Literal::eSRC_TUNER_SW):
                case static_cast<int32_t>(Literal::eSRC_TUNER_WB):
                case static_cast<int32_t>(Literal::eSRC_TUNER_SDARS):
                case static_cast<int32_t>(Literal::eSRC_TUNER_TRF):
                case static_cast<int32_t>(Literal::eSRC_CDA):
                case static_cast<int32_t>(Literal::eSRC_CDA_MC):
                case static_cast<int32_t>(Literal::eSRC_CDA_DOWNMIX):
                case static_cast<int32_t>(Literal::eSRC_DVDA):
                case static_cast<int32_t>(Literal::eSRC_DVDA_MC):
                case static_cast<int32_t>(Literal::eSRC_DVDV):
                case static_cast<int32_t>(Literal::eSRC_DVDV_MC):
                case static_cast<int32_t>(Literal::eSRC_AF):
                case static_cast<int32_t>(Literal::eSRC_AF_MC):
                case static_cast<int32_t>(Literal::eSRC_HDD):
                case static_cast<int32_t>(Literal::eSRC_USB1):
                case static_cast<int32_t>(Literal::eSRC_USB2):
                case static_cast<int32_t>(Literal::eSRC_SD_CARD):
                case static_cast<int32_t>(Literal::eSRC_UCI_AF):
                case static_cast<int32_t>(Literal::eSRC_UCI_AUXIN):
                case static_cast<int32_t>(Literal::eSRC_AUDIO_AUX1):
                case static_cast<int32_t>(Literal::eSRC_AUDIO_AUX2):
                case static_cast<int32_t>(Literal::eSRC_VIDEO_AUX1):
                case static_cast<int32_t>(Literal::eSRC_VIDEO_AUX2):
                case static_cast<int32_t>(Literal::eSRC_TV):
                case static_cast<int32_t>(Literal::eSRC_BT_A2DP):
                case static_cast<int32_t>(Literal::eSRC_UXI_ENTT):
                case static_cast<int32_t>(Literal::eSRC_SAT_SERVICE):
                case static_cast<int32_t>(Literal::eSRC_BROWSER):
                case static_cast<int32_t>(Literal::eSRC_BROWSER_HP):
                case static_cast<int32_t>(Literal::eSRC_BROWSER_FUL):
                case static_cast<int32_t>(Literal::eSRC_BROWSER_FUR):
                case static_cast<int32_t>(Literal::eSRC_IP_RADIO):
                case static_cast<int32_t>(Literal::eSRC_POI):
                case static_cast<int32_t>(Literal::eSRC_TUNERBOX):
                case static_cast<int32_t>(Literal::eSRC_TUNERBOX_VIDEO):
                case static_cast<int32_t>(Literal::eSRC_DIPO_MEDIA):
                case static_cast<int32_t>(Literal::eSRC_GAL_MEDIA):
                case static_cast<int32_t>(Literal::eSRC_CARLIFE_MEDIA):
                case static_cast<int32_t>(Literal::eSRC_MIRRORLINK_MEDIA):
                case static_cast<int32_t>(Literal::eSRC_FU_CDA):
                case static_cast<int32_t>(Literal::eSRC_FU_DVD_MC):
                case static_cast<int32_t>(Literal::eSRC_FU_IPOD):
                case static_cast<int32_t>(Literal::eSRC_FU_MP3):
                case static_cast<int32_t>(Literal::eSRC_FU_AUXA):
                case static_cast<int32_t>(Literal::eSRC_FU_BTA):
                case static_cast<int32_t>(Literal::eSRC_FU_BRO):
                case static_cast<int32_t>(Literal::eSRC_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_sourceID_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_sourceID_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_sourceID_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_sourceID_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_sourceID_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_sourceID_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_sourceClassID_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SOURCE_CLASS_UNKNOWN = 0,
            SOURCE_CLASS_ENTERTAINMENT = 1,
            SOURCE_CLASS_PHONE = 2,
            SOURCE_CLASS_NAVIGATION = 3,
            SOURCE_CLASS_BEEP = 4,
            SOURCE_CLASS_MAX = 5
        };
        
        am_sourceClassID_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SOURCE_CLASS_UNKNOWN)) {}
        am_sourceClassID_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SOURCE_CLASS_UNKNOWN):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_ENTERTAINMENT):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_PHONE):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_NAVIGATION):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_BEEP):
                case static_cast<int32_t>(Literal::SOURCE_CLASS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_sourceClassID_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_sourceClassID_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_sourceClassID_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_sourceClassID_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_sourceClassID_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_sourceClassID_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_sinkID_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            eSNK_UNKNOWN = 0,
            eSNK_SPKS = 1,
            eSNK_HUHP = 2,
            eSNK_WHPL = 3,
            eSNK_WHPR = 4,
            eSNK_MAX = 5
        };
        
        am_sinkID_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::eSNK_UNKNOWN)) {}
        am_sinkID_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::eSNK_UNKNOWN):
                case static_cast<int32_t>(Literal::eSNK_SPKS):
                case static_cast<int32_t>(Literal::eSNK_HUHP):
                case static_cast<int32_t>(Literal::eSNK_WHPL):
                case static_cast<int32_t>(Literal::eSNK_WHPR):
                case static_cast<int32_t>(Literal::eSNK_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_sinkID_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_sinkID_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_sinkID_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_sinkID_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_sinkID_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_sinkID_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_EQ_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            EQ_UNKNOWN = 0,
            JAZZ = 1,
            POP = 2,
            FLAT = 3,
            CLASSIC = 4,
            CHURCH = 5,
            USERDEFINE = 6,
            EQ_MAX = 7
        };
        
        am_EQ_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::EQ_UNKNOWN)) {}
        am_EQ_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::EQ_UNKNOWN):
                case static_cast<int32_t>(Literal::JAZZ):
                case static_cast<int32_t>(Literal::POP):
                case static_cast<int32_t>(Literal::FLAT):
                case static_cast<int32_t>(Literal::CLASSIC):
                case static_cast<int32_t>(Literal::CHURCH):
                case static_cast<int32_t>(Literal::USERDEFINE):
                case static_cast<int32_t>(Literal::EQ_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_EQ_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_EQ_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_EQ_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_EQ_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_EQ_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_EQ_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_Clarifi_control_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            CCT_UNKNOWN = -1,
            CCT_ENABLE = 0,
            CCT_DISABLE = 1,
            CCT_MAX = 3
        };
        
        am_Clarifi_control_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::CCT_UNKNOWN)) {}
        am_Clarifi_control_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::CCT_UNKNOWN):
                case static_cast<int32_t>(Literal::CCT_ENABLE):
                case static_cast<int32_t>(Literal::CCT_DISABLE):
                case static_cast<int32_t>(Literal::CCT_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Clarifi_control_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Clarifi_control_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Clarifi_control_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Clarifi_control_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Clarifi_control_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Clarifi_control_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_loudness_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            AM_LOUDNESS_UNKNOWN = -1,
            AM_LOUDNESS_DISABLE = 0,
            AM_LOUDNESS_ENABLE = 1,
            AM_LOUDNESS_MAX = 3
        };
        
        am_loudness_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::AM_LOUDNESS_UNKNOWN)) {}
        am_loudness_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::AM_LOUDNESS_UNKNOWN):
                case static_cast<int32_t>(Literal::AM_LOUDNESS_DISABLE):
                case static_cast<int32_t>(Literal::AM_LOUDNESS_ENABLE):
                case static_cast<int32_t>(Literal::AM_LOUDNESS_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_loudness_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_loudness_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_loudness_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_loudness_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_loudness_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_loudness_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_avcMode_Type_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            AM_AVC_MODE_UNKNOWN = -1,
            AM_AVC_MODE_OFF = 0,
            AM_AVC_MODE_LOW = 1,
            AM_AVC_MODE_MID = 2,
            AM_AVC_MODE_HIGH = 3,
            AM_AVC_MODE_MAX = 5
        };
        
        am_avcMode_Type_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::AM_AVC_MODE_UNKNOWN)) {}
        am_avcMode_Type_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::AM_AVC_MODE_UNKNOWN):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_OFF):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_LOW):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_MID):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_HIGH):
                case static_cast<int32_t>(Literal::AM_AVC_MODE_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_avcMode_Type_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_avcMode_Type_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_avcMode_Type_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_avcMode_Type_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_avcMode_Type_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_avcMode_Type_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_Error_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E_OK = 0,
            E_UNKNOWN = 1,
            E_OUT_OF_RANGE = 2,
            E_NOT_USED = 3,
            E_DATABASE_ERROR = 4,
            E_ALREADY_EXISTS = 5,
            E_NO_CHANGE = 6,
            E_NOT_POSSIBLE = 7,
            E_NON_EXISTENT = 8,
            E_ABORTED = 9,
            E_WRONG_FORMAT = 10,
            E_MAX = 11
        };
        
        am_Error_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E_OK)) {}
        am_Error_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E_OK):
                case static_cast<int32_t>(Literal::E_UNKNOWN):
                case static_cast<int32_t>(Literal::E_OUT_OF_RANGE):
                case static_cast<int32_t>(Literal::E_NOT_USED):
                case static_cast<int32_t>(Literal::E_DATABASE_ERROR):
                case static_cast<int32_t>(Literal::E_ALREADY_EXISTS):
                case static_cast<int32_t>(Literal::E_NO_CHANGE):
                case static_cast<int32_t>(Literal::E_NOT_POSSIBLE):
                case static_cast<int32_t>(Literal::E_NON_EXISTENT):
                case static_cast<int32_t>(Literal::E_ABORTED):
                case static_cast<int32_t>(Literal::E_WRONG_FORMAT):
                case static_cast<int32_t>(Literal::E_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_Error_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_Error_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_Error_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_Error_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_Error_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_Error_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct am_RoutingReady_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            RR_UNKNOWN = 0,
            RR_READY = 1,
            RR_RUNDOWN = 2
        };
        
        am_RoutingReady_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::RR_UNKNOWN)) {}
        am_RoutingReady_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::RR_UNKNOWN):
                case static_cast<int32_t>(Literal::RR_READY):
                case static_cast<int32_t>(Literal::RR_RUNDOWN):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const am_RoutingReady_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const am_RoutingReady_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const am_RoutingReady_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const am_RoutingReady_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const am_RoutingReady_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const am_RoutingReady_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: unsigned char.
     */
    typedef uint8_t hq_uInt8_t;
    /**
     * description: unsigned short.
     */
    typedef uint16_t hq_uInt16_t;
    /**
     * description: unsigned int.
     */
    typedef uint32_t hq_uInt32_t;
    /**
     * description: signed char.
     */
    typedef int8_t hq_sInt8_t;
    /**
     * description: signed short.
     */
    typedef int16_t hq_sInt16_t;
    /**
     * description: signed int.
     */
    typedef int32_t hq_sInt32_t;
    /**
     * description: signed int.
     */
    typedef float hq_float32_t;
    /**
     * description: unsigned short.
     */
    typedef uint16_t hq_sourceID_t;
    /**
     * description: signed short.
     */
    typedef int16_t hq_volume_t;
    /**
     * description: unsigned char array.
     */
    typedef std::vector<am_t::hq_uInt8_t> hq_uInt8_t_L;
    /**
     * description: unsigned short array.
     */
    typedef std::vector<am_t::hq_uInt16_t> hq_uInt16_t_L;
    /**
     * description: unsigned int array.
     */
    typedef std::vector<am_t::hq_uInt32_t> hq_uInt32_t_L;
    /**
     * description: signed char array.
     */
    typedef std::vector<am_t::hq_sInt8_t> hq_sInt8_t_L;
    /**
     * description: signed short array.
     */
    typedef std::vector<am_t::hq_sInt16_t> hq_sInt16_t_L;
    /**
     * description: signed int array.
     */
    typedef std::vector<am_t::hq_sInt32_t> hq_sInt32_t_L;
    /**
     * description: signed int array.
     */
    typedef std::vector<am_t::hq_float32_t> hq_float32_t_L;
    /**
     * description: This struct describes the attributes of a limiter.
     */
    struct hq_limiterStruct_s : CommonAPI::Struct<hq_uInt8_t, hq_sInt16_t, hq_sInt8_t, hq_float32_t, hq_float32_t, hq_float32_t, hq_float32_t> {
    	
    	hq_limiterStruct_s() {
    	}
    	hq_limiterStruct_s(const hq_uInt8_t &_channel, const hq_sInt16_t &_gain, const hq_sInt8_t &_threshold, const hq_float32_t &_attackTime, const hq_float32_t &_releaseTime, const hq_float32_t &_holdThreshold, const hq_float32_t &_holdTime)
    	{
    		std::get<0>(values_) = _channel;
    		std::get<1>(values_) = _gain;
    		std::get<2>(values_) = _threshold;
    		std::get<3>(values_) = _attackTime;
    		std::get<4>(values_) = _releaseTime;
    		std::get<5>(values_) = _holdThreshold;
    		std::get<6>(values_) = _holdTime;
    	}
    	/**
    	 * description: This is the channel number.
    	 */
    	inline const hq_uInt8_t &getChannel() const { return std::get<0>(values_); }
    	inline void setChannel(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the gain value, unit: db
    	 */
    	inline const hq_sInt16_t &getGain() const { return std::get<1>(values_); }
    	inline void setGain(const hq_sInt16_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the threshold value, unit: db
    	 */
    	inline const hq_sInt8_t &getThreshold() const { return std::get<2>(values_); }
    	inline void setThreshold(const hq_sInt8_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the attack time of limiter, unit: ms
    	 */
    	inline const hq_float32_t &getAttackTime() const { return std::get<3>(values_); }
    	inline void setAttackTime(const hq_float32_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the release time of limiter, unit: ms.
    	 */
    	inline const hq_float32_t &getReleaseTime() const { return std::get<4>(values_); }
    	inline void setReleaseTime(const hq_float32_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is the hold threshold of limiter, unit: db.
    	 */
    	inline const hq_float32_t &getHoldThreshold() const { return std::get<5>(values_); }
    	inline void setHoldThreshold(const hq_float32_t &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This is the hold time of limiter, unit: ms.
    	 */
    	inline const hq_float32_t &getHoldTime() const { return std::get<6>(values_); }
    	inline void setHoldTime(const hq_float32_t &_value) { std::get<6>(values_) = _value; }
    	inline bool operator==(const hq_limiterStruct_s& _other) const {
                return (getChannel() == _other.getChannel() && getGain() == _other.getGain() && getThreshold() == _other.getThreshold() && getAttackTime() == _other.getAttackTime() && getReleaseTime() == _other.getReleaseTime() && getHoldThreshold() == _other.getHoldThreshold() && getHoldTime() == _other.getHoldTime());
        }
    	inline bool operator!=(const hq_limiterStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: array of hq_limiterStruct_s.
     */
    typedef std::vector<am_t::hq_limiterStruct_s> hq_limiterStruct_s_L;
    /**
     * description: This struct describes the attributes of a limiter.
     */
    struct hq_eqFilterStruct_s : CommonAPI::Struct<hq_uInt8_t, hq_uInt16_t, hq_sInt16_t, hq_float32_t, hq_uInt8_t, hq_uInt8_t> {
    	
    	hq_eqFilterStruct_s() {
    	}
    	hq_eqFilterStruct_s(const hq_uInt8_t &_bandIndex, const hq_uInt16_t &_frequency, const hq_sInt16_t &_gain, const hq_float32_t &_quality, const hq_uInt8_t &_type, const hq_uInt8_t &_order)
    	{
    		std::get<0>(values_) = _bandIndex;
    		std::get<1>(values_) = _frequency;
    		std::get<2>(values_) = _gain;
    		std::get<3>(values_) = _quality;
    		std::get<4>(values_) = _type;
    		std::get<5>(values_) = _order;
    	}
    	/**
    	 * description: This is the band index.
    	 */
    	inline const hq_uInt8_t &getBandIndex() const { return std::get<0>(values_); }
    	inline void setBandIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the frequency of filter, unit Hz
    	 */
    	inline const hq_uInt16_t &getFrequency() const { return std::get<1>(values_); }
    	inline void setFrequency(const hq_uInt16_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the gain value, unit: db
    	 */
    	inline const hq_sInt16_t &getGain() const { return std::get<2>(values_); }
    	inline void setGain(const hq_sInt16_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the quality of filter.
    	 */
    	inline const hq_float32_t &getQuality() const { return std::get<3>(values_); }
    	inline void setQuality(const hq_float32_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the type of filter.
    	 */
    	inline const hq_uInt8_t &getType() const { return std::get<4>(values_); }
    	inline void setType(const hq_uInt8_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is the order of filter.
    	 */
    	inline const hq_uInt8_t &getOrder() const { return std::get<5>(values_); }
    	inline void setOrder(const hq_uInt8_t &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const hq_eqFilterStruct_s& _other) const {
                return (getBandIndex() == _other.getBandIndex() && getFrequency() == _other.getFrequency() && getGain() == _other.getGain() && getQuality() == _other.getQuality() && getType() == _other.getType() && getOrder() == _other.getOrder());
        }
    	inline bool operator!=(const hq_eqFilterStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: array of hq_eqFilterStruct_s.
     */
    typedef std::vector<am_t::hq_eqFilterStruct_s> hq_eqFilterStruct_s_L;
    /**
     * description: This struct describes the attributes of a limiter.
     */
    struct hq_delayTimeStruct_s : CommonAPI::Struct<hq_uInt8_t, hq_float32_t> {
    	
    	hq_delayTimeStruct_s() {
    	}
    	hq_delayTimeStruct_s(const hq_uInt8_t &_channel, const hq_float32_t &_delayTime)
    	{
    		std::get<0>(values_) = _channel;
    		std::get<1>(values_) = _delayTime;
    	}
    	/**
    	 * description: This is the channel number.
    	 */
    	inline const hq_uInt8_t &getChannel() const { return std::get<0>(values_); }
    	inline void setChannel(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the delay time of delay component.
    	 */
    	inline const hq_float32_t &getDelayTime() const { return std::get<1>(values_); }
    	inline void setDelayTime(const hq_float32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const hq_delayTimeStruct_s& _other) const {
                return (getChannel() == _other.getChannel() && getDelayTime() == _other.getDelayTime());
        }
    	inline bool operator!=(const hq_delayTimeStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: array of hq_delayTimeStruct_s.
     */
    typedef std::vector<am_t::hq_delayTimeStruct_s> hq_delayTimeStruct_s_L;
    /**
     * description: This struct describes the attributes of a loudness.
     */
    struct hq_londnessStruct_s : CommonAPI::Struct<hq_sInt16_t, hq_sInt16_t, hq_sInt16_t, hq_sInt16_t> {
    	
    	hq_londnessStruct_s() {
    	}
    	hq_londnessStruct_s(const hq_sInt16_t &_volumeLow, const hq_sInt16_t &_volumeHigh, const hq_sInt16_t &_gainLow, const hq_sInt16_t &_gainHigh)
    	{
    		std::get<0>(values_) = _volumeLow;
    		std::get<1>(values_) = _volumeHigh;
    		std::get<2>(values_) = _gainLow;
    		std::get<3>(values_) = _gainHigh;
    	}
    	/**
    	 * description: This is the bass volume  of londness.
    	 */
    	inline const hq_sInt16_t &getVolumeLow() const { return std::get<0>(values_); }
    	inline void setVolumeLow(const hq_sInt16_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the treble volume of londness.
    	 */
    	inline const hq_sInt16_t &getVolumeHigh() const { return std::get<1>(values_); }
    	inline void setVolumeHigh(const hq_sInt16_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the bass addition gain of londness.
    	 */
    	inline const hq_sInt16_t &getGainLow() const { return std::get<2>(values_); }
    	inline void setGainLow(const hq_sInt16_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the treble addition gain of londness.
    	 */
    	inline const hq_sInt16_t &getGainHigh() const { return std::get<3>(values_); }
    	inline void setGainHigh(const hq_sInt16_t &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const hq_londnessStruct_s& _other) const {
                return (getVolumeLow() == _other.getVolumeLow() && getVolumeHigh() == _other.getVolumeHigh() && getGainLow() == _other.getGainLow() && getGainHigh() == _other.getGainHigh());
        }
    	inline bool operator!=(const hq_londnessStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: array of hq_londnessStruct_s.
     */
    typedef std::vector<am_t::hq_londnessStruct_s> hq_londnessStruct_s_L;
    /**
     * description: This struct describes the attributes of a channel gain.
     */
    struct hq_channelGainStruct_s : CommonAPI::Struct<hq_uInt8_t, hq_sInt16_t, hq_uInt8_t> {
    	
    	hq_channelGainStruct_s() {
    	}
    	hq_channelGainStruct_s(const hq_uInt8_t &_channel, const hq_sInt16_t &_gain, const hq_uInt8_t &_phase)
    	{
    		std::get<0>(values_) = _channel;
    		std::get<1>(values_) = _gain;
    		std::get<2>(values_) = _phase;
    	}
    	/**
    	 * description: This is the channel number.
    	 */
    	inline const hq_uInt8_t &getChannel() const { return std::get<0>(values_); }
    	inline void setChannel(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the gain value of channelGain.
    	 */
    	inline const hq_sInt16_t &getGain() const { return std::get<1>(values_); }
    	inline void setGain(const hq_sInt16_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the phase value of channelGain.
    	 */
    	inline const hq_uInt8_t &getPhase() const { return std::get<2>(values_); }
    	inline void setPhase(const hq_uInt8_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const hq_channelGainStruct_s& _other) const {
                return (getChannel() == _other.getChannel() && getGain() == _other.getGain() && getPhase() == _other.getPhase());
        }
    	inline bool operator!=(const hq_channelGainStruct_s &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: array of hq_channelGainStruct_s.
     */
    typedef std::vector<am_t::hq_channelGainStruct_s> hq_channelGainStruct_s_L;
    /**
     * description: parameter of limiter function.
     */
    struct hq_limiterStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_limiterStruct_s_L> {
    	
    	hq_limiterStruct_param() {
    	}
    	hq_limiterStruct_param(const hq_uInt8_t &_activateChlIndex, const hq_limiterStruct_s_L &_limiterStructArry)
    	{
    		std::get<0>(values_) = _activateChlIndex;
    		std::get<1>(values_) = _limiterStructArry;
    	}
    	/**
    	 * description: the index of one channel which's parameter need to be sended. If all channel
    	 *   need to be sended, the value is 0xff.
    	 */
    	inline const hq_uInt8_t &getActivateChlIndex() const { return std::get<0>(values_); }
    	inline void setActivateChlIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: the array of limiter paramter struct which can save all channels' parameter.
    	 */
    	inline const hq_limiterStruct_s_L &getLimiterStructArry() const { return std::get<1>(values_); }
    	inline void setLimiterStructArry(const hq_limiterStruct_s_L &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const hq_limiterStruct_param& _other) const {
                return (getActivateChlIndex() == _other.getActivateChlIndex() && getLimiterStructArry() == _other.getLimiterStructArry());
        }
    	inline bool operator!=(const hq_limiterStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: parameter of eq function.
     */
    struct hq_eqFilterStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_uInt8_t, hq_uInt8_t, hq_uInt8_t, hq_eqFilterStruct_s_L> {
    	
    	hq_eqFilterStruct_param() {
    	}
    	hq_eqFilterStruct_param(const hq_uInt8_t &_activateBandIndex, const hq_uInt8_t &_channel, const hq_uInt8_t &_startBandIndex, const hq_uInt8_t &_bandNum, const hq_eqFilterStruct_s_L &_eqFilterStructArry)
    	{
    		std::get<0>(values_) = _activateBandIndex;
    		std::get<1>(values_) = _channel;
    		std::get<2>(values_) = _startBandIndex;
    		std::get<3>(values_) = _bandNum;
    		std::get<4>(values_) = _eqFilterStructArry;
    	}
    	/**
    	 * description: the index of one channel which's parameter need to be sended. If all channel
    	 *   need to be sended, the value is 0xff.
    	 */
    	inline const hq_uInt8_t &getActivateBandIndex() const { return std::get<0>(values_); }
    	inline void setActivateBandIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the Index of the channel whose filters shall be updated.
    	 */
    	inline const hq_uInt8_t &getChannel() const { return std::get<1>(values_); }
    	inline void setChannel(const hq_uInt8_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the index of the first filter that shall be updated.
    	 */
    	inline const hq_uInt8_t &getStartBandIndex() const { return std::get<2>(values_); }
    	inline void setStartBandIndex(const hq_uInt8_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the number of filters to be exchanged for this channel ( beginning from
    	 *   startBandIndex).
    	 */
    	inline const hq_uInt8_t &getBandNum() const { return std::get<3>(values_); }
    	inline void setBandNum(const hq_uInt8_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: The settings for the individual filters.
    	 */
    	inline const hq_eqFilterStruct_s_L &getEqFilterStructArry() const { return std::get<4>(values_); }
    	inline void setEqFilterStructArry(const hq_eqFilterStruct_s_L &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const hq_eqFilterStruct_param& _other) const {
                return (getActivateBandIndex() == _other.getActivateBandIndex() && getChannel() == _other.getChannel() && getStartBandIndex() == _other.getStartBandIndex() && getBandNum() == _other.getBandNum() && getEqFilterStructArry() == _other.getEqFilterStructArry());
        }
    	inline bool operator!=(const hq_eqFilterStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: parameter of delayTime function.
     */
    struct hq_delayTimeStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_delayTimeStruct_s_L> {
    	
    	hq_delayTimeStruct_param() {
    	}
    	hq_delayTimeStruct_param(const hq_uInt8_t &_activateChlIndex, const hq_delayTimeStruct_s_L &_delayTimeStructArry)
    	{
    		std::get<0>(values_) = _activateChlIndex;
    		std::get<1>(values_) = _delayTimeStructArry;
    	}
    	/**
    	 * description: the index of one channel which's parameter need to be sended. If all channel
    	 *   need to be sended, the value is 0xff.
    	 */
    	inline const hq_uInt8_t &getActivateChlIndex() const { return std::get<0>(values_); }
    	inline void setActivateChlIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: the array of delay time paramter struct which can save all channels' parameter.
    	 */
    	inline const hq_delayTimeStruct_s_L &getDelayTimeStructArry() const { return std::get<1>(values_); }
    	inline void setDelayTimeStructArry(const hq_delayTimeStruct_s_L &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const hq_delayTimeStruct_param& _other) const {
                return (getActivateChlIndex() == _other.getActivateChlIndex() && getDelayTimeStructArry() == _other.getDelayTimeStructArry());
        }
    	inline bool operator!=(const hq_delayTimeStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: parameter of loudness function.
     */
    struct hq_londnessStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_uInt8_t, hq_uInt16_t, hq_uInt16_t, hq_float32_t, hq_float32_t, hq_uInt8_t, hq_uInt8_t, hq_uInt8_t, hq_londnessStruct_s_L> {
    	
    	hq_londnessStruct_param() {
    	}
    	hq_londnessStruct_param(const hq_uInt8_t &_activateldIndex, const hq_uInt8_t &_calculationMode, const hq_uInt16_t &_frequencyLow, const hq_uInt16_t &_frequencyHigh, const hq_float32_t &_qualityLow, const hq_float32_t &_qualityHigh, const hq_uInt8_t &_filterTypeLow, const hq_uInt8_t &_filterTypeHigh, const hq_uInt8_t &_numTableEntries, const hq_londnessStruct_s_L &_londnessStructArry)
    	{
    		std::get<0>(values_) = _activateldIndex;
    		std::get<1>(values_) = _calculationMode;
    		std::get<2>(values_) = _frequencyLow;
    		std::get<3>(values_) = _frequencyHigh;
    		std::get<4>(values_) = _qualityLow;
    		std::get<5>(values_) = _qualityHigh;
    		std::get<6>(values_) = _filterTypeLow;
    		std::get<7>(values_) = _filterTypeHigh;
    		std::get<8>(values_) = _numTableEntries;
    		std::get<9>(values_) = _londnessStructArry;
    	}
    	/**
    	 * description: the index of one channel which's parameter need to be sended. If all channel
    	 *   need to be sended, the value is 0xff.
    	 */
    	inline const hq_uInt8_t &getActivateldIndex() const { return std::get<0>(values_); }
    	inline void setActivateldIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The way the loudness gain is calculated.
    	 */
    	inline const hq_uInt8_t &getCalculationMode() const { return std::get<1>(values_); }
    	inline void setCalculationMode(const hq_uInt8_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: This is the bass frequency of londness, unit Hz.
    	 */
    	inline const hq_uInt16_t &getFrequencyLow() const { return std::get<2>(values_); }
    	inline void setFrequencyLow(const hq_uInt16_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: This is the trible frequency of londness, unit Hz.
    	 */
    	inline const hq_uInt16_t &getFrequencyHigh() const { return std::get<3>(values_); }
    	inline void setFrequencyHigh(const hq_uInt16_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the bass quality of londness.
    	 */
    	inline const hq_float32_t &getQualityLow() const { return std::get<4>(values_); }
    	inline void setQualityLow(const hq_float32_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This is the trible quality of londness.
    	 */
    	inline const hq_float32_t &getQualityHigh() const { return std::get<5>(values_); }
    	inline void setQualityHigh(const hq_float32_t &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: This is the bass filter type of londness.
    	 */
    	inline const hq_uInt8_t &getFilterTypeLow() const { return std::get<6>(values_); }
    	inline void setFilterTypeLow(const hq_uInt8_t &_value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: This is the trible filter type of londness.
    	 */
    	inline const hq_uInt8_t &getFilterTypeHigh() const { return std::get<7>(values_); }
    	inline void setFilterTypeHigh(const hq_uInt8_t &_value) { std::get<7>(values_) = _value; }
    	/**
    	 * description: This is the trible filter type of londness.
    	 */
    	inline const hq_uInt8_t &getNumTableEntries() const { return std::get<8>(values_); }
    	inline void setNumTableEntries(const hq_uInt8_t &_value) { std::get<8>(values_) = _value; }
    	/**
    	 * description: the array of loudness struct which can save all channels' parameter.
    	 */
    	inline const hq_londnessStruct_s_L &getLondnessStructArry() const { return std::get<9>(values_); }
    	inline void setLondnessStructArry(const hq_londnessStruct_s_L &_value) { std::get<9>(values_) = _value; }
    	inline bool operator==(const hq_londnessStruct_param& _other) const {
                return (getActivateldIndex() == _other.getActivateldIndex() && getCalculationMode() == _other.getCalculationMode() && getFrequencyLow() == _other.getFrequencyLow() && getFrequencyHigh() == _other.getFrequencyHigh() && getQualityLow() == _other.getQualityLow() && getQualityHigh() == _other.getQualityHigh() && getFilterTypeLow() == _other.getFilterTypeLow() && getFilterTypeHigh() == _other.getFilterTypeHigh() && getNumTableEntries() == _other.getNumTableEntries() && getLondnessStructArry() == _other.getLondnessStructArry());
        }
    	inline bool operator!=(const hq_londnessStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: parameter of channel gain function.
     */
    struct hq_channelGainStruct_param : CommonAPI::Struct<hq_uInt8_t, hq_uInt8_t, hq_channelGainStruct_s_L> {
    	
    	hq_channelGainStruct_param() {
    	}
    	hq_channelGainStruct_param(const hq_uInt8_t &_activateChlIndex, const hq_uInt8_t &_channelNum, const hq_channelGainStruct_s_L &_channelGainStructArry)
    	{
    		std::get<0>(values_) = _activateChlIndex;
    		std::get<1>(values_) = _channelNum;
    		std::get<2>(values_) = _channelGainStructArry;
    	}
    	/**
    	 * description: the index of one channel which's parameter need to be sended. If all channel
    	 *   need to be sended, the value is 0xff.
    	 */
    	inline const hq_uInt8_t &getActivateChlIndex() const { return std::get<0>(values_); }
    	inline void setActivateChlIndex(const hq_uInt8_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: this is the sum of channel
    	 */
    	inline const hq_uInt8_t &getChannelNum() const { return std::get<1>(values_); }
    	inline void setChannelNum(const hq_uInt8_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: the array of channel gain struct which can save all channels' parameter.
    	 */
    	inline const hq_channelGainStruct_s_L &getChannelGainStructArry() const { return std::get<2>(values_); }
    	inline void setChannelGainStructArry(const hq_channelGainStruct_s_L &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const hq_channelGainStruct_param& _other) const {
                return (getActivateChlIndex() == _other.getActivateChlIndex() && getChannelNum() == _other.getChannelNum() && getChannelGainStructArry() == _other.getChannelGainStructArry());
        }
    	inline bool operator!=(const hq_channelGainStruct_param &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.genivi.am_t";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(3, 7);
}

}; // struct am_t

} // namespace genivi
} // namespace org
} // namespace v3

namespace CommonAPI {
}


namespace std {
    //Hash for am_Availability_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Availability_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Availability_e& am_Availability_e) const {
            return static_cast<int32_t>(am_Availability_e);
        }
    };
    //Hash for am_HotSink_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_HotSink_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_HotSink_e& am_HotSink_e) const {
            return static_cast<int32_t>(am_HotSink_e);
        }
    };
    //Hash for am_ConnectionState_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_ConnectionState_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_ConnectionState_e& am_ConnectionState_e) const {
            return static_cast<int32_t>(am_ConnectionState_e);
        }
    };
    //Hash for am_sourceID_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_sourceID_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_sourceID_e& am_sourceID_e) const {
            return static_cast<int32_t>(am_sourceID_e);
        }
    };
    //Hash for am_sourceClassID_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_sourceClassID_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_sourceClassID_e& am_sourceClassID_e) const {
            return static_cast<int32_t>(am_sourceClassID_e);
        }
    };
    //Hash for am_sinkID_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_sinkID_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_sinkID_e& am_sinkID_e) const {
            return static_cast<int32_t>(am_sinkID_e);
        }
    };
    //Hash for am_EQ_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_EQ_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_EQ_e& am_EQ_e) const {
            return static_cast<int32_t>(am_EQ_e);
        }
    };
    //Hash for am_Clarifi_control_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Clarifi_control_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Clarifi_control_Type_e& am_Clarifi_control_Type_e) const {
            return static_cast<int32_t>(am_Clarifi_control_Type_e);
        }
    };
    //Hash for am_loudness_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_loudness_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_loudness_Type_e& am_loudness_Type_e) const {
            return static_cast<int32_t>(am_loudness_Type_e);
        }
    };
    //Hash for am_avcMode_Type_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_avcMode_Type_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_avcMode_Type_e& am_avcMode_Type_e) const {
            return static_cast<int32_t>(am_avcMode_Type_e);
        }
    };
    //Hash for am_CustomSoundPropertyType_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_CustomSoundPropertyType_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_CustomSoundPropertyType_e& am_CustomSoundPropertyType_e) const {
            return static_cast<int32_t>(am_CustomSoundPropertyType_e);
        }
    };
    //Hash for am_DomainState_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_DomainState_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_DomainState_e& am_DomainState_e) const {
            return static_cast<int32_t>(am_DomainState_e);
        }
    };
    //Hash for am_EarlyDataType_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_EarlyDataType_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_EarlyDataType_e& am_EarlyDataType_e) const {
            return static_cast<int32_t>(am_EarlyDataType_e);
        }
    };
    //Hash for am_Error_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Error_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Error_e& am_Error_e) const {
            return static_cast<int32_t>(am_Error_e);
        }
    };
    //Hash for am_MuteState_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_MuteState_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_MuteState_e& am_MuteState_e) const {
            return static_cast<int32_t>(am_MuteState_e);
        }
    };
    //Hash for am_InterruptState_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_InterruptState_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_InterruptState_e& am_InterruptState_e) const {
            return static_cast<int32_t>(am_InterruptState_e);
        }
    };
    //Hash for am_VolumeType_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_VolumeType_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_VolumeType_e& am_VolumeType_e) const {
            return static_cast<int32_t>(am_VolumeType_e);
        }
    };
    //Hash for am_NotificationStatus_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_NotificationStatus_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_NotificationStatus_e& am_NotificationStatus_e) const {
            return static_cast<int32_t>(am_NotificationStatus_e);
        }
    };
    //Hash for am_Handle_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_Handle_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_Handle_e& am_Handle_e) const {
            return static_cast<int32_t>(am_Handle_e);
        }
    };
    //Hash for am_SourceState_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_SourceState_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_SourceState_e& am_SourceState_e) const {
            return static_cast<int32_t>(am_SourceState_e);
        }
    };
    //Hash for am_RoutingReady_e
    template<>
    struct hash<::v3::org::genivi::am_t::am_RoutingReady_e> {
        inline size_t operator()(const ::v3::org::genivi::am_t::am_RoutingReady_e& am_RoutingReady_e) const {
            return static_cast<int32_t>(am_RoutingReady_e);
        }
    };
}


// Compatibility
namespace v3_7 = v3;

#endif // V3_ORG_GENIVI_am_t_HPP_
