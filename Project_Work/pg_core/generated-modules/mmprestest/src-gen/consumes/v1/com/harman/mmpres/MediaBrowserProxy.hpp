/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Wed Oct 26 18:16:09 IST 2016
*/
#ifndef V1_COM_HARMAN_MMPRES_Media_Browser_PROXY_HPP_
#define V1_COM_HARMAN_MMPRES_Media_Browser_PROXY_HPP_

#include <v1/com/harman/mmpres/MediaBrowserProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace mmpres {

template <typename ... _AttributeExtensions>
class MediaBrowserProxy
    : virtual public MediaBrowser, 
      virtual public MediaBrowserProxyBase,
      virtual public _AttributeExtensions... {
public:
    MediaBrowserProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~MediaBrowserProxy();

    typedef MediaBrowser InterfaceType;



    /**
     * description: Will only be posted to the respective listeners if the session query parameters
     *   have changed. 
    					  For example, for externally played back devices, the
     *   number of items in the currently playing list might change.  Will be published
     *   
    					  only if auto update was enabled when setting the query. 
    	      
         
     *      returns  sessionID:      The Session ID alloted.
             returns 
     *   sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
     *   particular session query/filter for retrieving data in a session and it has to
     *   be passed 
                                          for furthur setting the
     *   sessionQuery window and retrieving the contents of that window.
             
        
     *       returns  numItems:		   The updated number of items for the
     *   sessionID/sessionQueryID.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sessionQueryUpdate.
     */
    virtual SessionQueryUpdateSelectiveEvent& getSessionQueryUpdateSelectiveEvent() {
        return delegate_->getSessionQueryUpdateSelectiveEvent();
    }
    /**
     * description: Publishes the query status to all clients. The client can get the data once the
     *   query is "finished"
    	
    	     returns  sessionID: 	   The Session ID alloted.
      
     *         returns  sessionQueryID:  The sessionQueryID allotted.This uniquely
     *   identifies a particular session query/filter for retrieving data in a session
     *   and it has to be passed 
                                          for furthur
     *   setting the sessionQuery window and retrieving the contents of that window.
      
     *       
             returns  eQueryStatus:    query status of the window update.
       
     *        returns  startIndex:	   The index to start fetching.  
             returns 
     *   numItems:		   The number of items to fetch.
             returns  itemList:       
     *    List of tMetadataItems.
             
             returns
     *   windowContainsCurrentlyPlayingTrack: This will be true if one of the
     *   tMetadataItems is the currently playing track.
            
             returns
     *   itemIndexTobeHighlighted: // index of the item to be highlighted in the
     *   returned nowPlaying list. If the 
                                                
     *    currently playing item is not part of the returned window, then this will be
     *   assigned 0.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sessionQueryWindowUpdate.
     */
    virtual SessionQueryWindowUpdateSelectiveEvent& getSessionQueryWindowUpdateSelectiveEvent() {
        return delegate_->getSessionQueryWindowUpdateSelectiveEvent();
    }

    /**
     * description: Opens a session for the client communication. This session will be used
     *   internally to uniquely identify a client, and to maintain client specific
     *   caches.
    					  The client need not create a new session for every request,
     *   this is rather used to identify different instances of clients.   
             
     
     *          returns:     sessionID: Session identifier allocated to the client.
     * Calls openSession with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void openSession(CommonAPI::CallStatus &_internalCallStatus, uint32_t &_sessionID, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls openSession with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> openSessionAsync(OpenSessionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Close a client session and release all associated resources. Once HMI calls
     *   closeSession,they cannot use the same sessionId
    	for furthur browsing. For
     *   this, they have to again invoke a openSession to get a new sessionId for
     *   furthur browsing.
     * param: sessionID: The Session ID to close.
     * Calls closeSession with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void closeSession(const uint32_t &_sessionID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls closeSession with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> closeSessionAsync(const uint32_t &_sessionID, CloseSessionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Essentially Stops all background tasks in the specified session. But unlike
     *   closeSession, the sessionID
    	 is valid and can be used for furthur browsing.
     * param: sessionID: The Session ID alloted.
     * Calls cancelSession with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void cancelSession(const uint32_t &_sessionID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls cancelSession with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> cancelSessionAsync(const uint32_t &_sessionID, CancelSessionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Sets a session query. This api handles all requests to fetch metadata browse
     *   results, database searches, file system browse etc. 
    	 	 
    	 	 Note: iF HMI
     *   wants to show the categories like ARTISTS,ALBUMS,FOLDERS,GENRES etc on
     *   clicking browse icon,they need not
    	 	 use the setSessionQuery. They can
     *   instead use the tSlotUpdate broadcast which contains the tDevice structure.In
     *   
    	 	 this, browse capabilities will be provided as a bitmask of different
     *   eMetadataTypes.If HMI is interested in
    	 	 the count of these categories,then
     *   HMI can use the MetadataCountMap which is a map of different
     *   eMetadataCountType.
    	 	 
    	 	 
    	 	 1st Example: 
    	 	 
    	 	 Get a list of all
     *   available artists. The filterID's' and filter's' will be empty, and the result
     *   type would be set to artist id. 
    	 	 Presentation control would return a list
     *   of all available artists / artist id for the medium.
    	 	 sessionQueryType will
     *   be METADATA_BROWSE 
    	 	 
    	 	 2nd Example:
    	 	 
    	 	 Get a list of all available
     *   artists. Also for each artist,get the count of songs.For this, input
     *   parameters will be same as first example
    	 	 but now HMI should pass
     *   metadataCountTypes=eMetadataType::METADATATYPE_SONG.
    	 	 
    	 	 If HMI wants
     *   album count also along with songs count, then metadataCountTypes= bitmask
     *   combination of 
    	 	 eMetadataType::METADATATYPE_SONG +
     *   eMetadataType::METADATATYPE_ALBUM.
    	 	 
    	 	 sessionQueryType will be
     *   METADATA_BROWSE 
    	 	 
    	 	 3rd Example : 
    	 	 
    	 	 Get a list of all available
     *   albums by the artist "Pink Floyd". HMI would know the artist id for "Pink
     *   Floyd" because of the previous returned result. 
    	 	 
    	 	 In the session
     *   query, HMI sets the filterIDMap as:
    	 	 
    	 	
     *   key=eMetadataType::METADATATYPE_ARTIST,value="artist id" for Pink Floyd 
    	 	
     *   
    	 	 resultType=eMetadataType::METADATATYPE_ALBUM. 
    	 	 
    	 	 Presentation
     *   Controller understands what needs to be done here. This can be further
     *   extended by setting
    	 	 artist id and album id returned in the previous steps,
     *   and a query for songs can be done. 
    	 	 
    	 	 sessionQueryType will be
     *   METADATA_BROWSE.
    	 	 
    	 	 Suppose we need the list of songs inside the artist
     *   "Pink Floyd" but for eah song song, we also need to pass the artist,album 
    	 	
     *   and genre values. Then this can be done by providing the "metadataAttributes"
     *   input parameter as a bit mask combination of
     *   eMetadataType::METADATATYPE_ARTIST +
    	 	 eMetadataType::METADATATYPE_ALBUM &
     *   eMetadataType::METADATATYPE_GENRE.
    	 	 
    	 	 Note that metadataAttributes will
     *   be considered only if the resultType="song".
    	 	 
    	 	 4th Example : 
    	 	 
    	 	
     *   Get a list of all available albums by "Pink Floyd", which begin with the
     *   letters "The". 
    	 	 This is same as the 3rd example, but in addition, the
     *   filter "album" must be set to "The"
    	 	 
    	 	 sessionQueryType will be
     *   METADATA_BROWSE 
    	 	 
    	 	 5th example:
    	 	 
    	 	 usage of resetPrevious
     *   parameter.
    	 	 
    	 	 Assume resetPrevious=false:
    	 	 
    	 	 In the first
     *   example,HMI obtained the list of albums for artist "Pink Floyed". Now if HMI
     *   wants list of songs for
    	 	 artist "Pink Floyed", then in the filters,HMi need
     *   not mention anything again. 
    	 	 They can just set
     *   resultype=eMetadataType::METADATATYPE_SONG .
    	 	 
    	 	 Now pres will remember
     *   that artist "Pink Floyd" was already selected. So pres will supply the song
     *   list for artist pink floyd.
    	 	 
    	 	 If resetPrevious=true,pres would not
     *   remeber that Artist Pink Floyd was already selected. In that case,
    	 	 HMI has
     *   to set the filterIDMap again by providing the artist id for pink Floyd.
    	 	 
    	
     *   	 Now in the use cases, where the resultType is
     *   "eMetadataType::METADATATYPE_SONG", if the requirement is to show only AUDIO
    	
     *   	 or VIDEO or both AUDIO + VIDEO, this can be done by setting "ContentMask"
     *   param as a bit mask of "eTitleContentType".
    	 	 
    	 	
     *   eTitleContentType::TITLETYPE_IMAGE will be applicable for filesystem browse.
     *   
    	 	 
    	 	 6th Example:
    	 	 
    	 	 Do a fileSystem or FOLDER browse.This is
     *   applicable for mass storage devices like USB.At any level, we are 
    	 	 allowed
     *   to show both folders, files or playlists depending on project requirements.
    	
     *   	 
    	 	 sessionQueryType will be SESSION_QUERY_FS_BROWSE.
    	 	 
    	 	 First go to
     *   root level and show only folders and files but not playlists. For this, the
     *   filterID's and filters are empty, but the resultType will be 
    	 	 combination
     *   of eMetadataType::METADATATYPE_FOLDER + eMetadataType::METADATATYPE_FILE.With
     *   this query,HMI can get
    	 	 the folders and file at a given level in
     *   filesystem. When HMI gets the individual items, they can check the
     *   eMetadataType
    	 	 of that item to see if it is a file or folder.
    	 	 
    	 	 Now
     *   HMI wants to go inside one more level by selecting a folder obtained in the
     *   previous step.For this,HMI can set the filterID as 
    	 	
     *   key=METADATAID_FOLDER_ID and value=(folder id or item id) of folder
     *   communicated in previous step.
    	 	 
    	 	 If at every level, there is a
     *   requirement to list folders first and only then followed by audio files,image
     *   files etc, then
    	 	 these will be maintained by pres as project specific
     *   config parameters. 
    	 	 
    	 	 Now HMI wants to go inside one of the folders
     *   named "Folder1" listed at the root level.For this,HMI can set the FilterIDMap
     *   as:
    	 	 
    	 	 key: "eMetadataType::METADATATYPE_FOLDER" and value: folder id of
     *   "folder 1" from the result of the first query to 
    	 	       show the root
     *   level contents.
    	 	 
    	 	 Also if HMI wants the level ID (depth of folder) in
     *   file system browse, such as 4th folder depth or fifth folder depth etc,
    	 	
     *   then they can use the sessionQueryID as an indicator of level ID. Each
     *   sessionQueryID will correspond to a
    	 	 particular folder depth in file system
     *   browse.
    	 	 
    	 	 7th example:
    	 	 
    	 	 If HMI wants the list of songs from the
     *   recently played list.
    	 	 
    	 	 The can set the sessionQueryType will be
     *   SESSION_QUERY_RECENTLYPLAYED and resultype=eMetadataType::METADATATYPE_SONG
    	 
     *      other parameters can be empty.
     * param: filterIDs: The previously communicated numeric identifiers of the different
     *   filter categories.
     * param: filters:	 The string filters which should be applied to the result.
     * param: resultType: The data which is expected from the query.
     * param: sessionID: The Session ID alloted.
     * param: mediumID:	 The identifier for the mediastore to query.
     * param: type:		 The type of session query.
     * param: metadataAttributes: [TODO]:Pres ctrl can return the required attributes for
     *   each metadata item based on the 
                                             
     *   client requirements.This is a bitmask combination of eMetadataType values.
     *   This will be 
                                              supported only for the
     *   song category.
     * param: metadataCountTypes: Pres Ctrl can count the number of items present in a
     *   subcategory. For example, while retreving a list of all artists, 
            
     *   								  Pres Ctrl can also count how many albums/songs are available for
     *   each artist. (Might be a costly operation depending on Media Type. 
            
     *   								  	Select this option only if really required )
     * param: resetPrevious: Whether to use old history or not. Pres Ctrl has internal
     *   history mechanism. For example
             							 if in the first session query,
     *   the list of all available artists was obtained.In the 2nd browse level, HMI
     *   requested for
             							 all albums by a specific artist. If now HMI
     *   wants a list of all songs by the artist, it need not tell the selected artist
     *   
             							 again. However if this flag is reset, it will override this
     *   behavior.
     * param: AutoUpdateEnabled: 	This is applicable for result sets which might update
     *   dynamically, for example the current playing list for external
            
     *   								devices might update on its own.
     * param: ContentMask      //Bitmask combination of eTitleContentType. Bitmask
     *   combination for what content is expected - Audio/Video/Image.
            
           
     *    returns:	  numResults: The number of records matching the search criteria.
     *   (The number of results might not be accurate for ipod iAP1 like devices)
         
     *      
             returns      sessionQueryID:The sessionQueryID allotted.This
     *   uniquely identifies a particular session query/filter for retrieving data in a
     *   session and it has to be passed 
                                          for
     *   furthur setting the sessionQuery window and retrieving the contents of that
     *   window.
     * Calls setSessionQuery with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSessionQuery(const uint32_t &_sessionID, const uint64_t &_mediumID, const ::v1::com::harman::mmpres::MMPresTypes::FilterIDMap &_filterIDs, const ::v1::com::harman::mmpres::MMPresTypes::FilterMap &_filters, const ::v1::com::harman::mmpres::MMPresTypes::eMetadataType &_resultType, const uint32_t &_metadataAttributes, const uint32_t &_metadataCountTypes, const ::v1::com::harman::mmpres::MMPresTypes::eSessionQueryTypes &_type, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const uint32_t &_ContentMask, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, uint64_t &_numResults, uint32_t &_sessionQueryID, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSessionQuery with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSessionQueryAsync(const uint32_t &_sessionID, const uint64_t &_mediumID, const ::v1::com::harman::mmpres::MMPresTypes::FilterIDMap &_filterIDs, const ::v1::com::harman::mmpres::MMPresTypes::FilterMap &_filters, const ::v1::com::harman::mmpres::MMPresTypes::eMetadataType &_resultType, const uint32_t &_metadataAttributes, const uint32_t &_metadataCountTypes, const ::v1::com::harman::mmpres::MMPresTypes::eSessionQueryTypes &_type, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const uint32_t &_ContentMask, SetSessionQueryAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Ask presentation control to fetch the desired set of entries for a particular
     *   session query. This call does not block for the result to complete, and will
     *   override
    					  the last request given to Pres Ctrl.
     * param: sessionID: 	The Session ID alloted.
     * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
     *   particular session query/filter for retrieving data in a session and it has to
     *   be passed 
                                          for furthur setting the
     *   sessionQuery window and retrieving the contents of that window.
     * param: startIndex:	The index to start fetching.
     * param: numItems:		The number of items to fetch.
     * Calls setSessionQueryWindow with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSessionQueryWindow(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const uint64_t &_startIndex, const uint64_t &_numItems, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSessionQueryWindow with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSessionQueryWindowAsync(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const uint64_t &_startIndex, const uint64_t &_numItems, SetSessionQueryWindowAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Reselects the previous selected session query criteria. The previously shared
     *   sessionQueryID  will be returned.
     * Calls gotoPreviousSessionQuery with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void gotoPreviousSessionQuery(const uint32_t &_sessionID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, uint64_t &_numResults, uint32_t &_sessionQueryID, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls gotoPreviousSessionQuery with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> gotoPreviousSessionQueryAsync(const uint32_t &_sessionID, GotoPreviousSessionQueryAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: HMI Can use this to do a direct jump to any previous query ids
     * Calls jumpToSessionQuery with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void jumpToSessionQuery(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, uint64_t &_numResults, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls jumpToSessionQuery with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> jumpToSessionQueryAsync(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, JumpToSessionQueryAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Play session category. This api handles all requests to play metadata browse
     *   results, database searches, etc . 
                   
                   
               
     *      For this API, HMI should have initially done a openSession used the
     *   setSessionQuery to browse something. Then playSession
                   will play
     *   the currently selected browse context.
                   
                   1st
     *   Example:
                  
                   If the HMI wanted to play a list of all
     *   available songs.
                   
                   Initially HMI would have got
     *   the list of songs using setSessionQuery.
                   
                   Now
     *   playSession will just play the songs of that session.         
       
               
     *      If HMI wants to play a particular song from the list of songs, then HMI can
     *   set the filterID map by:
                   
                   passing the id of the
     *   praticular song.
                   
                   But if there is a rquirement
     *   that on selecting the partiuclar song, the entire collection has to be played
     *   with the 
                   selected song maintaining its position/offset, then
     *   this type of playback will be maintained in pres ctrl project
                  
     *   configuration.           
                 
                   2nd Example : 
            
     *        
                   We are in the root level of file system and HMI screen
     *   has the list of folders and files.Now HMI selects a file.
                  We
     *   want to play only that file.
                  
                   Then HMI can pass
     *   the fileID in filterIDMap.
                  
                   But if the project
     *   requirement is to play that file + other files in the same level together, or
     *   even incude the files from subfolders,then this will
                  be
     *   maintained as a config parameter in pres.
                  
                   or if
     *   there is a button in HMI called "playAll" at each level of file system browse
     *   and on clicking that, we
                  need to play all the files in that
     *   level. Now for these cases, HMI can just pass the sessionID as an input
          
     *          based on project requirements,we can play all the files in the current
     *   folder browse level or include the 
                   subfolders.
     * param: sessionID: The Session ID alloted.
     * param: filterIDs: The previously communicated numeric identifiers of the different
     *   filter categories.
     * Calls playSession with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void playSession(const uint32_t &_sessionID, const ::v1::com::harman::mmpres::MMPresTypes::FilterIDMap &_filterIDs, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls playSession with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> playSessionAsync(const uint32_t &_sessionID, const ::v1::com::harman::mmpres::MMPresTypes::FilterIDMap &_filterIDs, PlaySessionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This requests the pres to directly jump to the file system level or metadata
     *   browse path level which
                        contains the currently playing
     *   track and returns the number of items in that level matching the filter 
         
     *                 criteria. 
    	
                        For example, after connecting
     *   the USB and selecting it for playback and it starts playing some file 
           
     *               (which is at the 4th nested level from root). 
    	
                     
     *     Now clicking on browse icon, based on project requirement , we can directly
     *   jump to the 4th nested level
                        (assuming it is the
     *   nowplaying level) by calling this API.
    
                       [TODO]:The
     *   interface input & output parameters are yet to be finalized. To check if the
     *   interface can be 
                       combined with setSessionQuery.
     * Calls gotoNowplayingLevel with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void gotoNowplayingLevel(const uint32_t &_sessionID, const uint64_t &_mediumID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, uint64_t &_numItems, uint32_t &_sessionQueryID, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls gotoNowplayingLevel with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> gotoNowplayingLevelAsync(const uint32_t &_sessionID, const uint64_t &_mediumID, GotoNowplayingLevelAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<MediaBrowserProxyBase> delegate_;
};

typedef MediaBrowserProxy<> MediaBrowserProxyDefault;


//
// MediaBrowserProxy Implementation
//
template <typename ... _AttributeExtensions>
MediaBrowserProxy<_AttributeExtensions...>::MediaBrowserProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<MediaBrowserProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<MediaBrowserProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
MediaBrowserProxy<_AttributeExtensions...>::~MediaBrowserProxy() {
}

/**
 * description: Opens a session for the client communication. This session will be used
 *   internally to uniquely identify a client, and to maintain client specific
 *   caches.
					  The client need not create a new session for every request,
 *   this is rather used to identify different instances of clients.   
         
 
 *          returns:     sessionID: Session identifier allocated to the client.
 */
template <typename ... _AttributeExtensions>
void MediaBrowserProxy<_AttributeExtensions...>::openSession(CommonAPI::CallStatus &_internalCallStatus, uint32_t &_sessionID, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->openSession(_internalCallStatus, _sessionID, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MediaBrowserProxy<_AttributeExtensions...>::openSessionAsync(OpenSessionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->openSessionAsync(_callback, _info);
}
/**
 * description: Close a client session and release all associated resources. Once HMI calls
 *   closeSession,they cannot use the same sessionId
	for furthur browsing. For
 *   this, they have to again invoke a openSession to get a new sessionId for
 *   furthur browsing.
 * param: sessionID: The Session ID to close.
 */
template <typename ... _AttributeExtensions>
void MediaBrowserProxy<_AttributeExtensions...>::closeSession(const uint32_t &_sessionID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->closeSession(_sessionID, _internalCallStatus, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MediaBrowserProxy<_AttributeExtensions...>::closeSessionAsync(const uint32_t &_sessionID, CloseSessionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->closeSessionAsync(_sessionID, _callback, _info);
}
/**
 * description: Essentially Stops all background tasks in the specified session. But unlike
 *   closeSession, the sessionID
	 is valid and can be used for furthur browsing.
 * param: sessionID: The Session ID alloted.
 */
template <typename ... _AttributeExtensions>
void MediaBrowserProxy<_AttributeExtensions...>::cancelSession(const uint32_t &_sessionID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->cancelSession(_sessionID, _internalCallStatus, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MediaBrowserProxy<_AttributeExtensions...>::cancelSessionAsync(const uint32_t &_sessionID, CancelSessionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->cancelSessionAsync(_sessionID, _callback, _info);
}
/**
 * description: Sets a session query. This api handles all requests to fetch metadata browse
 *   results, database searches, file system browse etc. 
	 	 
	 	 Note: iF HMI
 *   wants to show the categories like ARTISTS,ALBUMS,FOLDERS,GENRES etc on
 *   clicking browse icon,they need not
	 	 use the setSessionQuery. They can
 *   instead use the tSlotUpdate broadcast which contains the tDevice structure.In
 *   
	 	 this, browse capabilities will be provided as a bitmask of different
 *   eMetadataTypes.If HMI is interested in
	 	 the count of these categories,then
 *   HMI can use the MetadataCountMap which is a map of different
 *   eMetadataCountType.
	 	 
	 	 
	 	 1st Example: 
	 	 
	 	 Get a list of all
 *   available artists. The filterID's' and filter's' will be empty, and the result
 *   type would be set to artist id. 
	 	 Presentation control would return a list
 *   of all available artists / artist id for the medium.
	 	 sessionQueryType will
 *   be METADATA_BROWSE 
	 	 
	 	 2nd Example:
	 	 
	 	 Get a list of all available
 *   artists. Also for each artist,get the count of songs.For this, input
 *   parameters will be same as first example
	 	 but now HMI should pass
 *   metadataCountTypes=eMetadataType::METADATATYPE_SONG.
	 	 
	 	 If HMI wants
 *   album count also along with songs count, then metadataCountTypes= bitmask
 *   combination of 
	 	 eMetadataType::METADATATYPE_SONG +
 *   eMetadataType::METADATATYPE_ALBUM.
	 	 
	 	 sessionQueryType will be
 *   METADATA_BROWSE 
	 	 
	 	 3rd Example : 
	 	 
	 	 Get a list of all available
 *   albums by the artist "Pink Floyd". HMI would know the artist id for "Pink
 *   Floyd" because of the previous returned result. 
	 	 
	 	 In the session
 *   query, HMI sets the filterIDMap as:
	 	 
	 	
 *   key=eMetadataType::METADATATYPE_ARTIST,value="artist id" for Pink Floyd 
	 	
 *   
	 	 resultType=eMetadataType::METADATATYPE_ALBUM. 
	 	 
	 	 Presentation
 *   Controller understands what needs to be done here. This can be further
 *   extended by setting
	 	 artist id and album id returned in the previous steps,
 *   and a query for songs can be done. 
	 	 
	 	 sessionQueryType will be
 *   METADATA_BROWSE.
	 	 
	 	 Suppose we need the list of songs inside the artist
 *   "Pink Floyd" but for eah song song, we also need to pass the artist,album 
	 	
 *   and genre values. Then this can be done by providing the "metadataAttributes"
 *   input parameter as a bit mask combination of
 *   eMetadataType::METADATATYPE_ARTIST +
	 	 eMetadataType::METADATATYPE_ALBUM &
 *   eMetadataType::METADATATYPE_GENRE.
	 	 
	 	 Note that metadataAttributes will
 *   be considered only if the resultType="song".
	 	 
	 	 4th Example : 
	 	 
	 	
 *   Get a list of all available albums by "Pink Floyd", which begin with the
 *   letters "The". 
	 	 This is same as the 3rd example, but in addition, the
 *   filter "album" must be set to "The"
	 	 
	 	 sessionQueryType will be
 *   METADATA_BROWSE 
	 	 
	 	 5th example:
	 	 
	 	 usage of resetPrevious
 *   parameter.
	 	 
	 	 Assume resetPrevious=false:
	 	 
	 	 In the first
 *   example,HMI obtained the list of albums for artist "Pink Floyed". Now if HMI
 *   wants list of songs for
	 	 artist "Pink Floyed", then in the filters,HMi need
 *   not mention anything again. 
	 	 They can just set
 *   resultype=eMetadataType::METADATATYPE_SONG .
	 	 
	 	 Now pres will remember
 *   that artist "Pink Floyd" was already selected. So pres will supply the song
 *   list for artist pink floyd.
	 	 
	 	 If resetPrevious=true,pres would not
 *   remeber that Artist Pink Floyd was already selected. In that case,
	 	 HMI has
 *   to set the filterIDMap again by providing the artist id for pink Floyd.
	 	 
	
 *   	 Now in the use cases, where the resultType is
 *   "eMetadataType::METADATATYPE_SONG", if the requirement is to show only AUDIO
	
 *   	 or VIDEO or both AUDIO + VIDEO, this can be done by setting "ContentMask"
 *   param as a bit mask of "eTitleContentType".
	 	 
	 	
 *   eTitleContentType::TITLETYPE_IMAGE will be applicable for filesystem browse.
 *   
	 	 
	 	 6th Example:
	 	 
	 	 Do a fileSystem or FOLDER browse.This is
 *   applicable for mass storage devices like USB.At any level, we are 
	 	 allowed
 *   to show both folders, files or playlists depending on project requirements.
	
 *   	 
	 	 sessionQueryType will be SESSION_QUERY_FS_BROWSE.
	 	 
	 	 First go to
 *   root level and show only folders and files but not playlists. For this, the
 *   filterID's and filters are empty, but the resultType will be 
	 	 combination
 *   of eMetadataType::METADATATYPE_FOLDER + eMetadataType::METADATATYPE_FILE.With
 *   this query,HMI can get
	 	 the folders and file at a given level in
 *   filesystem. When HMI gets the individual items, they can check the
 *   eMetadataType
	 	 of that item to see if it is a file or folder.
	 	 
	 	 Now
 *   HMI wants to go inside one more level by selecting a folder obtained in the
 *   previous step.For this,HMI can set the filterID as 
	 	
 *   key=METADATAID_FOLDER_ID and value=(folder id or item id) of folder
 *   communicated in previous step.
	 	 
	 	 If at every level, there is a
 *   requirement to list folders first and only then followed by audio files,image
 *   files etc, then
	 	 these will be maintained by pres as project specific
 *   config parameters. 
	 	 
	 	 Now HMI wants to go inside one of the folders
 *   named "Folder1" listed at the root level.For this,HMI can set the FilterIDMap
 *   as:
	 	 
	 	 key: "eMetadataType::METADATATYPE_FOLDER" and value: folder id of
 *   "folder 1" from the result of the first query to 
	 	       show the root
 *   level contents.
	 	 
	 	 Also if HMI wants the level ID (depth of folder) in
 *   file system browse, such as 4th folder depth or fifth folder depth etc,
	 	
 *   then they can use the sessionQueryID as an indicator of level ID. Each
 *   sessionQueryID will correspond to a
	 	 particular folder depth in file system
 *   browse.
	 	 
	 	 7th example:
	 	 
	 	 If HMI wants the list of songs from the
 *   recently played list.
	 	 
	 	 The can set the sessionQueryType will be
 *   SESSION_QUERY_RECENTLYPLAYED and resultype=eMetadataType::METADATATYPE_SONG
	 
 *      other parameters can be empty.
 * param: filterIDs: The previously communicated numeric identifiers of the different
 *   filter categories.
 * param: filters:	 The string filters which should be applied to the result.
 * param: resultType: The data which is expected from the query.
 * param: sessionID: The Session ID alloted.
 * param: mediumID:	 The identifier for the mediastore to query.
 * param: type:		 The type of session query.
 * param: metadataAttributes: [TODO]:Pres ctrl can return the required attributes for
 *   each metadata item based on the 
                                         
 *   client requirements.This is a bitmask combination of eMetadataType values.
 *   This will be 
                                          supported only for the
 *   song category.
 * param: metadataCountTypes: Pres Ctrl can count the number of items present in a
 *   subcategory. For example, while retreving a list of all artists, 
        
 *   								  Pres Ctrl can also count how many albums/songs are available for
 *   each artist. (Might be a costly operation depending on Media Type. 
        
 *   								  	Select this option only if really required )
 * param: resetPrevious: Whether to use old history or not. Pres Ctrl has internal
 *   history mechanism. For example
         							 if in the first session query,
 *   the list of all available artists was obtained.In the 2nd browse level, HMI
 *   requested for
         							 all albums by a specific artist. If now HMI
 *   wants a list of all songs by the artist, it need not tell the selected artist
 *   
         							 again. However if this flag is reset, it will override this
 *   behavior.
 * param: AutoUpdateEnabled: 	This is applicable for result sets which might update
 *   dynamically, for example the current playing list for external
        
 *   								devices might update on its own.
 * param: ContentMask      //Bitmask combination of eTitleContentType. Bitmask
 *   combination for what content is expected - Audio/Video/Image.
        
       
 *    returns:	  numResults: The number of records matching the search criteria.
 *   (The number of results might not be accurate for ipod iAP1 like devices)
     
 *      
         returns      sessionQueryID:The sessionQueryID allotted.This
 *   uniquely identifies a particular session query/filter for retrieving data in a
 *   session and it has to be passed 
                                      for
 *   furthur setting the sessionQuery window and retrieving the contents of that
 *   window.
 */
template <typename ... _AttributeExtensions>
void MediaBrowserProxy<_AttributeExtensions...>::setSessionQuery(const uint32_t &_sessionID, const uint64_t &_mediumID, const ::v1::com::harman::mmpres::MMPresTypes::FilterIDMap &_filterIDs, const ::v1::com::harman::mmpres::MMPresTypes::FilterMap &_filters, const ::v1::com::harman::mmpres::MMPresTypes::eMetadataType &_resultType, const uint32_t &_metadataAttributes, const uint32_t &_metadataCountTypes, const ::v1::com::harman::mmpres::MMPresTypes::eSessionQueryTypes &_type, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const uint32_t &_ContentMask, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, uint64_t &_numResults, uint32_t &_sessionQueryID, const CommonAPI::CallInfo *_info) {
    if (!_resultType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_type.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setSessionQuery(_sessionID, _mediumID, _filterIDs, _filters, _resultType, _metadataAttributes, _metadataCountTypes, _type, _resetPrevious, _AutoUpdateEnabled, _ContentMask, _internalCallStatus, _result, _numResults, _sessionQueryID, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MediaBrowserProxy<_AttributeExtensions...>::setSessionQueryAsync(const uint32_t &_sessionID, const uint64_t &_mediumID, const ::v1::com::harman::mmpres::MMPresTypes::FilterIDMap &_filterIDs, const ::v1::com::harman::mmpres::MMPresTypes::FilterMap &_filters, const ::v1::com::harman::mmpres::MMPresTypes::eMetadataType &_resultType, const uint32_t &_metadataAttributes, const uint32_t &_metadataCountTypes, const ::v1::com::harman::mmpres::MMPresTypes::eSessionQueryTypes &_type, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const uint32_t &_ContentMask, SetSessionQueryAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_resultType.validate()) {
        ::v1::com::harman::mmpres::MMPresTypes::eCallResult result = ::v1::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
        uint64_t numResults = 0ull;
        uint32_t sessionQueryID = 0ul;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, result, numResults, sessionQueryID);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_type.validate()) {
        ::v1::com::harman::mmpres::MMPresTypes::eCallResult result = ::v1::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
        uint64_t numResults = 0ull;
        uint32_t sessionQueryID = 0ul;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, result, numResults, sessionQueryID);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setSessionQueryAsync(_sessionID, _mediumID, _filterIDs, _filters, _resultType, _metadataAttributes, _metadataCountTypes, _type, _resetPrevious, _AutoUpdateEnabled, _ContentMask, _callback, _info);
}
/**
 * description: Ask presentation control to fetch the desired set of entries for a particular
 *   session query. This call does not block for the result to complete, and will
 *   override
					  the last request given to Pres Ctrl.
 * param: sessionID: 	The Session ID alloted.
 * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed 
                                      for furthur setting the
 *   sessionQuery window and retrieving the contents of that window.
 * param: startIndex:	The index to start fetching.
 * param: numItems:		The number of items to fetch.
 */
template <typename ... _AttributeExtensions>
void MediaBrowserProxy<_AttributeExtensions...>::setSessionQueryWindow(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const uint64_t &_startIndex, const uint64_t &_numItems, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->setSessionQueryWindow(_sessionID, _sessionQueryID, _startIndex, _numItems, _internalCallStatus, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MediaBrowserProxy<_AttributeExtensions...>::setSessionQueryWindowAsync(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const uint64_t &_startIndex, const uint64_t &_numItems, SetSessionQueryWindowAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setSessionQueryWindowAsync(_sessionID, _sessionQueryID, _startIndex, _numItems, _callback, _info);
}
/**
 * description: Reselects the previous selected session query criteria. The previously shared
 *   sessionQueryID  will be returned.
 */
template <typename ... _AttributeExtensions>
void MediaBrowserProxy<_AttributeExtensions...>::gotoPreviousSessionQuery(const uint32_t &_sessionID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, uint64_t &_numResults, uint32_t &_sessionQueryID, const CommonAPI::CallInfo *_info) {
    delegate_->gotoPreviousSessionQuery(_sessionID, _internalCallStatus, _result, _numResults, _sessionQueryID, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MediaBrowserProxy<_AttributeExtensions...>::gotoPreviousSessionQueryAsync(const uint32_t &_sessionID, GotoPreviousSessionQueryAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->gotoPreviousSessionQueryAsync(_sessionID, _callback, _info);
}
/**
 * description: HMI Can use this to do a direct jump to any previous query ids
 */
template <typename ... _AttributeExtensions>
void MediaBrowserProxy<_AttributeExtensions...>::jumpToSessionQuery(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, uint64_t &_numResults, const CommonAPI::CallInfo *_info) {
    delegate_->jumpToSessionQuery(_sessionID, _sessionQueryID, _internalCallStatus, _result, _numResults, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MediaBrowserProxy<_AttributeExtensions...>::jumpToSessionQueryAsync(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, JumpToSessionQueryAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->jumpToSessionQueryAsync(_sessionID, _sessionQueryID, _callback, _info);
}
/**
 * description: Play session category. This api handles all requests to play metadata browse
 *   results, database searches, etc . 
               
               
           
 *      For this API, HMI should have initially done a openSession used the
 *   setSessionQuery to browse something. Then playSession
               will play
 *   the currently selected browse context.
               
               1st
 *   Example:
              
               If the HMI wanted to play a list of all
 *   available songs.
               
               Initially HMI would have got
 *   the list of songs using setSessionQuery.
               
               Now
 *   playSession will just play the songs of that session.         
   
           
 *      If HMI wants to play a particular song from the list of songs, then HMI can
 *   set the filterID map by:
               
               passing the id of the
 *   praticular song.
               
               But if there is a rquirement
 *   that on selecting the partiuclar song, the entire collection has to be played
 *   with the 
               selected song maintaining its position/offset, then
 *   this type of playback will be maintained in pres ctrl project
              
 *   configuration.           
             
               2nd Example : 
        
 *        
               We are in the root level of file system and HMI screen
 *   has the list of folders and files.Now HMI selects a file.
              We
 *   want to play only that file.
              
               Then HMI can pass
 *   the fileID in filterIDMap.
              
               But if the project
 *   requirement is to play that file + other files in the same level together, or
 *   even incude the files from subfolders,then this will
              be
 *   maintained as a config parameter in pres.
              
               or if
 *   there is a button in HMI called "playAll" at each level of file system browse
 *   and on clicking that, we
              need to play all the files in that
 *   level. Now for these cases, HMI can just pass the sessionID as an input
      
 *          based on project requirements,we can play all the files in the current
 *   folder browse level or include the 
               subfolders.
 * param: sessionID: The Session ID alloted.
 * param: filterIDs: The previously communicated numeric identifiers of the different
 *   filter categories.
 */
template <typename ... _AttributeExtensions>
void MediaBrowserProxy<_AttributeExtensions...>::playSession(const uint32_t &_sessionID, const ::v1::com::harman::mmpres::MMPresTypes::FilterIDMap &_filterIDs, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->playSession(_sessionID, _filterIDs, _internalCallStatus, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MediaBrowserProxy<_AttributeExtensions...>::playSessionAsync(const uint32_t &_sessionID, const ::v1::com::harman::mmpres::MMPresTypes::FilterIDMap &_filterIDs, PlaySessionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->playSessionAsync(_sessionID, _filterIDs, _callback, _info);
}
/**
 * description: This requests the pres to directly jump to the file system level or metadata
 *   browse path level which
                    contains the currently playing
 *   track and returns the number of items in that level matching the filter 
     
 *                 criteria. 
	
                    For example, after connecting
 *   the USB and selecting it for playback and it starts playing some file 
       
 *               (which is at the 4th nested level from root). 
	
                 
 *     Now clicking on browse icon, based on project requirement , we can directly
 *   jump to the 4th nested level
                    (assuming it is the
 *   nowplaying level) by calling this API.

                   [TODO]:The
 *   interface input & output parameters are yet to be finalized. To check if the
 *   interface can be 
                   combined with setSessionQuery.
 */
template <typename ... _AttributeExtensions>
void MediaBrowserProxy<_AttributeExtensions...>::gotoNowplayingLevel(const uint32_t &_sessionID, const uint64_t &_mediumID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, uint64_t &_numItems, uint32_t &_sessionQueryID, const CommonAPI::CallInfo *_info) {
    delegate_->gotoNowplayingLevel(_sessionID, _mediumID, _internalCallStatus, _result, _numItems, _sessionQueryID, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MediaBrowserProxy<_AttributeExtensions...>::gotoNowplayingLevelAsync(const uint32_t &_sessionID, const uint64_t &_mediumID, GotoNowplayingLevelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->gotoNowplayingLevelAsync(_sessionID, _mediumID, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &MediaBrowserProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool MediaBrowserProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool MediaBrowserProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& MediaBrowserProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& MediaBrowserProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace mmpres
} // namespace harman
} // namespace com
} // namespace v1



// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_MMPRES_Media_Browser_PROXY_HPP_
