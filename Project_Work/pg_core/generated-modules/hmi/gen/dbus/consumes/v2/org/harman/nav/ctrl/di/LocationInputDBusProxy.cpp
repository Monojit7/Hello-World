/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: LocationInput = This interface offers functions that implement the
 *   location-input functionality of a navigation system
 */
#include <v2/org/harman/nav/ctrl/di/LocationInputDBusProxy.hpp>

namespace v2 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace di {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createLocationInputDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<LocationInputDBusProxy>(_address, _connection);
}

INITIALIZER(registerLocationInputDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		LocationInput::getInterface(),
		&createLocationInputDBusProxy);
}

LocationInputDBusProxy::LocationInputDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		currentSelectionCriterion_(*this, "currentSelectionCriterion", "ui", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		searchStatus_(*this, "searchStatus", "ui", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		spellResult_(*this, "spellResult", "ussb", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		searchResultList_(*this, "searchResultList", "uqqqaa{i(yv)}", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::ArrayDeployment<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t>*>(nullptr))),
		searchResultListSizeChanged_(*this, "searchResultListSizeChanged", "uq", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		contentUpdated_(*this, "contentUpdated", "ubaia{i(yv)}", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr), static_cast<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t*>(nullptr))),
		addressValidationResult_(*this, "addressValidationResult", "uaa{i(yv)}aa{ii}", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::ArrayDeployment<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t>*>(nullptr), static_cast<CommonAPI::DBus::ArrayDeployment<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::ValidationStatusDeployment_t>*>(nullptr)))
{
}


LocationInputDBusProxy::CurrentSelectionCriterionEvent& LocationInputDBusProxy::getCurrentSelectionCriterionEvent() {
    return currentSelectionCriterion_;
}
LocationInputDBusProxy::SearchStatusEvent& LocationInputDBusProxy::getSearchStatusEvent() {
    return searchStatus_;
}
LocationInputDBusProxy::SpellResultEvent& LocationInputDBusProxy::getSpellResultEvent() {
    return spellResult_;
}
LocationInputDBusProxy::SearchResultListEvent& LocationInputDBusProxy::getSearchResultListEvent() {
    return searchResultList_;
}
LocationInputDBusProxy::SearchResultListSizeChangedEvent& LocationInputDBusProxy::getSearchResultListSizeChangedEvent() {
    return searchResultListSizeChanged_;
}
LocationInputDBusProxy::ContentUpdatedEvent& LocationInputDBusProxy::getContentUpdatedEvent() {
    return contentUpdated_;
}
LocationInputDBusProxy::AddressValidationResultEvent& LocationInputDBusProxy::getAddressValidationResultEvent() {
    return addressValidationResult_;
}
    
    /**
     * description: getVersion = This method returns the API version implemented by the server
     *   application
     */
    void LocationInputDBusProxy::getVersion(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Version, ::org::harman::nav::ctrl::CommonTypes_::VersionDeployment_t> deploy_version(static_cast<::org::harman::nav::ctrl::CommonTypes_::VersionDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Version,::org::harman::nav::ctrl::CommonTypes_::VersionDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getVersion",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_version);
_version = deploy_version.getValue();
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::getVersionAsync(GetVersionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Version, ::org::harman::nav::ctrl::CommonTypes_::VersionDeployment_t> deploy_version(static_cast<::org::harman::nav::ctrl::CommonTypes_::VersionDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Version,::org::harman::nav::ctrl::CommonTypes_::VersionDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getVersion",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Version, ::org::harman::nav::ctrl::CommonTypes_::VersionDeployment_t> _version) {
        	if (_callback)
        		_callback(_internalCallStatus, _version.getValue());
        },
        std::make_tuple(deploy_version));
    }
    /**
     * description: createLocationInput = This method creates a new location input and retrieves a
     *   handle
     */
    void LocationInputDBusProxy::createLocationInput(CommonAPI::CallStatus &_internalCallStatus, LocationInput::createLocationInputError &_error, ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::createLocationInputError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::createLocationInputError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "createLocationInput",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_locationInputHandle);
_error = deploy_error.getValue();
_locationInputHandle = deploy_locationInputHandle.getValue();
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::createLocationInputAsync(CreateLocationInputAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::createLocationInputError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::createLocationInputError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "createLocationInput",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<LocationInput::createLocationInputError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> _locationInputHandle) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _locationInputHandle.getValue());
        },
        std::make_tuple(deploy_error, deploy_locationInputHandle));
    }
    /**
     * description: deleteLocationInput = This method deletes a location input and its associated
     *   resources
     */
    void LocationInputDBusProxy::deleteLocationInput(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "deleteLocationInput",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locationInputHandle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::deleteLocationInputAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, DeleteLocationInputAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "deleteLocationInput",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locationInputHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: getSupportedAddressAttributes = This method retrieves the supported address
     *   attributes
     */
    void LocationInputDBusProxy::getSupportedAddressAttributes(CommonAPI::CallStatus &_internalCallStatus, ::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttributeList &_addressAttributesList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttributeList, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressAttributeListDeployment_t> deploy_addressAttributesList(static_cast<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressAttributeListDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttributeList,::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressAttributeListDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedAddressAttributes",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_addressAttributesList);
_addressAttributesList = deploy_addressAttributesList.getValue();
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::getSupportedAddressAttributesAsync(GetSupportedAddressAttributesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttributeList, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressAttributeListDeployment_t> deploy_addressAttributesList(static_cast<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressAttributeListDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttributeList,::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressAttributeListDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedAddressAttributes",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttributeList, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressAttributeListDeployment_t> _addressAttributesList) {
        	if (_callback)
        		_callback(_internalCallStatus, _addressAttributesList.getValue());
        },
        std::make_tuple(deploy_addressAttributesList));
    }
    /**
     * description: setAddress = This method sets the address to start with for the LocationInput
     *   identified by the given handle
     */
    void LocationInputDBusProxy::setAddress(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const ::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address &_address, CommonAPI::CallStatus &_internalCallStatus, LocationInput::setAddressError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::setAddressError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t> deploy_address(_address, static_cast<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::setAddressError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setAddress",
        "ua{i(yv)}",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locationInputHandle, deploy_address,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::setAddressAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const ::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address &_address, SetAddressAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::setAddressError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t> deploy_address(_address, static_cast<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::setAddressError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setAddress",
        "ua{i(yv)}",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locationInputHandle, deploy_address,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<LocationInput::setAddressError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: setSelectionCriterion = This method sets the selection criterion for the
     *   current speller, search input and the corresponding result-lists for the
     *   current session
     */
    void LocationInputDBusProxy::setSelectionCriterion(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const ::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttribute &_selectionCriterion, CommonAPI::CallStatus &_internalCallStatus, LocationInput::setSelectionCriterionError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::setSelectionCriterionError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttribute, CommonAPI::EmptyDeployment> deploy_selectionCriterion(_selectionCriterion, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttribute, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::setSelectionCriterionError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setSelectionCriterion",
        "ui",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locationInputHandle, deploy_selectionCriterion,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::setSelectionCriterionAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const ::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttribute &_selectionCriterion, SetSelectionCriterionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::setSelectionCriterionError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttribute, CommonAPI::EmptyDeployment> deploy_selectionCriterion(_selectionCriterion, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::AddressAttribute, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::setSelectionCriterionError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setSelectionCriterion",
        "ui",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locationInputHandle, deploy_selectionCriterion,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<LocationInput::setSelectionCriterionError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: spell = This method sends the next spell input for the current session
         
     *   TBD: expected broadcasts
     */
    void LocationInputDBusProxy::spell(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const std::string &_inputCharacter, const uint16_t &_maxWindowSize, CommonAPI::CallStatus &_internalCallStatus, LocationInput::spellError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::spellError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_inputCharacter(_inputCharacter, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_maxWindowSize(_maxWindowSize, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::spellError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "spell",
        "usq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locationInputHandle, deploy_inputCharacter, deploy_maxWindowSize,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::spellAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const std::string &_inputCharacter, const uint16_t &_maxWindowSize, SpellAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::spellError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_inputCharacter(_inputCharacter, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_maxWindowSize(_maxWindowSize, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::spellError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "spell",
        "usq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locationInputHandle, deploy_inputCharacter, deploy_maxWindowSize,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<LocationInput::spellError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: search = This method sets the inputString for the current selection criterion
     
     *       TBD: expected broadcasts
     */
    void LocationInputDBusProxy::search(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const std::string &_inputString, const uint16_t &_maxWindowSize, CommonAPI::CallStatus &_internalCallStatus, LocationInput::searchError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::searchError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_inputString(_inputString, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_maxWindowSize(_maxWindowSize, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::searchError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "search",
        "usq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locationInputHandle, deploy_inputString, deploy_maxWindowSize,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::searchAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const std::string &_inputString, const uint16_t &_maxWindowSize, SearchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::searchError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_inputString(_inputString, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_maxWindowSize(_maxWindowSize, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::searchError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "search",
        "usq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locationInputHandle, deploy_inputString, deploy_maxWindowSize,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<LocationInput::searchError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: requestListUpdate = This method sends a request for more list elements for the
     *   current session
          If a session changes, e.g. new character is entered, a
     *   new list is generated. Offset is starting at 0 again.
     */
    void LocationInputDBusProxy::requestListUpdate(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const uint16_t &_offset, const uint16_t &_maxWindowSize, CommonAPI::CallStatus &_internalCallStatus, LocationInput::requestListUpdateError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::requestListUpdateError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_offset(_offset, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_maxWindowSize(_maxWindowSize, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::requestListUpdateError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "requestListUpdate",
        "uqq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locationInputHandle, deploy_offset, deploy_maxWindowSize,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::requestListUpdateAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const uint16_t &_offset, const uint16_t &_maxWindowSize, RequestListUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::requestListUpdateError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_offset(_offset, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_maxWindowSize(_maxWindowSize, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::requestListUpdateError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "requestListUpdate",
        "uqq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locationInputHandle, deploy_offset, deploy_maxWindowSize,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<LocationInput::requestListUpdateError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: selectEntry = This method triggers selection of a result list entry by index
     */
    void LocationInputDBusProxy::selectEntry(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const uint16_t &_index, CommonAPI::CallStatus &_internalCallStatus, LocationInput::selectEntryError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::selectEntryError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_index(_index, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::selectEntryError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "selectEntry",
        "uq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locationInputHandle, deploy_index,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::selectEntryAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const uint16_t &_index, SelectEntryAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<LocationInput::selectEntryError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_index(_index, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<LocationInput::selectEntryError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "selectEntry",
        "uq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locationInputHandle, deploy_index,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<LocationInput::selectEntryError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: getEntry = This method synchronously gets the address for the given result list
     *   entry
     */
    void LocationInputDBusProxy::getEntry(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const uint16_t &_index, CommonAPI::CallStatus &_internalCallStatus, ::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address &_address, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_index(_index, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t> deploy_address(static_cast<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address,::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getEntry",
        "uq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locationInputHandle, deploy_index,
_internalCallStatus,
deploy_address);
_address = deploy_address.getValue();
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::getEntryAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const uint16_t &_index, GetEntryAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_index(_index, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t> deploy_address(static_cast<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address,::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getEntry",
        "uq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locationInputHandle, deploy_index,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t> _address) {
        	if (_callback)
        		_callback(_internalCallStatus, _address.getValue());
        },
        std::make_tuple(deploy_address));
    }
    /**
     * description: validateAddress = This method validates an address from different sources than
     *   Navigation
          TBD: functionality to be clarified
     */
    void LocationInputDBusProxy::validateAddress(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const ::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address &_inputAddress, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t> deploy_inputAddress(_inputAddress, static_cast<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "validateAddress",
        "ua{i(yv)}",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locationInputHandle, deploy_inputAddress,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::validateAddressAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const ::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address &_inputAddress, ValidateAddressAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t> deploy_inputAddress(_inputAddress, static_cast<::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v2::org::harman::nav::ctrl::di::LocationInputTypes::Address, ::v2::org::harman::nav::ctrl::di::LocationInputTypes_::AddressDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "validateAddress",
        "ua{i(yv)}",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locationInputHandle, deploy_inputAddress,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: reverseGeocode = This method transforms a geocoordinate into an address
     */
    void LocationInputDBusProxy::reverseGeocode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate2D &_coordinate, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Coordinate2D, ::org::harman::nav::ctrl::CommonTypes_::Coordinate2DDeployment_t> deploy_coordinate(_coordinate, static_cast<::org::harman::nav::ctrl::CommonTypes_::Coordinate2DDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Coordinate2D, ::org::harman::nav::ctrl::CommonTypes_::Coordinate2DDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "reverseGeocode",
        "u(dd)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locationInputHandle, deploy_coordinate,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> LocationInputDBusProxy::reverseGeocodeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_locationInputHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate2D &_coordinate, ReverseGeocodeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment> deploy_locationInputHandle(_locationInputHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Coordinate2D, ::org::harman::nav::ctrl::CommonTypes_::Coordinate2DDeployment_t> deploy_coordinate(_coordinate, static_cast<::org::harman::nav::ctrl::CommonTypes_::Coordinate2DDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::org::harman::nav::ctrl::CommonTypes::Coordinate2D, ::org::harman::nav::ctrl::CommonTypes_::Coordinate2DDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "reverseGeocode",
        "u(dd)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locationInputHandle, deploy_coordinate,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }


void LocationInputDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 2;
          ownVersionMinor = 1;
      }

      } // namespace di
      } // namespace ctrl
      } // namespace nav
      } // namespace harman
      } // namespace org
      } // namespace v2
