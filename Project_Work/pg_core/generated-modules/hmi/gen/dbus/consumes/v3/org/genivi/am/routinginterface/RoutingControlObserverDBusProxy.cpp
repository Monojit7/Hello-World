/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: Routing Receive sendInterface description.
 * author: lian zhang
 */
#include <v3/org/genivi/am/routinginterface/RoutingControlObserverDBusProxy.hpp>

namespace v3 {
namespace org {
namespace genivi {
namespace am {
namespace routinginterface {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createRoutingControlObserverDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<RoutingControlObserverDBusProxy>(_address, _connection);
}

INITIALIZER(registerRoutingControlObserverDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		RoutingControlObserver::getInterface(),
		&createRoutingControlObserverDBusProxy);
}

RoutingControlObserverDBusProxy::RoutingControlObserverDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		routingReady_(*this, "onRoutingReadyAttributeChanged", "i", "getRoutingReadyAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr))
{
}

      RoutingControlObserverDBusProxy::RoutingReadyAttribute& RoutingControlObserverDBusProxy::getRoutingReadyAttribute() {
          return routingReady_;
      }

    
    /**
     * description: Registers a domain.
    (at)return E_OK on success, E_ALREADY_EXISTENT if already
     *   registered E_UNKNOWN on error
     */
    void RoutingControlObserverDBusProxy::registerDomain(const ::v3::org::genivi::am_t::am_Domain_s &_domainData, const std::string &_returnBusname, const std::string &_returnInterface, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_domainID_t &_domainID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Domain_s, ::v3::org::genivi::am_t_::am_Domain_sDeployment_t> deploy_domainData(_domainData, static_cast<::v3::org::genivi::am_t_::am_Domain_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_returnBusname(_returnBusname, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_returnInterface(_returnInterface, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> deploy_domainID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Domain_s, ::v3::org::genivi::am_t_::am_Domain_sDeployment_t >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "registerDomain",
        "(qsssbbi)ss",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_domainData, deploy_returnBusname, deploy_returnInterface,
_internalCallStatus,
deploy_domainID, deploy_amError);
_domainID = deploy_domainID.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerDomainAsync(const ::v3::org::genivi::am_t::am_Domain_s &_domainData, const std::string &_returnBusname, const std::string &_returnInterface, RegisterDomainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Domain_s, ::v3::org::genivi::am_t_::am_Domain_sDeployment_t> deploy_domainData(_domainData, static_cast<::v3::org::genivi::am_t_::am_Domain_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_returnBusname(_returnBusname, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_returnInterface(_returnInterface, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> deploy_domainID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Domain_s, ::v3::org::genivi::am_t_::am_Domain_sDeployment_t >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "registerDomain",
        "(qsssbbi)ss",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_domainData, deploy_returnBusname, deploy_returnInterface,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> _domainID, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _domainID.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_domainID, deploy_amError));
    }
    /**
     * description: Deregisters a domain. All sources, sinks, gateways and crossfaders from that
     *   domain will be removed as well.
    (at)return E_OK on success, E_NON_EXISTENT if
     *   not found E_UNKNOWN on error
     */
    void RoutingControlObserverDBusProxy::deregisterDomain(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> deploy_domainID(_domainID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "deregisterDomain",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_domainID,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterDomainAsync(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, DeregisterDomainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> deploy_domainID(_domainID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "deregisterDomain",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_domainID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: This function returns the ID to the given domain name. If already a domain is
     *   registered with this name, it will return the corresponding ID, if not it will
     *   reserve an ID but not register the domain. The other parameters of the domain
     *   will be overwritten when the domain is registered.
    (at)return E_OK on success,
     *   E_UNKNOWN on error
        please use pulseAudio as the name to peek domainID. now
     *   all the sources and sinks are defined in domain pulseAudio.
     */
    void RoutingControlObserverDBusProxy::peekDomain(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_domainID_t &_domainID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> deploy_domainID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "peekDomain",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_name,
_internalCallStatus,
deploy_domainID, deploy_amError);
_domainID = deploy_domainID.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekDomainAsync(const std::string &_name, PeekDomainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> deploy_domainID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "peekDomain",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_name,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> _domainID, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _domainID.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_domainID, deploy_amError));
    }
    /**
     * description: Registers a sink. If the sink is part of a gateway, the list connection formats
     *   are copied to the gateway information
    (at)return E_OK on success,
     *   E_ALREADY_EXISTENT if already registered E_UNKNOWN on error
     */
    void RoutingControlObserverDBusProxy::registerSink(const ::v3::org::genivi::am_t::am_Sink_s &_sinkData, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Sink_s, ::v3::org::genivi::am_t_::am_Sink_sDeployment_t> deploy_sinkData(_sinkData, static_cast<::v3::org::genivi::am_t_::am_Sink_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Sink_s, ::v3::org::genivi::am_t_::am_Sink_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "registerSink",
        "(qsqqnb(iq)ina(qn)aqa(in)a(qin)a(qin))",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkData,
_internalCallStatus,
deploy_sinkID, deploy_amError);
_sinkID = deploy_sinkID.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerSinkAsync(const ::v3::org::genivi::am_t::am_Sink_s &_sinkData, RegisterSinkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Sink_s, ::v3::org::genivi::am_t_::am_Sink_sDeployment_t> deploy_sinkData(_sinkData, static_cast<::v3::org::genivi::am_t_::am_Sink_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Sink_s, ::v3::org::genivi::am_t_::am_Sink_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "registerSink",
        "(qsqqnb(iq)ina(qn)aqa(in)a(qin)a(qin))",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkData,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> _sinkID, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _sinkID.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_sinkID, deploy_amError));
    }
    /**
     * description: Deregisters a sink.
    (at)return E_OK on success, E_NON_EXISTENT if not found
     *   E_UNKNOWN on error
     */
    void RoutingControlObserverDBusProxy::deregisterSink(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "deregisterSink",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkID,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterSinkAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, DeregisterSinkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "deregisterSink",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: This function returns the ID to the given sink name. If already a sink is
     *   registered with this name, it will return the corresponding ID, if not it will
     *   reserve an ID but not register the sink. The other parameters of the sink will
     *   be overwritten when the sink is registered.
    (at)return E_OK on success,
     *   E_UNKNOWN on error
     */
    void RoutingControlObserverDBusProxy::peekSink(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "peekSink",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_name,
_internalCallStatus,
deploy_sinkID, deploy_amError);
_sinkID = deploy_sinkID.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSinkAsync(const std::string &_name, PeekSinkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "peekSink",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_name,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> _sinkID, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _sinkID.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_sinkID, deploy_amError));
    }
    /**
     * description: This function peeks a sink class ID. It is used by the RoutingPlugins to
     *   determine the sink class IDs of a sink class.
    (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     */
    void RoutingControlObserverDBusProxy::peekSinkClassID(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sinkClass_t &_sinkClassID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkClass_t, CommonAPI::EmptyDeployment> deploy_sinkClassID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkClass_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "peekSinkClassID",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_name,
_internalCallStatus,
deploy_sinkClassID, deploy_amError);
_sinkClassID = deploy_sinkClassID.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSinkClassIDAsync(const std::string &_name, PeekSinkClassIDAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkClass_t, CommonAPI::EmptyDeployment> deploy_sinkClassID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkClass_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "peekSinkClassID",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_name,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkClass_t, CommonAPI::EmptyDeployment> _sinkClassID, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _sinkClassID.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_sinkClassID, deploy_amError));
    }
    /**
     * description: Updates data of a sink.
    (at)return E_OK on success, E_NON_EXISTENT if the sink
     *   ID is not valid.
     */
    void RoutingControlObserverDBusProxy::updateSink(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_sinkClass_t &_sinkClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkClass_t, CommonAPI::EmptyDeployment> deploy_sinkClassID(_sinkClassID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SoundProperty_L, ::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t> deploy_listSoundProperties(_listSoundProperties, static_cast<::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_ConnectionFormat_L, ::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t> deploy_listConnectionFormats(_listConnectionFormats, static_cast<::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t> deploy_listMainSoundProperties(_listMainSoundProperties, static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkClass_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SoundProperty_L, ::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_ConnectionFormat_L, ::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "updateSink",
        "qqa(qn)aqa(in)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkID, deploy_sinkClassID, deploy_listSoundProperties, deploy_listConnectionFormats, deploy_listMainSoundProperties,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::updateSinkAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_sinkClass_t &_sinkClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, UpdateSinkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkClass_t, CommonAPI::EmptyDeployment> deploy_sinkClassID(_sinkClassID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SoundProperty_L, ::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t> deploy_listSoundProperties(_listSoundProperties, static_cast<::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_ConnectionFormat_L, ::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t> deploy_listConnectionFormats(_listConnectionFormats, static_cast<::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t> deploy_listMainSoundProperties(_listMainSoundProperties, static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkClass_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SoundProperty_L, ::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_ConnectionFormat_L, ::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "updateSink",
        "qqa(qn)aqa(in)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkID, deploy_sinkClassID, deploy_listSoundProperties, deploy_listConnectionFormats, deploy_listMainSoundProperties,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: Registers a source.  If the source is part of a gateway, the list connection
     *   formats are copied to the gateway information
    (at)return E_OK on success,
     *   E_UNKNOWN on error, E_ALREADY_EXIST if either name or source ID already exists
     */
    void RoutingControlObserverDBusProxy::registerSource(const ::v3::org::genivi::am_t::am_Source_s &_sourceData, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Source_s, ::v3::org::genivi::am_t_::am_Source_sDeployment_t> deploy_sourceData(_sourceData, static_cast<::v3::org::genivi::am_t_::am_Source_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Source_s, ::v3::org::genivi::am_t_::am_Source_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "registerSource",
        "(qqsqinb(iq)ia(qn)aqa(in)a(qin)a(qin))",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceData,
_internalCallStatus,
deploy_sourceID, deploy_amError);
_sourceID = deploy_sourceID.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::registerSourceAsync(const ::v3::org::genivi::am_t::am_Source_s &_sourceData, RegisterSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Source_s, ::v3::org::genivi::am_t_::am_Source_sDeployment_t> deploy_sourceData(_sourceData, static_cast<::v3::org::genivi::am_t_::am_Source_sDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Source_s, ::v3::org::genivi::am_t_::am_Source_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "registerSource",
        "(qqsqinb(iq)ia(qn)aqa(in)a(qin)a(qin))",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceData,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> _sourceID, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _sourceID.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_sourceID, deploy_amError));
    }
    /**
     * description: Deregisters a source.
    (at)return E_OK on success, E_NON_EXISTENT if not found
     *   E_UNKNOWN on error
     */
    void RoutingControlObserverDBusProxy::deregisterSource(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "deregisterSource",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::deregisterSourceAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, DeregisterSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "deregisterSource",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: This function returns the ID to the given source name. If already a source is
     *   registered with this name, it will return the corresponding ID, if not it will
     *   reserve an ID but not register the source. The other parameters of the source
     *   will be overwritten when the source is registered.
    (at)return E_OK on success,
     *   E_UNKNOWN on error
     */
    void RoutingControlObserverDBusProxy::peekSource(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "peekSource",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_name,
_internalCallStatus,
deploy_sourceID, deploy_amError);
_sourceID = deploy_sourceID.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSourceAsync(const std::string &_name, PeekSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "peekSource",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_name,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> _sourceID, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _sourceID.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_sourceID, deploy_amError));
    }
    /**
     * description: Peeks a source class ID. It is used by the RoutingPlugins to determine the
     *   source class IDs of a source class.
    (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     */
    void RoutingControlObserverDBusProxy::peekSourceClassID(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sourceClass_t &_sourceClassID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceClass_t, CommonAPI::EmptyDeployment> deploy_sourceClassID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceClass_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "peekSourceClassID",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_name,
_internalCallStatus,
deploy_sourceClassID, deploy_amError);
_sourceClassID = deploy_sourceClassID.getValue();
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::peekSourceClassIDAsync(const std::string &_name, PeekSourceClassIDAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceClass_t, CommonAPI::EmptyDeployment> deploy_sourceClassID(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceClass_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "peekSourceClassID",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_name,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceClass_t, CommonAPI::EmptyDeployment> _sourceClassID, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _sourceClassID.getValue(), _amError.getValue());
        },
        std::make_tuple(deploy_sourceClassID, deploy_amError));
    }
    /**
     * description: Updates data of a source.
    (at)return E_OK on success, E_NON_EXISTENT if the
     *   source ID in the struct is not valid. 
    Please note that only the following
     *   data out of am_Source_s have effect when they are
     *   changed:
    sourceClassID,
    listSoundProperties,
    listConnectionFormats,
    listMainSou
     *  ndProperties
     */
    void RoutingControlObserverDBusProxy::updateSource(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sourceClass_t &_sourceClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceClass_t, CommonAPI::EmptyDeployment> deploy_sourceClassID(_sourceClassID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SoundProperty_L, ::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t> deploy_listSoundProperties(_listSoundProperties, static_cast<::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_ConnectionFormat_L, ::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t> deploy_listConnectionFormats(_listConnectionFormats, static_cast<::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t> deploy_listMainSoundProperties(_listMainSoundProperties, static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceClass_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SoundProperty_L, ::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_ConnectionFormat_L, ::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "updateSource",
        "qqa(qn)aqa(in)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID, deploy_sourceClassID, deploy_listSoundProperties, deploy_listConnectionFormats, deploy_listMainSoundProperties,
_internalCallStatus,
deploy_amError);
_amError = deploy_amError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::updateSourceAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sourceClass_t &_sourceClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, UpdateSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceClass_t, CommonAPI::EmptyDeployment> deploy_sourceClassID(_sourceClassID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_SoundProperty_L, ::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t> deploy_listSoundProperties(_listSoundProperties, static_cast<::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_ConnectionFormat_L, ::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t> deploy_listConnectionFormats(_listConnectionFormats, static_cast<::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t> deploy_listMainSoundProperties(_listMainSoundProperties, static_cast<::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_amError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceClass_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_SoundProperty_L, ::v3::org::genivi::am_t_::am_SoundProperty_LDeployment_t >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_ConnectionFormat_L, ::v3::org::genivi::am_t_::am_ConnectionFormat_LDeployment_t >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_MainSoundProperty_L, ::v3::org::genivi::am_t_::am_MainSoundProperty_LDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "updateSource",
        "qqa(qn)aqa(in)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID, deploy_sourceClassID, deploy_listSoundProperties, deploy_listConnectionFormats, deploy_listMainSoundProperties,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _amError) {
        	if (_callback)
        		_callback(_internalCallStatus, _amError.getValue());
        },
        std::make_tuple(deploy_amError));
    }
    /**
     * description: Is called when a low level interrupt changes it status.
     */
    void RoutingControlObserverDBusProxy::hookInterruptStatusChange(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_InterruptState_e &_interruptState, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_InterruptState_e, CommonAPI::EmptyDeployment> deploy_interruptState(_interruptState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_InterruptState_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "hookInterruptStatusChange",
        "qi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID, deploy_interruptState,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookInterruptStatusChangeAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_InterruptState_e &_interruptState, HookInterruptStatusChangeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_InterruptState_e, CommonAPI::EmptyDeployment> deploy_interruptState(_interruptState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_InterruptState_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "hookInterruptStatusChange",
        "qi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID, deploy_interruptState,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: This hook is called when all elements from a domain are registered.
    Is used by
     *   the Controller to know when all expected domains are finally registered.
     */
    void RoutingControlObserverDBusProxy::hookDomainRegistrationComplete(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> deploy_domainID(_domainID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "hookDomainRegistrationComplete",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_domainID,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookDomainRegistrationCompleteAsync(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, HookDomainRegistrationCompleteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> deploy_domainID(_domainID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "hookDomainRegistrationComplete",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_domainID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Is called when a sink changes its availability.
     */
    void RoutingControlObserverDBusProxy::hookSinkAvailablityStatusChange(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Availability_s, ::v3::org::genivi::am_t_::am_Availability_sDeployment_t> deploy_availability(_availability, static_cast<::v3::org::genivi::am_t_::am_Availability_sDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Availability_s, ::v3::org::genivi::am_t_::am_Availability_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "hookSinkAvailablityStatusChange",
        "q(iq)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sinkID, deploy_availability,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookSinkAvailablityStatusChangeAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, HookSinkAvailablityStatusChangeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment> deploy_sinkID(_sinkID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Availability_s, ::v3::org::genivi::am_t_::am_Availability_sDeployment_t> deploy_availability(_availability, static_cast<::v3::org::genivi::am_t_::am_Availability_sDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sinkID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Availability_s, ::v3::org::genivi::am_t_::am_Availability_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "hookSinkAvailablityStatusChange",
        "q(iq)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sinkID, deploy_availability,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Is called when a source changes its availability.
     */
    void RoutingControlObserverDBusProxy::hookSourceAvailablityStatusChange(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Availability_s, ::v3::org::genivi::am_t_::am_Availability_sDeployment_t> deploy_availability(_availability, static_cast<::v3::org::genivi::am_t_::am_Availability_sDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Availability_s, ::v3::org::genivi::am_t_::am_Availability_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "hookSourceAvailablityStatusChange",
        "q(iq)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID, deploy_availability,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookSourceAvailablityStatusChangeAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, HookSourceAvailablityStatusChangeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Availability_s, ::v3::org::genivi::am_t_::am_Availability_sDeployment_t> deploy_availability(_availability, static_cast<::v3::org::genivi::am_t_::am_Availability_sDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Availability_s, ::v3::org::genivi::am_t_::am_Availability_sDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "hookSourceAvailablityStatusChange",
        "q(iq)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID, deploy_availability,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Is called when a domain changes its status. This used for early domains only.
     */
    void RoutingControlObserverDBusProxy::hookDomainStateChange(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, const ::v3::org::genivi::am_t::am_DomainState_e &_domainState, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> deploy_domainID(_domainID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_DomainState_e, CommonAPI::EmptyDeployment> deploy_domainState(_domainState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_DomainState_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "hookDomainStateChange",
        "qi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_domainID, deploy_domainState,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::hookDomainStateChangeAsync(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, const ::v3::org::genivi::am_t::am_DomainState_e &_domainState, HookDomainStateChangeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment> deploy_domainID(_domainID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_DomainState_e, CommonAPI::EmptyDeployment> deploy_domainState(_domainState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_domainID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_DomainState_e, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "hookDomainStateChange",
        "qi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_domainID, deploy_domainState,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: This function is used to send out all data that has been changed in an early
     *   state.
     */
    void RoutingControlObserverDBusProxy::sendChangedData(const ::v3::org::genivi::am_t::am_EarlyData_L &_earlyData, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_EarlyData_L, ::v3::org::genivi::am_t_::am_EarlyData_LDeployment_t> deploy_earlyData(_earlyData, static_cast<::v3::org::genivi::am_t_::am_EarlyData_LDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_EarlyData_L, ::v3::org::genivi::am_t_::am_EarlyData_LDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "sendChangedData",
        "a(i(yv)(yv))",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_earlyData,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendChangedDataAsync(const ::v3::org::genivi::am_t::am_EarlyData_L &_earlyData, SendChangedDataAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_EarlyData_L, ::v3::org::genivi::am_t_::am_EarlyData_LDeployment_t> deploy_earlyData(_earlyData, static_cast<::v3::org::genivi::am_t_::am_EarlyData_LDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_EarlyData_L, ::v3::org::genivi::am_t_::am_EarlyData_LDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "sendChangedData",
        "a(i(yv)(yv))",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_earlyData,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: This function send parameters of limiter. If there is no error it will return
     *   0. If not it will return -1.
     */
    void RoutingControlObserverDBusProxy::sendLimiter(const ::v3::org::genivi::am_t::hq_limiterStruct_param &_limiter, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_hqError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_limiterStruct_param, ::v3::org::genivi::am_t_::hq_limiterStruct_paramDeployment_t> deploy_limiter(_limiter, static_cast<::v3::org::genivi::am_t_::hq_limiterStruct_paramDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_hqError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_limiterStruct_param, ::v3::org::genivi::am_t_::hq_limiterStruct_paramDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "sendLimiter",
        "(ya(ynydddd))",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_limiter,
_internalCallStatus,
deploy_hqError);
_hqError = deploy_hqError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendLimiterAsync(const ::v3::org::genivi::am_t::hq_limiterStruct_param &_limiter, SendLimiterAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_limiterStruct_param, ::v3::org::genivi::am_t_::hq_limiterStruct_paramDeployment_t> deploy_limiter(_limiter, static_cast<::v3::org::genivi::am_t_::hq_limiterStruct_paramDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_hqError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_limiterStruct_param, ::v3::org::genivi::am_t_::hq_limiterStruct_paramDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "sendLimiter",
        "(ya(ynydddd))",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_limiter,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _hqError) {
        	if (_callback)
        		_callback(_internalCallStatus, _hqError.getValue());
        },
        std::make_tuple(deploy_hqError));
    }
    /**
     * description: This function send parameters of EQ filter. If there is no error it will return
     *   0. If not it will return -1.
     */
    void RoutingControlObserverDBusProxy::sendEQFilter(const ::v3::org::genivi::am_t::hq_eqFilterStruct_param &_bsFilter, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_eqFilterStruct_param, ::v3::org::genivi::am_t_::hq_eqFilterStruct_paramDeployment_t> deploy_bsFilter(_bsFilter, static_cast<::v3::org::genivi::am_t_::hq_eqFilterStruct_paramDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_eqFilterStruct_param, ::v3::org::genivi::am_t_::hq_eqFilterStruct_paramDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "sendEQFilter",
        "(yyyya(yqndyy))",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_bsFilter,
_internalCallStatus,
deploy_qhError);
_qhError = deploy_qhError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendEQFilterAsync(const ::v3::org::genivi::am_t::hq_eqFilterStruct_param &_bsFilter, SendEQFilterAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_eqFilterStruct_param, ::v3::org::genivi::am_t_::hq_eqFilterStruct_paramDeployment_t> deploy_bsFilter(_bsFilter, static_cast<::v3::org::genivi::am_t_::hq_eqFilterStruct_paramDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_eqFilterStruct_param, ::v3::org::genivi::am_t_::hq_eqFilterStruct_paramDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "sendEQFilter",
        "(yyyya(yqndyy))",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_bsFilter,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _qhError) {
        	if (_callback)
        		_callback(_internalCallStatus, _qhError.getValue());
        },
        std::make_tuple(deploy_qhError));
    }
    /**
     * description: This function send parameters of delay time. If there is no error it will
     *   return 0. If not it will return -1.
     */
    void RoutingControlObserverDBusProxy::sendDelayTime(const ::v3::org::genivi::am_t::hq_delayTimeStruct_param &_delayTime, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_delayTimeStruct_param, ::v3::org::genivi::am_t_::hq_delayTimeStruct_paramDeployment_t> deploy_delayTime(_delayTime, static_cast<::v3::org::genivi::am_t_::hq_delayTimeStruct_paramDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_delayTimeStruct_param, ::v3::org::genivi::am_t_::hq_delayTimeStruct_paramDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "sendDelayTime",
        "(ya(yd))",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_delayTime,
_internalCallStatus,
deploy_qhError);
_qhError = deploy_qhError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendDelayTimeAsync(const ::v3::org::genivi::am_t::hq_delayTimeStruct_param &_delayTime, SendDelayTimeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_delayTimeStruct_param, ::v3::org::genivi::am_t_::hq_delayTimeStruct_paramDeployment_t> deploy_delayTime(_delayTime, static_cast<::v3::org::genivi::am_t_::hq_delayTimeStruct_paramDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_delayTimeStruct_param, ::v3::org::genivi::am_t_::hq_delayTimeStruct_paramDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "sendDelayTime",
        "(ya(yd))",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_delayTime,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _qhError) {
        	if (_callback)
        		_callback(_internalCallStatus, _qhError.getValue());
        },
        std::make_tuple(deploy_qhError));
    }
    /**
     * description: This function send parameters of loudness. If there is no error it will return
     *   0. If not it will return -1.
     */
    void RoutingControlObserverDBusProxy::sendLoudness(const ::v3::org::genivi::am_t::hq_londnessStruct_param &_bs, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_londnessStruct_param, ::v3::org::genivi::am_t_::hq_londnessStruct_paramDeployment_t> deploy_bs(_bs, static_cast<::v3::org::genivi::am_t_::hq_londnessStruct_paramDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_londnessStruct_param, ::v3::org::genivi::am_t_::hq_londnessStruct_paramDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "sendLoudness",
        "(yyqqddyyya(nnnn))",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_bs,
_internalCallStatus,
deploy_qhError);
_qhError = deploy_qhError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendLoudnessAsync(const ::v3::org::genivi::am_t::hq_londnessStruct_param &_bs, SendLoudnessAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_londnessStruct_param, ::v3::org::genivi::am_t_::hq_londnessStruct_paramDeployment_t> deploy_bs(_bs, static_cast<::v3::org::genivi::am_t_::hq_londnessStruct_paramDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_londnessStruct_param, ::v3::org::genivi::am_t_::hq_londnessStruct_paramDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "sendLoudness",
        "(yyqqddyyya(nnnn))",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_bs,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _qhError) {
        	if (_callback)
        		_callback(_internalCallStatus, _qhError.getValue());
        },
        std::make_tuple(deploy_qhError));
    }
    /**
     * description: This function send parameters of channel gain. If there is no error it will
     *   return 0. If not it will return -1.
     */
    void RoutingControlObserverDBusProxy::sendChannelGain(const ::v3::org::genivi::am_t::hq_channelGainStruct_param &_bs, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_channelGainStruct_param, ::v3::org::genivi::am_t_::hq_channelGainStruct_paramDeployment_t> deploy_bs(_bs, static_cast<::v3::org::genivi::am_t_::hq_channelGainStruct_paramDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_channelGainStruct_param, ::v3::org::genivi::am_t_::hq_channelGainStruct_paramDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "sendChannelGain",
        "(yya(yny))",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_bs,
_internalCallStatus,
deploy_qhError);
_qhError = deploy_qhError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendChannelGainAsync(const ::v3::org::genivi::am_t::hq_channelGainStruct_param &_bs, SendChannelGainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_channelGainStruct_param, ::v3::org::genivi::am_t_::hq_channelGainStruct_paramDeployment_t> deploy_bs(_bs, static_cast<::v3::org::genivi::am_t_::hq_channelGainStruct_paramDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_channelGainStruct_param, ::v3::org::genivi::am_t_::hq_channelGainStruct_paramDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "sendChannelGain",
        "(yya(yny))",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_bs,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _qhError) {
        	if (_callback)
        		_callback(_internalCallStatus, _qhError.getValue());
        },
        std::make_tuple(deploy_qhError));
    }
    /**
     * description: This function send parameters of maximum volume of source. If there is no error
     *   it will return 0. If not it will return -1.
     */
    void RoutingControlObserverDBusProxy::sendVolumeMax(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "sendVolumeMax",
        "qn",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID, deploy_volume,
_internalCallStatus,
deploy_qhError);
_qhError = deploy_qhError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendVolumeMaxAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeMaxAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "sendVolumeMax",
        "qn",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID, deploy_volume,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _qhError) {
        	if (_callback)
        		_callback(_internalCallStatus, _qhError.getValue());
        },
        std::make_tuple(deploy_qhError));
    }
    /**
     * description: This function send parameters of minimum volume of source. If there is no error
     *   it will return 0. If not it will return -1.
     */
    void RoutingControlObserverDBusProxy::sendVolumeMin(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "sendVolumeMin",
        "qn",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID, deploy_volume,
_internalCallStatus,
deploy_qhError);
_qhError = deploy_qhError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendVolumeMinAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeMinAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "sendVolumeMin",
        "qn",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID, deploy_volume,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _qhError) {
        	if (_callback)
        		_callback(_internalCallStatus, _qhError.getValue());
        },
        std::make_tuple(deploy_qhError));
    }
    /**
     * description: This function send parameters of absolute volume of source. If there is no
     *   error it will return 0. If not it will return -1.
     */
    void RoutingControlObserverDBusProxy::sendVolumeAbs(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "sendVolumeAbs",
        "qn",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID, deploy_volume,
_internalCallStatus,
deploy_qhError);
_qhError = deploy_qhError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendVolumeAbsAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeAbsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "sendVolumeAbs",
        "qn",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID, deploy_volume,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _qhError) {
        	if (_callback)
        		_callback(_internalCallStatus, _qhError.getValue());
        },
        std::make_tuple(deploy_qhError));
    }
    /**
     * description: This function send parameters of ratio volume of source. If there is no error
     *   it will return 0. If not it will return -1.
     */
    void RoutingControlObserverDBusProxy::sendVolumeRatio(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "sendVolumeRatio",
        "qn",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceID, deploy_volume,
_internalCallStatus,
deploy_qhError);
_qhError = deploy_qhError.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingControlObserverDBusProxy::sendVolumeRatioAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeRatioAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment> deploy_sourceID(_sourceID, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> deploy_qhError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_sourceID_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::org::genivi::am_t::hq_volume_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "sendVolumeRatio",
        "qn",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceID, deploy_volume,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::org::genivi::am_t::am_Error_e, CommonAPI::EmptyDeployment> _qhError) {
        	if (_callback)
        		_callback(_internalCallStatus, _qhError.getValue());
        },
        std::make_tuple(deploy_qhError));
    }


void RoutingControlObserverDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 3;
          ownVersionMinor = 5;
      }

      } // namespace routinginterface
      } // namespace am
      } // namespace genivi
      } // namespace org
      } // namespace v3
