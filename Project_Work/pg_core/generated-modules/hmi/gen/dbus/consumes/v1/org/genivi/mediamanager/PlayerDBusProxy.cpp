/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
#include <v1/org/genivi/mediamanager/PlayerDBusProxy.hpp>

namespace v1 {
namespace org {
namespace genivi {
namespace mediamanager {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createPlayerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<PlayerDBusProxy>(_address, _connection);
}

INITIALIZER(registerPlayerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		Player::getInterface(),
		&createPlayerDBusProxy);
}

PlayerDBusProxy::PlayerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		mute_(*this, "onMuteAttributeChanged", "setMuteAttribute", "i", "getMuteAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		shuffle_(*this, "onShuffleAttributeChanged", "setShuffleAttribute", "i", "getShuffleAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		repeat_(*this, "onRepeatAttributeChanged", "setRepeatAttribute", "i", "getRepeatAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		rate_(*this, "onRateAttributeChanged", "setRateAttribute", "d", "getRateAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		volume_(*this, "onVolumeAttributeChanged", "setVolumeAttribute", "d", "getVolumeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canGoNext_(*this, "onCanGoNextAttributeChanged", "b", "getCanGoNextAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canGoPrevious_(*this, "onCanGoPreviousAttributeChanged", "b", "getCanGoPreviousAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canPause_(*this, "onCanPauseAttributeChanged", "b", "getCanPauseAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canPlay_(*this, "onCanPlayAttributeChanged", "b", "getCanPlayAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canSeek_(*this, "onCanSeekAttributeChanged", "b", "getCanSeekAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		currentTrack_(*this, "onCurrentTrackAttributeChanged", "t", "getCurrentTrackAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		playbackStatus_(*this, "onPlaybackStatusAttributeChanged", "i", "getPlaybackStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		position_(*this, "onPositionAttributeChanged", "t", "getPositionAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		duration_(*this, "onDurationAttributeChanged", "t", "getDurationAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		videoPlayStatus_(*this, "onVideoPlayStatusAttributeChanged", "b", "getVideoPlayStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		metadata_(*this, "onMetadataAttributeChanged", "a{s(yv)}", "getMetadataAttribute", static_cast<::v1::org::genivi::mediamanager::MediaTypes_::ResultMapDeployment_t*>(nullptr))
{
}

      PlayerDBusProxy::MuteAttribute& PlayerDBusProxy::getMuteAttribute() {
          return mute_;
      }
      PlayerDBusProxy::ShuffleAttribute& PlayerDBusProxy::getShuffleAttribute() {
          return shuffle_;
      }
      PlayerDBusProxy::RepeatAttribute& PlayerDBusProxy::getRepeatAttribute() {
          return repeat_;
      }
      PlayerDBusProxy::RateAttribute& PlayerDBusProxy::getRateAttribute() {
          return rate_;
      }
      PlayerDBusProxy::VolumeAttribute& PlayerDBusProxy::getVolumeAttribute() {
          return volume_;
      }
      PlayerDBusProxy::CanGoNextAttribute& PlayerDBusProxy::getCanGoNextAttribute() {
          return canGoNext_;
      }
      PlayerDBusProxy::CanGoPreviousAttribute& PlayerDBusProxy::getCanGoPreviousAttribute() {
          return canGoPrevious_;
      }
      PlayerDBusProxy::CanPauseAttribute& PlayerDBusProxy::getCanPauseAttribute() {
          return canPause_;
      }
      PlayerDBusProxy::CanPlayAttribute& PlayerDBusProxy::getCanPlayAttribute() {
          return canPlay_;
      }
      PlayerDBusProxy::CanSeekAttribute& PlayerDBusProxy::getCanSeekAttribute() {
          return canSeek_;
      }
      PlayerDBusProxy::CurrentTrackAttribute& PlayerDBusProxy::getCurrentTrackAttribute() {
          return currentTrack_;
      }
      PlayerDBusProxy::PlaybackStatusAttribute& PlayerDBusProxy::getPlaybackStatusAttribute() {
          return playbackStatus_;
      }
      PlayerDBusProxy::PositionAttribute& PlayerDBusProxy::getPositionAttribute() {
          return position_;
      }
      PlayerDBusProxy::DurationAttribute& PlayerDBusProxy::getDurationAttribute() {
          return duration_;
      }
      PlayerDBusProxy::VideoPlayStatusAttribute& PlayerDBusProxy::getVideoPlayStatusAttribute() {
          return videoPlayStatus_;
      }
      PlayerDBusProxy::MetadataAttribute& PlayerDBusProxy::getMetadataAttribute() {
          return metadata_;
      }

    
    /**
     * description: Skip to the next track in the play queue. If there is no
                          
     *   next track, playback is stopped. If playback is paused or
                        
     *     stopped, this function will set the next plack to be
                          
     *   played once playback is activated
     */
    void PlayerDBusProxy::next(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "next",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::nextAsync(NextAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "next",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Open the supplied Uri for playback in the playback engine.
             returns:
     *   INVALID_URI When an invalid URI is supplied
                                  
     *   (decided by playback engine)
                       NO_ERROR    On success
     * param: uri URI of media to play, uri format is decided by backend
     */
    void PlayerDBusProxy::openUri(const std::string &_uri, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "openUri",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_uri,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::openUriAsync(const std::string &_uri, OpenUriAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "openUri",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_uri,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Enqueue the supplied Uri for playback in the playback engine.
             returns:
     *   INVALID_URI When an invalid URI is supplied
                                  
     *   (decided by playback engine)
                      NO_ERROR    On success
     * param: uri URI of media to enqueue, uri format is decided by backend
     */
    void PlayerDBusProxy::enqueueUri(const std::string &_uri, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "enqueueUri",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_uri,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::enqueueUriAsync(const std::string &_uri, EnqueueUriAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "enqueueUri",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_uri,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Dequeue the item with the supplied index in the playback
                         
     *   engine.
     * param: pos index of media to dequeue
     */
    void PlayerDBusProxy::dequeueIndex(const uint64_t &_pos, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "dequeueIndex",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_pos,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::dequeueIndexAsync(const uint64_t &_pos, DequeueIndexAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "dequeueIndex",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_pos,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Retrieve the current play queue. The format of the result
                         
     *   object is described in MediaTypes.fidl
             returns: Current play queue
     */
    void PlayerDBusProxy::getCurrentPlayQueue(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::MediaTypes::ResultMapList &_playQueue, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> deploy_playQueue(static_cast<::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList,::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t>,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getCurrentPlayQueue",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_playQueue, deploy_e);
_playQueue = deploy_playQueue.getValue();
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::getCurrentPlayQueueAsync(GetCurrentPlayQueueAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> deploy_playQueue(static_cast<::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList,::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t>,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getCurrentPlayQueue",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> _playQueue, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _playQueue.getValue(), _e.getValue());
        },
        std::make_tuple(deploy_playQueue, deploy_e));
    }
    /**
     * description: Dequeue all elements, emptying the play queue
     */
    void PlayerDBusProxy::dequeueAll(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "dequeueAll",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::dequeueAllAsync(DequeueAllAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "dequeueAll",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Use the supplied playlist as the current play queue. If
                         
     *   the play queue is invalid, the old play queue is
                         
     *   untouched.
             returns: BAD_PLAYLIST If playlist can not be loaded
          
     *               NO_ERROR     On success
     */
    void PlayerDBusProxy::openPlaylist(const std::string &_uri, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "openPlaylist",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_uri,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::openPlaylistAsync(const std::string &_uri, OpenPlaylistAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "openPlaylist",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_uri,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Pause playback in the playback engine.
                           If already
     *   paused, this has no effect
                           Note: If CanPause is false,
     *   this has no effect
     */
    void PlayerDBusProxy::pause(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "pause",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::pauseAsync(PauseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "pause",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Start or resume playback in the playback engine.
                           If
     *   playback is already commencing, this has not effect.
                           If
     *   paused, playback resumes from the current position.
                           If
     *   there is no track to play, calling this has no effect
                          
     *   Note: If CanPlay is false, this has no effect
     */
    void PlayerDBusProxy::play(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "play",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::playAsync(PlayAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "play",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Starts playback (see Play) if paused
                          Pauses playback (see
     *   Pause) is playing
     * see: Play
     * see: Pause
     */
    void PlayerDBusProxy::playPause(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "playPause",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::playPauseAsync(PlayPauseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "playPause",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Loads previous track in play queue
                          If there is no
     *   previous track, playback is stopped
                          If playback is
     *   stopped or paused, it remains this way,
                          but the next
     *   track to be played will the set
                          by this function
           
     *                 Note: If CanGoPrevious is false, this has no effect
     */
    void PlayerDBusProxy::previous(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "previous",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::previousAsync(PreviousAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "previous",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Seek relatively in the current track
                          If a negative seek
     *   leads to a play position less than 0,
                          the play position
     *   will be set to 0.
                          If a positive seek leads outside the
     *   length of the current
                          track, this is treated like a call
     *   to Next()
                          Note: If CanSeek is false, this has no effect
     * param: pos Relative seek amount in microseconds
     * see: Next
     */
    void PlayerDBusProxy::seek(const int64_t &_pos, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "seek",
        "x",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_pos,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::seekAsync(const int64_t &_pos, SeekAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "seek",
        "x",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_pos,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Jump to the specified position in the current
                           If the
     *   position is not within range of the current track,
                           do
     *   nothing
             Note: If CanSeek is false, this has no effect
     * param: pos Absolute position in microseconds
     */
    void PlayerDBusProxy::setPosition(const uint64_t &_pos, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setPosition",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_pos,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::setPositionAsync(const uint64_t &_pos, SetPositionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setPosition",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_pos,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }


void PlayerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace mediamanager
      } // namespace genivi
      } // namespace org
      } // namespace v1
