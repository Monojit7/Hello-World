/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * author: Rico Schuster
 * description: Configuration baed interface to get the current configuration settings. This
 *   interface provides
    only getter methods.
 */
#include <v1/org/harman/nav/ctrl/configuration/ConfigurationBaseDBusProxy.hpp>

namespace v1 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace configuration {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createConfigurationBaseDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<ConfigurationBaseDBusProxy>(_address, _connection);
}

INITIALIZER(registerConfigurationBaseDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		ConfigurationBase::getInterface(),
		&createConfigurationBaseDBusProxy);
}

ConfigurationBaseDBusProxy::ConfigurationBaseDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		configurationChanges_(*this, "configurationChanges", "ai", std::make_tuple(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::SettingsDeployment_t*>(nullptr)))
{
}


ConfigurationBaseDBusProxy::ConfigurationChangesEvent& ConfigurationBaseDBusProxy::getConfigurationChangesEvent() {
    return configurationChanges_;
}
    
    /**
     * description: Methode for getting version.
     */
    void ConfigurationBaseDBusProxy::getNavigationVersion(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion &_navigationVersion, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t> deploy_navigationVersion(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getNavigationVersion",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_navigationVersion);
_error = deploy_error.getValue();
_navigationVersion = deploy_navigationVersion.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationBaseDBusProxy::getNavigationVersionAsync(GetNavigationVersionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t> deploy_navigationVersion(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getNavigationVersion",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t> _navigationVersion) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _navigationVersion.getValue());
        },
        std::make_tuple(deploy_error, deploy_navigationVersion));
    }
    /**
     * description: Methode for getting supported units of measurements.
     */
    void ConfigurationBaseDBusProxy::getSupportedUnitsOfMeasurement(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement &_unitsOfMeasurement, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> deploy_unitsOfMeasurement(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedUnitsOfMeasurement",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_unitsOfMeasurement);
_error = deploy_error.getValue();
_unitsOfMeasurement = deploy_unitsOfMeasurement.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationBaseDBusProxy::getSupportedUnitsOfMeasurementAsync(GetSupportedUnitsOfMeasurementAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> deploy_unitsOfMeasurement(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedUnitsOfMeasurement",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> _unitsOfMeasurement) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _unitsOfMeasurement.getValue());
        },
        std::make_tuple(deploy_error, deploy_unitsOfMeasurement));
    }
    /**
     * description: Methode for getting units of measurements.
     */
    void ConfigurationBaseDBusProxy::getUnitsOfMeasurement(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement &_unitsOfMeasurement, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> deploy_unitsOfMeasurement(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getUnitsOfMeasurement",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_unitsOfMeasurement);
_error = deploy_error.getValue();
_unitsOfMeasurement = deploy_unitsOfMeasurement.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationBaseDBusProxy::getUnitsOfMeasurementAsync(GetUnitsOfMeasurementAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> deploy_unitsOfMeasurement(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getUnitsOfMeasurement",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> _unitsOfMeasurement) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _unitsOfMeasurement.getValue());
        },
        std::make_tuple(deploy_error, deploy_unitsOfMeasurement));
    }
    /**
     * description: Methode for getting time format.
     */
    void ConfigurationBaseDBusProxy::getTimeFormat(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat &_timeFormat, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat, CommonAPI::EmptyDeployment> deploy_timeFormat(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getTimeFormat",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_timeFormat);
_error = deploy_error.getValue();
_timeFormat = deploy_timeFormat.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationBaseDBusProxy::getTimeFormatAsync(GetTimeFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat, CommonAPI::EmptyDeployment> deploy_timeFormat(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getTimeFormat",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat, CommonAPI::EmptyDeployment> _timeFormat) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _timeFormat.getValue());
        },
        std::make_tuple(deploy_error, deploy_timeFormat));
    }
    /**
     * description: Methode for getting coordinates format.
     */
    void ConfigurationBaseDBusProxy::getCoordinatesFormat(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat &_coordinatesFormat, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat, CommonAPI::EmptyDeployment> deploy_coordinatesFormat(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getCoordinatesFormat",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_coordinatesFormat);
_error = deploy_error.getValue();
_coordinatesFormat = deploy_coordinatesFormat.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationBaseDBusProxy::getCoordinatesFormatAsync(GetCoordinatesFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat, CommonAPI::EmptyDeployment> deploy_coordinatesFormat(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getCoordinatesFormat",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat, CommonAPI::EmptyDeployment> _coordinatesFormat) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _coordinatesFormat.getValue());
        },
        std::make_tuple(deploy_error, deploy_coordinatesFormat));
    }
    /**
     * description: Methode for getting supported coordinates format.
     */
    void ConfigurationBaseDBusProxy::getSupportedCoordinatesFormats(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats &_coordinatesFormats, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t> deploy_coordinatesFormats(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedCoordinatesFormats",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_coordinatesFormats);
_error = deploy_error.getValue();
_coordinatesFormats = deploy_coordinatesFormats.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationBaseDBusProxy::getSupportedCoordinatesFormatsAsync(GetSupportedCoordinatesFormatsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t> deploy_coordinatesFormats(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedCoordinatesFormats",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t> _coordinatesFormats) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _coordinatesFormats.getValue());
        },
        std::make_tuple(deploy_error, deploy_coordinatesFormats));
    }
    /**
     * description: Methode for getting locale.
     */
    void ConfigurationBaseDBusProxy::getLocale(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale &_locale, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t> deploy_locale(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getLocale",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_locale);
_error = deploy_error.getValue();
_locale = deploy_locale.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationBaseDBusProxy::getLocaleAsync(GetLocaleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t> deploy_locale(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getLocale",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t> _locale) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _locale.getValue());
        },
        std::make_tuple(deploy_error, deploy_locale));
    }
    /**
     * description: Methode for getting supported locales.
     */
    void ConfigurationBaseDBusProxy::getSupportedLocales(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales &_locales, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t> deploy_locales(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedLocales",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_locales);
_error = deploy_error.getValue();
_locales = deploy_locales.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationBaseDBusProxy::getSupportedLocalesAsync(GetSupportedLocalesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t> deploy_locales(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedLocales",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t> _locales) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _locales.getValue());
        },
        std::make_tuple(deploy_error, deploy_locales));
    }
    /**
     * description: Methode for getting style theme.
     */
    void ConfigurationBaseDBusProxy::getStyleTheme(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetStyleThemeError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme &_style, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetStyleThemeError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme, CommonAPI::EmptyDeployment> deploy_style(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetStyleThemeError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getStyleTheme",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_style);
_error = deploy_error.getValue();
_style = deploy_style.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationBaseDBusProxy::getStyleThemeAsync(GetStyleThemeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetStyleThemeError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme, CommonAPI::EmptyDeployment> deploy_style(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetStyleThemeError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getStyleTheme",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetStyleThemeError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme, CommonAPI::EmptyDeployment> _style) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _style.getValue());
        },
        std::make_tuple(deploy_error, deploy_style));
    }


void ConfigurationBaseDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace configuration
      } // namespace ctrl
      } // namespace nav
      } // namespace harman
      } // namespace org
      } // namespace v1
