/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: ListViewBase = This interface offers functions that implement a basic list
 *   concept 
    The basic idea of this inteface is the following:
    A client
 *   registers a view with a certain size n on a list with a dynamic size m. Please
 *   note: during 
    initial call, a view might be bigger than the underlying
 *   list. 
    The client uses index - so called ListTypes.ListKey to position the
 *   first element of a view to a certain
    element in the list. Please note: the
 *   ListKey value must be in a valid range between first (0) and last (m)
 *   element.
    Furthermore the client specifies it's anchor point. An anchor is
 *   more or less the stable entry in a view which - 
    even in case of a
 *   listupdate - stays at a permanent position in the view. It is used to
 *   guarantee a stable view
    in case of list changes (sorting changed,
 *   inserts/deletes) and furthermore allow a client to realize a smooth
   
 *   scrolling - if necessary. For better understanding see the following example:
 *   
    There is a list of 30 elements and a view with a total of 4 entries. The
 *   view is positioned at entry 21, which 
    means the view shows the entries
 *   [21, 22, 23, 24]. The client specifies the anchor on 22. Now imagine an update
 *   
    occurs (e.g. a new entry will get inserted between 17 and 18). The
 *   clients get notified by a broadcast that the
    ListTypes.ListKey of his
 *   anchor is now 23 (because the entry 22 is moved on index 23). 
    
    While
 *   the base list specifies how to navitation and create a view on a given list,
 *   the concrete implementation of 
    a list is responsible for providing the
 *   data of a view. This must be realized in the following manner: each
   
 *   concrete implementation must provide a getView() function which returns the
 *   entries of a current view, the absolute
    key/index of the view and the
 *   relative anchor position based on the view position. The provider
    of the
 *   list is responsible for providing always the correct elements of a list based
 *   on the anchor, the client
    has specified. 
    
    Special case handling:
 *   in some cases it might happen, that the specified anchor point get's removed
 *   from the list
    and therefore from the view. In this case the list
 *   implementation will behave like the following: If possible,
    the anchor
 *   will be replaced by the provider with the next element (successor) in the
 *   list. If this is not possible
    (anchor already pointed to the last element
 *   in list), the previous element (predecessor) is selected as new anchor.
   
 *   Anyway - the impact of an update on the anchor will be indicated by
 *   appropriate enum.
 */
#include <v1/org/harman/nav/ctrl/common/list/ListViewBaseDBusProxy.hpp>

namespace v1 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace common {
namespace list {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createListViewBaseDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<ListViewBaseDBusProxy>(_address, _connection);
}

INITIALIZER(registerListViewBaseDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		ListViewBase::getInterface(),
		&createListViewBaseDBusProxy);
}

ListViewBaseDBusProxy::ListViewBaseDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		viewUpdate_(*this, "viewUpdate", "qqbb", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		listSize_(*this, "listSize", "(s)q", std::make_tuple(static_cast<::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)))
{
}


ListViewBaseDBusProxy::ViewUpdateEvent& ListViewBaseDBusProxy::getViewUpdateEvent() {
    return viewUpdate_;
}
ListViewBaseDBusProxy::ListSizeEvent& ListViewBaseDBusProxy::getListSizeEvent() {
    return listSize_;
}
    
    /**
     * description: get the current number of contained elements in the given list.
     */
    void ListViewBaseDBusProxy::getListSize(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, ::org::harman::nav::ctrl::common::list::ListTypes::ListSize &_size, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListId, ::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t> deploy_list(_list, static_cast<::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListSize, CommonAPI::EmptyDeployment> deploy_size(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListId, ::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListSize,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getListSize",
        "(s)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_list,
_internalCallStatus,
deploy_error,
deploy_size);
_error = deploy_error.getValue();
_size = deploy_size.getValue();
}
    std::future<CommonAPI::CallStatus> ListViewBaseDBusProxy::getListSizeAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, GetListSizeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListId, ::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t> deploy_list(_list, static_cast<::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListSize, CommonAPI::EmptyDeployment> deploy_size(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListId, ::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListSize,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getListSize",
        "(s)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_list,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListSize, CommonAPI::EmptyDeployment> _size) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _size.getValue());
        },
        std::make_tuple(deploy_error, deploy_size));
    }
    /**
     * description: create a new view to the mother array. 
            This view will be maintained
     *   until the client uses destroyView, 
            unsubscribes or service/proxy
     *   exit. 
            After creating a view the client must receive an update.
          
     *    Only one created view is allowed to modify the list entries.
            Please
     *   note: a valid usecase is to specify a viewSize which is 
            bigger than
     *   the inital list size
     */
    void ListViewBaseDBusProxy::createView(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_viewsize, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListId, ::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t> deploy_list(_list, static_cast<::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewSize, CommonAPI::EmptyDeployment> deploy_viewsize(_viewsize, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment> deploy_view(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListId, ::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t >,
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewSize, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "createView",
        "(s)q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_list, deploy_viewsize,
_internalCallStatus,
deploy_error,
deploy_view);
_error = deploy_error.getValue();
_view = deploy_view.getValue();
}
    std::future<CommonAPI::CallStatus> ListViewBaseDBusProxy::createViewAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_viewsize, CreateViewAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListId, ::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t> deploy_list(_list, static_cast<::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewSize, CommonAPI::EmptyDeployment> deploy_viewsize(_viewsize, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment> deploy_view(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListId, ::org::harman::nav::ctrl::common::list::ListTypes_::ListIdDeployment_t >,
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewSize, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "createView",
        "(s)q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_list, deploy_viewsize,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment> _view) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _view.getValue());
        },
        std::make_tuple(deploy_error, deploy_view));
    }
    /**
     * description: delete the given view instance
     */
    void ListViewBaseDBusProxy::deleteView(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment> deploy_view(_view, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "deleteView",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_view,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> ListViewBaseDBusProxy::deleteViewAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, DeleteViewAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment> deploy_view(_view, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "deleteView",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_view,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: adjust the view size. It is allowed to set view size to a larger value
           
     *   than the actual size of the list, but less or equal than the maximum size of
     *   the list. 
            The implementation may limit the maximum view size for
     *   resource reasons. 
            After adjusting the window size the client must
     *   receive an update.
     */
    void ListViewBaseDBusProxy::setViewSize(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_new_size, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment> deploy_view(_view, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewSize, CommonAPI::EmptyDeployment> deploy_new_size(_new_size, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewSize, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setViewSize",
        "qq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_view, deploy_new_size,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> ListViewBaseDBusProxy::setViewSizeAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_new_size, SetViewSizeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment> deploy_view(_view, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewSize, CommonAPI::EmptyDeployment> deploy_new_size(_new_size, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewSize, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setViewSize",
        "qq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_view, deploy_new_size,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: set the absolute view position to element key. 
            The client should use
     *   an available snapshot of a view to maintain focused elements 
            within
     *   the view if possible, and change the view position only if an 
            element
     *   to be focused is outside of the given view. A snapshot is generated whenever
     
     *         querying the data contained in a view. Together with that data, the
     *   ViewSnapshotPosition is provided.
            The initial snapshot of the view is
     *   always [0, min(viewSize-1, listSize-1)].
            When creating a new view
     *   snapshot, the last call of setViewPosition or setViewAnchor (whichever was the
     *   last one)
            will be the relevant information to reposition the new view
     *   snapshot. If setViewPosition was the last call,
            the view is moved such
     *   that the provided key refers to the absolute position on the current snapshot
     *   of the view.
            (This becomes important if the current view snapshot is
     *   outdated because the list has been updated.)
    
            The following rules are
     *   applied to set the position of the new view snapshot [newFrom, newTo], given a
     *   snapshot [from, to]:
            Let elem(k) denote the element at key k in the
     *   old snapshot and new(e) denote the key the element e will have 
            (would
     *   have if deleted) in the new snapshot (see also examples (1)-(3) below).
          
     *    (1) If key is less than from, then newFrom will be set to new(elem(from)) -
     *   (from-key).
            (2) If key is contained in [from, to], then newKey will be
     *   set to new(elem(key)).
            (3) If key is greater than to, then newFrom
     *   will be set to new(elem(to)) + (key-to).
            If any of these calculated
     *   values are out of the range of the list [0, listSize-1], they will be
     *   truncated to fit into the list.
            (Note that the resulting newFrom is
     *   always equal to key if the data wasn't updated, 
            but it doesn't have
     *   to be equal to key if the data was updated.)
            After setting the view
     *   position the anchor offset will automatically be set to 0.
            There are
     *   two special key values to allow scrolling to the top/bottom of the list,
     *   independently from the above rules:
            The key value 0xFFFE always
     *   positions the view to the top of the list.
            The key value 0xFFFF always
     *   positions the view to the bottom of the list.
    
            As an example for the
     *   case in which the data was updated:
            old list {"a", "b", "c", "d", "e",
     *   "f"} with view snapshot ["c", "d"] with viewSize 2 and viewKey 2
            new
     *   list {"b", "d", "f", "h", "j", "l"}
            (1) setViewPosition(0) => [from,
     *   to] is [2, 3], elem(from) is "c", new(elem(from)) is 1
                           
     *          => ["b", "d"] with ViewSnapshotPosition {listSize=6, listKey=0,
     *   anchorOffset=0}.
            (2) setViewPosition(3) => [from, to] is [2, 3],
     *   elem(key) is "d", new(elem(key)) is 1
                                   => ["d",
     *   "f"] with ViewSnapshotPosition {listSize=6, listKey=1, anchorOffset=0}.
          
     *    (3) setViewPosition(4) => [from, to] is [2, 3], elem(to) is "d", new(elem(d))
     *   is 1
                                   => ["f", "h"] with ViewSnapshotPosition
     *   {listSize=6, listKey=2, anchorOffset=0}.
     */
    void ListViewBaseDBusProxy::setViewPosition(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ListKey &_key, CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment> deploy_view(_view, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListKey, CommonAPI::EmptyDeployment> deploy_key(_key, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ListKey, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "setViewPosition",
        "qq",
deploy_view, deploy_key,
_internalCallStatus);
}
    /**
     * description: set a stable element inside the current view snapshot.
            The client
     *   should use an available snapshot of a view to maintain focused elements 
         
     *     within the view if possible, and change the view position only if an 
          
     *    element to be focused is outside of the given view. A snapshot is generated
     *   whenever
            querying the data contained in a view. Together with that
     *   data, the ViewSnapshotPosition is provided.
            The initial snapshot of
     *   the view is always [0, min(viewSize-1, listSize-1)] with anchor offset 0.
        
     *      When creating a new view snapshot, the last call of setViewPosition or
     *   setViewAnchor (whichever was the last one)
            will be the relevant
     *   information to reposition the new view snapshot. If setViewAnchor was the last
     *   call,
            the anchor element of the old view snapshot is used for
     *   repositioning.
            (This method only needs to be used if the current view
     *   snapshot is outdated because the list has been updated.)
    
            The
     *   following rules are applied to set the position of the new view snapshot
     *   [newFrom, newTo], given a snapshot [from, to]
            and anchor offset aOff:
    
     *          Let elem(k) denote the element at key k in the old snapshot and new(e)
     *   denote the key the element e will have 
            (would have if deleted) in the
     *   new snapshot (see also examples below).
            newFrom is set to
     *   new(elem(from+aOff)) - aOff.
            If any of these calculated values are out
     *   of the range of the list [0, listSize-1], they will be truncated to fit into
     *   the list.
            As a consequence, whenever possible, the anchor element of
     *   the old snapshot will be at the same offset within the new snapshot.
    
           
     *   As an example for the case in which the data was updated:
            old list
     *   {"a", "b", "c", "d", "e", "f"} with view snapshot ["c", "d"] with viewSize 2
     *   and viewKey 2
            new list {"b", "d", "f", "h", "j", "l"}
           
     *   setViewAnchor(0) => elem(from+aOff) is "c", new(elem(from+aOff)) is 1 ("c"
     *   would be inserted at index 1)
                             => ["d", "f"] with
     *   ViewSnapshotPosition {listSize=6, listKey=1, anchorOffset=0}.
           
     *   setViewAnchor(1) => elem(from+aOff) is "d", new(elem(from+aOff)) is 1
            
     *                   => ["b", "d"] with ViewSnapshotPosition {listSize=6,
     *   listKey=0, anchorOffset=1}.
     */
    void ListViewBaseDBusProxy::setViewAnchor(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::AnchorOffset &_anchor, CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment> deploy_view(_view, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::AnchorOffset, CommonAPI::EmptyDeployment> deploy_anchor(_anchor, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::ViewId, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::org::harman::nav::ctrl::common::list::ListTypes::AnchorOffset, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "setViewAnchor",
        "qq",
deploy_view, deploy_anchor,
_internalCallStatus);
}


void ListViewBaseDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace list
      } // namespace common
      } // namespace ctrl
      } // namespace nav
      } // namespace harman
      } // namespace org
      } // namespace v1
