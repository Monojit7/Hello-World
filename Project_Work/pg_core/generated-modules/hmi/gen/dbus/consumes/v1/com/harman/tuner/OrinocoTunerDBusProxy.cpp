/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: Orinoco specific tuner interface. This interface is a facade to a bunch of
 *   plattform interfaces in order to provide a simplified access to tuner data and
 *   functionality.
 * author: Dirk Engel
 */
#include <v1/com/harman/tuner/OrinocoTunerDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace tuner {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createOrinocoTunerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<OrinocoTunerDBusProxy>(_address, _connection);
}

INITIALIZER(registerOrinocoTunerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		OrinocoTuner::getInterface(),
		&createOrinocoTunerDBusProxy);
}

OrinocoTunerDBusProxy::OrinocoTunerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		controlReady_(*this, "onControlReadyAttributeChanged", "b", "getControlReadyAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		controlPowerSync_(*this, "onControlPowerSyncAttributeChanged", "au", "getControlPowerSyncAttribute", static_cast<OrinocoTunerTypes_::UInt32sDeployment_t*>(nullptr)),
		audioCurrentSource_(*this, "onAudioCurrentSourceAttributeChanged", "(iu)", "getAudioCurrentSourceAttribute", static_cast<OrinocoTunerTypes_::CurrentSourceDeployment_t*>(nullptr)),
		announcementCurrentStation_(*this, "onAnnouncementCurrentStationAttributeChanged", "(i(tuui)(s(usus))iu)", "getAnnouncementCurrentStationAttribute", static_cast<OrinocoTunerTypes_::AnnouncementStationDeployment_t*>(nullptr)),
		amfmControlRegionInfo_(*this, "onAmfmControlRegionInfoAttributeChanged", "(i((uuuu)(uuuu)(uuuu)(uuuu)))", "getAmfmControlRegionInfoAttribute", static_cast<OrinocoTunerTypes_::AmFmRegionInfoDeployment_t*>(nullptr)),
		amfmControlAfSwitch_(*this, "onAmfmControlAfSwitchAttributeChanged", "b", "getAmfmControlAfSwitchAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		amfmControlRegSwitch_(*this, "onAmfmControlRegSwitchAttributeChanged", "b", "getAmfmControlRegSwitchAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		amfmControlHdMode_(*this, "onAmfmControlHdModeAttributeChanged", "i", "getAmfmControlHdModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		dabControlRegionInfo_(*this, "onDabControlRegionInfoAttributeChanged", "(i)", "getDabControlRegionInfoAttribute", static_cast<OrinocoTunerTypes_::DabRegionInfoDeployment_t*>(nullptr)),
		dabControlFollowingSwitch_(*this, "onDabControlFollowingSwitchAttributeChanged", "b", "getDabControlFollowingSwitchAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr))
,		stationCurrentStation_(*this, "stationCurrentStation", "(i(tuui)(s(usus))(ssssss)(y)(bbbb)(ii)u)", std::make_tuple(static_cast<OrinocoTunerTypes_::CurrentStationDeployment_t*>(nullptr))),
		stationStationList_(*this, "stationStationList", "(a(i(tuui)(s(usus))(y))iu)", std::make_tuple(static_cast<OrinocoTunerTypes_::StationListDeployment_t*>(nullptr)))
{
}

      OrinocoTunerDBusProxy::ControlReadyAttribute& OrinocoTunerDBusProxy::getControlReadyAttribute() {
          return controlReady_;
      }
      OrinocoTunerDBusProxy::ControlPowerSyncAttribute& OrinocoTunerDBusProxy::getControlPowerSyncAttribute() {
          return controlPowerSync_;
      }
      OrinocoTunerDBusProxy::AudioCurrentSourceAttribute& OrinocoTunerDBusProxy::getAudioCurrentSourceAttribute() {
          return audioCurrentSource_;
      }
      OrinocoTunerDBusProxy::AnnouncementCurrentStationAttribute& OrinocoTunerDBusProxy::getAnnouncementCurrentStationAttribute() {
          return announcementCurrentStation_;
      }
      OrinocoTunerDBusProxy::AmfmControlRegionInfoAttribute& OrinocoTunerDBusProxy::getAmfmControlRegionInfoAttribute() {
          return amfmControlRegionInfo_;
      }
      OrinocoTunerDBusProxy::AmfmControlAfSwitchAttribute& OrinocoTunerDBusProxy::getAmfmControlAfSwitchAttribute() {
          return amfmControlAfSwitch_;
      }
      OrinocoTunerDBusProxy::AmfmControlRegSwitchAttribute& OrinocoTunerDBusProxy::getAmfmControlRegSwitchAttribute() {
          return amfmControlRegSwitch_;
      }
      OrinocoTunerDBusProxy::AmfmControlHdModeAttribute& OrinocoTunerDBusProxy::getAmfmControlHdModeAttribute() {
          return amfmControlHdMode_;
      }
      OrinocoTunerDBusProxy::DabControlRegionInfoAttribute& OrinocoTunerDBusProxy::getDabControlRegionInfoAttribute() {
          return dabControlRegionInfo_;
      }
      OrinocoTunerDBusProxy::DabControlFollowingSwitchAttribute& OrinocoTunerDBusProxy::getDabControlFollowingSwitchAttribute() {
          return dabControlFollowingSwitch_;
      }

OrinocoTunerDBusProxy::StationCurrentStationEvent& OrinocoTunerDBusProxy::getStationCurrentStationEvent() {
    return stationCurrentStation_;
}
OrinocoTunerDBusProxy::StationStationListEvent& OrinocoTunerDBusProxy::getStationStationListEvent() {
    return stationStationList_;
}
    
    /**
     * description: Set the coding of the AM/FM tuner and DAB tuner. 
    	 	IMPORTANT: This request
     *   must be called first before everything else otherwise the tuner will not start
     *   correctly.
     */
    void OrinocoTunerDBusProxy::controlSetRegion(const OrinocoTunerTypes::AmFmRegionCode &_amfmRegionCode, const uint32_t &_amfmCodingFlags, const OrinocoTunerTypes::DabRegionInfo &_dabRegionCode, const uint32_t &_dabCodingFlags, const uint8_t &_fmAntennaGain, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<OrinocoTunerTypes::AmFmRegionCode, CommonAPI::EmptyDeployment> deploy_amfmRegionCode(_amfmRegionCode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_amfmCodingFlags(_amfmCodingFlags, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<OrinocoTunerTypes::DabRegionInfo, OrinocoTunerTypes_::DabRegionInfoDeployment_t> deploy_dabRegionCode(_dabRegionCode, static_cast<OrinocoTunerTypes_::DabRegionInfoDeployment_t*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_dabCodingFlags(_dabCodingFlags, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_fmAntennaGain(_fmAntennaGain, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<OrinocoTunerTypes::AmFmRegionCode, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<OrinocoTunerTypes::DabRegionInfo, OrinocoTunerTypes_::DabRegionInfoDeployment_t >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "controlSetRegion",
        "iu(i)uy",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_amfmRegionCode, deploy_amfmCodingFlags, deploy_dabRegionCode, deploy_dabCodingFlags, deploy_fmAntennaGain,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::controlSetRegionAsync(const OrinocoTunerTypes::AmFmRegionCode &_amfmRegionCode, const uint32_t &_amfmCodingFlags, const OrinocoTunerTypes::DabRegionInfo &_dabRegionCode, const uint32_t &_dabCodingFlags, const uint8_t &_fmAntennaGain, ControlSetRegionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<OrinocoTunerTypes::AmFmRegionCode, CommonAPI::EmptyDeployment> deploy_amfmRegionCode(_amfmRegionCode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_amfmCodingFlags(_amfmCodingFlags, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<OrinocoTunerTypes::DabRegionInfo, OrinocoTunerTypes_::DabRegionInfoDeployment_t> deploy_dabRegionCode(_dabRegionCode, static_cast<OrinocoTunerTypes_::DabRegionInfoDeployment_t*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_dabCodingFlags(_dabCodingFlags, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_fmAntennaGain(_fmAntennaGain, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<OrinocoTunerTypes::AmFmRegionCode, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<OrinocoTunerTypes::DabRegionInfo, OrinocoTunerTypes_::DabRegionInfoDeployment_t >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "controlSetRegion",
        "iu(i)uy",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_amfmRegionCode, deploy_amfmCodingFlags, deploy_dabRegionCode, deploy_dabCodingFlags, deploy_fmAntennaGain,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Use this method to set the currently active tuner source as soon as the tuner
     *   application is entered or changed. Furthmore, use this method if the tuner
     *   application is exited in combination with "ASRC_NONE".&#13;
    		As result the
     *   attribute "audioCurrentSource" is updated with the given handle.
     */
    void OrinocoTunerDBusProxy::audioSetCurrentSource(const OrinocoTunerTypes::Source &_source, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<OrinocoTunerTypes::Source, CommonAPI::EmptyDeployment> deploy_source(_source, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<OrinocoTunerTypes::Source, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "audioSetCurrentSource",
        "iu",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_source, deploy_handle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::audioSetCurrentSourceAsync(const OrinocoTunerTypes::Source &_source, const uint32_t &_handle, AudioSetCurrentSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<OrinocoTunerTypes::Source, CommonAPI::EmptyDeployment> deploy_source(_source, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<OrinocoTunerTypes::Source, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "audioSetCurrentSource",
        "iu",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_source, deploy_handle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Any manipulation of the current station: Selection by list / direct frequency
     *   tuning / preset selection / starting a search run.  &#13;
    		As result the
     *   information "stationCurrentStation" is updated with the given handle.
     */
    void OrinocoTunerDBusProxy::stationSelectStation(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<OrinocoTunerTypes::StationSelector, OrinocoTunerTypes_::StationSelectorDeployment_t> deploy_stationSelector(_stationSelector, static_cast<OrinocoTunerTypes_::StationSelectorDeployment_t*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<OrinocoTunerTypes::StationSelector, OrinocoTunerTypes_::StationSelectorDeployment_t >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "stationSelectStation",
        "(tuui)u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_stationSelector, deploy_handle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::stationSelectStationAsync(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, StationSelectStationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<OrinocoTunerTypes::StationSelector, OrinocoTunerTypes_::StationSelectorDeployment_t> deploy_stationSelector(_stationSelector, static_cast<OrinocoTunerTypes_::StationSelectorDeployment_t*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<OrinocoTunerTypes::StationSelector, OrinocoTunerTypes_::StationSelectorDeployment_t >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "stationSelectStation",
        "(tuui)u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_stationSelector, deploy_handle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Store the given station in corresponding preset list and assign the given
     *   preset number for later recalls (via "stationStartTune").&#13;
    		As result the
     *   corresponding information "stationStationList" is updated with the given
     *   handle.
     */
    void OrinocoTunerDBusProxy::stationStorePreset(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<OrinocoTunerTypes::StationSelector, OrinocoTunerTypes_::StationSelectorDeployment_t> deploy_stationSelector(_stationSelector, static_cast<OrinocoTunerTypes_::StationSelectorDeployment_t*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_preset(_preset, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<OrinocoTunerTypes::StationSelector, OrinocoTunerTypes_::StationSelectorDeployment_t >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "stationStorePreset",
        "(tuui)uu",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_stationSelector, deploy_preset, deploy_handle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::stationStorePresetAsync(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, StationStorePresetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<OrinocoTunerTypes::StationSelector, OrinocoTunerTypes_::StationSelectorDeployment_t> deploy_stationSelector(_stationSelector, static_cast<OrinocoTunerTypes_::StationSelectorDeployment_t*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_preset(_preset, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<OrinocoTunerTypes::StationSelector, OrinocoTunerTypes_::StationSelectorDeployment_t >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "stationStorePreset",
        "(tuui)uu",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_stationSelector, deploy_preset, deploy_handle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Remove given preset number from corresponding preset list.
    		As result the
     *   corresponding information "stationStationList" is updated with the given handle
     */
    void OrinocoTunerDBusProxy::stationDeletePreset(const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_preset(_preset, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "stationDeletePreset",
        "uu",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_preset, deploy_handle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::stationDeletePresetAsync(const uint32_t &_preset, const uint32_t &_handle, StationDeletePresetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_preset(_preset, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "stationDeletePreset",
        "uu",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_preset, deploy_handle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Enable/disable the announcement monitoring for FM and DAB.
    		As result the
     *   attribute "announcementCurrentStation" is updated with the given handle
     */
    void OrinocoTunerDBusProxy::announcementSwitchTp(const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enable(_enable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "announcementSwitchTp",
        "bu",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_enable, deploy_handle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::announcementSwitchTpAsync(const bool &_enable, const uint32_t &_handle, AnnouncementSwitchTpAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enable(_enable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "announcementSwitchTp",
        "bu",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_enable, deploy_handle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Abort an active announcement. As a result the attribute
     *   "announcementCurrentStation" is updated with the given handle.
     */
    void OrinocoTunerDBusProxy::announcementAbort(const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "announcementAbort",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_handle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::announcementAbortAsync(const uint32_t &_handle, AnnouncementAbortAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_handle(_handle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "announcementAbort",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_handle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Set the desired RDS alternative frequency (AF) state.
    		As result the attribute
     *   "amfmControlAfSwitch" is updated with the given handle.
     */
    void OrinocoTunerDBusProxy::amfmControlSetAfSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enable(_enable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "amfmControlSetAfSwitch",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_enable,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::amfmControlSetAfSwitchAsync(const bool &_enable, AmfmControlSetAfSwitchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enable(_enable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "amfmControlSetAfSwitch",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_enable,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Set the desired RDS regionalisation (REG) state.
    		As result the attribute
     *   "amfmControlRegSwitch" is updated with the given handle.
     */
    void OrinocoTunerDBusProxy::amfmControlSetRegSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enable(_enable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "amfmControlSetRegSwitch",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_enable,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::amfmControlSetRegSwitchAsync(const bool &_enable, AmfmControlSetRegSwitchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enable(_enable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "amfmControlSetRegSwitch",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_enable,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Set the desired HD mode.
    		As result the attribute "amfmControlHdMode" is
     *   updated with the given handle.
     */
    void OrinocoTunerDBusProxy::amfmControlSetHdMode(const OrinocoTunerTypes::AmFmHdMode &_hdMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<OrinocoTunerTypes::AmFmHdMode, CommonAPI::EmptyDeployment> deploy_hdMode(_hdMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<OrinocoTunerTypes::AmFmHdMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "amfmControlSetHdMode",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_hdMode,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::amfmControlSetHdModeAsync(const OrinocoTunerTypes::AmFmHdMode &_hdMode, AmfmControlSetHdModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<OrinocoTunerTypes::AmFmHdMode, CommonAPI::EmptyDeployment> deploy_hdMode(_hdMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<OrinocoTunerTypes::AmFmHdMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "amfmControlSetHdMode",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_hdMode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Set the desired service following at the FollowingMaster.
    		As result the
     *   attribute "dabControlFollowingSwitch" is updated with the given
     *   handle.
    		Note: This switch only affects DAB/FM linking, DAB/DAB is always on
     */
    void OrinocoTunerDBusProxy::dabControlSetFollowingSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enable(_enable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "dabControlSetFollowingSwitch",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_enable,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::dabControlSetFollowingSwitchAsync(const bool &_enable, DabControlSetFollowingSwitchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enable(_enable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "dabControlSetFollowingSwitch",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_enable,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Request initial information update at startup (stationCurrentStation,
     *   stationStationList) in order to force an "on change" update.
     */
    void OrinocoTunerDBusProxy::forceInformationUpdate(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "forceInformationUpdate",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> OrinocoTunerDBusProxy::forceInformationUpdateAsync(ForceInformationUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "forceInformationUpdate",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }


void OrinocoTunerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace tuner
      } // namespace harman
      } // namespace com
      } // namespace v1
