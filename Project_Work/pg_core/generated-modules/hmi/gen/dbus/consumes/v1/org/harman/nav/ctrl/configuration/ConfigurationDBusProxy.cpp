/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * author: Rico Schuster
 * description: Configuration interface which extends the ConfigurationBase interface to be
 *   able to set several configuration values.
    Note: Usually Franca supports
 *   the extension of Interface via "extends" keyword. But Mocca is not able to
 *   handle the inheritance of Interfaces.
    Therefore all Methods of
 *   ConfigurationBase are also part of the Configuration Interface.
 * see: org.harman.nav.ctrl.configuration.ConfigurationBase.fidl
 * see: ConfigurationBase
 */
#include <v1/org/harman/nav/ctrl/configuration/ConfigurationDBusProxy.hpp>

namespace v1 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace configuration {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createConfigurationDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<ConfigurationDBusProxy>(_address, _connection);
}

INITIALIZER(registerConfigurationDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		Configuration::getInterface(),
		&createConfigurationDBusProxy);
}

ConfigurationDBusProxy::ConfigurationDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		configurationChanges_(*this, "configurationChanges", "ai", std::make_tuple(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::SettingsDeployment_t*>(nullptr)))
{
}


ConfigurationDBusProxy::ConfigurationChangesEvent& ConfigurationDBusProxy::getConfigurationChangesEvent() {
    return configurationChanges_;
}
    
    /**
     * description: Methode for getting version of Navigation Controller.
     */
    void ConfigurationDBusProxy::getNavigationVersion(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion &_navigationVersion, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t> deploy_navigationVersion(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getNavigationVersion",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_navigationVersion);
_error = deploy_error.getValue();
_navigationVersion = deploy_navigationVersion.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::getNavigationVersionAsync(GetNavigationVersionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t> deploy_navigationVersion(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getNavigationVersion",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::NavigationVersion, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::NavigationVersionDeployment_t> _navigationVersion) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _navigationVersion.getValue());
        },
        std::make_tuple(deploy_error, deploy_navigationVersion));
    }
    /**
     * description: Methode for setting units of measurements.
     */
    void ConfigurationDBusProxy::setUnitsOfMeasurement(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement &_unitsOfMeasurement, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetUnitsOfMeasurementError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetUnitsOfMeasurementError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> deploy_unitsOfMeasurement(_unitsOfMeasurement, static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetUnitsOfMeasurementError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setUnitsOfMeasurement",
        "a(ii)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_unitsOfMeasurement,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::setUnitsOfMeasurementAsync(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement &_unitsOfMeasurement, SetUnitsOfMeasurementAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetUnitsOfMeasurementError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> deploy_unitsOfMeasurement(_unitsOfMeasurement, static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetUnitsOfMeasurementError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setUnitsOfMeasurement",
        "a(ii)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_unitsOfMeasurement,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetUnitsOfMeasurementError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: Methode for setting time format.
     */
    void ConfigurationDBusProxy::setTimeFormat(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat &_timeFormat, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetTimeFormatError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetTimeFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat, CommonAPI::EmptyDeployment> deploy_timeFormat(_timeFormat, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetTimeFormatError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setTimeFormat",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_timeFormat,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::setTimeFormatAsync(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat &_timeFormat, SetTimeFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetTimeFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat, CommonAPI::EmptyDeployment> deploy_timeFormat(_timeFormat, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetTimeFormatError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setTimeFormat",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_timeFormat,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetTimeFormatError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: Methode for getting supported time formats.
     */
    void ConfigurationDBusProxy::getSupportedTimeFormats(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedTimeFormatsError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormats &_timeFormats, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedTimeFormatsError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormats, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::TimeFormatsDeployment_t> deploy_timeFormats(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::TimeFormatsDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedTimeFormatsError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormats,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::TimeFormatsDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedTimeFormats",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_timeFormats);
_error = deploy_error.getValue();
_timeFormats = deploy_timeFormats.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::getSupportedTimeFormatsAsync(GetSupportedTimeFormatsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedTimeFormatsError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormats, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::TimeFormatsDeployment_t> deploy_timeFormats(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::TimeFormatsDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedTimeFormatsError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormats,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::TimeFormatsDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedTimeFormats",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedTimeFormatsError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormats, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::TimeFormatsDeployment_t> _timeFormats) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _timeFormats.getValue());
        },
        std::make_tuple(deploy_error, deploy_timeFormats));
    }
    /**
     * description: Methode for setting coordinates format.
     */
    void ConfigurationDBusProxy::setCoordinatesFormat(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat &_coordinatesFormat, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetCoordinatesFormatError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetCoordinatesFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat, CommonAPI::EmptyDeployment> deploy_coordinatesFormat(_coordinatesFormat, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetCoordinatesFormatError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setCoordinatesFormat",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_coordinatesFormat,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::setCoordinatesFormatAsync(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat &_coordinatesFormat, SetCoordinatesFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetCoordinatesFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat, CommonAPI::EmptyDeployment> deploy_coordinatesFormat(_coordinatesFormat, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetCoordinatesFormatError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setCoordinatesFormat",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_coordinatesFormat,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetCoordinatesFormatError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: Methode for setting locale.
     */
    void ConfigurationDBusProxy::setLocale(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale &_locale, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetLocaleError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetLocaleError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t> deploy_locale(_locale, static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetLocaleError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setLocale",
        "(sss)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_locale,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::setLocaleAsync(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale &_locale, SetLocaleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetLocaleError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t> deploy_locale(_locale, static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetLocaleError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setLocale",
        "(sss)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_locale,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetLocaleError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: Methode for getting supported units of measurements.
     */
    void ConfigurationDBusProxy::getSupportedUnitsOfMeasurement(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement &_unitsOfMeasurement, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> deploy_unitsOfMeasurement(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedUnitsOfMeasurement",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_unitsOfMeasurement);
_error = deploy_error.getValue();
_unitsOfMeasurement = deploy_unitsOfMeasurement.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::getSupportedUnitsOfMeasurementAsync(GetSupportedUnitsOfMeasurementAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> deploy_unitsOfMeasurement(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedUnitsOfMeasurement",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> _unitsOfMeasurement) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _unitsOfMeasurement.getValue());
        },
        std::make_tuple(deploy_error, deploy_unitsOfMeasurement));
    }
    /**
     * description: Methode for getting units of measurements.
     */
    void ConfigurationDBusProxy::getUnitsOfMeasurement(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement &_unitsOfMeasurement, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> deploy_unitsOfMeasurement(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getUnitsOfMeasurement",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_unitsOfMeasurement);
_error = deploy_error.getValue();
_unitsOfMeasurement = deploy_unitsOfMeasurement.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::getUnitsOfMeasurementAsync(GetUnitsOfMeasurementAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> deploy_unitsOfMeasurement(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getUnitsOfMeasurement",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitsOfMeasurement, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::UnitsOfMeasurementDeployment_t> _unitsOfMeasurement) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _unitsOfMeasurement.getValue());
        },
        std::make_tuple(deploy_error, deploy_unitsOfMeasurement));
    }
    /**
     * description: Methode for getting time format.
     */
    void ConfigurationDBusProxy::getTimeFormat(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat &_timeFormat, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat, CommonAPI::EmptyDeployment> deploy_timeFormat(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getTimeFormat",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_timeFormat);
_error = deploy_error.getValue();
_timeFormat = deploy_timeFormat.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::getTimeFormatAsync(GetTimeFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat, CommonAPI::EmptyDeployment> deploy_timeFormat(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getTimeFormat",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat, CommonAPI::EmptyDeployment> _timeFormat) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _timeFormat.getValue());
        },
        std::make_tuple(deploy_error, deploy_timeFormat));
    }
    /**
     * description: Methode for getting coordinates format.
     */
    void ConfigurationDBusProxy::getCoordinatesFormat(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat &_coordinatesFormat, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat, CommonAPI::EmptyDeployment> deploy_coordinatesFormat(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getCoordinatesFormat",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_coordinatesFormat);
_error = deploy_error.getValue();
_coordinatesFormat = deploy_coordinatesFormat.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::getCoordinatesFormatAsync(GetCoordinatesFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat, CommonAPI::EmptyDeployment> deploy_coordinatesFormat(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getCoordinatesFormat",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat, CommonAPI::EmptyDeployment> _coordinatesFormat) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _coordinatesFormat.getValue());
        },
        std::make_tuple(deploy_error, deploy_coordinatesFormat));
    }
    /**
     * description: Methode for getting supported coordinates format.
     */
    void ConfigurationDBusProxy::getSupportedCoordinatesFormats(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats &_coordinatesFormats, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t> deploy_coordinatesFormats(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedCoordinatesFormats",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_coordinatesFormats);
_error = deploy_error.getValue();
_coordinatesFormats = deploy_coordinatesFormats.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::getSupportedCoordinatesFormatsAsync(GetSupportedCoordinatesFormatsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t> deploy_coordinatesFormats(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedCoordinatesFormats",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormats, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::CoordinatesFormatsDeployment_t> _coordinatesFormats) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _coordinatesFormats.getValue());
        },
        std::make_tuple(deploy_error, deploy_coordinatesFormats));
    }
    /**
     * description: Methode for getting locale.
     */
    void ConfigurationDBusProxy::getLocale(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale &_locale, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t> deploy_locale(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getLocale",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_locale);
_error = deploy_error.getValue();
_locale = deploy_locale.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::getLocaleAsync(GetLocaleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t> deploy_locale(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getLocale",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locale, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocaleDeployment_t> _locale) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _locale.getValue());
        },
        std::make_tuple(deploy_error, deploy_locale));
    }
    /**
     * description: Methode for getting supported locales.
     */
    void ConfigurationDBusProxy::getSupportedLocales(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError &_error, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales &_locales, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t> deploy_locales(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedLocales",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_locales);
_error = deploy_error.getValue();
_locales = deploy_locales.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::getSupportedLocalesAsync(GetSupportedLocalesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t> deploy_locales(static_cast<::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales,::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedLocales",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Locales, ::org::harman::nav::ctrl::configuration::ConfigurationTypes_::LocalesDeployment_t> _locales) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _locales.getValue());
        },
        std::make_tuple(deploy_error, deploy_locales));
    }
    /**
     * description: Methode for setting style for theme.
     */
    void ConfigurationDBusProxy::setStyleTheme(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme &_style, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetStyleThemeError &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetStyleThemeError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme, CommonAPI::EmptyDeployment> deploy_style(_style, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetStyleThemeError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setStyleTheme",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_style,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> ConfigurationDBusProxy::setStyleThemeAsync(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme &_style, SetStyleThemeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetStyleThemeError, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme, CommonAPI::EmptyDeployment> deploy_style(_style, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetStyleThemeError, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setStyleTheme",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_style,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetStyleThemeError, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }


void ConfigurationDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace configuration
      } // namespace ctrl
      } // namespace nav
      } // namespace harman
      } // namespace org
      } // namespace v1
