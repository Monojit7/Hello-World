/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: LocationInput = This interface offers functions that implement the
 *   location-input functionality of a navigation system
 */
#ifndef V2_ORG_HARMAN_NAV_CTRL_DI_LOCATION_INPUT_HPP_
#define V2_ORG_HARMAN_NAV_CTRL_DI_LOCATION_INPUT_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Types.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v2 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace di {

class LocationInput {
public:
    virtual ~LocationInput() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    /**
     * description: requestListUpdate = This method sends a request for more list elements for the
     *   current session
          If a session changes, e.g. new character is entered, a
     *   new list is generated. Offset is starting at 0 again.
     */
    
    struct requestListUpdateError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            OffsetBeyondListSizeError = 0,
            WindowSizeTooLargeError = 1
        };
        
        requestListUpdateError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::OffsetBeyondListSizeError)) {}
        requestListUpdateError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::OffsetBeyondListSizeError):
                case static_cast<int32_t>(Literal::WindowSizeTooLargeError):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const requestListUpdateError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const requestListUpdateError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const requestListUpdateError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const requestListUpdateError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const requestListUpdateError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const requestListUpdateError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: selectEntry = This method triggers selection of a result list entry by index
     */
    
    struct selectEntryError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            InvalidIndex = 0,
            InvalidHandle = 1
        };
        
        selectEntryError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::InvalidIndex)) {}
        selectEntryError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::InvalidIndex):
                case static_cast<int32_t>(Literal::InvalidHandle):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const selectEntryError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const selectEntryError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const selectEntryError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const selectEntryError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const selectEntryError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const selectEntryError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: spell = This method sends the next spell input for the current session
         
     *   TBD: expected broadcasts
     */
    
    struct spellError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            InvalidCharacterError = 0
        };
        
        spellError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::InvalidCharacterError)) {}
        spellError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::InvalidCharacterError):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const spellError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const spellError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const spellError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const spellError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const spellError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const spellError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: search = This method sets the inputString for the current selection criterion
     
     *       TBD: expected broadcasts
     */
    
    struct searchError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            InvalidStringError = 0
        };
        
        searchError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::InvalidStringError)) {}
        searchError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::InvalidStringError):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const searchError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const searchError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const searchError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const searchError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const searchError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const searchError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: setAddress = This method sets the address to start with for the LocationInput
     *   identified by the given handle
     */
    
    struct setAddressError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            InvalidAddressError = 0
        };
        
        setAddressError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::InvalidAddressError)) {}
        setAddressError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::InvalidAddressError):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const setAddressError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const setAddressError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const setAddressError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const setAddressError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const setAddressError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const setAddressError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: createLocationInput = This method creates a new location input and retrieves a
     *   handle
     */
    
    struct createLocationInputError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            NoMorelocationInputHandles = 0
        };
        
        createLocationInputError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::NoMorelocationInputHandles)) {}
        createLocationInputError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NoMorelocationInputHandles):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const createLocationInputError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const createLocationInputError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const createLocationInputError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const createLocationInputError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const createLocationInputError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const createLocationInputError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: setSelectionCriterion = This method sets the selection criterion for the
     *   current speller, search input and the corresponding result-lists for the
     *   current session
     */
    
    struct setSelectionCriterionError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            InvalidSelectionCriterion = 0
        };
        
        setSelectionCriterionError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::InvalidSelectionCriterion)) {}
        setSelectionCriterionError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::InvalidSelectionCriterion):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const setSelectionCriterionError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const setSelectionCriterionError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const setSelectionCriterionError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const setSelectionCriterionError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const setSelectionCriterionError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const setSelectionCriterionError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
};

const char* LocationInput::getInterface() {
    return ("org.harman.nav.ctrl.di.LocationInput");
}

CommonAPI::Version LocationInput::getInterfaceVersion() {
    return CommonAPI::Version(2, 1);
}


} // namespace di
} // namespace ctrl
} // namespace nav
} // namespace harman
} // namespace org
} // namespace v2

namespace CommonAPI {
}


// Compatibility
namespace v2_1 = v2;

#endif // V2_ORG_HARMAN_NAV_CTRL_DI_LOCATION_INPUT_HPP_
