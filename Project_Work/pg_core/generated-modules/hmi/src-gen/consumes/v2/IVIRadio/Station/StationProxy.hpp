/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * author: EGMG_Tuner
 */
#ifndef V2_IVIRADIO_STATION_Station_PROXY_HPP_
#define V2_IVIRADIO_STATION_Station_PROXY_HPP_

#include <v2/IVIRadio/Station/StationProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v2 {
namespace IVIRadio {
namespace Station {

template <typename ... _AttributeExtensions>
class StationProxy
    : virtual public Station, 
      virtual public StationProxyBase,
      virtual public _AttributeExtensions... {
public:
    StationProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~StationProxy();

    typedef Station InterfaceType;



    /**
     * description: information about the currently active station
     */
    /**
     * Returns the wrapper class that provides access to the broadcast currentStation.
     */
    virtual CurrentStationEvent& getCurrentStationEvent() {
        return delegate_->getCurrentStationEvent();
    }
    /**
     * description: seek information sent during an active search.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast seek.
     */
    virtual SeekEvent& getSeekEvent() {
        return delegate_->getSeekEvent();
    }
    /**
     * description: station list information.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast stationList.
     */
    virtual StationListEvent& getStationListEvent() {
        return delegate_->getStationListEvent();
    }

    /**
     * description: deallocate a tuner resource
     * Calls abortTune with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void abortTune(const ::v2::IVIRadio::Types::Types::DeviceType &_deviceType, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_handleOut, ::v2::IVIRadio::Types::Types::Feedback &_feedback, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls abortTune with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> abortTuneAsync(const ::v2::IVIRadio::Types::Types::DeviceType &_deviceType, const uint32_t &_handle, AbortTuneAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: make station permanent (tuning information will not be removed from middleware
     *   even if station is not receivable any more)
     * Calls makePermanent with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void makePermanent(const ::v2::IVIRadio::Types::Types::StationSelector &_station, const bool &_permanent, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_handleOut, ::v2::IVIRadio::Types::Types::Feedback &_feedback, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls makePermanent with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> makePermanentAsync(const ::v2::IVIRadio::Types::Types::StationSelector &_station, const bool &_permanent, const uint32_t &_handle, MakePermanentAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: request explicit update of currentStation or stationList information. E.g.
     *   necessary after startup.
     * Calls controlUpdate with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void controlUpdate(const ::v2::IVIRadio::Station::StationTypes::UpdateElement &_updateElement, const ::v2::IVIRadio::Types::Types::UpdateType &_updateType, const uint32_t &_sourceType, const uint32_t &_stationType, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_handleOut, ::v2::IVIRadio::Types::Types::Feedback &_feedback, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls controlUpdate with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> controlUpdateAsync(const ::v2::IVIRadio::Station::StationTypes::UpdateElement &_updateElement, const ::v2::IVIRadio::Types::Types::UpdateType &_updateType, const uint32_t &_sourceType, const uint32_t &_stationType, const uint32_t &_handle, ControlUpdateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: starts/stops a seek process
     * Calls seek with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void seek(const ::v2::IVIRadio::Types::Types::DeviceType &_device, const ::v2::IVIRadio::Station::StationTypes::SeekMode &_seekMode, const uint8_t &_genre, const uint32_t &_flags, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_handleOut, ::v2::IVIRadio::Types::Types::Feedback &_feedback, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls seek with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> seekAsync(const ::v2::IVIRadio::Types::Types::DeviceType &_device, const ::v2::IVIRadio::Station::StationTypes::SeekMode &_seekMode, const uint8_t &_genre, const uint32_t &_flags, const uint32_t &_handle, SeekAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: start tuning a frequency or selecting a station
     * Calls startTune with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startTune(const ::v2::IVIRadio::Types::Types::StationSelector &_station, const ::v2::IVIRadio::Station::StationTypes::SelectionMode &_selectionMode, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_handleOut, ::v2::IVIRadio::Types::Types::Feedback &_feedback, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startTune with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startTuneAsync(const ::v2::IVIRadio::Types::Types::StationSelector &_station, const ::v2::IVIRadio::Station::StationTypes::SelectionMode &_selectionMode, const uint32_t &_handle, StartTuneAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<StationProxyBase> delegate_;
};

typedef StationProxy<> StationProxyDefault;


//
// StationProxy Implementation
//
template <typename ... _AttributeExtensions>
StationProxy<_AttributeExtensions...>::StationProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<StationProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<StationProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
StationProxy<_AttributeExtensions...>::~StationProxy() {
}

/**
 * description: deallocate a tuner resource
 */
template <typename ... _AttributeExtensions>
void StationProxy<_AttributeExtensions...>::abortTune(const ::v2::IVIRadio::Types::Types::DeviceType &_deviceType, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_handleOut, ::v2::IVIRadio::Types::Types::Feedback &_feedback, const CommonAPI::CallInfo *_info) {
    if (!_deviceType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->abortTune(_deviceType, _handle, _internalCallStatus, _handleOut, _feedback, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> StationProxy<_AttributeExtensions...>::abortTuneAsync(const ::v2::IVIRadio::Types::Types::DeviceType &_deviceType, const uint32_t &_handle, AbortTuneAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_deviceType.validate()) {
        uint32_t handleOut = 0ul;
        ::v2::IVIRadio::Types::Types::Feedback feedback = ::v2::IVIRadio::Types::Types::Feedback::DONE;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, handleOut, feedback);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->abortTuneAsync(_deviceType, _handle, _callback, _info);
}
/**
 * description: make station permanent (tuning information will not be removed from middleware
 *   even if station is not receivable any more)
 */
template <typename ... _AttributeExtensions>
void StationProxy<_AttributeExtensions...>::makePermanent(const ::v2::IVIRadio::Types::Types::StationSelector &_station, const bool &_permanent, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_handleOut, ::v2::IVIRadio::Types::Types::Feedback &_feedback, const CommonAPI::CallInfo *_info) {
    delegate_->makePermanent(_station, _permanent, _handle, _internalCallStatus, _handleOut, _feedback, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> StationProxy<_AttributeExtensions...>::makePermanentAsync(const ::v2::IVIRadio::Types::Types::StationSelector &_station, const bool &_permanent, const uint32_t &_handle, MakePermanentAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->makePermanentAsync(_station, _permanent, _handle, _callback, _info);
}
/**
 * description: request explicit update of currentStation or stationList information. E.g.
 *   necessary after startup.
 */
template <typename ... _AttributeExtensions>
void StationProxy<_AttributeExtensions...>::controlUpdate(const ::v2::IVIRadio::Station::StationTypes::UpdateElement &_updateElement, const ::v2::IVIRadio::Types::Types::UpdateType &_updateType, const uint32_t &_sourceType, const uint32_t &_stationType, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_handleOut, ::v2::IVIRadio::Types::Types::Feedback &_feedback, const CommonAPI::CallInfo *_info) {
    if (!_updateElement.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_updateType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->controlUpdate(_updateElement, _updateType, _sourceType, _stationType, _handle, _internalCallStatus, _handleOut, _feedback, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> StationProxy<_AttributeExtensions...>::controlUpdateAsync(const ::v2::IVIRadio::Station::StationTypes::UpdateElement &_updateElement, const ::v2::IVIRadio::Types::Types::UpdateType &_updateType, const uint32_t &_sourceType, const uint32_t &_stationType, const uint32_t &_handle, ControlUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_updateElement.validate()) {
        uint32_t handleOut = 0ul;
        ::v2::IVIRadio::Types::Types::Feedback feedback = ::v2::IVIRadio::Types::Types::Feedback::DONE;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, handleOut, feedback);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_updateType.validate()) {
        uint32_t handleOut = 0ul;
        ::v2::IVIRadio::Types::Types::Feedback feedback = ::v2::IVIRadio::Types::Types::Feedback::DONE;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, handleOut, feedback);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->controlUpdateAsync(_updateElement, _updateType, _sourceType, _stationType, _handle, _callback, _info);
}
/**
 * description: starts/stops a seek process
 */
template <typename ... _AttributeExtensions>
void StationProxy<_AttributeExtensions...>::seek(const ::v2::IVIRadio::Types::Types::DeviceType &_device, const ::v2::IVIRadio::Station::StationTypes::SeekMode &_seekMode, const uint8_t &_genre, const uint32_t &_flags, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_handleOut, ::v2::IVIRadio::Types::Types::Feedback &_feedback, const CommonAPI::CallInfo *_info) {
    if (!_device.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_seekMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->seek(_device, _seekMode, _genre, _flags, _handle, _internalCallStatus, _handleOut, _feedback, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> StationProxy<_AttributeExtensions...>::seekAsync(const ::v2::IVIRadio::Types::Types::DeviceType &_device, const ::v2::IVIRadio::Station::StationTypes::SeekMode &_seekMode, const uint8_t &_genre, const uint32_t &_flags, const uint32_t &_handle, SeekAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_device.validate()) {
        uint32_t handleOut = 0ul;
        ::v2::IVIRadio::Types::Types::Feedback feedback = ::v2::IVIRadio::Types::Types::Feedback::DONE;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, handleOut, feedback);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_seekMode.validate()) {
        uint32_t handleOut = 0ul;
        ::v2::IVIRadio::Types::Types::Feedback feedback = ::v2::IVIRadio::Types::Types::Feedback::DONE;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, handleOut, feedback);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->seekAsync(_device, _seekMode, _genre, _flags, _handle, _callback, _info);
}
/**
 * description: start tuning a frequency or selecting a station
 */
template <typename ... _AttributeExtensions>
void StationProxy<_AttributeExtensions...>::startTune(const ::v2::IVIRadio::Types::Types::StationSelector &_station, const ::v2::IVIRadio::Station::StationTypes::SelectionMode &_selectionMode, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_handleOut, ::v2::IVIRadio::Types::Types::Feedback &_feedback, const CommonAPI::CallInfo *_info) {
    if (!_selectionMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->startTune(_station, _selectionMode, _handle, _internalCallStatus, _handleOut, _feedback, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> StationProxy<_AttributeExtensions...>::startTuneAsync(const ::v2::IVIRadio::Types::Types::StationSelector &_station, const ::v2::IVIRadio::Station::StationTypes::SelectionMode &_selectionMode, const uint32_t &_handle, StartTuneAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_selectionMode.validate()) {
        uint32_t handleOut = 0ul;
        ::v2::IVIRadio::Types::Types::Feedback feedback = ::v2::IVIRadio::Types::Types::Feedback::DONE;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, handleOut, feedback);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->startTuneAsync(_station, _selectionMode, _handle, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &StationProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool StationProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool StationProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& StationProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& StationProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace Station
} // namespace IVIRadio
} // namespace v2



// Compatibility
namespace v2_1 = v2;

#endif // V2_IVIRADIO_STATION_Station_PROXY_HPP_
