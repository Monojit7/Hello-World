/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * author: MGEG_Tuner
 */
#ifndef V2_IVIRADIO_ADDITIONALSERVICE_Additional_Service_Types_HPP_
#define V2_IVIRADIO_ADDITIONALSERVICE_Additional_Service_Types_HPP_


#include <v2/IVIRadio/Types/Types.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/ByteBuffer.hpp>
#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v2 {
namespace IVIRadio {
namespace AdditionalService {

struct AdditionalServiceTypes {
    
    struct AnnouncementState : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            NotAvailable = 0,
            Available = 1,
            Active = 2
        };
        
        AnnouncementState() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::NotAvailable)) {}
        AnnouncementState(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NotAvailable):
                case static_cast<int32_t>(Literal::Available):
                case static_cast<int32_t>(Literal::Active):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AnnouncementState &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AnnouncementState &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AnnouncementState &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AnnouncementState &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AnnouncementState &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AnnouncementState &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: array of announcement states
     */
    typedef std::vector<AdditionalServiceTypes::AnnouncementState> AnnouncementStates;
    typedef std::vector<AdditionalServiceTypes::AnnouncementStates> arrayAnnouncementStates;
    /**
     * description: Union for the return value of the data broadcast.
     */
    typedef CommonAPI::Variant<std::string, CommonAPI::ByteBuffer>  Data;
    
    struct DataFormat : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DF_XML = 0,
            DF_HTML = 1,
            DF_PICTURE = 2,
            DF_RAW = 3
        };
        
        DataFormat() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DF_XML)) {}
        DataFormat(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DF_XML):
                case static_cast<int32_t>(Literal::DF_HTML):
                case static_cast<int32_t>(Literal::DF_PICTURE):
                case static_cast<int32_t>(Literal::DF_RAW):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DataFormat &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DataFormat &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DataFormat &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DataFormat &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DataFormat &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DataFormat &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct DataType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DT_STRING = 0,
            DT_STREAM = 1,
            DT_BYTEBUFFER = 2
        };
        
        DataType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DT_STRING)) {}
        DataType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DT_STRING):
                case static_cast<int32_t>(Literal::DT_STREAM):
                case static_cast<int32_t>(Literal::DT_BYTEBUFFER):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DataType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DataType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DataType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DataType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DataType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DataType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct EWSAffectedArea : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            EAA_UNKNOWN = 0,
            EAA_NATIONALWIDE = 1,
            EAA_WIDEAREA = 2,
            EAA_REGION = 3,
            EAA_LOCAL = 4,
            EAA_POINT = 5
        };
        
        EWSAffectedArea() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::EAA_UNKNOWN)) {}
        EWSAffectedArea(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::EAA_UNKNOWN):
                case static_cast<int32_t>(Literal::EAA_NATIONALWIDE):
                case static_cast<int32_t>(Literal::EAA_WIDEAREA):
                case static_cast<int32_t>(Literal::EAA_REGION):
                case static_cast<int32_t>(Literal::EAA_LOCAL):
                case static_cast<int32_t>(Literal::EAA_POINT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const EWSAffectedArea &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const EWSAffectedArea &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const EWSAffectedArea &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const EWSAffectedArea &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const EWSAffectedArea &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const EWSAffectedArea &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct EWSType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ET_UNKNOWN = 0,
            ET_EMERGENCY_WARNING = 1,
            ET_EARTHQUAKE_WARNING = 2,
            ET_TIDAL_WAVE_WARNING = 3,
            ET_WEATHER_WARNING = 4,
            ET_ROAD_TRAFFIC = 5,
            ET_PERSONAL_CALL = 6,
            ET_EVENT_ANNOUNCEMENT = 7,
            ET_CAS_SERVICE_MESSAGE = 8,
            ET_TEST_SIGNAL = 9
        };
        
        EWSType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ET_UNKNOWN)) {}
        EWSType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ET_UNKNOWN):
                case static_cast<int32_t>(Literal::ET_EMERGENCY_WARNING):
                case static_cast<int32_t>(Literal::ET_EARTHQUAKE_WARNING):
                case static_cast<int32_t>(Literal::ET_TIDAL_WAVE_WARNING):
                case static_cast<int32_t>(Literal::ET_WEATHER_WARNING):
                case static_cast<int32_t>(Literal::ET_ROAD_TRAFFIC):
                case static_cast<int32_t>(Literal::ET_PERSONAL_CALL):
                case static_cast<int32_t>(Literal::ET_EVENT_ANNOUNCEMENT):
                case static_cast<int32_t>(Literal::ET_CAS_SERVICE_MESSAGE):
                case static_cast<int32_t>(Literal::ET_TEST_SIGNAL):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const EWSType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const EWSType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const EWSType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const EWSType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const EWSType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const EWSType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ImageService : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            IS_CATEGORIZED_SLIDESHOW = 0,
            IS_SLIDESHOW = 1,
            IS_ALBUM_COVER = 2,
            IS_STATION_LOGO = 3
        };
        
        ImageService() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::IS_CATEGORIZED_SLIDESHOW)) {}
        ImageService(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::IS_CATEGORIZED_SLIDESHOW):
                case static_cast<int32_t>(Literal::IS_SLIDESHOW):
                case static_cast<int32_t>(Literal::IS_ALBUM_COVER):
                case static_cast<int32_t>(Literal::IS_STATION_LOGO):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ImageService &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ImageService &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ImageService &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ImageService &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ImageService &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ImageService &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ImageType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            IT_BOOKLET_FRONT = 0,
            IT_BOOKLET_BACK = 1,
            IT_INTERPRET = 2
        };
        
        ImageType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::IT_BOOKLET_FRONT)) {}
        ImageType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::IT_BOOKLET_FRONT):
                case static_cast<int32_t>(Literal::IT_BOOKLET_BACK):
                case static_cast<int32_t>(Literal::IT_INTERPRET):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ImageType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ImageType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ImageType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ImageType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ImageType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ImageType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Struct for languages
     */
    struct Language : CommonAPI::Struct<std::string> {
    	
    	Language() {
    	}
    	Language(const std::string &_Name)
    	{
    		std::get<0>(values_) = _Name;
    	}
    	inline const std::string &getName() const { return std::get<0>(values_); }
    	inline void setName(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline bool operator==(const Language& _other) const {
                return (getName() == _other.getName());
        }
    	inline bool operator!=(const Language &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Array of languages
     */
    typedef std::vector<AdditionalServiceTypes::Language> Languages;
    
    struct DataService : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DS_NO_SERVICE = 0,
            DS_SUBTITLE = 1,
            DS_TELETEXT = 2,
            DS_EPG = 3,
            DS_IMAGE = 4,
            DS_TMC = 5,
            DS_TPEG = 6,
            DS_JOURNALINE = 7,
            DS_ANNOUNCEMENT = 8,
            DS_EWS = 9
        };
        
        DataService() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DS_NO_SERVICE)) {}
        DataService(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DS_NO_SERVICE):
                case static_cast<int32_t>(Literal::DS_SUBTITLE):
                case static_cast<int32_t>(Literal::DS_TELETEXT):
                case static_cast<int32_t>(Literal::DS_EPG):
                case static_cast<int32_t>(Literal::DS_IMAGE):
                case static_cast<int32_t>(Literal::DS_TMC):
                case static_cast<int32_t>(Literal::DS_TPEG):
                case static_cast<int32_t>(Literal::DS_JOURNALINE):
                case static_cast<int32_t>(Literal::DS_ANNOUNCEMENT):
                case static_cast<int32_t>(Literal::DS_EWS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DataService &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DataService &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DataService &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DataService &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DataService &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DataService &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AnnouncementType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            AT_ALARM = 0,
            AT_ROAD_TRAFFIC = 1,
            AT_TRANSPORT_FLASH = 2,
            AT_WARNING_SERVICE = 3,
            AT_NEWS = 4,
            AT_AREA_WEATHER = 5,
            AT_EVENT = 6,
            AT_SEPECIAL_EVENT = 7,
            AT_PROGRAM_INFORMATION = 8,
            AT_SPORT_REPORT = 9,
            AT_FINANCIAL_REPORT = 10
        };
        
        AnnouncementType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::AT_ALARM)) {}
        AnnouncementType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::AT_ALARM):
                case static_cast<int32_t>(Literal::AT_ROAD_TRAFFIC):
                case static_cast<int32_t>(Literal::AT_TRANSPORT_FLASH):
                case static_cast<int32_t>(Literal::AT_WARNING_SERVICE):
                case static_cast<int32_t>(Literal::AT_NEWS):
                case static_cast<int32_t>(Literal::AT_AREA_WEATHER):
                case static_cast<int32_t>(Literal::AT_EVENT):
                case static_cast<int32_t>(Literal::AT_SEPECIAL_EVENT):
                case static_cast<int32_t>(Literal::AT_PROGRAM_INFORMATION):
                case static_cast<int32_t>(Literal::AT_SPORT_REPORT):
                case static_cast<int32_t>(Literal::AT_FINANCIAL_REPORT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AnnouncementType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AnnouncementType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AnnouncementType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AnnouncementType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AnnouncementType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AnnouncementType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Structure for the current announcement with information about channel and type.
     */
    struct Announcement : CommonAPI::Struct<::v2::IVIRadio::Types::Types::StationSelector, AnnouncementType> {
    	
    	Announcement() {
    	}
    	Announcement(const ::v2::IVIRadio::Types::Types::StationSelector &_stationSelector, const AnnouncementType &_type)
    	{
    		std::get<0>(values_) = _stationSelector;
    		std::get<1>(values_) = _type;
    	}
    	/**
    	 * description: Station which provides the announcement.
    	 */
    	inline const ::v2::IVIRadio::Types::Types::StationSelector &getStationSelector() const { return std::get<0>(values_); }
    	inline void setStationSelector(const ::v2::IVIRadio::Types::Types::StationSelector &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: information about the announcement type.
    	 */
    	inline const AnnouncementType &getType() const { return std::get<1>(values_); }
    	inline void setType(const AnnouncementType &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const Announcement& _other) const {
                return (getStationSelector() == _other.getStationSelector() && getType() == _other.getType());
        }
    	inline bool operator!=(const Announcement &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Structure for announcement types. For every type of announcement the
     *   availability is given. The user can activate or deactivate each type and he
     *   can change the priorities for every type
     */
    struct AnnouncementConfiguration : CommonAPI::Struct<AnnouncementType, ::v2::IVIRadio::Types::Types::Activation, uint32_t> {
    	
    	AnnouncementConfiguration() {
    	}
    	AnnouncementConfiguration(const AnnouncementType &_type, const ::v2::IVIRadio::Types::Types::Activation &_active, const uint32_t &_priority)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _active;
    		std::get<2>(values_) = _priority;
    	}
    	/**
    	 * description: announcement types.
    	 */
    	inline const AnnouncementType &getType() const { return std::get<0>(values_); }
    	inline void setType(const AnnouncementType &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: activation of announcement type
    	 */
    	inline const ::v2::IVIRadio::Types::Types::Activation &getActive() const { return std::get<1>(values_); }
    	inline void setActive(const ::v2::IVIRadio::Types::Types::Activation &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: priority for the type.
    	 */
    	inline const uint32_t &getPriority() const { return std::get<2>(values_); }
    	inline void setPriority(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const AnnouncementConfiguration& _other) const {
                return (getType() == _other.getType() && getActive() == _other.getActive() && getPriority() == _other.getPriority());
        }
    	inline bool operator!=(const AnnouncementConfiguration &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Array type for announcement configuration
     */
    typedef std::vector<AdditionalServiceTypes::AnnouncementConfiguration> AnnouncementConfigurations;



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "IVIRadio.AdditionalService.AdditionalServiceTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(2, 0);
}

}; // struct AdditionalServiceTypes

} // namespace AdditionalService
} // namespace IVIRadio
} // namespace v2

namespace CommonAPI {
}


namespace std {
    //Hash for AnnouncementState
    template<>
    struct hash<::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::AnnouncementState> {
        inline size_t operator()(const ::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::AnnouncementState& announcementState) const {
            return static_cast<int32_t>(announcementState);
        }
    };
    //Hash for DataFormat
    template<>
    struct hash<::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::DataFormat> {
        inline size_t operator()(const ::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::DataFormat& dataFormat) const {
            return static_cast<int32_t>(dataFormat);
        }
    };
    //Hash for DataType
    template<>
    struct hash<::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::DataType> {
        inline size_t operator()(const ::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::DataType& dataType) const {
            return static_cast<int32_t>(dataType);
        }
    };
    //Hash for EWSAffectedArea
    template<>
    struct hash<::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::EWSAffectedArea> {
        inline size_t operator()(const ::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::EWSAffectedArea& eWSAffectedArea) const {
            return static_cast<int32_t>(eWSAffectedArea);
        }
    };
    //Hash for EWSType
    template<>
    struct hash<::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::EWSType> {
        inline size_t operator()(const ::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::EWSType& eWSType) const {
            return static_cast<int32_t>(eWSType);
        }
    };
    //Hash for ImageService
    template<>
    struct hash<::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::ImageService> {
        inline size_t operator()(const ::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::ImageService& imageService) const {
            return static_cast<int32_t>(imageService);
        }
    };
    //Hash for ImageType
    template<>
    struct hash<::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::ImageType> {
        inline size_t operator()(const ::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::ImageType& imageType) const {
            return static_cast<int32_t>(imageType);
        }
    };
    //Hash for DataService
    template<>
    struct hash<::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::DataService> {
        inline size_t operator()(const ::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::DataService& dataService) const {
            return static_cast<int32_t>(dataService);
        }
    };
    //Hash for AnnouncementType
    template<>
    struct hash<::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::AnnouncementType> {
        inline size_t operator()(const ::v2::IVIRadio::AdditionalService::AdditionalServiceTypes::AnnouncementType& announcementType) const {
            return static_cast<int32_t>(announcementType);
        }
    };
}


// Compatibility
namespace v2_0 = v2;

#endif // V2_IVIRADIO_ADDITIONALSERVICE_Additional_Service_Types_HPP_
