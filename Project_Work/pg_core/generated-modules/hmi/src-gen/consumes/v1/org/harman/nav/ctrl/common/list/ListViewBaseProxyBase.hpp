/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: ListViewBase = This interface offers functions that implement a basic list
 *   concept 
    The basic idea of this inteface is the following:
    A client
 *   registers a view with a certain size n on a list with a dynamic size m. Please
 *   note: during 
    initial call, a view might be bigger than the underlying
 *   list. 
    The client uses index - so called ListTypes.ListKey to position the
 *   first element of a view to a certain
    element in the list. Please note: the
 *   ListKey value must be in a valid range between first (0) and last (m)
 *   element.
    Furthermore the client specifies it's anchor point. An anchor is
 *   more or less the stable entry in a view which - 
    even in case of a
 *   listupdate - stays at a permanent position in the view. It is used to
 *   guarantee a stable view
    in case of list changes (sorting changed,
 *   inserts/deletes) and furthermore allow a client to realize a smooth
   
 *   scrolling - if necessary. For better understanding see the following example:
 *   
    There is a list of 30 elements and a view with a total of 4 entries. The
 *   view is positioned at entry 21, which 
    means the view shows the entries
 *   [21, 22, 23, 24]. The client specifies the anchor on 22. Now imagine an update
 *   
    occurs (e.g. a new entry will get inserted between 17 and 18). The
 *   clients get notified by a broadcast that the
    ListTypes.ListKey of his
 *   anchor is now 23 (because the entry 22 is moved on index 23). 
    
    While
 *   the base list specifies how to navitation and create a view on a given list,
 *   the concrete implementation of 
    a list is responsible for providing the
 *   data of a view. This must be realized in the following manner: each
   
 *   concrete implementation must provide a getView() function which returns the
 *   entries of a current view, the absolute
    key/index of the view and the
 *   relative anchor position based on the view position. The provider
    of the
 *   list is responsible for providing always the correct elements of a list based
 *   on the anchor, the client
    has specified. 
    
    Special case handling:
 *   in some cases it might happen, that the specified anchor point get's removed
 *   from the list
    and therefore from the view. In this case the list
 *   implementation will behave like the following: If possible,
    the anchor
 *   will be replaced by the provider with the next element (successor) in the
 *   list. If this is not possible
    (anchor already pointed to the last element
 *   in list), the previous element (predecessor) is selected as new anchor.
   
 *   Anyway - the impact of an update on the anchor will be indicated by
 *   appropriate enum.
 */
#ifndef V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_List_View_Base_PROXY_BASE_HPP_
#define V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_List_View_Base_PROXY_BASE_HPP_

#include <v1/org/harman/nav/ctrl/common/list/ListViewBase.hpp>


#include <org/harman/nav/ctrl/CommonTypes.hpp>
#include <org/harman/nav/ctrl/common/list/ListTypes.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <cstdint>
#include <string>
#include <vector>

#include <CommonAPI/Event.hpp>
#include <CommonAPI/Proxy.hpp>
#include <functional>
#include <future>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace common {
namespace list {

class ListViewBaseProxyBase
    : virtual public CommonAPI::Proxy {
public:
    typedef CommonAPI::Event<
        ::org::harman::nav::ctrl::common::list::ListTypes::ViewId, ::org::harman::nav::ctrl::common::list::ListTypes::ListSize, bool, bool
    > ViewUpdateEvent;
    typedef CommonAPI::Event<
        ::org::harman::nav::ctrl::common::list::ListTypes::ListId, ::org::harman::nav::ctrl::common::list::ListTypes::ListSize
    > ListSizeEvent;

    typedef std::function<void(const CommonAPI::CallStatus&, const ::org::harman::nav::ctrl::common::list::ListTypes::ListError&, const ::org::harman::nav::ctrl::common::list::ListTypes::ListSize&)> GetListSizeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::org::harman::nav::ctrl::common::list::ListTypes::ListError&, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId&)> CreateViewAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::org::harman::nav::ctrl::common::list::ListTypes::ListError&)> DeleteViewAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::org::harman::nav::ctrl::common::list::ListTypes::ListError&)> SetViewSizeAsyncCallback;


    /**
     * description: indicate to the client that the underlying list of a certain view has changed
     
     *         Whenever elements get inserted/removed or the content of element gets
     *   changed, the size 
            or the sorting order of a list might change. This
     *   might influence the current view and
            especially the position of the
     *   anchor element in the list. To allow a client to react on such
            changes
     *   in an approapriate manner, the viewUpdate broadcast will provide all necessary
     *   information
            to its client. 
            It is up to the client to
     *   reposition the view to its needs based on the provided information, 
           
     *   using the methods setViewPosition or setViewAnchor.
     */
    virtual ViewUpdateEvent& getViewUpdateEvent() = 0;
    /**
     * description: informs the client about changes of the list size.
     */
    virtual ListSizeEvent& getListSizeEvent() = 0;

    /**
     * description: get the current number of contained elements in the given list.
     */
    virtual void getListSize(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, ::org::harman::nav::ctrl::common::list::ListTypes::ListSize &_size, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> getListSizeAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, GetListSizeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: create a new view to the mother array. 
            This view will be maintained
     *   until the client uses destroyView, 
            unsubscribes or service/proxy
     *   exit. 
            After creating a view the client must receive an update.
          
     *    Only one created view is allowed to modify the list entries.
            Please
     *   note: a valid usecase is to specify a viewSize which is 
            bigger than
     *   the inital list size
     */
    virtual void createView(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_viewsize, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> createViewAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_viewsize, CreateViewAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: delete the given view instance
     */
    virtual void deleteView(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> deleteViewAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, DeleteViewAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: adjust the view size. It is allowed to set view size to a larger value
           
     *   than the actual size of the list, but less or equal than the maximum size of
     *   the list. 
            The implementation may limit the maximum view size for
     *   resource reasons. 
            After adjusting the window size the client must
     *   receive an update.
     */
    virtual void setViewSize(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_new_size, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> setViewSizeAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_new_size, SetViewSizeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: set the absolute view position to element key. 
            The client should use
     *   an available snapshot of a view to maintain focused elements 
            within
     *   the view if possible, and change the view position only if an 
            element
     *   to be focused is outside of the given view. A snapshot is generated whenever
     
     *         querying the data contained in a view. Together with that data, the
     *   ViewSnapshotPosition is provided.
            The initial snapshot of the view is
     *   always [0, min(viewSize-1, listSize-1)].
            When creating a new view
     *   snapshot, the last call of setViewPosition or setViewAnchor (whichever was the
     *   last one)
            will be the relevant information to reposition the new view
     *   snapshot. If setViewPosition was the last call,
            the view is moved such
     *   that the provided key refers to the absolute position on the current snapshot
     *   of the view.
            (This becomes important if the current view snapshot is
     *   outdated because the list has been updated.)
    
            The following rules are
     *   applied to set the position of the new view snapshot [newFrom, newTo], given a
     *   snapshot [from, to]:
            Let elem(k) denote the element at key k in the
     *   old snapshot and new(e) denote the key the element e will have 
            (would
     *   have if deleted) in the new snapshot (see also examples (1)-(3) below).
          
     *    (1) If key is less than from, then newFrom will be set to new(elem(from)) -
     *   (from-key).
            (2) If key is contained in [from, to], then newKey will be
     *   set to new(elem(key)).
            (3) If key is greater than to, then newFrom
     *   will be set to new(elem(to)) + (key-to).
            If any of these calculated
     *   values are out of the range of the list [0, listSize-1], they will be
     *   truncated to fit into the list.
            (Note that the resulting newFrom is
     *   always equal to key if the data wasn't updated, 
            but it doesn't have
     *   to be equal to key if the data was updated.)
            After setting the view
     *   position the anchor offset will automatically be set to 0.
            There are
     *   two special key values to allow scrolling to the top/bottom of the list,
     *   independently from the above rules:
            The key value 0xFFFE always
     *   positions the view to the top of the list.
            The key value 0xFFFF always
     *   positions the view to the bottom of the list.
    
            As an example for the
     *   case in which the data was updated:
            old list {"a", "b", "c", "d", "e",
     *   "f"} with view snapshot ["c", "d"] with viewSize 2 and viewKey 2
            new
     *   list {"b", "d", "f", "h", "j", "l"}
            (1) setViewPosition(0) => [from,
     *   to] is [2, 3], elem(from) is "c", new(elem(from)) is 1
                           
     *          => ["b", "d"] with ViewSnapshotPosition {listSize=6, listKey=0,
     *   anchorOffset=0}.
            (2) setViewPosition(3) => [from, to] is [2, 3],
     *   elem(key) is "d", new(elem(key)) is 1
                                   => ["d",
     *   "f"] with ViewSnapshotPosition {listSize=6, listKey=1, anchorOffset=0}.
          
     *    (3) setViewPosition(4) => [from, to] is [2, 3], elem(to) is "d", new(elem(d))
     *   is 1
                                   => ["f", "h"] with ViewSnapshotPosition
     *   {listSize=6, listKey=2, anchorOffset=0}.
     */
    /**
     * @invariant Fire And Forget
     */
    virtual void setViewPosition(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ListKey &_key, CommonAPI::CallStatus &_internalCallStatus) = 0;
    /**
     * description: set a stable element inside the current view snapshot.
            The client
     *   should use an available snapshot of a view to maintain focused elements 
         
     *     within the view if possible, and change the view position only if an 
          
     *    element to be focused is outside of the given view. A snapshot is generated
     *   whenever
            querying the data contained in a view. Together with that
     *   data, the ViewSnapshotPosition is provided.
            The initial snapshot of
     *   the view is always [0, min(viewSize-1, listSize-1)] with anchor offset 0.
        
     *      When creating a new view snapshot, the last call of setViewPosition or
     *   setViewAnchor (whichever was the last one)
            will be the relevant
     *   information to reposition the new view snapshot. If setViewAnchor was the last
     *   call,
            the anchor element of the old view snapshot is used for
     *   repositioning.
            (This method only needs to be used if the current view
     *   snapshot is outdated because the list has been updated.)
    
            The
     *   following rules are applied to set the position of the new view snapshot
     *   [newFrom, newTo], given a snapshot [from, to]
            and anchor offset aOff:
    
     *          Let elem(k) denote the element at key k in the old snapshot and new(e)
     *   denote the key the element e will have 
            (would have if deleted) in the
     *   new snapshot (see also examples below).
            newFrom is set to
     *   new(elem(from+aOff)) - aOff.
            If any of these calculated values are out
     *   of the range of the list [0, listSize-1], they will be truncated to fit into
     *   the list.
            As a consequence, whenever possible, the anchor element of
     *   the old snapshot will be at the same offset within the new snapshot.
    
           
     *   As an example for the case in which the data was updated:
            old list
     *   {"a", "b", "c", "d", "e", "f"} with view snapshot ["c", "d"] with viewSize 2
     *   and viewKey 2
            new list {"b", "d", "f", "h", "j", "l"}
           
     *   setViewAnchor(0) => elem(from+aOff) is "c", new(elem(from+aOff)) is 1 ("c"
     *   would be inserted at index 1)
                             => ["d", "f"] with
     *   ViewSnapshotPosition {listSize=6, listKey=1, anchorOffset=0}.
           
     *   setViewAnchor(1) => elem(from+aOff) is "d", new(elem(from+aOff)) is 1
            
     *                   => ["b", "d"] with ViewSnapshotPosition {listSize=6,
     *   listKey=0, anchorOffset=1}.
     */
    /**
     * @invariant Fire And Forget
     */
    virtual void setViewAnchor(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::AnchorOffset &_anchor, CommonAPI::CallStatus &_internalCallStatus) = 0;
};

} // namespace list
} // namespace common
} // namespace ctrl
} // namespace nav
} // namespace harman
} // namespace org
} // namespace v1


// Compatibility
namespace v1_0 = v1;

#endif // V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_List_View_Base_PROXY_BASE_HPP_
