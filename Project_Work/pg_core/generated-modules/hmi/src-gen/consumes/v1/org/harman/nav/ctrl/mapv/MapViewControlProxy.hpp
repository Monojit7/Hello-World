/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: MapViewerController = This interface offers functions to control the MapViewer
 */
#ifndef V1_ORG_HARMAN_NAV_CTRL_MAPV_Map_View_Control_PROXY_HPP_
#define V1_ORG_HARMAN_NAV_CTRL_MAPV_Map_View_Control_PROXY_HPP_

#include <v1/org/harman/nav/ctrl/mapv/MapViewControlProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace mapv {

template <typename ... _AttributeExtensions>
class MapViewControlProxy
    : virtual public MapViewControl, 
      virtual public MapViewControlProxyBase,
      virtual public _AttributeExtensions... {
public:
    MapViewControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~MapViewControlProxy();

    typedef MapViewControl InterfaceType;


    /**
     * Returns the wrapper class that provides access to the attribute status.
     */
    virtual StatusAttribute& getStatusAttribute() {
        return delegate_->getStatusAttribute();
    }

    /**
     * description: mapViewScaleChanged = This signal is emitted when the mapview scale changes
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mapViewScaleChanged.
     */
    virtual MapViewScaleChangedEvent& getMapViewScaleChangedEvent() {
        return delegate_->getMapViewScaleChangedEvent();
    }
    /**
     * description: mapViewVisibilityChanged = This signal is emitted when the MapView visibility
     *   changes
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mapViewVisibilityChanged.
     */
    virtual MapViewVisibilityChangedEvent& getMapViewVisibilityChangedEvent() {
        return delegate_->getMapViewVisibilityChangedEvent();
    }
    /**
     * description: displayedRoutes = This signal is emitted when the list of displayed routes
     *   change
     */
    /**
     * Returns the wrapper class that provides access to the broadcast displayedRoutes.
     */
    virtual DisplayedRoutesEvent& getDisplayedRoutesEvent() {
        return delegate_->getDisplayedRoutesEvent();
    }

    /**
     * description: GetVersion = This method returns the API version implemented by the server
     *   application
     * Calls getVersion with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getVersion(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getVersion with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getVersionAsync(GetVersionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: createMapViewInstance = This method creates a new map instance
     * Calls createMapViewInstance with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void createMapViewInstance(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Dimension &_mapViewSize, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewType &_mapViewType, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls createMapViewInstance with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> createMapViewInstanceAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Dimension &_mapViewSize, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewType &_mapViewType, CreateMapViewInstanceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: releaseMapViewInstance = This method releases (i.e. destroys) a given map
     *   instance. Only invisible map instances can be released
     * Calls releaseMapViewInstance with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void releaseMapViewInstance(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls releaseMapViewInstance with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> releaseMapViewInstanceAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, ReleaseMapViewInstanceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapViewType = This method returns the map type of a map instance as it was
     *   set using CreateMapViewInstance
     * Calls getMapViewType with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewType(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewType &_mapViewType, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewType with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewTypeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewTypeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getSupportedMapViewTypes = This method retrieves the supported map view types
     * Calls getSupportedMapViewTypes with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedMapViewTypes(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewType> &_mapViewTypeList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedMapViewTypes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedMapViewTypesAsync(GetSupportedMapViewTypesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setTargetPoint = This method sets the position of the point the camera is
     *   always aimed at
     * Calls setTargetPoint with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setTargetPoint(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_targetPoint, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setTargetPoint with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setTargetPointAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_targetPoint, SetTargetPointAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getTargetPoint = This method retrieves the target point position
     * Calls getTargetPoint with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getTargetPoint(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_targetPoint, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getTargetPoint with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getTargetPointAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetTargetPointAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setFollowCarMode = This method sets the FollowCar mode
     * Calls setFollowCarMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setFollowCarMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_followCarMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setFollowCarMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setFollowCarModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_followCarMode, SetFollowCarModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getFollowCarMode = This method returns the current FollowCar-mode
     * Calls getFollowCarMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getFollowCarMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, bool &_followCarMode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getFollowCarMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getFollowCarModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetFollowCarModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setCameraPosition = This method sets the coordinates of the point at which the
     *   camera must be positioned
     * Calls setCameraPosition with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setCameraPosition(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_position, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setCameraPosition with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setCameraPositionAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_position, SetCameraPositionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getCameraPosition = This method returns the coordinates of the point at which
     *   the camera is positioned
     * Calls getCameraPosition with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCameraPosition(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_position, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCameraPosition with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCameraPositionAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraPositionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setCameraHeadingAngle = This method sets the map view heading angle
     * Calls setCameraHeadingAngle with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setCameraHeadingAngle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_heading, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setCameraHeadingAngle with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setCameraHeadingAngleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_heading, SetCameraHeadingAngleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setCameraHeadingToTarget = This method sets the camera heading in such a way,
     *   that the camera always looks at a given target
     * Calls setCameraHeadingToTarget with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setCameraHeadingToTarget(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate2D &_target, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setCameraHeadingToTarget with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setCameraHeadingToTargetAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate2D &_target, SetCameraHeadingToTargetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setCameraHeadingTrackUp = This method sets the camera heading in such a way,
     *   that the camera always looks in the direction in which the car is moving
     * Calls setCameraHeadingTrackUp with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setCameraHeadingTrackUp(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setCameraHeadingTrackUp with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setCameraHeadingTrackUpAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, SetCameraHeadingTrackUpAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getCameraHeading = This method returns the current camera heading
     * Calls getCameraHeading with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCameraHeading(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, uint16_t &_headingType, int32_t &_headingAngle, ::org::harman::nav::ctrl::CommonTypes::Coordinate2D &_target, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCameraHeading with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCameraHeadingAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraHeadingAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setCameraTiltAngle = This method sets the camera tilt angle
     * Calls setCameraTiltAngle with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setCameraTiltAngle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_tilt, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setCameraTiltAngle with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setCameraTiltAngleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_tilt, SetCameraTiltAngleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getCameraTiltAngle = This method returns the camera tilt angle
     * Calls getCameraTiltAngle with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCameraTiltAngle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, int32_t &_tilt, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCameraTiltAngle with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCameraTiltAngleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraTiltAngleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setCameraRollAngle = This method sets the camera roll angle
     * Calls setCameraRollAngle with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setCameraRollAngle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_roll, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setCameraRollAngle with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setCameraRollAngleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_roll, SetCameraRollAngleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getCameraRollAngle = This method returns the camera roll angle
     * Calls getCameraRollAngle with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCameraRollAngle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, int32_t &_roll, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCameraRollAngle with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCameraRollAngleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraRollAngleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setCameraDistanceFromTargetPoint = This method sets the mode and the camera
     *   distance from the target point
     * Calls setCameraDistanceFromTargetPoint with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setCameraDistanceFromTargetPoint(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_distance, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setCameraDistanceFromTargetPoint with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setCameraDistanceFromTargetPointAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_distance, SetCameraDistanceFromTargetPointAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getCameraDistanceFromTargetPoint = This method gets the mode and the camera
     *   distance from the target point
     * Calls getCameraDistanceFromTargetPoint with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCameraDistanceFromTargetPoint(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_distance, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCameraDistanceFromTargetPoint with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCameraDistanceFromTargetPointAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraDistanceFromTargetPointAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewScaleMode = This method sets the scaling mode.
     * Calls setMapViewScaleMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewScaleMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScaleMode &_scaleMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewScaleMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewScaleModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScaleMode &_scaleMode, SetMapViewScaleModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapViewScaleMode = This method gets the scaling mode.
     * Calls getMapViewScaleMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewScaleMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScaleMode &_scaleMode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewScaleMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewScaleModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewScaleModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getSupportedMapViewScaleModes = This method gets the supported scaling modes.
     * Calls getSupportedMapViewScaleModes with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedMapViewScaleModes(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScaleMode> &_scaleModeList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedMapViewScaleModes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedMapViewScaleModesAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetSupportedMapViewScaleModesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: addMapViewScaleChangedListener = This method adds a listener which is notified
     *   when map view scale changes.
     * Calls addMapViewScaleChangedListener with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void addMapViewScaleChangedListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls addMapViewScaleChangedListener with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> addMapViewScaleChangedListenerAsync(AddMapViewScaleChangedListenerAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: removeMapViewScaleChangedListener = This method removes a listener which is
     *   notified when map view scale changes.
     * Calls removeMapViewScaleChangedListener with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void removeMapViewScaleChangedListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls removeMapViewScaleChangedListener with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> removeMapViewScaleChangedListenerAsync(RemoveMapViewScaleChangedListenerAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setCameraHeight = This method sets the camera height
     * Calls setCameraHeight with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setCameraHeight(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_height, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setCameraHeight with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setCameraHeightAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_height, SetCameraHeightAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getCameraHeight = This method gets the camera height
     * Calls getCameraHeight with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCameraHeight(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_height, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCameraHeight with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCameraHeightAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraHeightAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewPerspective = This method sets the map perspective
     * Calls setMapViewPerspective with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewPerspective(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapPerspective &_perspective, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewPerspective with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewPerspectiveAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapPerspective &_perspective, SetMapViewPerspectiveAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapViewPerspective = This method returns the current map perspective
     * Calls getMapViewPerspective with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewPerspective(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapPerspective &_perspective, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewPerspective with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewPerspectiveAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewPerspectiveAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getSupportedMapViewPerspectives = This method retrieves the supported mapview
     *   perspectives
     * Calls getSupportedMapViewPerspectives with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedMapViewPerspectives(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapPerspective> &_perspectiveList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedMapViewPerspectives with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedMapViewPerspectivesAsync(GetSupportedMapViewPerspectivesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewObjectVisibility = This method specifies the type of objects to show
     *   on the map.
     * Calls setMapViewObjectVisibility with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewObjectVisibility(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapObjectVisibility &_objectVisibilityList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewObjectVisibility with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewObjectVisibilityAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapObjectVisibility &_objectVisibilityList, SetMapViewObjectVisibilityAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapViewObjectVisibility = This method gets the type of objects shown on the
     *   map.
     * Calls getMapViewObjectVisibility with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewObjectVisibility(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapObjectVisibility &_objectVisibilityList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewObjectVisibility with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewObjectVisibilityAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewObjectVisibilityAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getSupportedMapViewObjectVisibilities = This method gets the supported object
     *   visibilities.
     * Calls getSupportedMapViewObjectVisibilities with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedMapViewObjectVisibilities(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapObject> &_objectVisibilityList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedMapViewObjectVisibilities with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedMapViewObjectVisibilitiesAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetSupportedMapViewObjectVisibilitiesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getScaleList = This method returns a list of supported map scales
     * Calls getScaleList with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getScaleList(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScale> &_scaleList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getScaleList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getScaleListAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetScaleListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewScale = This method sets the map scale by specifying a ScaleID
     * Calls setMapViewScale with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewScale(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint16_t &_scaleID, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewScale with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewScaleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint16_t &_scaleID, SetMapViewScaleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewScaleByDelta = This method sets the map scale by specifying a delta
     *   value with respect to the currently set ScaleID
     * Calls setMapViewScaleByDelta with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewScaleByDelta(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int16_t &_scaleDelta, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewScaleByDelta with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewScaleByDeltaAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int16_t &_scaleDelta, SetMapViewScaleByDeltaAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewScaleByMetersPerPixel = This method sets the map scale by specifying
     *   the number of meters that a pixel represents
     * Calls setMapViewScaleByMetersPerPixel with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewScaleByMetersPerPixel(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const double &_metersPerPixel, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewScaleByMetersPerPixel with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewScaleByMetersPerPixelAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const double &_metersPerPixel, SetMapViewScaleByMetersPerPixelAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapViewScale = This method returns the currently used map scale
     * Calls getMapViewScale with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewScale(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, int8_t &_scaleID, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScaleType &_isMinMax, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewScale with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewScaleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewScaleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewBoundingBox = This method sets the map bounding box
     * Calls setMapViewBoundingBox with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewBoundingBox(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_boundingBox, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewBoundingBox with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewBoundingBoxAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_boundingBox, SetMapViewBoundingBoxAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapViewBoundingBox = This method returns the bounding box of a given map
     *   instance
     * Calls getMapViewBoundingBox with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewBoundingBox(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_boundingBox, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewBoundingBox with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewBoundingBoxAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewBoundingBoxAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewSaveArea = This methods defines the area that the HMI guarantees not
     *   to 
    cover with other windows or user interface elements
     * Calls setMapViewSaveArea with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewSaveArea(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_saveArea, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewSaveArea with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewSaveAreaAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_saveArea, SetMapViewSaveAreaAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: SetMapViewSaveArea = This methods defines the area that the HMI guarantees not
     *   to 
    cover with other getMapViewSaveArea or user interface elements
     * Calls getMapViewSaveArea with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewSaveArea(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_saveArea, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewSaveArea with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewSaveAreaAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewSaveAreaAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewPan = This method pans a given map instance
     * Calls setMapViewPan with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewPan(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_systemMilisecondsTime, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::PanAction &_panningAction, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate> &_pixelCoordinates, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewPan with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewPanAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_systemMilisecondsTime, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::PanAction &_panningAction, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate> &_pixelCoordinates, SetMapViewPanAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewRotation = This method rotates the map
     * Calls setMapViewRotation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewRotation(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_rotationAngle, const int32_t &_rotationAnglePerSecond, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewRotation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewRotationAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_rotationAngle, const int32_t &_rotationAnglePerSecond, SetMapViewRotationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapViewRotation = This method is particularly interesting for debugging
     *   purposes
     * Calls getMapViewRotation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewRotation(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, int32_t &_rotationAngle, int32_t &_rotationAnglePerFrame, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewRotation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewRotationAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewRotationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewVisibilityMode = This method sets the current visibility mode
     * Calls setMapViewVisibilityMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewVisibilityMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Visibility &_visibilityMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewVisibilityMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewVisibilityModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Visibility &_visibilityMode, SetMapViewVisibilityModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapViewVisibilityMode = This method returns the current visibility mode
     * Calls getMapViewVisibilityMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewVisibilityMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Visibility &_visibilityMode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewVisibilityMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewVisibilityModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewVisibilityModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getSupportedMapViewVisibilityModes = This method retrieves the supported
     *   mapview visibility modes
     * Calls getSupportedMapViewVisibilityModes with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedMapViewVisibilityModes(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Visibility> &_visibilityModeList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedMapViewVisibilityModes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedMapViewVisibilityModesAsync(GetSupportedMapViewVisibilityModesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewPerformanceLevel = This method sets the perfomance level of a given
     *   map instance
     * Calls setMapViewPerformanceLevel with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewPerformanceLevel(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Level &_performanceLevel, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewPerformanceLevel with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewPerformanceLevelAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Level &_performanceLevel, SetMapViewPerformanceLevelAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapViewPerformanceLevel = This method returns the perfomance level of a
     *   given map instance
     * Calls getMapViewPerformanceLevel with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewPerformanceLevel(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Level &_performanceLevel, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewPerformanceLevel with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewPerformanceLevelAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewPerformanceLevelAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getSupportedMapViewPerformanceLevels = This method retrieves the supported
     *   perfomance levels
     * Calls getSupportedMapViewPerformanceLevels with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedMapViewPerformanceLevels(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Level> &_performanceLevelList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedMapViewPerformanceLevels with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedMapViewPerformanceLevelsAsync(GetSupportedMapViewPerformanceLevelsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: displayRoute = This method visualizes one of the calculated routes
     * Calls displayRoute with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void displayRoute(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_routeHandle, const bool &_highlighted, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls displayRoute with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> displayRouteAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_routeHandle, const bool &_highlighted, DisplayRouteAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: hideRoute = This method hides one of the visible routes
     * Calls hideRoute with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hideRoute(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hideRoute with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hideRouteAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_routeHandle, HideRouteAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getDisplayedRoutes = This method returns a list of displayed routes
     * Calls getDisplayedRoutes with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getDisplayedRoutes(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::DisplayedRoute> &_displayedRoutes, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getDisplayedRoutes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getDisplayedRoutesAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetDisplayedRoutesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: addKml = add Kml Content to MapViewer
     * Calls addKml with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void addKml(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::KmlType &_kmlType, const std::string &_kml, const bool &_show, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Handle &_kmlHandle, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls addKml with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> addKmlAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::KmlType &_kmlType, const std::string &_kml, const bool &_show, AddKmlAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: deleteKml = deletes (and hides) Kml Content to MapViewer
     * Calls deleteKml with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteKml(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_kmlHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteKml with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deleteKmlAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_kmlHandle, DeleteKmlAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setKmlVisibility = shows/hides a kmlFile (without deleting it actually)
     * Calls setKmlVisibility with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setKmlVisibility(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_kmlHandle, const bool &_show, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setKmlVisibility with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setKmlVisibilityAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_kmlHandle, const bool &_show, SetKmlVisibilityAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: pushSettings = stores the current map-ctrl setting (scale, orientation, visible
     *   objects ...) to an internal stack
     * Calls pushSettings with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void pushSettings(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls pushSettings with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> pushSettingsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, PushSettingsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: popSettings = re-stores the current map-ctrl setting (scale, orientation,
     *   visible objects ...) from the stack (called after pushSetting)
     * Calls popSettings with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void popSettings(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls popSettings with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> popSettingsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, PopSettingsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: resetSettings = resets the mapInstance to a dedicated state (same as startup)
     * Calls resetSettings with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void resetSettings(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls resetSettings with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> resetSettingsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, ResetSettingsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: displayObjectList = This method visualizes a list of objects, created in
     *   another domain
     * Calls displayObjectList with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void displayObjectList(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectList &_objectList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls displayObjectList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> displayObjectListAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectList &_objectList, DisplayObjectListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: hideObjectList = This method hides a list of objects, created in another domain
     * Calls hideObjectList with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hideObjectList(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectList &_objectList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hideObjectList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hideObjectListAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectList &_objectList, HideObjectListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: highlightObjectListItem = highlights exclusively a various number of items
     *   within an objectList. For unhighlight all, objectListItems is empty
     * Calls highlightObjectListItem with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void highlightObjectListItem(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectListItem> &_objectListItems, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls highlightObjectListItem with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> highlightObjectListItemAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectListItem> &_objectListItems, HighlightObjectListItemAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: centerOnObjectListItems = This method shows an overview map with the current
     *   route in the center
     * Calls centerOnObjectListItems with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void centerOnObjectListItems(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectListItem> &_objectListItems, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls centerOnObjectListItems with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> centerOnObjectListItemsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectListItem> &_objectListItems, CenterOnObjectListItemsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getPoiCategoriesVisible = Get the set of POI categories displayed on the map.
     * Calls getPoiCategoriesVisible with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getPoiCategoriesVisible(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<uint32_t> &_poiCategoryIds, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPoiCategoriesVisible with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getPoiCategoriesVisibleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetPoiCategoriesVisibleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setPoiCategoriesVisible = Add POI categories to the set of POI categories
     *   displayed on the map.
                       Any specified category that until now
     *   was displayed with scale limits is now displayed without limits.
     * Calls setPoiCategoriesVisible with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setPoiCategoriesVisible(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setPoiCategoriesVisible with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setPoiCategoriesVisibleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, SetPoiCategoriesVisibleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setPoiCategoriesVisibleMode = gives the possibility to show or hide all POI
     *   categories regardsless of
                       of which one are enabled with
     *   setPoiCategoriesVisible/setPoiCategoriesNotVisible.
                       The
     *   selection which is done with
     *   setPoiCategoriesVisible/setPoiCategoriesNotVisible is not changed by this
     *   command.
     * Calls setPoiCategoriesVisibleMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setPoiCategoriesVisibleMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::PoiCategoriesVisibleMode &_poiCategoriesVisibleMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setPoiCategoriesVisibleMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setPoiCategoriesVisibleModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::PoiCategoriesVisibleMode &_poiCategoriesVisibleMode, SetPoiCategoriesVisibleModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setPoiCategoriesVisible = Add POI categories to the set of POI categories
     *   displayed on the map, where the POI's are only displayed in a specific range
     *   of scales.
                       Any specified category that until now was
     *   displayed without scale limits is now displayed with limits.
     * Calls setPoiCategoriesVisibleWithinLimits with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setPoiCategoriesVisibleWithinLimits(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, const int8_t &_minScaleID, const int8_t &_maxScaleID, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setPoiCategoriesVisibleWithinLimits with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setPoiCategoriesVisibleWithinLimitsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, const int8_t &_minScaleID, const int8_t &_maxScaleID, SetPoiCategoriesVisibleWithinLimitsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setPoiCategoriesNotVisible = Remove POI categories from the set of POI
     *   categories displayed on the map.
     * Calls setPoiCategoriesNotVisible with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setPoiCategoriesNotVisible(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setPoiCategoriesNotVisible with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setPoiCategoriesNotVisibleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, SetPoiCategoriesNotVisibleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setTrafficIncidentsVisibility = Set the visibility of Traffic Incidents on the
     *   map.
     * Calls setTrafficIncidentsVisibility with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setTrafficIncidentsVisibility(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_visible, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setTrafficIncidentsVisibility with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setTrafficIncidentsVisibilityAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_visible, SetTrafficIncidentsVisibilityAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapViewTheme = This method configures the theme of a given map view instance
     * Calls setMapViewTheme with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapViewTheme(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapTheme &_mapViewTheme, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapViewTheme with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapViewThemeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapTheme &_mapViewTheme, SetMapViewThemeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapViewTheme = This method returns the current theme of a given map view
     *   instance
     * Calls getMapViewTheme with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapViewTheme(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapTheme &_mapViewTheme, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapViewTheme with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapViewThemeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewThemeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getSupportedMapViewThemes = This method retrieves the supported mapview themes
     * Calls getSupportedMapViewThemes with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedMapViewThemes(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapTheme> &_mapViewThemeList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedMapViewThemes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedMapViewThemesAsync(GetSupportedMapViewThemesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: convertPixelCoordsToGeoCoords = This method converts pixel coordinates to
     *   geographical coordinates
     * Calls convertPixelCoordsToGeoCoords with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void convertPixelCoordsToGeoCoords(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Pixel> &_pixelCoordinates, CommonAPI::CallStatus &_internalCallStatus, std::vector<::org::harman::nav::ctrl::CommonTypes::Coordinate2D> &_geoCoordinates, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls convertPixelCoordsToGeoCoords with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> convertPixelCoordsToGeoCoordsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Pixel> &_pixelCoordinates, ConvertPixelCoordsToGeoCoordsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: convertGeoCoordsToPixelCoords = This method converts geographical coordinates
     *   into pixel coordinates
     * Calls convertGeoCoordsToPixelCoords with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void convertGeoCoordsToPixelCoords(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::org::harman::nav::ctrl::CommonTypes::Coordinate2D> &_geoCoordinates, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Pixel> &_pixelCoordinates, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls convertGeoCoordsToPixelCoords with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> convertGeoCoordsToPixelCoordsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::org::harman::nav::ctrl::CommonTypes::Coordinate2D> &_geoCoordinates, ConvertGeoCoordsToPixelCoordsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: displayCustomElements = This method visualizes a set of custom elements on the
     *   map
     * Calls displayCustomElements with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void displayCustomElements(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::CustomElement> &_customElements, CommonAPI::CallStatus &_internalCallStatus, std::vector<::org::harman::nav::ctrl::CommonTypes::Handle> &_customElemenHandles, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls displayCustomElements with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> displayCustomElementsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::CustomElement> &_customElements, DisplayCustomElementsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: hideCustomElements = This method hides a set of custom elements which were
     *   visualized by DisplayCustomElements
     * Calls hideCustomElements with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hideCustomElements(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::org::harman::nav::ctrl::CommonTypes::Handle> &_customElemenHandles, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hideCustomElements with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hideCustomElementsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::org::harman::nav::ctrl::CommonTypes::Handle> &_customElemenHandles, HideCustomElementsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getDisplayedCustomElements = This method retrieves the visualized custom
     *   elements on the map
     * Calls getDisplayedCustomElements with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getDisplayedCustomElements(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::tCustomElementDict &_customElements, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getDisplayedCustomElements with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getDisplayedCustomElementsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetDisplayedCustomElementsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: selectElementsOnMap = This method selects elements on the map view which are at
     *   the position specified by user input
     * Calls selectElementsOnMap with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void selectElementsOnMap(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Pixel &_pixelCoordinate, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::SelectableMapType> &_selectableTypes, const uint16_t &_maxNumberOfSelectedElements, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::SelectedMapElement> &_selectedElements, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls selectElementsOnMap with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> selectElementsOnMapAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Pixel &_pixelCoordinate, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::SelectableMapType> &_selectableTypes, const uint16_t &_maxNumberOfSelectedElements, SelectElementsOnMapAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: mapViewGesture = This method is a compound gesture command
     * Calls mapViewGesture with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void mapViewGesture(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_systemMilisecondsTime, const bool &_isFingerDown, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate &_anchorScreen, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate &_scrollOffset, const double &_zoomFactor, const double &_rotationAngle, const double &_pitchAngle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls mapViewGesture with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> mapViewGestureAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_systemMilisecondsTime, const bool &_isFingerDown, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate &_anchorScreen, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate &_scrollOffset, const double &_zoomFactor, const double &_rotationAngle, const double &_pitchAngle, MapViewGestureAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: mapShowRouteOverview = This method shows an overview map with the current route
     *   in the center
     * Calls mapShowRouteOverview with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void mapShowRouteOverview(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_routeId, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewOrientation &_orientation, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls mapShowRouteOverview with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> mapShowRouteOverviewAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_routeId, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewOrientation &_orientation, MapShowRouteOverviewAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: mapSetStyle = Changes the StyleSet of the MapViewer. e.g. day/night switch
     * Calls mapSetStyle with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void mapSetStyle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewStyleSet &_styleSet, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls mapSetStyle with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> mapSetStyleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewStyleSet &_styleSet, MapSetStyleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getMapModeList = This method returns a list of supported map modes
     * Calls getMapModeList with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapModeList(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<std::string> &_mapModeList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapModeList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapModeListAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapModeListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setMapMode = This method sets the map mode (String-datatype, could be
     *   hard-coded in HMI if controller is known)
     * Calls setMapMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMapMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::string &_mapMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMapMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMapModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::string &_mapMode, SetMapModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMapMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::string &_mapMode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMapMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMapModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setAutozoomSetting with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setAutozoomSetting(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::AutozoomSetting &_autozoomSetting, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setAutozoomSetting with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setAutozoomSettingAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::AutozoomSetting &_autozoomSetting, SetAutozoomSettingAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getAutozoomSetting with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getAutozoomSetting(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::AutozoomSetting &_autozoomSetting, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getAutozoomSetting with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getAutozoomSettingAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetAutozoomSettingAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setAutozoomEnabled with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setAutozoomEnabled(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_enabled, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setAutozoomEnabled with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setAutozoomEnabledAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_enabled, SetAutozoomEnabledAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getAutozoomEnabled with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getAutozoomEnabled(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, bool &_enabled, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getAutozoomEnabled with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getAutozoomEnabledAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetAutozoomEnabledAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<MapViewControlProxyBase> delegate_;
};

typedef MapViewControlProxy<> MapViewControlProxyDefault;

namespace MapViewControlExtensions {
    template <template <typename > class _ExtensionType>
    class StatusAttributeExtension {
     public:
        typedef _ExtensionType<MapViewControlProxyBase::StatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<MapViewControlProxyBase::StatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        StatusAttributeExtension() {}
    #endif
    
        StatusAttributeExtension(MapViewControlProxyBase& proxy): attributeExtension_(proxy.getStatusAttribute()) {
        }
    
        inline extension_type& getStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace MapViewControlExtensions

//
// MapViewControlProxy Implementation
//
template <typename ... _AttributeExtensions>
MapViewControlProxy<_AttributeExtensions...>::MapViewControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<MapViewControlProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<MapViewControlProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
MapViewControlProxy<_AttributeExtensions...>::~MapViewControlProxy() {
}

/**
 * description: GetVersion = This method returns the API version implemented by the server
 *   application
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getVersion(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info) {
    delegate_->getVersion(_internalCallStatus, _version, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getVersionAsync(GetVersionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getVersionAsync(_callback, _info);
}
/**
 * description: createMapViewInstance = This method creates a new map instance
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::createMapViewInstance(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Dimension &_mapViewSize, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewType &_mapViewType, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const CommonAPI::CallInfo *_info) {
    if (!_mapViewType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->createMapViewInstance(_sessionHandle, _mapViewSize, _mapViewType, _internalCallStatus, _mapViewInstanceHandle, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::createMapViewInstanceAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Dimension &_mapViewSize, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewType &_mapViewType, CreateMapViewInstanceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_mapViewType.validate()) {
        ::org::harman::nav::ctrl::CommonTypes::Handle mapViewInstanceHandle = 0ul;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, mapViewInstanceHandle);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->createMapViewInstanceAsync(_sessionHandle, _mapViewSize, _mapViewType, _callback, _info);
}
/**
 * description: releaseMapViewInstance = This method releases (i.e. destroys) a given map
 *   instance. Only invisible map instances can be released
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::releaseMapViewInstance(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->releaseMapViewInstance(_sessionHandle, _mapViewInstanceHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::releaseMapViewInstanceAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, ReleaseMapViewInstanceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->releaseMapViewInstanceAsync(_sessionHandle, _mapViewInstanceHandle, _callback, _info);
}
/**
 * description: getMapViewType = This method returns the map type of a map instance as it was
 *   set using CreateMapViewInstance
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewType(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewType &_mapViewType, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewType(_mapViewInstanceHandle, _internalCallStatus, _mapViewType, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewTypeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewTypeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewTypeAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: getSupportedMapViewTypes = This method retrieves the supported map view types
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewTypes(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewType> &_mapViewTypeList, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedMapViewTypes(_internalCallStatus, _mapViewTypeList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewTypesAsync(GetSupportedMapViewTypesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedMapViewTypesAsync(_callback, _info);
}
/**
 * description: setTargetPoint = This method sets the position of the point the camera is
 *   always aimed at
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setTargetPoint(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_targetPoint, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setTargetPoint(_sessionHandle, _mapViewInstanceHandle, _targetPoint, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setTargetPointAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_targetPoint, SetTargetPointAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setTargetPointAsync(_sessionHandle, _mapViewInstanceHandle, _targetPoint, _callback, _info);
}
/**
 * description: getTargetPoint = This method retrieves the target point position
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getTargetPoint(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_targetPoint, const CommonAPI::CallInfo *_info) {
    delegate_->getTargetPoint(_mapViewInstanceHandle, _internalCallStatus, _targetPoint, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getTargetPointAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetTargetPointAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getTargetPointAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setFollowCarMode = This method sets the FollowCar mode
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setFollowCarMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_followCarMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setFollowCarMode(_sessionHandle, _mapViewInstanceHandle, _followCarMode, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setFollowCarModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_followCarMode, SetFollowCarModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setFollowCarModeAsync(_sessionHandle, _mapViewInstanceHandle, _followCarMode, _callback, _info);
}
/**
 * description: getFollowCarMode = This method returns the current FollowCar-mode
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getFollowCarMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, bool &_followCarMode, const CommonAPI::CallInfo *_info) {
    delegate_->getFollowCarMode(_mapViewInstanceHandle, _internalCallStatus, _followCarMode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getFollowCarModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetFollowCarModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getFollowCarModeAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setCameraPosition = This method sets the coordinates of the point at which the
 *   camera must be positioned
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setCameraPosition(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_position, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setCameraPosition(_sessionHandle, _mapViewInstanceHandle, _position, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setCameraPositionAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_position, SetCameraPositionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setCameraPositionAsync(_sessionHandle, _mapViewInstanceHandle, _position, _callback, _info);
}
/**
 * description: getCameraPosition = This method returns the coordinates of the point at which
 *   the camera is positioned
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getCameraPosition(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_position, const CommonAPI::CallInfo *_info) {
    delegate_->getCameraPosition(_mapViewInstanceHandle, _internalCallStatus, _position, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getCameraPositionAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraPositionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCameraPositionAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setCameraHeadingAngle = This method sets the map view heading angle
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setCameraHeadingAngle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_heading, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setCameraHeadingAngle(_sessionHandle, _mapViewInstanceHandle, _heading, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setCameraHeadingAngleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_heading, SetCameraHeadingAngleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setCameraHeadingAngleAsync(_sessionHandle, _mapViewInstanceHandle, _heading, _callback, _info);
}
/**
 * description: setCameraHeadingToTarget = This method sets the camera heading in such a way,
 *   that the camera always looks at a given target
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setCameraHeadingToTarget(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate2D &_target, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setCameraHeadingToTarget(_sessionHandle, _mapViewInstanceHandle, _target, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setCameraHeadingToTargetAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Coordinate2D &_target, SetCameraHeadingToTargetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setCameraHeadingToTargetAsync(_sessionHandle, _mapViewInstanceHandle, _target, _callback, _info);
}
/**
 * description: setCameraHeadingTrackUp = This method sets the camera heading in such a way,
 *   that the camera always looks in the direction in which the car is moving
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setCameraHeadingTrackUp(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setCameraHeadingTrackUp(_sessionHandle, _mapViewInstanceHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setCameraHeadingTrackUpAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, SetCameraHeadingTrackUpAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setCameraHeadingTrackUpAsync(_sessionHandle, _mapViewInstanceHandle, _callback, _info);
}
/**
 * description: getCameraHeading = This method returns the current camera heading
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getCameraHeading(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, uint16_t &_headingType, int32_t &_headingAngle, ::org::harman::nav::ctrl::CommonTypes::Coordinate2D &_target, const CommonAPI::CallInfo *_info) {
    delegate_->getCameraHeading(_mapViewInstanceHandle, _internalCallStatus, _headingType, _headingAngle, _target, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getCameraHeadingAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraHeadingAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCameraHeadingAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setCameraTiltAngle = This method sets the camera tilt angle
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setCameraTiltAngle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_tilt, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setCameraTiltAngle(_sessionHandle, _mapViewInstanceHandle, _tilt, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setCameraTiltAngleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_tilt, SetCameraTiltAngleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setCameraTiltAngleAsync(_sessionHandle, _mapViewInstanceHandle, _tilt, _callback, _info);
}
/**
 * description: getCameraTiltAngle = This method returns the camera tilt angle
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getCameraTiltAngle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, int32_t &_tilt, const CommonAPI::CallInfo *_info) {
    delegate_->getCameraTiltAngle(_mapViewInstanceHandle, _internalCallStatus, _tilt, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getCameraTiltAngleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraTiltAngleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCameraTiltAngleAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setCameraRollAngle = This method sets the camera roll angle
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setCameraRollAngle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_roll, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setCameraRollAngle(_sessionHandle, _mapViewInstanceHandle, _roll, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setCameraRollAngleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_roll, SetCameraRollAngleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setCameraRollAngleAsync(_sessionHandle, _mapViewInstanceHandle, _roll, _callback, _info);
}
/**
 * description: getCameraRollAngle = This method returns the camera roll angle
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getCameraRollAngle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, int32_t &_roll, const CommonAPI::CallInfo *_info) {
    delegate_->getCameraRollAngle(_mapViewInstanceHandle, _internalCallStatus, _roll, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getCameraRollAngleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraRollAngleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCameraRollAngleAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setCameraDistanceFromTargetPoint = This method sets the mode and the camera
 *   distance from the target point
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setCameraDistanceFromTargetPoint(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_distance, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setCameraDistanceFromTargetPoint(_sessionHandle, _mapViewInstanceHandle, _distance, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setCameraDistanceFromTargetPointAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_distance, SetCameraDistanceFromTargetPointAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setCameraDistanceFromTargetPointAsync(_sessionHandle, _mapViewInstanceHandle, _distance, _callback, _info);
}
/**
 * description: getCameraDistanceFromTargetPoint = This method gets the mode and the camera
 *   distance from the target point
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getCameraDistanceFromTargetPoint(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_distance, const CommonAPI::CallInfo *_info) {
    delegate_->getCameraDistanceFromTargetPoint(_mapViewInstanceHandle, _internalCallStatus, _distance, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getCameraDistanceFromTargetPointAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraDistanceFromTargetPointAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCameraDistanceFromTargetPointAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setMapViewScaleMode = This method sets the scaling mode.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewScaleMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScaleMode &_scaleMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_scaleMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setMapViewScaleMode(_sessionHandle, _mapViewInstanceHandle, _scaleMode, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewScaleModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScaleMode &_scaleMode, SetMapViewScaleModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_scaleMode.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setMapViewScaleModeAsync(_sessionHandle, _mapViewInstanceHandle, _scaleMode, _callback, _info);
}
/**
 * description: getMapViewScaleMode = This method gets the scaling mode.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewScaleMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScaleMode &_scaleMode, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewScaleMode(_mapViewInstanceHandle, _internalCallStatus, _scaleMode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewScaleModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewScaleModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewScaleModeAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: getSupportedMapViewScaleModes = This method gets the supported scaling modes.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewScaleModes(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScaleMode> &_scaleModeList, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedMapViewScaleModes(_mapViewInstanceHandle, _internalCallStatus, _scaleModeList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewScaleModesAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetSupportedMapViewScaleModesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedMapViewScaleModesAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: addMapViewScaleChangedListener = This method adds a listener which is notified
 *   when map view scale changes.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::addMapViewScaleChangedListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->addMapViewScaleChangedListener(_internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::addMapViewScaleChangedListenerAsync(AddMapViewScaleChangedListenerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->addMapViewScaleChangedListenerAsync(_callback, _info);
}
/**
 * description: removeMapViewScaleChangedListener = This method removes a listener which is
 *   notified when map view scale changes.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::removeMapViewScaleChangedListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->removeMapViewScaleChangedListener(_internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::removeMapViewScaleChangedListenerAsync(RemoveMapViewScaleChangedListenerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->removeMapViewScaleChangedListenerAsync(_callback, _info);
}
/**
 * description: setCameraHeight = This method sets the camera height
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setCameraHeight(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_height, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setCameraHeight(_sessionHandle, _mapViewInstanceHandle, _height, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setCameraHeightAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_height, SetCameraHeightAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setCameraHeightAsync(_sessionHandle, _mapViewInstanceHandle, _height, _callback, _info);
}
/**
 * description: getCameraHeight = This method gets the camera height
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getCameraHeight(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_height, const CommonAPI::CallInfo *_info) {
    delegate_->getCameraHeight(_mapViewInstanceHandle, _internalCallStatus, _height, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getCameraHeightAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetCameraHeightAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCameraHeightAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setMapViewPerspective = This method sets the map perspective
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewPerspective(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapPerspective &_perspective, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_perspective.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setMapViewPerspective(_sessionHandle, _mapViewInstanceHandle, _perspective, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewPerspectiveAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapPerspective &_perspective, SetMapViewPerspectiveAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_perspective.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setMapViewPerspectiveAsync(_sessionHandle, _mapViewInstanceHandle, _perspective, _callback, _info);
}
/**
 * description: getMapViewPerspective = This method returns the current map perspective
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewPerspective(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapPerspective &_perspective, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewPerspective(_mapViewInstanceHandle, _internalCallStatus, _perspective, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewPerspectiveAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewPerspectiveAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewPerspectiveAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: getSupportedMapViewPerspectives = This method retrieves the supported mapview
 *   perspectives
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewPerspectives(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapPerspective> &_perspectiveList, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedMapViewPerspectives(_internalCallStatus, _perspectiveList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewPerspectivesAsync(GetSupportedMapViewPerspectivesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedMapViewPerspectivesAsync(_callback, _info);
}
/**
 * description: setMapViewObjectVisibility = This method specifies the type of objects to show
 *   on the map.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewObjectVisibility(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapObjectVisibility &_objectVisibilityList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setMapViewObjectVisibility(_sessionHandle, _mapViewInstanceHandle, _objectVisibilityList, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewObjectVisibilityAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapObjectVisibility &_objectVisibilityList, SetMapViewObjectVisibilityAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMapViewObjectVisibilityAsync(_sessionHandle, _mapViewInstanceHandle, _objectVisibilityList, _callback, _info);
}
/**
 * description: getMapViewObjectVisibility = This method gets the type of objects shown on the
 *   map.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewObjectVisibility(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapObjectVisibility &_objectVisibilityList, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewObjectVisibility(_mapViewInstanceHandle, _internalCallStatus, _objectVisibilityList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewObjectVisibilityAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewObjectVisibilityAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewObjectVisibilityAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: getSupportedMapViewObjectVisibilities = This method gets the supported object
 *   visibilities.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewObjectVisibilities(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapObject> &_objectVisibilityList, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedMapViewObjectVisibilities(_mapViewInstanceHandle, _internalCallStatus, _objectVisibilityList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewObjectVisibilitiesAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetSupportedMapViewObjectVisibilitiesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedMapViewObjectVisibilitiesAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: getScaleList = This method returns a list of supported map scales
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getScaleList(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScale> &_scaleList, const CommonAPI::CallInfo *_info) {
    delegate_->getScaleList(_mapViewInstanceHandle, _internalCallStatus, _scaleList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getScaleListAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetScaleListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getScaleListAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setMapViewScale = This method sets the map scale by specifying a ScaleID
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewScale(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint16_t &_scaleID, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setMapViewScale(_sessionHandle, _mapViewInstanceHandle, _scaleID, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewScaleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint16_t &_scaleID, SetMapViewScaleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMapViewScaleAsync(_sessionHandle, _mapViewInstanceHandle, _scaleID, _callback, _info);
}
/**
 * description: setMapViewScaleByDelta = This method sets the map scale by specifying a delta
 *   value with respect to the currently set ScaleID
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewScaleByDelta(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int16_t &_scaleDelta, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setMapViewScaleByDelta(_sessionHandle, _mapViewInstanceHandle, _scaleDelta, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewScaleByDeltaAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int16_t &_scaleDelta, SetMapViewScaleByDeltaAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMapViewScaleByDeltaAsync(_sessionHandle, _mapViewInstanceHandle, _scaleDelta, _callback, _info);
}
/**
 * description: setMapViewScaleByMetersPerPixel = This method sets the map scale by specifying
 *   the number of meters that a pixel represents
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewScaleByMetersPerPixel(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const double &_metersPerPixel, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setMapViewScaleByMetersPerPixel(_sessionHandle, _mapViewInstanceHandle, _metersPerPixel, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewScaleByMetersPerPixelAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const double &_metersPerPixel, SetMapViewScaleByMetersPerPixelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMapViewScaleByMetersPerPixelAsync(_sessionHandle, _mapViewInstanceHandle, _metersPerPixel, _callback, _info);
}
/**
 * description: getMapViewScale = This method returns the currently used map scale
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewScale(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, int8_t &_scaleID, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapScaleType &_isMinMax, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewScale(_mapViewInstanceHandle, _internalCallStatus, _scaleID, _isMinMax, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewScaleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewScaleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewScaleAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setMapViewBoundingBox = This method sets the map bounding box
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewBoundingBox(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_boundingBox, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setMapViewBoundingBox(_sessionHandle, _mapViewInstanceHandle, _boundingBox, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewBoundingBoxAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_boundingBox, SetMapViewBoundingBoxAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMapViewBoundingBoxAsync(_sessionHandle, _mapViewInstanceHandle, _boundingBox, _callback, _info);
}
/**
 * description: getMapViewBoundingBox = This method returns the bounding box of a given map
 *   instance
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewBoundingBox(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_boundingBox, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewBoundingBox(_mapViewInstanceHandle, _internalCallStatus, _boundingBox, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewBoundingBoxAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewBoundingBoxAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewBoundingBoxAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setMapViewSaveArea = This methods defines the area that the HMI guarantees not
 *   to 
cover with other windows or user interface elements
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewSaveArea(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_saveArea, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setMapViewSaveArea(_sessionHandle, _mapViewInstanceHandle, _saveArea, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewSaveAreaAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_saveArea, SetMapViewSaveAreaAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMapViewSaveAreaAsync(_sessionHandle, _mapViewInstanceHandle, _saveArea, _callback, _info);
}
/**
 * description: SetMapViewSaveArea = This methods defines the area that the HMI guarantees not
 *   to 
cover with other getMapViewSaveArea or user interface elements
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewSaveArea(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenRectangle &_saveArea, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewSaveArea(_mapViewInstanceHandle, _internalCallStatus, _saveArea, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewSaveAreaAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewSaveAreaAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewSaveAreaAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setMapViewPan = This method pans a given map instance
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewPan(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_systemMilisecondsTime, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::PanAction &_panningAction, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate> &_pixelCoordinates, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_panningAction.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setMapViewPan(_sessionHandle, _mapViewInstanceHandle, _systemMilisecondsTime, _panningAction, _pixelCoordinates, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewPanAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_systemMilisecondsTime, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::PanAction &_panningAction, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate> &_pixelCoordinates, SetMapViewPanAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_panningAction.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setMapViewPanAsync(_sessionHandle, _mapViewInstanceHandle, _systemMilisecondsTime, _panningAction, _pixelCoordinates, _callback, _info);
}
/**
 * description: setMapViewRotation = This method rotates the map
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewRotation(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_rotationAngle, const int32_t &_rotationAnglePerSecond, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setMapViewRotation(_sessionHandle, _mapViewInstanceHandle, _rotationAngle, _rotationAnglePerSecond, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewRotationAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_rotationAngle, const int32_t &_rotationAnglePerSecond, SetMapViewRotationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMapViewRotationAsync(_sessionHandle, _mapViewInstanceHandle, _rotationAngle, _rotationAnglePerSecond, _callback, _info);
}
/**
 * description: getMapViewRotation = This method is particularly interesting for debugging
 *   purposes
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewRotation(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, int32_t &_rotationAngle, int32_t &_rotationAnglePerFrame, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewRotation(_mapViewInstanceHandle, _internalCallStatus, _rotationAngle, _rotationAnglePerFrame, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewRotationAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewRotationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewRotationAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setMapViewVisibilityMode = This method sets the current visibility mode
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewVisibilityMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Visibility &_visibilityMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_visibilityMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setMapViewVisibilityMode(_sessionHandle, _mapViewInstanceHandle, _visibilityMode, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewVisibilityModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Visibility &_visibilityMode, SetMapViewVisibilityModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_visibilityMode.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setMapViewVisibilityModeAsync(_sessionHandle, _mapViewInstanceHandle, _visibilityMode, _callback, _info);
}
/**
 * description: getMapViewVisibilityMode = This method returns the current visibility mode
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewVisibilityMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Visibility &_visibilityMode, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewVisibilityMode(_mapViewInstanceHandle, _internalCallStatus, _visibilityMode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewVisibilityModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewVisibilityModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewVisibilityModeAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: getSupportedMapViewVisibilityModes = This method retrieves the supported
 *   mapview visibility modes
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewVisibilityModes(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Visibility> &_visibilityModeList, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedMapViewVisibilityModes(_internalCallStatus, _visibilityModeList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewVisibilityModesAsync(GetSupportedMapViewVisibilityModesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedMapViewVisibilityModesAsync(_callback, _info);
}
/**
 * description: setMapViewPerformanceLevel = This method sets the perfomance level of a given
 *   map instance
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewPerformanceLevel(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Level &_performanceLevel, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_performanceLevel.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setMapViewPerformanceLevel(_sessionHandle, _mapViewInstanceHandle, _performanceLevel, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewPerformanceLevelAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Level &_performanceLevel, SetMapViewPerformanceLevelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_performanceLevel.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setMapViewPerformanceLevelAsync(_sessionHandle, _mapViewInstanceHandle, _performanceLevel, _callback, _info);
}
/**
 * description: getMapViewPerformanceLevel = This method returns the perfomance level of a
 *   given map instance
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewPerformanceLevel(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Level &_performanceLevel, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewPerformanceLevel(_mapViewInstanceHandle, _internalCallStatus, _performanceLevel, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewPerformanceLevelAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewPerformanceLevelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewPerformanceLevelAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: getSupportedMapViewPerformanceLevels = This method retrieves the supported
 *   perfomance levels
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewPerformanceLevels(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Level> &_performanceLevelList, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedMapViewPerformanceLevels(_internalCallStatus, _performanceLevelList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewPerformanceLevelsAsync(GetSupportedMapViewPerformanceLevelsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedMapViewPerformanceLevelsAsync(_callback, _info);
}
/**
 * description: displayRoute = This method visualizes one of the calculated routes
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::displayRoute(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_routeHandle, const bool &_highlighted, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->displayRoute(_sessionHandle, _mapViewInstanceHandle, _routeHandle, _highlighted, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::displayRouteAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_routeHandle, const bool &_highlighted, DisplayRouteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->displayRouteAsync(_sessionHandle, _mapViewInstanceHandle, _routeHandle, _highlighted, _callback, _info);
}
/**
 * description: hideRoute = This method hides one of the visible routes
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::hideRoute(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->hideRoute(_sessionHandle, _mapViewInstanceHandle, _routeHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::hideRouteAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_routeHandle, HideRouteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->hideRouteAsync(_sessionHandle, _mapViewInstanceHandle, _routeHandle, _callback, _info);
}
/**
 * description: getDisplayedRoutes = This method returns a list of displayed routes
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getDisplayedRoutes(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::DisplayedRoute> &_displayedRoutes, const CommonAPI::CallInfo *_info) {
    delegate_->getDisplayedRoutes(_mapViewInstanceHandle, _internalCallStatus, _displayedRoutes, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getDisplayedRoutesAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetDisplayedRoutesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getDisplayedRoutesAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: addKml = add Kml Content to MapViewer
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::addKml(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::KmlType &_kmlType, const std::string &_kml, const bool &_show, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Handle &_kmlHandle, const CommonAPI::CallInfo *_info) {
    if (!_kmlType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->addKml(_sessionHandle, _mapViewInstanceHandle, _kmlType, _kml, _show, _internalCallStatus, _kmlHandle, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::addKmlAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::KmlType &_kmlType, const std::string &_kml, const bool &_show, AddKmlAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_kmlType.validate()) {
        ::org::harman::nav::ctrl::CommonTypes::Handle kmlHandle = 0ul;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, kmlHandle);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->addKmlAsync(_sessionHandle, _mapViewInstanceHandle, _kmlType, _kml, _show, _callback, _info);
}
/**
 * description: deleteKml = deletes (and hides) Kml Content to MapViewer
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::deleteKml(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_kmlHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->deleteKml(_sessionHandle, _mapViewInstanceHandle, _kmlHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::deleteKmlAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_kmlHandle, DeleteKmlAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deleteKmlAsync(_sessionHandle, _mapViewInstanceHandle, _kmlHandle, _callback, _info);
}
/**
 * description: setKmlVisibility = shows/hides a kmlFile (without deleting it actually)
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setKmlVisibility(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_kmlHandle, const bool &_show, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setKmlVisibility(_sessionHandle, _mapViewInstanceHandle, _kmlHandle, _show, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setKmlVisibilityAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_kmlHandle, const bool &_show, SetKmlVisibilityAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setKmlVisibilityAsync(_sessionHandle, _mapViewInstanceHandle, _kmlHandle, _show, _callback, _info);
}
/**
 * description: pushSettings = stores the current map-ctrl setting (scale, orientation, visible
 *   objects ...) to an internal stack
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::pushSettings(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->pushSettings(_sessionHandle, _mapViewInstanceHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::pushSettingsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, PushSettingsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->pushSettingsAsync(_sessionHandle, _mapViewInstanceHandle, _callback, _info);
}
/**
 * description: popSettings = re-stores the current map-ctrl setting (scale, orientation,
 *   visible objects ...) from the stack (called after pushSetting)
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::popSettings(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->popSettings(_sessionHandle, _mapViewInstanceHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::popSettingsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, PopSettingsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->popSettingsAsync(_sessionHandle, _mapViewInstanceHandle, _callback, _info);
}
/**
 * description: resetSettings = resets the mapInstance to a dedicated state (same as startup)
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::resetSettings(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->resetSettings(_sessionHandle, _mapViewInstanceHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::resetSettingsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, ResetSettingsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->resetSettingsAsync(_sessionHandle, _mapViewInstanceHandle, _callback, _info);
}
/**
 * description: displayObjectList = This method visualizes a list of objects, created in
 *   another domain
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::displayObjectList(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectList &_objectList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->displayObjectList(_sessionHandle, _mapViewInstanceHandle, _objectList, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::displayObjectListAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectList &_objectList, DisplayObjectListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->displayObjectListAsync(_sessionHandle, _mapViewInstanceHandle, _objectList, _callback, _info);
}
/**
 * description: hideObjectList = This method hides a list of objects, created in another domain
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::hideObjectList(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectList &_objectList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->hideObjectList(_sessionHandle, _mapViewInstanceHandle, _objectList, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::hideObjectListAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectList &_objectList, HideObjectListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->hideObjectListAsync(_sessionHandle, _mapViewInstanceHandle, _objectList, _callback, _info);
}
/**
 * description: highlightObjectListItem = highlights exclusively a various number of items
 *   within an objectList. For unhighlight all, objectListItems is empty
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::highlightObjectListItem(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectListItem> &_objectListItems, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->highlightObjectListItem(_sessionHandle, _mapViewInstanceHandle, _objectListItems, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::highlightObjectListItemAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectListItem> &_objectListItems, HighlightObjectListItemAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->highlightObjectListItemAsync(_sessionHandle, _mapViewInstanceHandle, _objectListItems, _callback, _info);
}
/**
 * description: centerOnObjectListItems = This method shows an overview map with the current
 *   route in the center
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::centerOnObjectListItems(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectListItem> &_objectListItems, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->centerOnObjectListItems(_sessionHandle, _mapViewInstanceHandle, _objectListItems, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::centerOnObjectListItemsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ObjectListItem> &_objectListItems, CenterOnObjectListItemsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->centerOnObjectListItemsAsync(_sessionHandle, _mapViewInstanceHandle, _objectListItems, _callback, _info);
}
/**
 * description: getPoiCategoriesVisible = Get the set of POI categories displayed on the map.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getPoiCategoriesVisible(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<uint32_t> &_poiCategoryIds, const CommonAPI::CallInfo *_info) {
    delegate_->getPoiCategoriesVisible(_mapViewInstanceHandle, _internalCallStatus, _poiCategoryIds, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getPoiCategoriesVisibleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetPoiCategoriesVisibleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getPoiCategoriesVisibleAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setPoiCategoriesVisible = Add POI categories to the set of POI categories
 *   displayed on the map.
                   Any specified category that until now
 *   was displayed with scale limits is now displayed without limits.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setPoiCategoriesVisible(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setPoiCategoriesVisible(_sessionHandle, _mapViewInstanceHandle, _poiCategoryIds, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setPoiCategoriesVisibleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, SetPoiCategoriesVisibleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setPoiCategoriesVisibleAsync(_sessionHandle, _mapViewInstanceHandle, _poiCategoryIds, _callback, _info);
}
/**
 * description: setPoiCategoriesVisibleMode = gives the possibility to show or hide all POI
 *   categories regardsless of
                   of which one are enabled with
 *   setPoiCategoriesVisible/setPoiCategoriesNotVisible.
                   The
 *   selection which is done with
 *   setPoiCategoriesVisible/setPoiCategoriesNotVisible is not changed by this
 *   command.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setPoiCategoriesVisibleMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::PoiCategoriesVisibleMode &_poiCategoriesVisibleMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_poiCategoriesVisibleMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setPoiCategoriesVisibleMode(_sessionHandle, _mapViewInstanceHandle, _poiCategoriesVisibleMode, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setPoiCategoriesVisibleModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::PoiCategoriesVisibleMode &_poiCategoriesVisibleMode, SetPoiCategoriesVisibleModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_poiCategoriesVisibleMode.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setPoiCategoriesVisibleModeAsync(_sessionHandle, _mapViewInstanceHandle, _poiCategoriesVisibleMode, _callback, _info);
}
/**
 * description: setPoiCategoriesVisible = Add POI categories to the set of POI categories
 *   displayed on the map, where the POI's are only displayed in a specific range
 *   of scales.
                   Any specified category that until now was
 *   displayed without scale limits is now displayed with limits.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setPoiCategoriesVisibleWithinLimits(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, const int8_t &_minScaleID, const int8_t &_maxScaleID, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setPoiCategoriesVisibleWithinLimits(_sessionHandle, _mapViewInstanceHandle, _poiCategoryIds, _minScaleID, _maxScaleID, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setPoiCategoriesVisibleWithinLimitsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, const int8_t &_minScaleID, const int8_t &_maxScaleID, SetPoiCategoriesVisibleWithinLimitsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setPoiCategoriesVisibleWithinLimitsAsync(_sessionHandle, _mapViewInstanceHandle, _poiCategoryIds, _minScaleID, _maxScaleID, _callback, _info);
}
/**
 * description: setPoiCategoriesNotVisible = Remove POI categories from the set of POI
 *   categories displayed on the map.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setPoiCategoriesNotVisible(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setPoiCategoriesNotVisible(_sessionHandle, _mapViewInstanceHandle, _poiCategoryIds, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setPoiCategoriesNotVisibleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<uint32_t> &_poiCategoryIds, SetPoiCategoriesNotVisibleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setPoiCategoriesNotVisibleAsync(_sessionHandle, _mapViewInstanceHandle, _poiCategoryIds, _callback, _info);
}
/**
 * description: setTrafficIncidentsVisibility = Set the visibility of Traffic Incidents on the
 *   map.
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setTrafficIncidentsVisibility(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_visible, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setTrafficIncidentsVisibility(_sessionHandle, _mapViewInstanceHandle, _visible, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setTrafficIncidentsVisibilityAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_visible, SetTrafficIncidentsVisibilityAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setTrafficIncidentsVisibilityAsync(_sessionHandle, _mapViewInstanceHandle, _visible, _callback, _info);
}
/**
 * description: setMapViewTheme = This method configures the theme of a given map view instance
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapViewTheme(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapTheme &_mapViewTheme, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_mapViewTheme.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setMapViewTheme(_sessionHandle, _mapViewInstanceHandle, _mapViewTheme, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapViewThemeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapTheme &_mapViewTheme, SetMapViewThemeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_mapViewTheme.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setMapViewThemeAsync(_sessionHandle, _mapViewInstanceHandle, _mapViewTheme, _callback, _info);
}
/**
 * description: getMapViewTheme = This method returns the current theme of a given map view
 *   instance
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapViewTheme(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapTheme &_mapViewTheme, const CommonAPI::CallInfo *_info) {
    delegate_->getMapViewTheme(_mapViewInstanceHandle, _internalCallStatus, _mapViewTheme, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapViewThemeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapViewThemeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapViewThemeAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: getSupportedMapViewThemes = This method retrieves the supported mapview themes
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewThemes(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapTheme> &_mapViewThemeList, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedMapViewThemes(_internalCallStatus, _mapViewThemeList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getSupportedMapViewThemesAsync(GetSupportedMapViewThemesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedMapViewThemesAsync(_callback, _info);
}
/**
 * description: convertPixelCoordsToGeoCoords = This method converts pixel coordinates to
 *   geographical coordinates
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::convertPixelCoordsToGeoCoords(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Pixel> &_pixelCoordinates, CommonAPI::CallStatus &_internalCallStatus, std::vector<::org::harman::nav::ctrl::CommonTypes::Coordinate2D> &_geoCoordinates, const CommonAPI::CallInfo *_info) {
    delegate_->convertPixelCoordsToGeoCoords(_sessionHandle, _mapViewInstanceHandle, _pixelCoordinates, _internalCallStatus, _geoCoordinates, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::convertPixelCoordsToGeoCoordsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Pixel> &_pixelCoordinates, ConvertPixelCoordsToGeoCoordsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->convertPixelCoordsToGeoCoordsAsync(_sessionHandle, _mapViewInstanceHandle, _pixelCoordinates, _callback, _info);
}
/**
 * description: convertGeoCoordsToPixelCoords = This method converts geographical coordinates
 *   into pixel coordinates
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::convertGeoCoordsToPixelCoords(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::org::harman::nav::ctrl::CommonTypes::Coordinate2D> &_geoCoordinates, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Pixel> &_pixelCoordinates, const CommonAPI::CallInfo *_info) {
    delegate_->convertGeoCoordsToPixelCoords(_sessionHandle, _mapViewInstanceHandle, _geoCoordinates, _internalCallStatus, _pixelCoordinates, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::convertGeoCoordsToPixelCoordsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::org::harman::nav::ctrl::CommonTypes::Coordinate2D> &_geoCoordinates, ConvertGeoCoordsToPixelCoordsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->convertGeoCoordsToPixelCoordsAsync(_sessionHandle, _mapViewInstanceHandle, _geoCoordinates, _callback, _info);
}
/**
 * description: displayCustomElements = This method visualizes a set of custom elements on the
 *   map
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::displayCustomElements(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::CustomElement> &_customElements, CommonAPI::CallStatus &_internalCallStatus, std::vector<::org::harman::nav::ctrl::CommonTypes::Handle> &_customElemenHandles, const CommonAPI::CallInfo *_info) {
    delegate_->displayCustomElements(_sessionHandle, _mapViewInstanceHandle, _customElements, _internalCallStatus, _customElemenHandles, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::displayCustomElementsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::CustomElement> &_customElements, DisplayCustomElementsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->displayCustomElementsAsync(_sessionHandle, _mapViewInstanceHandle, _customElements, _callback, _info);
}
/**
 * description: hideCustomElements = This method hides a set of custom elements which were
 *   visualized by DisplayCustomElements
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::hideCustomElements(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::org::harman::nav::ctrl::CommonTypes::Handle> &_customElemenHandles, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->hideCustomElements(_sessionHandle, _mapViewInstanceHandle, _customElemenHandles, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::hideCustomElementsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::vector<::org::harman::nav::ctrl::CommonTypes::Handle> &_customElemenHandles, HideCustomElementsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->hideCustomElementsAsync(_sessionHandle, _mapViewInstanceHandle, _customElemenHandles, _callback, _info);
}
/**
 * description: getDisplayedCustomElements = This method retrieves the visualized custom
 *   elements on the map
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getDisplayedCustomElements(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::tCustomElementDict &_customElements, const CommonAPI::CallInfo *_info) {
    delegate_->getDisplayedCustomElements(_mapViewInstanceHandle, _internalCallStatus, _customElements, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getDisplayedCustomElementsAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetDisplayedCustomElementsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getDisplayedCustomElementsAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: selectElementsOnMap = This method selects elements on the map view which are at
 *   the position specified by user input
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::selectElementsOnMap(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Pixel &_pixelCoordinate, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::SelectableMapType> &_selectableTypes, const uint16_t &_maxNumberOfSelectedElements, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::SelectedMapElement> &_selectedElements, const CommonAPI::CallInfo *_info) {
    delegate_->selectElementsOnMap(_mapViewInstanceHandle, _pixelCoordinate, _selectableTypes, _maxNumberOfSelectedElements, _internalCallStatus, _selectedElements, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::selectElementsOnMapAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::Pixel &_pixelCoordinate, const std::vector<::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::SelectableMapType> &_selectableTypes, const uint16_t &_maxNumberOfSelectedElements, SelectElementsOnMapAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->selectElementsOnMapAsync(_mapViewInstanceHandle, _pixelCoordinate, _selectableTypes, _maxNumberOfSelectedElements, _callback, _info);
}
/**
 * description: mapViewGesture = This method is a compound gesture command
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::mapViewGesture(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_systemMilisecondsTime, const bool &_isFingerDown, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate &_anchorScreen, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate &_scrollOffset, const double &_zoomFactor, const double &_rotationAngle, const double &_pitchAngle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->mapViewGesture(_sessionHandle, _mapViewInstanceHandle, _systemMilisecondsTime, _isFingerDown, _anchorScreen, _scrollOffset, _zoomFactor, _rotationAngle, _pitchAngle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::mapViewGestureAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const int32_t &_systemMilisecondsTime, const bool &_isFingerDown, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate &_anchorScreen, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::ScreenCoordinate &_scrollOffset, const double &_zoomFactor, const double &_rotationAngle, const double &_pitchAngle, MapViewGestureAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->mapViewGestureAsync(_sessionHandle, _mapViewInstanceHandle, _systemMilisecondsTime, _isFingerDown, _anchorScreen, _scrollOffset, _zoomFactor, _rotationAngle, _pitchAngle, _callback, _info);
}
/**
 * description: mapShowRouteOverview = This method shows an overview map with the current route
 *   in the center
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::mapShowRouteOverview(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_routeId, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewOrientation &_orientation, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_orientation.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->mapShowRouteOverview(_sessionHandle, _mapViewInstanceHandle, _routeId, _orientation, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::mapShowRouteOverviewAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const uint32_t &_routeId, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewOrientation &_orientation, MapShowRouteOverviewAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_orientation.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->mapShowRouteOverviewAsync(_sessionHandle, _mapViewInstanceHandle, _routeId, _orientation, _callback, _info);
}
/**
 * description: mapSetStyle = Changes the StyleSet of the MapViewer. e.g. day/night switch
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::mapSetStyle(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewStyleSet &_styleSet, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_styleSet.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->mapSetStyle(_sessionHandle, _mapViewInstanceHandle, _styleSet, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::mapSetStyleAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::MapViewStyleSet &_styleSet, MapSetStyleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_styleSet.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->mapSetStyleAsync(_sessionHandle, _mapViewInstanceHandle, _styleSet, _callback, _info);
}
/**
 * description: getMapModeList = This method returns a list of supported map modes
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapModeList(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<std::string> &_mapModeList, const CommonAPI::CallInfo *_info) {
    delegate_->getMapModeList(_mapViewInstanceHandle, _internalCallStatus, _mapModeList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapModeListAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapModeListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapModeListAsync(_mapViewInstanceHandle, _callback, _info);
}
/**
 * description: setMapMode = This method sets the map mode (String-datatype, could be
 *   hard-coded in HMI if controller is known)
 */
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setMapMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::string &_mapMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setMapMode(_sessionHandle, _mapViewInstanceHandle, _mapMode, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setMapModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const std::string &_mapMode, SetMapModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMapModeAsync(_sessionHandle, _mapViewInstanceHandle, _mapMode, _callback, _info);
}
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getMapMode(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, std::string &_mapMode, const CommonAPI::CallInfo *_info) {
    delegate_->getMapMode(_sessionHandle, _mapViewInstanceHandle, _internalCallStatus, _mapMode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getMapModeAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetMapModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMapModeAsync(_sessionHandle, _mapViewInstanceHandle, _callback, _info);
}
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setAutozoomSetting(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::AutozoomSetting &_autozoomSetting, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_autozoomSetting.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setAutozoomSetting(_sessionHandle, _mapViewInstanceHandle, _autozoomSetting, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setAutozoomSettingAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::AutozoomSetting &_autozoomSetting, SetAutozoomSettingAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_autozoomSetting.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setAutozoomSettingAsync(_sessionHandle, _mapViewInstanceHandle, _autozoomSetting, _callback, _info);
}
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getAutozoomSetting(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::harman::nav::ctrl::mapv::MapViewControlTypes::AutozoomSetting &_autozoomSetting, const CommonAPI::CallInfo *_info) {
    delegate_->getAutozoomSetting(_sessionHandle, _mapViewInstanceHandle, _internalCallStatus, _autozoomSetting, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getAutozoomSettingAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetAutozoomSettingAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getAutozoomSettingAsync(_sessionHandle, _mapViewInstanceHandle, _callback, _info);
}
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::setAutozoomEnabled(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_enabled, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setAutozoomEnabled(_sessionHandle, _mapViewInstanceHandle, _enabled, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::setAutozoomEnabledAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, const bool &_enabled, SetAutozoomEnabledAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setAutozoomEnabledAsync(_sessionHandle, _mapViewInstanceHandle, _enabled, _callback, _info);
}
template <typename ... _AttributeExtensions>
void MapViewControlProxy<_AttributeExtensions...>::getAutozoomEnabled(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, CommonAPI::CallStatus &_internalCallStatus, bool &_enabled, const CommonAPI::CallInfo *_info) {
    delegate_->getAutozoomEnabled(_sessionHandle, _mapViewInstanceHandle, _internalCallStatus, _enabled, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapViewControlProxy<_AttributeExtensions...>::getAutozoomEnabledAsync(const ::org::harman::nav::ctrl::CommonTypes::Handle &_sessionHandle, const ::org::harman::nav::ctrl::CommonTypes::Handle &_mapViewInstanceHandle, GetAutozoomEnabledAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getAutozoomEnabledAsync(_sessionHandle, _mapViewInstanceHandle, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &MapViewControlProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool MapViewControlProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool MapViewControlProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& MapViewControlProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& MapViewControlProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace mapv
} // namespace ctrl
} // namespace nav
} // namespace harman
} // namespace org
} // namespace v1

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v1::org::harman::nav::ctrl::mapv::MapViewControlProxy,
    _AttributeExtension> {
    typedef typename ::v1::org::harman::nav::ctrl::mapv::MapViewControlProxy<
            ::v1::org::harman::nav::ctrl::mapv::MapViewControlExtensions::StatusAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v1_2 = v1;

#endif // V1_ORG_HARMAN_NAV_CTRL_MAPV_Map_View_Control_PROXY_HPP_
