/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: ListViewBase = This interface offers functions that implement a basic list
 *   concept 
    The basic idea of this inteface is the following:
    A client
 *   registers a view with a certain size n on a list with a dynamic size m. Please
 *   note: during 
    initial call, a view might be bigger than the underlying
 *   list. 
    The client uses index - so called ListTypes.ListKey to position the
 *   first element of a view to a certain
    element in the list. Please note: the
 *   ListKey value must be in a valid range between first (0) and last (m)
 *   element.
    Furthermore the client specifies it's anchor point. An anchor is
 *   more or less the stable entry in a view which - 
    even in case of a
 *   listupdate - stays at a permanent position in the view. It is used to
 *   guarantee a stable view
    in case of list changes (sorting changed,
 *   inserts/deletes) and furthermore allow a client to realize a smooth
   
 *   scrolling - if necessary. For better understanding see the following example:
 *   
    There is a list of 30 elements and a view with a total of 4 entries. The
 *   view is positioned at entry 21, which 
    means the view shows the entries
 *   [21, 22, 23, 24]. The client specifies the anchor on 22. Now imagine an update
 *   
    occurs (e.g. a new entry will get inserted between 17 and 18). The
 *   clients get notified by a broadcast that the
    ListTypes.ListKey of his
 *   anchor is now 23 (because the entry 22 is moved on index 23). 
    
    While
 *   the base list specifies how to navitation and create a view on a given list,
 *   the concrete implementation of 
    a list is responsible for providing the
 *   data of a view. This must be realized in the following manner: each
   
 *   concrete implementation must provide a getView() function which returns the
 *   entries of a current view, the absolute
    key/index of the view and the
 *   relative anchor position based on the view position. The provider
    of the
 *   list is responsible for providing always the correct elements of a list based
 *   on the anchor, the client
    has specified. 
    
    Special case handling:
 *   in some cases it might happen, that the specified anchor point get's removed
 *   from the list
    and therefore from the view. In this case the list
 *   implementation will behave like the following: If possible,
    the anchor
 *   will be replaced by the provider with the next element (successor) in the
 *   list. If this is not possible
    (anchor already pointed to the last element
 *   in list), the previous element (predecessor) is selected as new anchor.
   
 *   Anyway - the impact of an update on the anchor will be indicated by
 *   appropriate enum.
 */
#ifndef V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_List_View_Base_PROXY_HPP_
#define V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_List_View_Base_PROXY_HPP_

#include <v1/org/harman/nav/ctrl/common/list/ListViewBaseProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace common {
namespace list {

template <typename ... _AttributeExtensions>
class ListViewBaseProxy
    : virtual public ListViewBase, 
      virtual public ListViewBaseProxyBase,
      virtual public _AttributeExtensions... {
public:
    ListViewBaseProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~ListViewBaseProxy();

    typedef ListViewBase InterfaceType;



    /**
     * description: indicate to the client that the underlying list of a certain view has changed
     
     *         Whenever elements get inserted/removed or the content of element gets
     *   changed, the size 
            or the sorting order of a list might change. This
     *   might influence the current view and
            especially the position of the
     *   anchor element in the list. To allow a client to react on such
            changes
     *   in an approapriate manner, the viewUpdate broadcast will provide all necessary
     *   information
            to its client. 
            It is up to the client to
     *   reposition the view to its needs based on the provided information, 
           
     *   using the methods setViewPosition or setViewAnchor.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast viewUpdate.
     */
    virtual ViewUpdateEvent& getViewUpdateEvent() {
        return delegate_->getViewUpdateEvent();
    }
    /**
     * description: informs the client about changes of the list size.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast listSize.
     */
    virtual ListSizeEvent& getListSizeEvent() {
        return delegate_->getListSizeEvent();
    }

    /**
     * description: get the current number of contained elements in the given list.
     * Calls getListSize with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListSize(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, ::org::harman::nav::ctrl::common::list::ListTypes::ListSize &_size, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListSize with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListSizeAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, GetListSizeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: create a new view to the mother array. 
            This view will be maintained
     *   until the client uses destroyView, 
            unsubscribes or service/proxy
     *   exit. 
            After creating a view the client must receive an update.
          
     *    Only one created view is allowed to modify the list entries.
            Please
     *   note: a valid usecase is to specify a viewSize which is 
            bigger than
     *   the inital list size
     * Calls createView with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void createView(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_viewsize, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls createView with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> createViewAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_viewsize, CreateViewAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: delete the given view instance
     * Calls deleteView with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteView(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteView with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deleteViewAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, DeleteViewAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: adjust the view size. It is allowed to set view size to a larger value
           
     *   than the actual size of the list, but less or equal than the maximum size of
     *   the list. 
            The implementation may limit the maximum view size for
     *   resource reasons. 
            After adjusting the window size the client must
     *   receive an update.
     * Calls setViewSize with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setViewSize(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_new_size, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setViewSize with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setViewSizeAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_new_size, SetViewSizeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: set the absolute view position to element key. 
            The client should use
     *   an available snapshot of a view to maintain focused elements 
            within
     *   the view if possible, and change the view position only if an 
            element
     *   to be focused is outside of the given view. A snapshot is generated whenever
     
     *         querying the data contained in a view. Together with that data, the
     *   ViewSnapshotPosition is provided.
            The initial snapshot of the view is
     *   always [0, min(viewSize-1, listSize-1)].
            When creating a new view
     *   snapshot, the last call of setViewPosition or setViewAnchor (whichever was the
     *   last one)
            will be the relevant information to reposition the new view
     *   snapshot. If setViewPosition was the last call,
            the view is moved such
     *   that the provided key refers to the absolute position on the current snapshot
     *   of the view.
            (This becomes important if the current view snapshot is
     *   outdated because the list has been updated.)
    
            The following rules are
     *   applied to set the position of the new view snapshot [newFrom, newTo], given a
     *   snapshot [from, to]:
            Let elem(k) denote the element at key k in the
     *   old snapshot and new(e) denote the key the element e will have 
            (would
     *   have if deleted) in the new snapshot (see also examples (1)-(3) below).
          
     *    (1) If key is less than from, then newFrom will be set to new(elem(from)) -
     *   (from-key).
            (2) If key is contained in [from, to], then newKey will be
     *   set to new(elem(key)).
            (3) If key is greater than to, then newFrom
     *   will be set to new(elem(to)) + (key-to).
            If any of these calculated
     *   values are out of the range of the list [0, listSize-1], they will be
     *   truncated to fit into the list.
            (Note that the resulting newFrom is
     *   always equal to key if the data wasn't updated, 
            but it doesn't have
     *   to be equal to key if the data was updated.)
            After setting the view
     *   position the anchor offset will automatically be set to 0.
            There are
     *   two special key values to allow scrolling to the top/bottom of the list,
     *   independently from the above rules:
            The key value 0xFFFE always
     *   positions the view to the top of the list.
            The key value 0xFFFF always
     *   positions the view to the bottom of the list.
    
            As an example for the
     *   case in which the data was updated:
            old list {"a", "b", "c", "d", "e",
     *   "f"} with view snapshot ["c", "d"] with viewSize 2 and viewKey 2
            new
     *   list {"b", "d", "f", "h", "j", "l"}
            (1) setViewPosition(0) => [from,
     *   to] is [2, 3], elem(from) is "c", new(elem(from)) is 1
                           
     *          => ["b", "d"] with ViewSnapshotPosition {listSize=6, listKey=0,
     *   anchorOffset=0}.
            (2) setViewPosition(3) => [from, to] is [2, 3],
     *   elem(key) is "d", new(elem(key)) is 1
                                   => ["d",
     *   "f"] with ViewSnapshotPosition {listSize=6, listKey=1, anchorOffset=0}.
          
     *    (3) setViewPosition(4) => [from, to] is [2, 3], elem(to) is "d", new(elem(d))
     *   is 1
                                   => ["f", "h"] with ViewSnapshotPosition
     *   {listSize=6, listKey=2, anchorOffset=0}.
     * Calls setViewPosition with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setViewPosition(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ListKey &_key, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: set a stable element inside the current view snapshot.
            The client
     *   should use an available snapshot of a view to maintain focused elements 
         
     *     within the view if possible, and change the view position only if an 
          
     *    element to be focused is outside of the given view. A snapshot is generated
     *   whenever
            querying the data contained in a view. Together with that
     *   data, the ViewSnapshotPosition is provided.
            The initial snapshot of
     *   the view is always [0, min(viewSize-1, listSize-1)] with anchor offset 0.
        
     *      When creating a new view snapshot, the last call of setViewPosition or
     *   setViewAnchor (whichever was the last one)
            will be the relevant
     *   information to reposition the new view snapshot. If setViewAnchor was the last
     *   call,
            the anchor element of the old view snapshot is used for
     *   repositioning.
            (This method only needs to be used if the current view
     *   snapshot is outdated because the list has been updated.)
    
            The
     *   following rules are applied to set the position of the new view snapshot
     *   [newFrom, newTo], given a snapshot [from, to]
            and anchor offset aOff:
    
     *          Let elem(k) denote the element at key k in the old snapshot and new(e)
     *   denote the key the element e will have 
            (would have if deleted) in the
     *   new snapshot (see also examples below).
            newFrom is set to
     *   new(elem(from+aOff)) - aOff.
            If any of these calculated values are out
     *   of the range of the list [0, listSize-1], they will be truncated to fit into
     *   the list.
            As a consequence, whenever possible, the anchor element of
     *   the old snapshot will be at the same offset within the new snapshot.
    
           
     *   As an example for the case in which the data was updated:
            old list
     *   {"a", "b", "c", "d", "e", "f"} with view snapshot ["c", "d"] with viewSize 2
     *   and viewKey 2
            new list {"b", "d", "f", "h", "j", "l"}
           
     *   setViewAnchor(0) => elem(from+aOff) is "c", new(elem(from+aOff)) is 1 ("c"
     *   would be inserted at index 1)
                             => ["d", "f"] with
     *   ViewSnapshotPosition {listSize=6, listKey=1, anchorOffset=0}.
           
     *   setViewAnchor(1) => elem(from+aOff) is "d", new(elem(from+aOff)) is 1
            
     *                   => ["b", "d"] with ViewSnapshotPosition {listSize=6,
     *   listKey=0, anchorOffset=1}.
     * Calls setViewAnchor with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setViewAnchor(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::AnchorOffset &_anchor, CommonAPI::CallStatus &_internalCallStatus);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<ListViewBaseProxyBase> delegate_;
};

typedef ListViewBaseProxy<> ListViewBaseProxyDefault;


//
// ListViewBaseProxy Implementation
//
template <typename ... _AttributeExtensions>
ListViewBaseProxy<_AttributeExtensions...>::ListViewBaseProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<ListViewBaseProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<ListViewBaseProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
ListViewBaseProxy<_AttributeExtensions...>::~ListViewBaseProxy() {
}

/**
 * description: get the current number of contained elements in the given list.
 */
template <typename ... _AttributeExtensions>
void ListViewBaseProxy<_AttributeExtensions...>::getListSize(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, ::org::harman::nav::ctrl::common::list::ListTypes::ListSize &_size, const CommonAPI::CallInfo *_info) {
    delegate_->getListSize(_list, _internalCallStatus, _error, _size, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ListViewBaseProxy<_AttributeExtensions...>::getListSizeAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, GetListSizeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListSizeAsync(_list, _callback, _info);
}
/**
 * description: create a new view to the mother array. 
        This view will be maintained
 *   until the client uses destroyView, 
        unsubscribes or service/proxy
 *   exit. 
        After creating a view the client must receive an update.
      
 *    Only one created view is allowed to modify the list entries.
        Please
 *   note: a valid usecase is to specify a viewSize which is 
        bigger than
 *   the inital list size
 */
template <typename ... _AttributeExtensions>
void ListViewBaseProxy<_AttributeExtensions...>::createView(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_viewsize, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const CommonAPI::CallInfo *_info) {
    delegate_->createView(_list, _viewsize, _internalCallStatus, _error, _view, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ListViewBaseProxy<_AttributeExtensions...>::createViewAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_viewsize, CreateViewAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->createViewAsync(_list, _viewsize, _callback, _info);
}
/**
 * description: delete the given view instance
 */
template <typename ... _AttributeExtensions>
void ListViewBaseProxy<_AttributeExtensions...>::deleteView(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info) {
    delegate_->deleteView(_view, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ListViewBaseProxy<_AttributeExtensions...>::deleteViewAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, DeleteViewAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deleteViewAsync(_view, _callback, _info);
}
/**
 * description: adjust the view size. It is allowed to set view size to a larger value
       
 *   than the actual size of the list, but less or equal than the maximum size of
 *   the list. 
        The implementation may limit the maximum view size for
 *   resource reasons. 
        After adjusting the window size the client must
 *   receive an update.
 */
template <typename ... _AttributeExtensions>
void ListViewBaseProxy<_AttributeExtensions...>::setViewSize(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_new_size, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info) {
    delegate_->setViewSize(_view, _new_size, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ListViewBaseProxy<_AttributeExtensions...>::setViewSizeAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewSize &_new_size, SetViewSizeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setViewSizeAsync(_view, _new_size, _callback, _info);
}
/**
 * description: set the absolute view position to element key. 
        The client should use
 *   an available snapshot of a view to maintain focused elements 
        within
 *   the view if possible, and change the view position only if an 
        element
 *   to be focused is outside of the given view. A snapshot is generated whenever
 
 *         querying the data contained in a view. Together with that data, the
 *   ViewSnapshotPosition is provided.
        The initial snapshot of the view is
 *   always [0, min(viewSize-1, listSize-1)].
        When creating a new view
 *   snapshot, the last call of setViewPosition or setViewAnchor (whichever was the
 *   last one)
        will be the relevant information to reposition the new view
 *   snapshot. If setViewPosition was the last call,
        the view is moved such
 *   that the provided key refers to the absolute position on the current snapshot
 *   of the view.
        (This becomes important if the current view snapshot is
 *   outdated because the list has been updated.)

        The following rules are
 *   applied to set the position of the new view snapshot [newFrom, newTo], given a
 *   snapshot [from, to]:
        Let elem(k) denote the element at key k in the
 *   old snapshot and new(e) denote the key the element e will have 
        (would
 *   have if deleted) in the new snapshot (see also examples (1)-(3) below).
      
 *    (1) If key is less than from, then newFrom will be set to new(elem(from)) -
 *   (from-key).
        (2) If key is contained in [from, to], then newKey will be
 *   set to new(elem(key)).
        (3) If key is greater than to, then newFrom
 *   will be set to new(elem(to)) + (key-to).
        If any of these calculated
 *   values are out of the range of the list [0, listSize-1], they will be
 *   truncated to fit into the list.
        (Note that the resulting newFrom is
 *   always equal to key if the data wasn't updated, 
        but it doesn't have
 *   to be equal to key if the data was updated.)
        After setting the view
 *   position the anchor offset will automatically be set to 0.
        There are
 *   two special key values to allow scrolling to the top/bottom of the list,
 *   independently from the above rules:
        The key value 0xFFFE always
 *   positions the view to the top of the list.
        The key value 0xFFFF always
 *   positions the view to the bottom of the list.

        As an example for the
 *   case in which the data was updated:
        old list {"a", "b", "c", "d", "e",
 *   "f"} with view snapshot ["c", "d"] with viewSize 2 and viewKey 2
        new
 *   list {"b", "d", "f", "h", "j", "l"}
        (1) setViewPosition(0) => [from,
 *   to] is [2, 3], elem(from) is "c", new(elem(from)) is 1
                       
 *          => ["b", "d"] with ViewSnapshotPosition {listSize=6, listKey=0,
 *   anchorOffset=0}.
        (2) setViewPosition(3) => [from, to] is [2, 3],
 *   elem(key) is "d", new(elem(key)) is 1
                               => ["d",
 *   "f"] with ViewSnapshotPosition {listSize=6, listKey=1, anchorOffset=0}.
      
 *    (3) setViewPosition(4) => [from, to] is [2, 3], elem(to) is "d", new(elem(d))
 *   is 1
                               => ["f", "h"] with ViewSnapshotPosition
 *   {listSize=6, listKey=2, anchorOffset=0}.
 */
template <typename ... _AttributeExtensions>
void ListViewBaseProxy<_AttributeExtensions...>::setViewPosition(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::ListKey &_key, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->setViewPosition(_view, _key, _internalCallStatus);
}
/**
 * description: set a stable element inside the current view snapshot.
        The client
 *   should use an available snapshot of a view to maintain focused elements 
     
 *     within the view if possible, and change the view position only if an 
      
 *    element to be focused is outside of the given view. A snapshot is generated
 *   whenever
        querying the data contained in a view. Together with that
 *   data, the ViewSnapshotPosition is provided.
        The initial snapshot of
 *   the view is always [0, min(viewSize-1, listSize-1)] with anchor offset 0.
    
 *      When creating a new view snapshot, the last call of setViewPosition or
 *   setViewAnchor (whichever was the last one)
        will be the relevant
 *   information to reposition the new view snapshot. If setViewAnchor was the last
 *   call,
        the anchor element of the old view snapshot is used for
 *   repositioning.
        (This method only needs to be used if the current view
 *   snapshot is outdated because the list has been updated.)

        The
 *   following rules are applied to set the position of the new view snapshot
 *   [newFrom, newTo], given a snapshot [from, to]
        and anchor offset aOff:

 *          Let elem(k) denote the element at key k in the old snapshot and new(e)
 *   denote the key the element e will have 
        (would have if deleted) in the
 *   new snapshot (see also examples below).
        newFrom is set to
 *   new(elem(from+aOff)) - aOff.
        If any of these calculated values are out
 *   of the range of the list [0, listSize-1], they will be truncated to fit into
 *   the list.
        As a consequence, whenever possible, the anchor element of
 *   the old snapshot will be at the same offset within the new snapshot.

       
 *   As an example for the case in which the data was updated:
        old list
 *   {"a", "b", "c", "d", "e", "f"} with view snapshot ["c", "d"] with viewSize 2
 *   and viewKey 2
        new list {"b", "d", "f", "h", "j", "l"}
       
 *   setViewAnchor(0) => elem(from+aOff) is "c", new(elem(from+aOff)) is 1 ("c"
 *   would be inserted at index 1)
                         => ["d", "f"] with
 *   ViewSnapshotPosition {listSize=6, listKey=1, anchorOffset=0}.
       
 *   setViewAnchor(1) => elem(from+aOff) is "d", new(elem(from+aOff)) is 1
        
 *                   => ["b", "d"] with ViewSnapshotPosition {listSize=6,
 *   listKey=0, anchorOffset=1}.
 */
template <typename ... _AttributeExtensions>
void ListViewBaseProxy<_AttributeExtensions...>::setViewAnchor(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::AnchorOffset &_anchor, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->setViewAnchor(_view, _anchor, _internalCallStatus);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &ListViewBaseProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool ListViewBaseProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool ListViewBaseProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& ListViewBaseProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& ListViewBaseProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace list
} // namespace common
} // namespace ctrl
} // namespace nav
} // namespace harman
} // namespace org
} // namespace v1



// Compatibility
namespace v1_0 = v1;

#endif // V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_List_View_Base_PROXY_HPP_
