/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: This interface provides functionality to specify the sort order to views.
   
 *   Any interfaces using this interface building block must provide specification
 *   on which parts of list elements shall be used for sorting.
    The number of
 *   sort orders may be extended by inheritance of data type Order as well if
 *   needed.
 */
#ifndef V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_List_View_Sort_Order_PROXY_HPP_
#define V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_List_View_Sort_Order_PROXY_HPP_

#include <v1/org/harman/nav/ctrl/common/list/ListViewSortOrderProxyBase.hpp>

#include "v1/org/harman/nav/ctrl/common/list/ListViewBaseProxy.hpp"

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace common {
namespace list {

template <typename ... _AttributeExtensions>
class ListViewSortOrderProxy
    : virtual public ListViewSortOrder, 
      virtual public ListViewSortOrderProxyBase,
      public ListViewBaseProxy<_AttributeExtensions...>,
      virtual public _AttributeExtensions... {
public:
    ListViewSortOrderProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~ListViewSortOrderProxy();

    typedef ListViewSortOrder InterfaceType;

    inline static const char* getInterface() {
        return(ListViewSortOrder::getInterface());
    }



    /**
     * description: getVersion = This method returns the API version implemented by the server
     *   application
     * Calls getVersion with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getVersion(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getVersion with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getVersionAsync(GetVersionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: configure the sort order of a view instance. Changing the sort order of a view
     *   may trigger a view update.
     * Calls setSortOrder with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSortOrder(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::SortOption &_order, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSortOrder with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSortOrderAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::SortOption &_order, SetSortOrderAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: retrieve the sort order of a view instance
     * Calls getSortOrder with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSortOrder(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, ::org::harman::nav::ctrl::common::list::ListTypes::SortOption &_order, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSortOrder with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSortOrderAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, GetSortOrderAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: remove all items which are related to the given List id.
     * Calls removeAll with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void removeAll(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls removeAll with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> removeAllAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, RemoveAllAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: remove an item from a list
     * param: ListTypes.ViewId sourceViewId source view id, which is where this item is known
     *   from
     * param: ListTypes.ViewKey source item key, which identifies the item which shall be
     *   removed
     * param: ListTypes.destinationListId the list from which the item shall be removed
     * Calls removeItem with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void removeItem(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_sourceViewId, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewKey &_sourceItemKey, const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_destination, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls removeItem with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> removeItemAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_sourceViewId, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewKey &_sourceItemKey, const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_destination, RemoveItemAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: add a exsisting item to another list.
     * param: ListTypes.ViewId sourceViewId, the source viewid of the to be added item
     * param: ListTypes.ViewKey sourceItemKey, the key within the given view of the to be
     *   added item
     * param: ListTypes.ListId destinationListId, the list where the item should be added.
     * Calls addItem with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void addItem(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_sourceViewId, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewKey &_sourceItemKey, const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_destinationListId, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls addItem with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> addItemAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_sourceViewId, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewKey &_sourceItemKey, const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_destinationListId, AddItemAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<ListViewSortOrderProxyBase> delegate_;
};

typedef ListViewSortOrderProxy<> ListViewSortOrderProxyDefault;


//
// ListViewSortOrderProxy Implementation
//
template <typename ... _AttributeExtensions>
ListViewSortOrderProxy<_AttributeExtensions...>::ListViewSortOrderProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        ::v1::org::harman::nav::ctrl::common::list::ListViewBaseProxy<_AttributeExtensions...>(delegate),
        _AttributeExtensions(*(std::dynamic_pointer_cast<ListViewSortOrderProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<ListViewSortOrderProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
ListViewSortOrderProxy<_AttributeExtensions...>::~ListViewSortOrderProxy() {
}

/**
 * description: getVersion = This method returns the API version implemented by the server
 *   application
 */
template <typename ... _AttributeExtensions>
void ListViewSortOrderProxy<_AttributeExtensions...>::getVersion(CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info) {
    delegate_->getVersion(_internalCallStatus, _version, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ListViewSortOrderProxy<_AttributeExtensions...>::getVersionAsync(GetVersionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getVersionAsync(_callback, _info);
}
/**
 * description: configure the sort order of a view instance. Changing the sort order of a view
 *   may trigger a view update.
 */
template <typename ... _AttributeExtensions>
void ListViewSortOrderProxy<_AttributeExtensions...>::setSortOrder(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::SortOption &_order, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info) {
    if (!_order.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setSortOrder(_view, _order, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ListViewSortOrderProxy<_AttributeExtensions...>::setSortOrderAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, const ::org::harman::nav::ctrl::common::list::ListTypes::SortOption &_order, SetSortOrderAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_order.validate()) {
        ::org::harman::nav::ctrl::common::list::ListTypes::ListError error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setSortOrderAsync(_view, _order, _callback, _info);
}
/**
 * description: retrieve the sort order of a view instance
 */
template <typename ... _AttributeExtensions>
void ListViewSortOrderProxy<_AttributeExtensions...>::getSortOrder(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, ::org::harman::nav::ctrl::common::list::ListTypes::SortOption &_order, const CommonAPI::CallInfo *_info) {
    delegate_->getSortOrder(_view, _internalCallStatus, _error, _order, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ListViewSortOrderProxy<_AttributeExtensions...>::getSortOrderAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_view, GetSortOrderAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSortOrderAsync(_view, _callback, _info);
}
/**
 * description: remove all items which are related to the given List id.
 */
template <typename ... _AttributeExtensions>
void ListViewSortOrderProxy<_AttributeExtensions...>::removeAll(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info) {
    delegate_->removeAll(_list, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ListViewSortOrderProxy<_AttributeExtensions...>::removeAllAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_list, RemoveAllAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->removeAllAsync(_list, _callback, _info);
}
/**
 * description: remove an item from a list
 * param: ListTypes.ViewId sourceViewId source view id, which is where this item is known
 *   from
 * param: ListTypes.ViewKey source item key, which identifies the item which shall be
 *   removed
 * param: ListTypes.destinationListId the list from which the item shall be removed
 */
template <typename ... _AttributeExtensions>
void ListViewSortOrderProxy<_AttributeExtensions...>::removeItem(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_sourceViewId, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewKey &_sourceItemKey, const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_destination, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info) {
    delegate_->removeItem(_sourceViewId, _sourceItemKey, _destination, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ListViewSortOrderProxy<_AttributeExtensions...>::removeItemAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_sourceViewId, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewKey &_sourceItemKey, const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_destination, RemoveItemAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->removeItemAsync(_sourceViewId, _sourceItemKey, _destination, _callback, _info);
}
/**
 * description: add a exsisting item to another list.
 * param: ListTypes.ViewId sourceViewId, the source viewid of the to be added item
 * param: ListTypes.ViewKey sourceItemKey, the key within the given view of the to be
 *   added item
 * param: ListTypes.ListId destinationListId, the list where the item should be added.
 */
template <typename ... _AttributeExtensions>
void ListViewSortOrderProxy<_AttributeExtensions...>::addItem(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_sourceViewId, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewKey &_sourceItemKey, const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_destinationListId, CommonAPI::CallStatus &_internalCallStatus, ::org::harman::nav::ctrl::common::list::ListTypes::ListError &_error, const CommonAPI::CallInfo *_info) {
    delegate_->addItem(_sourceViewId, _sourceItemKey, _destinationListId, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ListViewSortOrderProxy<_AttributeExtensions...>::addItemAsync(const ::org::harman::nav::ctrl::common::list::ListTypes::ViewId &_sourceViewId, const ::org::harman::nav::ctrl::common::list::ListTypes::ViewKey &_sourceItemKey, const ::org::harman::nav::ctrl::common::list::ListTypes::ListId &_destinationListId, AddItemAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->addItemAsync(_sourceViewId, _sourceItemKey, _destinationListId, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &ListViewSortOrderProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool ListViewSortOrderProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool ListViewSortOrderProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& ListViewSortOrderProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& ListViewSortOrderProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace list
} // namespace common
} // namespace ctrl
} // namespace nav
} // namespace harman
} // namespace org
} // namespace v1



// Compatibility
namespace v1_0 = v1;

#endif // V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_List_View_Sort_Order_PROXY_HPP_
