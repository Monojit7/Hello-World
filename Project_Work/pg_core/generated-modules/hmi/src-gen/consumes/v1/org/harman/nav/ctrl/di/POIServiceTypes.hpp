/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
#ifndef V1_ORG_HARMAN_NAV_CTRL_DI_POI_Service_Types_HPP_
#define V1_ORG_HARMAN_NAV_CTRL_DI_POI_Service_Types_HPP_


#include <org/harman/nav/ctrl/CommonTypes.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace di {

struct POIServiceTypes {
    /**
     * description: TODO: This is a placeholder for a Category which used into the POISearch.fidl.
     */
    typedef uint16_t Category_t;
    /**
     * description: Unique ID for a POI results
     */
    typedef uint32_t POI_ID;
    /**
     * description: Unique ID for a POI Categories
     */
    typedef uint32_t CategoryID;
    /**
     * description: Unique ID for a POI Icon Resource
     */
    typedef uint32_t ResourceID;
    typedef uint32_t AttributeID;
    
    struct SortOptions : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SORT_BY_DISTANCE = 0,
            SORT_BY_NAME = 1,
            SORT_BY_TIME = 2,
            SORT_BY_PRICE = 3
        };
        
        SortOptions() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SORT_BY_DISTANCE)) {}
        SortOptions(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SORT_BY_DISTANCE):
                case static_cast<int32_t>(Literal::SORT_BY_NAME):
                case static_cast<int32_t>(Literal::SORT_BY_TIME):
                case static_cast<int32_t>(Literal::SORT_BY_PRICE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SortOptions &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SortOptions &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SortOptions &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SortOptions &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SortOptions &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SortOptions &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct SearchStatusState : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            NOT_STARTED = 1,
            SEARCHING = 2,
            FINISHED = 3
        };
        
        SearchStatusState() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        SearchStatusState(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::NOT_STARTED):
                case static_cast<int32_t>(Literal::SEARCHING):
                case static_cast<int32_t>(Literal::FINISHED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SearchStatusState &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SearchStatusState &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SearchStatusState &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SearchStatusState &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SearchStatusState &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SearchStatusState &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AttributeType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INTEGER = 0,
            BOOLEAN = 1,
            COORDINATE = 2,
            STRING = 3
        };
        
        AttributeType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INTEGER)) {}
        AttributeType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INTEGER):
                case static_cast<int32_t>(Literal::BOOLEAN):
                case static_cast<int32_t>(Literal::COORDINATE):
                case static_cast<int32_t>(Literal::STRING):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AttributeType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AttributeType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AttributeType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AttributeType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AttributeType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AttributeType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct OperatorType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            MORE_THAN = 1,
            LESS_THAN = 2,
            EQUAL = 3
        };
        
        OperatorType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        OperatorType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::MORE_THAN):
                case static_cast<int32_t>(Literal::LESS_THAN):
                case static_cast<int32_t>(Literal::EQUAL):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const OperatorType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const OperatorType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const OperatorType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const OperatorType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const OperatorType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const OperatorType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct UpdateReason : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ADDED = 0,
            REMOVED = 1,
            ATTR_ADDED = 2,
            ATTR_MODIFIED = 3,
            ATTR_REMOVED = 4
        };
        
        UpdateReason() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ADDED)) {}
        UpdateReason(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ADDED):
                case static_cast<int32_t>(Literal::REMOVED):
                case static_cast<int32_t>(Literal::ATTR_ADDED):
                case static_cast<int32_t>(Literal::ATTR_MODIFIED):
                case static_cast<int32_t>(Literal::ATTR_REMOVED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const UpdateReason &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const UpdateReason &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const UpdateReason &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const UpdateReason &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const UpdateReason &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const UpdateReason &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Different types of resources for icons
     */
    typedef CommonAPI::Variant<std::vector<ResourceID>, std::string>  Icon;
    /**
     * description: Differtent type of media
     */
    typedef CommonAPI::Variant<std::vector<ResourceID>, std::string>  Media;
    /**
     * description: values for attributes.
     */
    typedef CommonAPI::Variant<std::vector<int32_t>, std::vector<std::string>, std::vector<bool>, std::vector<::org::harman::nav::ctrl::CommonTypes::Coordinate2D>>  AttributeValue;
    /**
     * description: 
     */
    struct Details : CommonAPI::Struct<std::vector<CategoryID>, Icon, std::string, std::string, Media> {
    	
    	Details() {
    	}
    	Details(const std::vector<CategoryID> &_parentsId, const Icon &_icons, const std::string &_name, const std::string &_shortDesc, const Media &_media)
    	{
    		std::get<0>(values_) = _parentsId;
    		std::get<1>(values_) = _icons;
    		std::get<2>(values_) = _name;
    		std::get<3>(values_) = _shortDesc;
    		std::get<4>(values_) = _media;
    	}
    	/**
    	 * description: list of parent categories unique id.
    	 */
    	inline const std::vector<CategoryID> &getParentsId() const { return std::get<0>(values_); }
    	inline void setParentsId(const std::vector<CategoryID> &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: visual icons set.
    	 */
    	inline const Icon &getIcons() const { return std::get<1>(values_); }
    	inline void setIcons(const Icon &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: name.
    	 */
    	inline const std::string &getName() const { return std::get<2>(values_); }
    	inline void setName(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: short category description (optional).
    	 */
    	inline const std::string &getShortDesc() const { return std::get<3>(values_); }
    	inline void setShortDesc(const std::string &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: media associated (html web site, audio, video, ...) (optional).
    	 */
    	inline const Media &getMedia() const { return std::get<4>(values_); }
    	inline void setMedia(const Media &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const Details& _other) const {
                return (getParentsId() == _other.getParentsId() && getIcons() == _other.getIcons() && getName() == _other.getName() && getShortDesc() == _other.getShortDesc() && getMedia() == _other.getMedia());
        }
    	inline bool operator!=(const Details &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: 
     */
    struct Operator : CommonAPI::Struct<OperatorType, std::string, AttributeValue> {
    	
    	Operator() {
    	}
    	Operator(const OperatorType &_type, const std::string &_name, const AttributeValue &_value)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _value;
    	}
    	/**
    	 * description: enum(INVALID,MORE_THAN,LESS_THAN,EQUAL, ....).
    	 */
    	inline const OperatorType &getType() const { return std::get<0>(values_); }
    	inline void setType(const OperatorType &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: localized display name.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: value to use if this comparator is selected.
    	 */
    	inline const AttributeValue &getValue() const { return std::get<2>(values_); }
    	inline void setValue(const AttributeValue &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const Operator& _other) const {
                return (getType() == _other.getType() && getName() == _other.getName() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const Operator &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Describes an attribute which is associated to an category. Use more than one
     *   operator to specify choice options i.e. differtent accpeted credid cards
     *   
    	used in categor details and update category
     */
    struct CategoryAttribute : CommonAPI::Struct<AttributeID, std::string, AttributeType, std::vector<Operator>> {
    	
    	CategoryAttribute() {
    	}
    	CategoryAttribute(const AttributeID &_id, const std::string &_name, const AttributeType &_type, const std::vector<Operator> &_operators)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _type;
    		std::get<3>(values_) = _operators;
    	}
    	/**
    	 * description: id of attribute .
    	 */
    	inline const AttributeID &getId() const { return std::get<0>(values_); }
    	inline void setId(const AttributeID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: localized display name.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: enum(INVALID,STRING,INTEGER,COORDINATES ...).
    	 */
    	inline const AttributeType &getType() const { return std::get<2>(values_); }
    	inline void setType(const AttributeType &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: 
    	 */
    	inline const std::vector<Operator> &getOperators() const { return std::get<3>(values_); }
    	inline void setOperators(const std::vector<Operator> &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const CategoryAttribute& _other) const {
                return (getId() == _other.getId() && getName() == _other.getName() && getType() == _other.getType() && getOperators() == _other.getOperators());
        }
    	inline bool operator!=(const CategoryAttribute &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: 
     */
    struct CategorySortOption : CommonAPI::Struct<CategoryID, std::string> {
    	
    	CategorySortOption() {
    	}
    	CategorySortOption(const CategoryID &_id, const std::string &_name)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _name;
    	}
    	/**
    	 * description: enum(SORT_DEFAULT,SORT_BY_DISTANCE,SORT_BY_TIME,ATTRIBUTE_CUSTOM, ... ).
    	 */
    	inline const CategoryID &getId() const { return std::get<0>(values_); }
    	inline void setId(const CategoryID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: localized name to be displayed by application.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const CategorySortOption& _other) const {
                return (getId() == _other.getId() && getName() == _other.getName());
        }
    	inline bool operator!=(const CategorySortOption &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: 
     */
    struct CAMCategory : CommonAPI::Struct<Details, std::vector<CategoryAttribute>, std::vector<CategorySortOption>> {
    	
    	CAMCategory() {
    	}
    	CAMCategory(const Details &_details, const std::vector<CategoryAttribute> &_attribs, const std::vector<CategorySortOption> &_sortOptions)
    	{
    		std::get<0>(values_) = _details;
    		std::get<1>(values_) = _attribs;
    		std::get<2>(values_) = _sortOptions;
    	}
    	/**
    	 * description: struct(list of parents_id, icons, name, short_desc, media).
    	 */
    	inline const Details &getDetails() const { return std::get<0>(values_); }
    	inline void setDetails(const Details &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: array[struct(name, type, array[struct(operator_id, operator_name)])].
    	 */
    	inline const std::vector<CategoryAttribute> &getAttribs() const { return std::get<1>(values_); }
    	inline void setAttribs(const std::vector<CategoryAttribute> &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: array[struct(id, name)].
    	 */
    	inline const std::vector<CategorySortOption> &getSortOptions() const { return std::get<2>(values_); }
    	inline void setSortOptions(const std::vector<CategorySortOption> &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const CAMCategory& _other) const {
                return (getDetails() == _other.getDetails() && getAttribs() == _other.getAttribs() && getSortOptions() == _other.getSortOptions());
        }
    	inline bool operator!=(const CAMCategory &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: 
     */
    struct CAMCategoryUpdate : CommonAPI::Struct<CategoryID, std::vector<CategoryAttribute>, std::vector<CategorySortOption>> {
    	
    	CAMCategoryUpdate() {
    	}
    	CAMCategoryUpdate(const CategoryID &_id, const std::vector<CategoryAttribute> &_attribs, const std::vector<CategorySortOption> &_sortOptions)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _attribs;
    		std::get<2>(values_) = _sortOptions;
    	}
    	/**
    	 * description: enum(INVALID,ALL_CATEGORIES,AIRPORT,RESTAURANT,HOTEL,GAZ_STATION,CAR_PARK,
    	 *   ...). Note: A POI category is a unique ID. It could be a predefined category
    	 *   or a custom one defined by a POI plug-in
    	 */
    	inline const CategoryID &getId() const { return std::get<0>(values_); }
    	inline void setId(const CategoryID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: array[struct(name, type, array[struct(operator_id, operator_name)])].
    	 */
    	inline const std::vector<CategoryAttribute> &getAttribs() const { return std::get<1>(values_); }
    	inline void setAttribs(const std::vector<CategoryAttribute> &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: array[struct(id, name)].
    	 */
    	inline const std::vector<CategorySortOption> &getSortOptions() const { return std::get<2>(values_); }
    	inline void setSortOptions(const std::vector<CategorySortOption> &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const CAMCategoryUpdate& _other) const {
                return (getId() == _other.getId() && getAttribs() == _other.getAttribs() && getSortOptions() == _other.getSortOptions());
        }
    	inline bool operator!=(const CAMCategoryUpdate &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Attribute associcated to an POI used in addPOI and POI Search Result(both CAM
     *   and Service)
     */
    struct PoiAttribute : CommonAPI::Struct<AttributeID, AttributeType, AttributeValue> {
    	
    	PoiAttribute() {
    	}
    	PoiAttribute(const AttributeID &_id, const AttributeType &_type, const AttributeValue &_value)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _type;
    		std::get<2>(values_) = _value;
    	}
    	/**
    	 * description: attribute unique id (see data model)
    	 */
    	inline const AttributeID &getId() const { return std::get<0>(values_); }
    	inline void setId(const AttributeID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: enum(INVALID,STRING,INTEGER,COORDINATES ...)
    	 */
    	inline const AttributeType &getType() const { return std::get<1>(values_); }
    	inline void setType(const AttributeType &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The value depends on the attribute specifications and type
    	 */
    	inline const AttributeValue &getValue() const { return std::get<2>(values_); }
    	inline void setValue(const AttributeValue &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const PoiAttribute& _other) const {
                return (getId() == _other.getId() && getType() == _other.getType() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const PoiAttribute &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: 
     */
    struct CategoryAndRadius : CommonAPI::Struct<CategoryID, uint32_t> {
    	
    	CategoryAndRadius() {
    	}
    	CategoryAndRadius(const CategoryID &_id, const uint32_t &_radius)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _radius;
    	}
    	/**
    	 * description: enum(INVALID,ALL_CATEGORIES,AIRPORT,RESTAURANT,HOTEL,GAZ_STATION,CAR_PARK,
    	 *   ...). Note: A POI category is a unique ID. It could be a predefined category
    	 *   or a custom one defined by a POI plug-in
    	 */
    	inline const CategoryID &getId() const { return std::get<0>(values_); }
    	inline void setId(const CategoryID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: activation or search radius around the position (in 10 meters) for the
    	 *   category. If value is 0 (zero), the default radius (defined for a category) is
    	 *   applied.
    	 */
    	inline const uint32_t &getRadius() const { return std::get<1>(values_); }
    	inline void setRadius(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const CategoryAndRadius& _other) const {
                return (getId() == _other.getId() && getRadius() == _other.getRadius());
        }
    	inline bool operator!=(const CategoryAndRadius &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: 
     */
    struct PoiDetails : CommonAPI::Struct<POI_ID, std::string, ::org::harman::nav::ctrl::CommonTypes::Coordinate3D> {
    	
    	PoiDetails() {
    	}
    	PoiDetails(const POI_ID &_id, const std::string &_name, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_location)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _location;
    	}
    	/**
    	 * description: POI id
    	 */
    	inline const POI_ID &getId() const { return std::get<0>(values_); }
    	inline void setId(const POI_ID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: POI name
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: POI location.
    	 */
    	inline const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &getLocation() const { return std::get<2>(values_); }
    	inline void setLocation(const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const PoiDetails& _other) const {
                return (getId() == _other.getId() && getName() == _other.getName() && getLocation() == _other.getLocation());
        }
    	inline bool operator!=(const PoiDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: 
     */
    struct SearchResultDetails : CommonAPI::Struct<PoiDetails, std::vector<CategoryID>, std::vector<PoiAttribute>> {
    	
    	SearchResultDetails() {
    	}
    	SearchResultDetails(const PoiDetails &_details, const std::vector<CategoryID> &_categories, const std::vector<PoiAttribute> &_attribs)
    	{
    		std::get<0>(values_) = _details;
    		std::get<1>(values_) = _categories;
    		std::get<2>(values_) = _attribs;
    	}
    	/**
    	 * description: struct(id,name,latitude,longitude,altitude).
    	 */
    	inline const PoiDetails &getDetails() const { return std::get<0>(values_); }
    	inline void setDetails(const PoiDetails &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: array[unique_id].
    	 */
    	inline const std::vector<CategoryID> &getCategories() const { return std::get<1>(values_); }
    	inline void setCategories(const std::vector<CategoryID> &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: array[struct(name,type,value)].
    	 */
    	inline const std::vector<PoiAttribute> &getAttribs() const { return std::get<2>(values_); }
    	inline void setAttribs(const std::vector<PoiAttribute> &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const SearchResultDetails& _other) const {
                return (getDetails() == _other.getDetails() && getCategories() == _other.getCategories() && getAttribs() == _other.getAttribs());
        }
    	inline bool operator!=(const SearchResultDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: 
     */
    struct SearchResult : CommonAPI::Struct<POI_ID, uint32_t, uint16_t, std::vector<PoiAttribute>> {
    	
    	SearchResult() {
    	}
    	SearchResult(const POI_ID &_id, const uint32_t &_distance, const uint16_t &_routeStatus, const std::vector<PoiAttribute> &_attribs)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _distance;
    		std::get<2>(values_) = _routeStatus;
    		std::get<3>(values_) = _attribs;
    	}
    	/**
    	 * description: POI id
    	 */
    	inline const POI_ID &getId() const { return std::get<0>(values_); }
    	inline void setId(const POI_ID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: distance in meters to poi from center of the search or from vehicle if search
    	 *   along
    	 */
    	inline const uint32_t &getDistance() const { return std::get<1>(values_); }
    	inline void setDistance(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: enum(OFF_ROUTE,ON_ROUTE,INSIDE_CORRIDOR, ... )
    	 */
    	inline const uint16_t &getRouteStatus() const { return std::get<2>(values_); }
    	inline void setRouteStatus(const uint16_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: List of attributes requested. It could be empty
    	 */
    	inline const std::vector<PoiAttribute> &getAttribs() const { return std::get<3>(values_); }
    	inline void setAttribs(const std::vector<PoiAttribute> &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const SearchResult& _other) const {
                return (getId() == _other.getId() && getDistance() == _other.getDistance() && getRouteStatus() == _other.getRouteStatus() && getAttribs() == _other.getAttribs());
        }
    	inline bool operator!=(const SearchResult &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: 
     */
    struct PoiCAMDetails : CommonAPI::Struct<POI_ID, std::string, CategoryID, ::org::harman::nav::ctrl::CommonTypes::Coordinate3D, uint16_t, std::vector<PoiAttribute>> {
    	
    	PoiCAMDetails() {
    	}
    	PoiCAMDetails(const POI_ID &_sourceId, const std::string &_name, const CategoryID &_category, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_location, const uint16_t &_distance, const std::vector<PoiAttribute> &_attribs)
    	{
    		std::get<0>(values_) = _sourceId;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _category;
    		std::get<3>(values_) = _location;
    		std::get<4>(values_) = _distance;
    		std::get<5>(values_) = _attribs;
    	}
    	/**
    	 * description: POI unique id as known by the content access module. This id will be used by
    	 *   POI service to request POI details.
    	 */
    	inline const POI_ID &getSourceId() const { return std::get<0>(values_); }
    	inline void setSourceId(const POI_ID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: POI name.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: POI category unique id.
    	 */
    	inline const CategoryID &getCategory() const { return std::get<2>(values_); }
    	inline void setCategory(const CategoryID &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: POI location.
    	 */
    	inline const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &getLocation() const { return std::get<3>(values_); }
    	inline void setLocation(const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: distance in meters to poi from center of the search.
    	 */
    	inline const uint16_t &getDistance() const { return std::get<4>(values_); }
    	inline void setDistance(const uint16_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: List of attributes requested. It could be empty.
    	 */
    	inline const std::vector<PoiAttribute> &getAttribs() const { return std::get<5>(values_); }
    	inline void setAttribs(const std::vector<PoiAttribute> &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const PoiCAMDetails& _other) const {
                return (getSourceId() == _other.getSourceId() && getName() == _other.getName() && getCategory() == _other.getCategory() && getLocation() == _other.getLocation() && getDistance() == _other.getDistance() && getAttribs() == _other.getAttribs());
        }
    	inline bool operator!=(const PoiCAMDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: used in setAttrbutes and CAM startPOISearch
     */
    struct AttributeDetails : CommonAPI::Struct<AttributeID, CategoryID, AttributeType, AttributeValue, OperatorType, bool> {
    	
    	AttributeDetails() {
    		std::get<5>(values_) = false;
    	}
    	AttributeDetails(const AttributeID &_id, const CategoryID &_categoryId, const AttributeType &_type, const AttributeValue &_value, const OperatorType &_oper, const bool &_mandatory)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _categoryId;
    		std::get<2>(values_) = _type;
    		std::get<3>(values_) = _value;
    		std::get<4>(values_) = _oper;
    		std::get<5>(values_) = _mandatory;
    	}
    	/**
    	 * description: id of attribute .
    	 */
    	inline const AttributeID &getId() const { return std::get<0>(values_); }
    	inline void setId(const AttributeID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: enum(INVALID,ALL_CATEGORIES,AIRPORT,RESTAURANT,HOTEL,GAZ_STATION,CAR_PARK,
    	 *   ...). Note: A POI category is a unique ID. It could be a predefined category
    	 *   or a custom one defined by a POI plug-in
    	 */
    	inline const CategoryID &getCategoryId() const { return std::get<1>(values_); }
    	inline void setCategoryId(const CategoryID &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: enum(INVALID,STRING,INTEGER,COORDINATES ...).
    	 */
    	inline const AttributeType &getType() const { return std::get<2>(values_); }
    	inline void setType(const AttributeType &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: value or partial value. The value depends on the attribute specifications and
    	 *   type.
    	 */
    	inline const AttributeValue &getValue() const { return std::get<3>(values_); }
    	inline void setValue(const AttributeValue &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: enum(INVALID,MORE_THAN,LESS_THAN,EQUAL, ....).
    	 */
    	inline const OperatorType &getOper() const { return std::get<4>(values_); }
    	inline void setOper(const OperatorType &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: true if the attribute is mandatory for the search and false for optional.
    	 */
    	inline const bool &getMandatory() const { return std::get<5>(values_); }
    	inline void setMandatory(const bool _value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const AttributeDetails& _other) const {
                return (getId() == _other.getId() && getCategoryId() == _other.getCategoryId() && getType() == _other.getType() && getValue() == _other.getValue() && getOper() == _other.getOper() && getMandatory() == _other.getMandatory());
        }
    	inline bool operator!=(const AttributeDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Detailed descripton of a category
     */
    struct CategoryDetails : CommonAPI::Struct<CategoryID, std::vector<CategoryID>, Icon, std::string, bool, std::string, Media> {
    	
    	CategoryDetails() {
    		std::get<4>(values_) = false;
    	}
    	CategoryDetails(const CategoryID &_uniqueId, const std::vector<CategoryID> &_parentsId, const Icon &_icons, const std::string &_name, const bool &_topLevel, const std::string &_description, const Media &_media)
    	{
    		std::get<0>(values_) = _uniqueId;
    		std::get<1>(values_) = _parentsId;
    		std::get<2>(values_) = _icons;
    		std::get<3>(values_) = _name;
    		std::get<4>(values_) = _topLevel;
    		std::get<5>(values_) = _description;
    		std::get<6>(values_) = _media;
    	}
    	/**
    	 * description: Category unique id.
    	 */
    	inline const CategoryID &getUniqueId() const { return std::get<0>(values_); }
    	inline void setUniqueId(const CategoryID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: list of parent categories unique id.
    	 */
    	inline const std::vector<CategoryID> &getParentsId() const { return std::get<1>(values_); }
    	inline void setParentsId(const std::vector<CategoryID> &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: visual icons set.
    	 */
    	inline const Icon &getIcons() const { return std::get<2>(values_); }
    	inline void setIcons(const Icon &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: name.
    	 */
    	inline const std::string &getName() const { return std::get<3>(values_); }
    	inline void setName(const std::string &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: true if the category is a pre-defined one (top level), false for customized
    	 *   categories created by plug-in.
    	 */
    	inline const bool &getTopLevel() const { return std::get<4>(values_); }
    	inline void setTopLevel(const bool _value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: short category description (optional).
    	 */
    	inline const std::string &getDescription() const { return std::get<5>(values_); }
    	inline void setDescription(const std::string &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: media associated (html web site, audio, video, ...) (optional).
    	 */
    	inline const Media &getMedia() const { return std::get<6>(values_); }
    	inline void setMedia(const Media &_value) { std::get<6>(values_) = _value; }
    	inline bool operator==(const CategoryDetails& _other) const {
                return (getUniqueId() == _other.getUniqueId() && getParentsId() == _other.getParentsId() && getIcons() == _other.getIcons() && getName() == _other.getName() && getTopLevel() == _other.getTopLevel() && getDescription() == _other.getDescription() && getMedia() == _other.getMedia());
        }
    	inline bool operator!=(const CategoryDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Detailed description of a category including attributes and sort options
     */
    struct Category : CommonAPI::Struct<CategoryDetails, std::vector<CategoryAttribute>, std::vector<CategorySortOption>> {
    	
    	Category() {
    	}
    	Category(const CategoryDetails &_details, const std::vector<CategoryAttribute> &_attribs, const std::vector<CategorySortOption> &_sortOptions)
    	{
    		std::get<0>(values_) = _details;
    		std::get<1>(values_) = _attribs;
    		std::get<2>(values_) = _sortOptions;
    	}
    	/**
    	 * description: struct(unique_id, list of parents_id, icons, name, top_level, short_desc,
    	 *   media).
    	 */
    	inline const CategoryDetails &getDetails() const { return std::get<0>(values_); }
    	inline void setDetails(const CategoryDetails &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: array[struct(name, type, array[struct(operator_id, operator_name)].
    	 */
    	inline const std::vector<CategoryAttribute> &getAttribs() const { return std::get<1>(values_); }
    	inline void setAttribs(const std::vector<CategoryAttribute> &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: array[struct(id, name)].
    	 */
    	inline const std::vector<CategorySortOption> &getSortOptions() const { return std::get<2>(values_); }
    	inline void setSortOptions(const std::vector<CategorySortOption> &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const Category& _other) const {
                return (getDetails() == _other.getDetails() && getAttribs() == _other.getAttribs() && getSortOptions() == _other.getSortOptions());
        }
    	inline bool operator!=(const Category &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Pair of catgory and description of level
     */
    struct CategoryAndLevel : CommonAPI::Struct<CategoryID, bool, bool> {
    	
    	CategoryAndLevel() {
    		std::get<1>(values_) = false;
    		std::get<2>(values_) = false;
    	}
    	CategoryAndLevel(const CategoryID &_uniqueId, const bool &_topLevel, const bool &_hasChildCategories)
    	{
    		std::get<0>(values_) = _uniqueId;
    		std::get<1>(values_) = _topLevel;
    		std::get<2>(values_) = _hasChildCategories;
    	}
    	/**
    	 * description: Category unique id.
    	 */
    	inline const CategoryID &getUniqueId() const { return std::get<0>(values_); }
    	inline void setUniqueId(const CategoryID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: true if the category is a pre-defined one (top level), false for customized
    	 *   categories created by plug-in.
    	 */
    	inline const bool &getTopLevel() const { return std::get<1>(values_); }
    	inline void setTopLevel(const bool _value) { std::get<1>(values_) = _value; }
    	inline const bool &getHasChildCategories() const { return std::get<2>(values_); }
    	inline void setHasChildCategories(const bool _value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const CategoryAndLevel& _other) const {
                return (getUniqueId() == _other.getUniqueId() && getTopLevel() == _other.getTopLevel() && getHasChildCategories() == _other.getHasChildCategories());
        }
    	inline bool operator!=(const CategoryAndLevel &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: pair of category and name
     */
    struct CategoryAndName : CommonAPI::Struct<CategoryID, std::string, bool> {
    	
    	CategoryAndName() {
    		std::get<2>(values_) = false;
    	}
    	CategoryAndName(const CategoryID &_uniqueId, const std::string &_name, const bool &_topLevel)
    	{
    		std::get<0>(values_) = _uniqueId;
    		std::get<1>(values_) = _name;
    		std::get<2>(values_) = _topLevel;
    	}
    	/**
    	 * description: Category unique id.
    	 */
    	inline const CategoryID &getUniqueId() const { return std::get<0>(values_); }
    	inline void setUniqueId(const CategoryID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: name.
    	 */
    	inline const std::string &getName() const { return std::get<1>(values_); }
    	inline void setName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: true if the category is a pre-defined one (top level), false for customized
    	 *   categories created by plug-in.
    	 */
    	inline const bool &getTopLevel() const { return std::get<2>(values_); }
    	inline void setTopLevel(const bool _value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const CategoryAndName& _other) const {
                return (getUniqueId() == _other.getUniqueId() && getName() == _other.getName() && getTopLevel() == _other.getTopLevel());
        }
    	inline bool operator!=(const CategoryAndName &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: pair of category and reson for update
     */
    struct CategoryAndReason : CommonAPI::Struct<CategoryID, uint16_t> {
    	
    	CategoryAndReason() {
    	}
    	CategoryAndReason(const CategoryID &_unique_id, const uint16_t &_reason)
    	{
    		std::get<0>(values_) = _unique_id;
    		std::get<1>(values_) = _reason;
    	}
    	/**
    	 * description: Category unique id.
    	 */
    	inline const CategoryID &getUnique_id() const { return std::get<0>(values_); }
    	inline void setUnique_id(const CategoryID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: enum(ADDED,REMOVED,ATTR_ADDED,ATTR_MODIFIED,ATTR_REMOVED, ... ) .
    	 */
    	inline const uint16_t &getReason() const { return std::get<1>(values_); }
    	inline void setReason(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const CategoryAndReason& _other) const {
                return (getUnique_id() == _other.getUnique_id() && getReason() == _other.getReason());
        }
    	inline bool operator!=(const CategoryAndReason &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: pair of category and the this category is available
     */
    struct CategoryAndStatus : CommonAPI::Struct<CategoryID, bool> {
    	
    	CategoryAndStatus() {
    		std::get<1>(values_) = false;
    	}
    	CategoryAndStatus(const CategoryID &_uniqueId, const bool &_status)
    	{
    		std::get<0>(values_) = _uniqueId;
    		std::get<1>(values_) = _status;
    	}
    	/**
    	 * description: Category unique id.
    	 */
    	inline const CategoryID &getUniqueId() const { return std::get<0>(values_); }
    	inline void setUniqueId(const CategoryID &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: true if the category is available .
    	 */
    	inline const bool &getStatus() const { return std::get<1>(values_); }
    	inline void setStatus(const bool _value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const CategoryAndStatus& _other) const {
                return (getUniqueId() == _other.getUniqueId() && getStatus() == _other.getStatus());
        }
    	inline bool operator!=(const CategoryAndStatus &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: 
     */
    struct PoiAddedDetails : CommonAPI::Struct<std::string, ::org::harman::nav::ctrl::CommonTypes::Coordinate3D, std::vector<PoiAttribute>> {
    	
    	PoiAddedDetails() {
    	}
    	PoiAddedDetails(const std::string &_name, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_location, const std::vector<PoiAttribute> &_attribs)
    	{
    		std::get<0>(values_) = _name;
    		std::get<1>(values_) = _location;
    		std::get<2>(values_) = _attribs;
    	}
    	/**
    	 * description: POI name
    	 */
    	inline const std::string &getName() const { return std::get<0>(values_); }
    	inline void setName(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: POI location.
    	 */
    	inline const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &getLocation() const { return std::get<1>(values_); }
    	inline void setLocation(const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: array[struct(name,type,value)].
    	 */
    	inline const std::vector<PoiAttribute> &getAttribs() const { return std::get<2>(values_); }
    	inline void setAttribs(const std::vector<PoiAttribute> &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const PoiAddedDetails& _other) const {
                return (getName() == _other.getName() && getLocation() == _other.getLocation() && getAttribs() == _other.getAttribs());
        }
    	inline bool operator!=(const PoiAddedDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Details for a POI preview on map
     */
    struct PreviewDetails : CommonAPI::Struct<uint32_t, std::string, POI_ID, std::vector<CategoryID>, Icon, ::org::harman::nav::ctrl::CommonTypes::Coordinate3D, std::string> {
    	
    	PreviewDetails() {
    	}
    	PreviewDetails(const uint32_t &_index, const std::string &_displayedIndex, const POI_ID &_Id, const std::vector<CategoryID> &_category, const Icon &_icon, const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_geopos, const std::string &_name)
    	{
    		std::get<0>(values_) = _index;
    		std::get<1>(values_) = _displayedIndex;
    		std::get<2>(values_) = _Id;
    		std::get<3>(values_) = _category;
    		std::get<4>(values_) = _icon;
    		std::get<5>(values_) = _geopos;
    		std::get<6>(values_) = _name;
    	}
    	/**
    	 * description: Index in list.
    	 */
    	inline const uint32_t &getIndex() const { return std::get<0>(values_); }
    	inline void setIndex(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Displayed index (can differ, e.g. advertisemenet).
    	 */
    	inline const std::string &getDisplayedIndex() const { return std::get<1>(values_); }
    	inline void setDisplayedIndex(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: POI Id.
    	 */
    	inline const POI_ID &getId() const { return std::get<2>(values_); }
    	inline void setId(const POI_ID &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: list of parent categories unique id.
    	 */
    	inline const std::vector<CategoryID> &getCategory() const { return std::get<3>(values_); }
    	inline void setCategory(const std::vector<CategoryID> &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: visual icon.
    	 */
    	inline const Icon &getIcon() const { return std::get<4>(values_); }
    	inline void setIcon(const Icon &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: position.
    	 */
    	inline const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &getGeopos() const { return std::get<5>(values_); }
    	inline void setGeopos(const ::org::harman::nav::ctrl::CommonTypes::Coordinate3D &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: name, optional.
    	 */
    	inline const std::string &getName() const { return std::get<6>(values_); }
    	inline void setName(const std::string &_value) { std::get<6>(values_) = _value; }
    	inline bool operator==(const PreviewDetails& _other) const {
                return (getIndex() == _other.getIndex() && getDisplayedIndex() == _other.getDisplayedIndex() && getId() == _other.getId() && getCategory() == _other.getCategory() && getIcon() == _other.getIcon() && getGeopos() == _other.getGeopos() && getName() == _other.getName());
        }
    	inline bool operator!=(const PreviewDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.harman.nav.ctrl.di.POIServiceTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 0);
}

}; // struct POIServiceTypes

} // namespace di
} // namespace ctrl
} // namespace nav
} // namespace harman
} // namespace org
} // namespace v1

namespace CommonAPI {
}


namespace std {
    //Hash for SortOptions
    template<>
    struct hash<::v1::org::harman::nav::ctrl::di::POIServiceTypes::SortOptions> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::di::POIServiceTypes::SortOptions& sortOptions) const {
            return static_cast<int32_t>(sortOptions);
        }
    };
    //Hash for SearchStatusState
    template<>
    struct hash<::v1::org::harman::nav::ctrl::di::POIServiceTypes::SearchStatusState> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::di::POIServiceTypes::SearchStatusState& searchStatusState) const {
            return static_cast<int32_t>(searchStatusState);
        }
    };
    //Hash for AttributeType
    template<>
    struct hash<::v1::org::harman::nav::ctrl::di::POIServiceTypes::AttributeType> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::di::POIServiceTypes::AttributeType& attributeType) const {
            return static_cast<int32_t>(attributeType);
        }
    };
    //Hash for OperatorType
    template<>
    struct hash<::v1::org::harman::nav::ctrl::di::POIServiceTypes::OperatorType> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::di::POIServiceTypes::OperatorType& operatorType) const {
            return static_cast<int32_t>(operatorType);
        }
    };
    //Hash for UpdateReason
    template<>
    struct hash<::v1::org::harman::nav::ctrl::di::POIServiceTypes::UpdateReason> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::di::POIServiceTypes::UpdateReason& updateReason) const {
            return static_cast<int32_t>(updateReason);
        }
    };
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_ORG_HARMAN_NAV_CTRL_DI_POI_Service_Types_HPP_
