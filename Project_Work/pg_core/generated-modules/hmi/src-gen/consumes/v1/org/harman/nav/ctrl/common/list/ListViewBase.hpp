/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: ListViewBase = This interface offers functions that implement a basic list
 *   concept 
    The basic idea of this inteface is the following:
    A client
 *   registers a view with a certain size n on a list with a dynamic size m. Please
 *   note: during 
    initial call, a view might be bigger than the underlying
 *   list. 
    The client uses index - so called ListTypes.ListKey to position the
 *   first element of a view to a certain
    element in the list. Please note: the
 *   ListKey value must be in a valid range between first (0) and last (m)
 *   element.
    Furthermore the client specifies it's anchor point. An anchor is
 *   more or less the stable entry in a view which - 
    even in case of a
 *   listupdate - stays at a permanent position in the view. It is used to
 *   guarantee a stable view
    in case of list changes (sorting changed,
 *   inserts/deletes) and furthermore allow a client to realize a smooth
   
 *   scrolling - if necessary. For better understanding see the following example:
 *   
    There is a list of 30 elements and a view with a total of 4 entries. The
 *   view is positioned at entry 21, which 
    means the view shows the entries
 *   [21, 22, 23, 24]. The client specifies the anchor on 22. Now imagine an update
 *   
    occurs (e.g. a new entry will get inserted between 17 and 18). The
 *   clients get notified by a broadcast that the
    ListTypes.ListKey of his
 *   anchor is now 23 (because the entry 22 is moved on index 23). 
    
    While
 *   the base list specifies how to navitation and create a view on a given list,
 *   the concrete implementation of 
    a list is responsible for providing the
 *   data of a view. This must be realized in the following manner: each
   
 *   concrete implementation must provide a getView() function which returns the
 *   entries of a current view, the absolute
    key/index of the view and the
 *   relative anchor position based on the view position. The provider
    of the
 *   list is responsible for providing always the correct elements of a list based
 *   on the anchor, the client
    has specified. 
    
    Special case handling:
 *   in some cases it might happen, that the specified anchor point get's removed
 *   from the list
    and therefore from the view. In this case the list
 *   implementation will behave like the following: If possible,
    the anchor
 *   will be replaced by the provider with the next element (successor) in the
 *   list. If this is not possible
    (anchor already pointed to the last element
 *   in list), the previous element (predecessor) is selected as new anchor.
   
 *   Anyway - the impact of an update on the anchor will be indicated by
 *   appropriate enum.
 */
#ifndef V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_LIST_VIEW_BASE_HPP_
#define V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_LIST_VIEW_BASE_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Types.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace common {
namespace list {

class ListViewBase {
public:
    virtual ~ListViewBase() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
};

const char* ListViewBase::getInterface() {
    return ("org.harman.nav.ctrl.common.list.ListViewBase");
}

CommonAPI::Version ListViewBase::getInterfaceVersion() {
    return CommonAPI::Version(1, 0);
}


} // namespace list
} // namespace common
} // namespace ctrl
} // namespace nav
} // namespace harman
} // namespace org
} // namespace v1

namespace CommonAPI {
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_ORG_HARMAN_NAV_CTRL_COMMON_LIST_LIST_VIEW_BASE_HPP_
