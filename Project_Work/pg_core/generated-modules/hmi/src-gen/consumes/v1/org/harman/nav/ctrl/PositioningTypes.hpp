/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
#ifndef V1_ORG_HARMAN_NAV_CTRL_Positioning_Types_HPP_
#define V1_ORG_HARMAN_NAV_CTRL_Positioning_Types_HPP_


#include <org/harman/nav/ctrl/CommonTypes.hpp>
#include <org/harman/nav/ctrl/configuration/ConfigurationTypes.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace org {
namespace harman {
namespace nav {
namespace ctrl {

struct PositioningTypes {
    
    struct PositionStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            TIMESTAMP = 1,
            GNSS_FIX_STATUS = 2,
            DR_STATUS = 3,
            MM_STATUS = 4,
            SIMULATION_MODE = 5
        };
        
        PositionStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        PositionStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        PositionStatus &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::TIMESTAMP):
                case static_cast<int32_t>(Literal::GNSS_FIX_STATUS):
                case static_cast<int32_t>(Literal::DR_STATUS):
                case static_cast<int32_t>(Literal::MM_STATUS):
                case static_cast<int32_t>(Literal::SIMULATION_MODE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PositionStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PositionStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PositionStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PositionStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PositionStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PositionStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct PositionItemKey : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            TIMESTAMP = 1,
            GNSS_FIX_STATUS = 2,
            DR_STATUS = 3,
            MM_STATUS = 4,
            SIMULATION_MODE = 5,
            LATITUDE = 6,
            LONGITUDE = 7,
            ALTITUDE = 8,
            HEADING = 9,
            SPEED = 10,
            CLIMB = 11,
            NUM_SATELLITES_VISIBLE = 12,
            NUM_SATELLITES_USED = 13
        };
        
        PositionItemKey() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        PositionItemKey(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        PositionItemKey &operator=(const PositionStatus::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
        PositionItemKey &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::TIMESTAMP):
                case static_cast<int32_t>(Literal::GNSS_FIX_STATUS):
                case static_cast<int32_t>(Literal::DR_STATUS):
                case static_cast<int32_t>(Literal::MM_STATUS):
                case static_cast<int32_t>(Literal::SIMULATION_MODE):
                case static_cast<int32_t>(Literal::LATITUDE):
                case static_cast<int32_t>(Literal::LONGITUDE):
                case static_cast<int32_t>(Literal::ALTITUDE):
                case static_cast<int32_t>(Literal::HEADING):
                case static_cast<int32_t>(Literal::SPEED):
                case static_cast<int32_t>(Literal::CLIMB):
                case static_cast<int32_t>(Literal::NUM_SATELLITES_VISIBLE):
                case static_cast<int32_t>(Literal::NUM_SATELLITES_USED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PositionItemKey &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PositionItemKey &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PositionItemKey &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PositionItemKey &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PositionItemKey &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PositionItemKey &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GnnsFixStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            NO_FIX = 1,
            TIME_FIX = 2,
            FIX_2D = 3,
            FIX_3D = 4
        };
        
        GnnsFixStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GnnsFixStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GnnsFixStatus &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::NO_FIX):
                case static_cast<int32_t>(Literal::TIME_FIX):
                case static_cast<int32_t>(Literal::FIX_2D):
                case static_cast<int32_t>(Literal::FIX_3D):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnnsFixStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnnsFixStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnnsFixStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnnsFixStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnnsFixStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnnsFixStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct MatchMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ON_ROAD = 1,
            OFF_ROAD = 2,
            ON_FERRY = 3,
            IN_TUNNEL = 4,
            ON_CARPARK = 5
        };
        
        MatchMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        MatchMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ON_ROAD):
                case static_cast<int32_t>(Literal::OFF_ROAD):
                case static_cast<int32_t>(Literal::ON_FERRY):
                case static_cast<int32_t>(Literal::IN_TUNNEL):
                case static_cast<int32_t>(Literal::ON_CARPARK):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MatchMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MatchMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MatchMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MatchMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MatchMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MatchMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef CommonAPI::Variant<::org::harman::nav::ctrl::CommonTypes::Timestamp, bool, GnnsFixStatus, double, int32_t, ::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitOfMeasurement>  PositionItemValue;
    typedef std::unordered_map<::v1::org::harman::nav::ctrl::PositioningTypes::PositionItemKey, ::v1::org::harman::nav::ctrl::PositioningTypes::PositionItemValue, CommonAPI::EnumHasher<::v1::org::harman::nav::ctrl::PositioningTypes::PositionItemKey>> PositionItemDict;
    
    struct AddressItemKey : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            TIMESTAMP = 1,
            COUNTRY = 2,
            COUNTRYCODE = 3,
            STATE = 4,
            CITY = 5,
            STREET = 6,
            ROAD_NUMBER = 7,
            HOUSENUMBER = 8,
            HOUSENAME = 9,
            CROSSING = 10,
            DISTRICT = 11,
            TIMEZONE_OFFSET = 12,
            DAYLIGHT_OFFSET = 13,
            MATCH_TYPE = 14
        };
        
        AddressItemKey() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        AddressItemKey(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        AddressItemKey &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::TIMESTAMP):
                case static_cast<int32_t>(Literal::COUNTRY):
                case static_cast<int32_t>(Literal::COUNTRYCODE):
                case static_cast<int32_t>(Literal::STATE):
                case static_cast<int32_t>(Literal::CITY):
                case static_cast<int32_t>(Literal::STREET):
                case static_cast<int32_t>(Literal::ROAD_NUMBER):
                case static_cast<int32_t>(Literal::HOUSENUMBER):
                case static_cast<int32_t>(Literal::HOUSENAME):
                case static_cast<int32_t>(Literal::CROSSING):
                case static_cast<int32_t>(Literal::DISTRICT):
                case static_cast<int32_t>(Literal::TIMEZONE_OFFSET):
                case static_cast<int32_t>(Literal::DAYLIGHT_OFFSET):
                case static_cast<int32_t>(Literal::MATCH_TYPE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AddressItemKey &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AddressItemKey &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AddressItemKey &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AddressItemKey &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AddressItemKey &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AddressItemKey &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef CommonAPI::Variant<std::string, int16_t, ::org::harman::nav::ctrl::CommonTypes::Timestamp, MatchMode>  AddressItemValue;
    typedef std::unordered_map<::v1::org::harman::nav::ctrl::PositioningTypes::AddressItemKey, ::v1::org::harman::nav::ctrl::PositioningTypes::AddressItemValue, CommonAPI::EnumHasher<::v1::org::harman::nav::ctrl::PositioningTypes::AddressItemKey>> AddressItemDict;
    typedef CommonAPI::Variant<bool, GnnsFixStatus, ::org::harman::nav::ctrl::CommonTypes::Timestamp>  PositionStatusValue;
    typedef std::unordered_map<::v1::org::harman::nav::ctrl::PositioningTypes::PositionStatus, ::v1::org::harman::nav::ctrl::PositioningTypes::PositionStatusValue, CommonAPI::EnumHasher<::v1::org::harman::nav::ctrl::PositioningTypes::PositionStatus>> PositionStatusDict;
    
    struct GpsTimeQuality : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            GOOD = 0,
            POOR = 1
        };
        
        GpsTimeQuality() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::GOOD)) {}
        GpsTimeQuality(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::GOOD):
                case static_cast<int32_t>(Literal::POOR):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GpsTimeQuality &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GpsTimeQuality &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GpsTimeQuality &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GpsTimeQuality &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GpsTimeQuality &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GpsTimeQuality &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct GpsTime : CommonAPI::Struct<::org::harman::nav::ctrl::CommonTypes::Timestamp, GpsTimeQuality> {
    	
    	GpsTime() {
    	}
    	GpsTime(const ::org::harman::nav::ctrl::CommonTypes::Timestamp &_time, const GpsTimeQuality &_quality)
    	{
    		std::get<0>(values_) = _time;
    		std::get<1>(values_) = _quality;
    	}
    	inline const ::org::harman::nav::ctrl::CommonTypes::Timestamp &getTime() const { return std::get<0>(values_); }
    	inline void setTime(const ::org::harman::nav::ctrl::CommonTypes::Timestamp &_value) { std::get<0>(values_) = _value; }
    	inline const GpsTimeQuality &getQuality() const { return std::get<1>(values_); }
    	inline void setQuality(const GpsTimeQuality &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const GpsTime& _other) const {
                return (getTime() == _other.getTime() && getQuality() == _other.getQuality());
        }
    	inline bool operator!=(const GpsTime &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct RoadAttributeKey : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ROAD_CLASS = 1,
            ROAD_TYPE = 2,
            CONTROLLED_ACCESS = 3,
            URBAN = 4,
            SPEED_LIMIT = 5,
            LEFT_HAND_TRAFFIC = 6,
            INTERSECTION_TYPE = 7,
            EXIT_INFO = 8
        };
        
        RoadAttributeKey() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        RoadAttributeKey(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        RoadAttributeKey &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ROAD_CLASS):
                case static_cast<int32_t>(Literal::ROAD_TYPE):
                case static_cast<int32_t>(Literal::CONTROLLED_ACCESS):
                case static_cast<int32_t>(Literal::URBAN):
                case static_cast<int32_t>(Literal::SPEED_LIMIT):
                case static_cast<int32_t>(Literal::LEFT_HAND_TRAFFIC):
                case static_cast<int32_t>(Literal::INTERSECTION_TYPE):
                case static_cast<int32_t>(Literal::EXIT_INFO):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const RoadAttributeKey &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const RoadAttributeKey &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const RoadAttributeKey &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const RoadAttributeKey &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const RoadAttributeKey &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const RoadAttributeKey &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef std::vector<PositioningTypes::RoadAttributeKey> RoadAttributeKeys;
    
    struct ERoadClass : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ROADCLASS_GLOBAL = 1,
            ROADCLASS_MAIN = 2,
            ROADCLASS_REGIONAL = 3,
            ROADCLASS_LOCAL = 4,
            ROADCLASS_PRIVATE = 5
        };
        
        ERoadClass() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        ERoadClass(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        ERoadClass &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ROADCLASS_GLOBAL):
                case static_cast<int32_t>(Literal::ROADCLASS_MAIN):
                case static_cast<int32_t>(Literal::ROADCLASS_REGIONAL):
                case static_cast<int32_t>(Literal::ROADCLASS_LOCAL):
                case static_cast<int32_t>(Literal::ROADCLASS_PRIVATE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ERoadClass &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ERoadClass &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ERoadClass &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ERoadClass &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ERoadClass &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ERoadClass &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ERoadType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ROADTYPE_NONE = 0,
            ROADTYPE_RAMP = 1,
            ROADTYPE_ROUNDABOUT = 2,
            ROADTYPE_PARALLEL = 3,
            ROADTYPE_SERVICE = 4,
            ROADTYPE_MAIN = 5,
            ROADTYPE_SQUARE = 6,
            ROADTYPE_PARKING = 7,
            ROADTYPE_PEDESTRIAN = 8,
            ROADTYPE_CONTROLLED = 9
        };
        
        ERoadType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ROADTYPE_NONE)) {}
        ERoadType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ROADTYPE_NONE):
                case static_cast<int32_t>(Literal::ROADTYPE_RAMP):
                case static_cast<int32_t>(Literal::ROADTYPE_ROUNDABOUT):
                case static_cast<int32_t>(Literal::ROADTYPE_PARALLEL):
                case static_cast<int32_t>(Literal::ROADTYPE_SERVICE):
                case static_cast<int32_t>(Literal::ROADTYPE_MAIN):
                case static_cast<int32_t>(Literal::ROADTYPE_SQUARE):
                case static_cast<int32_t>(Literal::ROADTYPE_PARKING):
                case static_cast<int32_t>(Literal::ROADTYPE_PEDESTRIAN):
                case static_cast<int32_t>(Literal::ROADTYPE_CONTROLLED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ERoadType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ERoadType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ERoadType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ERoadType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ERoadType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ERoadType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct EIntersection : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INTERSECT_NA = 0,
            INTERSECTION_JUNCTION = 1
        };
        
        EIntersection() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INTERSECT_NA)) {}
        EIntersection(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INTERSECT_NA):
                case static_cast<int32_t>(Literal::INTERSECTION_JUNCTION):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const EIntersection &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const EIntersection &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const EIntersection &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const EIntersection &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const EIntersection &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const EIntersection &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct ExitInfo : CommonAPI::Struct<bool> {
    	
    	ExitInfo() {
    		std::get<0>(values_) = false;
    	}
    	ExitInfo(const bool &_present)
    	{
    		std::get<0>(values_) = _present;
    	}
    	inline const bool &getPresent() const { return std::get<0>(values_); }
    	inline void setPresent(const bool _value) { std::get<0>(values_) = _value; }
    	inline bool operator==(const ExitInfo& _other) const {
                return (getPresent() == _other.getPresent());
        }
    	inline bool operator!=(const ExitInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct ESpeedLimitStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            AVAILABLE = 0,
            NOT_AVAILABLE = 1,
            NO_LIMIT = 2
        };
        
        ESpeedLimitStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::AVAILABLE)) {}
        ESpeedLimitStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::AVAILABLE):
                case static_cast<int32_t>(Literal::NOT_AVAILABLE):
                case static_cast<int32_t>(Literal::NO_LIMIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ESpeedLimitStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ESpeedLimitStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ESpeedLimitStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ESpeedLimitStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ESpeedLimitStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ESpeedLimitStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct SpeedLimit : CommonAPI::Struct<ESpeedLimitStatus, uint32_t> {
    	
    	SpeedLimit() {
    	}
    	SpeedLimit(const ESpeedLimitStatus &_status, const uint32_t &_speedLimit)
    	{
    		std::get<0>(values_) = _status;
    		std::get<1>(values_) = _speedLimit;
    	}
    	inline const ESpeedLimitStatus &getStatus() const { return std::get<0>(values_); }
    	inline void setStatus(const ESpeedLimitStatus &_value) { std::get<0>(values_) = _value; }
    	inline const uint32_t &getSpeedLimit() const { return std::get<1>(values_); }
    	inline void setSpeedLimit(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const SpeedLimit& _other) const {
                return (getStatus() == _other.getStatus() && getSpeedLimit() == _other.getSpeedLimit());
        }
    	inline bool operator!=(const SpeedLimit &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef CommonAPI::Variant<bool, float, EIntersection, ERoadClass, ERoadType, ExitInfo, SpeedLimit>  RoadAttributeValue;
    typedef std::unordered_map<::v1::org::harman::nav::ctrl::PositioningTypes::RoadAttributeKey, ::v1::org::harman::nav::ctrl::PositioningTypes::RoadAttributeValue, CommonAPI::EnumHasher<::v1::org::harman::nav::ctrl::PositioningTypes::RoadAttributeKey>> RoadAttributeDict;



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.harman.nav.ctrl.PositioningTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 2);
}

}; // struct PositioningTypes

} // namespace ctrl
} // namespace nav
} // namespace harman
} // namespace org
} // namespace v1

namespace CommonAPI {
}


namespace std {
    //Hash for PositionStatus
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::PositionStatus> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::PositionStatus& positionStatus) const {
            return static_cast<int32_t>(positionStatus);
        }
    };
    //Hash for PositionItemKey
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::PositionItemKey> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::PositionItemKey& positionItemKey) const {
            return static_cast<int32_t>(positionItemKey);
        }
    };
    //Hash for GnnsFixStatus
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::GnnsFixStatus> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::GnnsFixStatus& gnnsFixStatus) const {
            return static_cast<int32_t>(gnnsFixStatus);
        }
    };
    //Hash for MatchMode
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::MatchMode> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::MatchMode& matchMode) const {
            return static_cast<int32_t>(matchMode);
        }
    };
    //Hash for AddressItemKey
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::AddressItemKey> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::AddressItemKey& addressItemKey) const {
            return static_cast<int32_t>(addressItemKey);
        }
    };
    //Hash for GpsTimeQuality
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::GpsTimeQuality> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::GpsTimeQuality& gpsTimeQuality) const {
            return static_cast<int32_t>(gpsTimeQuality);
        }
    };
    //Hash for RoadAttributeKey
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::RoadAttributeKey> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::RoadAttributeKey& roadAttributeKey) const {
            return static_cast<int32_t>(roadAttributeKey);
        }
    };
    //Hash for ERoadClass
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::ERoadClass> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::ERoadClass& eRoadClass) const {
            return static_cast<int32_t>(eRoadClass);
        }
    };
    //Hash for ERoadType
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::ERoadType> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::ERoadType& eRoadType) const {
            return static_cast<int32_t>(eRoadType);
        }
    };
    //Hash for EIntersection
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::EIntersection> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::EIntersection& eIntersection) const {
            return static_cast<int32_t>(eIntersection);
        }
    };
    //Hash for ESpeedLimitStatus
    template<>
    struct hash<::v1::org::harman::nav::ctrl::PositioningTypes::ESpeedLimitStatus> {
        inline size_t operator()(const ::v1::org::harman::nav::ctrl::PositioningTypes::ESpeedLimitStatus& eSpeedLimitStatus) const {
            return static_cast<int32_t>(eSpeedLimitStatus);
        }
    };
}


// Compatibility
namespace v1_2 = v1;

#endif // V1_ORG_HARMAN_NAV_CTRL_Positioning_Types_HPP_
