/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: Orinoco specific tuner data type collection.
 * author: Dirk Engel
 */
#ifndef V1_COM_HARMAN_TUNER_Orinoco_Tuner_Types_HPP_
#define V1_COM_HARMAN_TUNER_Orinoco_Tuner_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace tuner {

struct OrinocoTunerTypes {
    
    struct Source : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SRC_NONE = 0,
            SRC_FM = 1,
            SRC_SW = 2,
            SRC_MW = 4,
            SRC_LW = 8,
            SRC_DAB = 16
        };
        
        Source() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SRC_NONE)) {}
        Source(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SRC_NONE):
                case static_cast<int32_t>(Literal::SRC_FM):
                case static_cast<int32_t>(Literal::SRC_SW):
                case static_cast<int32_t>(Literal::SRC_MW):
                case static_cast<int32_t>(Literal::SRC_LW):
                case static_cast<int32_t>(Literal::SRC_DAB):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Source &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Source &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Source &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Source &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Source &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Source &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct StationSeekMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SEEK_OFF = 0,
            SEEK_MAN_UP = 1,
            SEEK_MAN_DOWN = 2,
            SEEK_AUTO_UP = 3,
            SEEK_AUTO_DOWN = 4,
            SEEK_AUTOSTORE = 5,
            SEEK_ENDLESS_UP = 6,
            SEEK_ENDLESS_DOWN = 7,
            SEEK_SCAN_UP = 8,
            SEEK_SCAN_SKIP_UP = 9,
            SEEK_SCAN_DOWN = 10,
            SEEK_SCAN_SKIP_DOWN = 11
        };
        
        StationSeekMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SEEK_OFF)) {}
        StationSeekMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SEEK_OFF):
                case static_cast<int32_t>(Literal::SEEK_MAN_UP):
                case static_cast<int32_t>(Literal::SEEK_MAN_DOWN):
                case static_cast<int32_t>(Literal::SEEK_AUTO_UP):
                case static_cast<int32_t>(Literal::SEEK_AUTO_DOWN):
                case static_cast<int32_t>(Literal::SEEK_AUTOSTORE):
                case static_cast<int32_t>(Literal::SEEK_ENDLESS_UP):
                case static_cast<int32_t>(Literal::SEEK_ENDLESS_DOWN):
                case static_cast<int32_t>(Literal::SEEK_SCAN_UP):
                case static_cast<int32_t>(Literal::SEEK_SCAN_SKIP_UP):
                case static_cast<int32_t>(Literal::SEEK_SCAN_DOWN):
                case static_cast<int32_t>(Literal::SEEK_SCAN_SKIP_DOWN):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const StationSeekMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const StationSeekMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const StationSeekMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const StationSeekMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const StationSeekMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const StationSeekMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AnnouncementState : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ANN_OFF = 0,
            ANN_ON_NONE = 1,
            ANN_ON_INACTIVE = 2,
            ANN_ON_ACTIVE = 3
        };
        
        AnnouncementState() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ANN_OFF)) {}
        AnnouncementState(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ANN_OFF):
                case static_cast<int32_t>(Literal::ANN_ON_NONE):
                case static_cast<int32_t>(Literal::ANN_ON_INACTIVE):
                case static_cast<int32_t>(Literal::ANN_ON_ACTIVE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AnnouncementState &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AnnouncementState &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AnnouncementState &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AnnouncementState &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AnnouncementState &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AnnouncementState &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AmFmRegionCode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ARC_NONE = 65535,
            ARC_EUROPE = 0,
            ARC_NORTH_AMERICA = 1,
            ARC_SOUTH_AMERICA = 2,
            ARC_CANADA = 3,
            ARC_ASIA = 4,
            ARC_JAPAN = 5,
            ARC_SOUTH_KOREA = 6,
            ARC_CHINA = 7,
            ARC_AUSTRALIA = 8,
            ARC_SOUTH_AFRICA = 9
        };
        
        AmFmRegionCode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ARC_NONE)) {}
        AmFmRegionCode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ARC_NONE):
                case static_cast<int32_t>(Literal::ARC_EUROPE):
                case static_cast<int32_t>(Literal::ARC_NORTH_AMERICA):
                case static_cast<int32_t>(Literal::ARC_SOUTH_AMERICA):
                case static_cast<int32_t>(Literal::ARC_CANADA):
                case static_cast<int32_t>(Literal::ARC_ASIA):
                case static_cast<int32_t>(Literal::ARC_JAPAN):
                case static_cast<int32_t>(Literal::ARC_SOUTH_KOREA):
                case static_cast<int32_t>(Literal::ARC_CHINA):
                case static_cast<int32_t>(Literal::ARC_AUSTRALIA):
                case static_cast<int32_t>(Literal::ARC_SOUTH_AFRICA):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AmFmRegionCode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AmFmRegionCode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AmFmRegionCode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AmFmRegionCode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AmFmRegionCode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AmFmRegionCode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct DabRegionCode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DRC_NONE = 65535,
            DRC_EUROPE = 0,
            DRC_CANADA = 1,
            DRC_KOREA = 2,
            DRC_CHINA = 3,
            DRC_NEW_ZEALAND = 7
        };
        
        DabRegionCode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DRC_NONE)) {}
        DabRegionCode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DRC_NONE):
                case static_cast<int32_t>(Literal::DRC_EUROPE):
                case static_cast<int32_t>(Literal::DRC_CANADA):
                case static_cast<int32_t>(Literal::DRC_KOREA):
                case static_cast<int32_t>(Literal::DRC_CHINA):
                case static_cast<int32_t>(Literal::DRC_NEW_ZEALAND):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DabRegionCode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DabRegionCode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DabRegionCode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DabRegionCode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DabRegionCode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DabRegionCode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AmFmCodingFlag : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            COD_AMFM_NONE = 0
        };
        
        AmFmCodingFlag() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::COD_AMFM_NONE)) {}
        AmFmCodingFlag(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::COD_AMFM_NONE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AmFmCodingFlag &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AmFmCodingFlag &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AmFmCodingFlag &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AmFmCodingFlag &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AmFmCodingFlag &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AmFmCodingFlag &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct DabCodingFlag : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            COD_DAB_NONE = 0,
            COD_DAB_TPEG = 1
        };
        
        DabCodingFlag() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::COD_DAB_NONE)) {}
        DabCodingFlag(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::COD_DAB_NONE):
                case static_cast<int32_t>(Literal::COD_DAB_TPEG):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DabCodingFlag &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DabCodingFlag &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DabCodingFlag &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DabCodingFlag &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DabCodingFlag &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DabCodingFlag &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AmFmHdMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            HD_ANALOG = 0,
            HD_AUTOMATIC = 1,
            HD_AUTOMATIC_AM = 2,
            HD_AUTOMATIC_FM = 3
        };
        
        AmFmHdMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::HD_ANALOG)) {}
        AmFmHdMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::HD_ANALOG):
                case static_cast<int32_t>(Literal::HD_AUTOMATIC):
                case static_cast<int32_t>(Literal::HD_AUTOMATIC_AM):
                case static_cast<int32_t>(Literal::HD_AUTOMATIC_FM):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AmFmHdMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AmFmHdMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AmFmHdMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AmFmHdMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AmFmHdMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AmFmHdMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct StationListType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            LIST_BACKGROUND = 0,
            LIST_AUTOSTORE = 1,
            LIST_PRESET = 2
        };
        
        StationListType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::LIST_BACKGROUND)) {}
        StationListType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::LIST_BACKGROUND):
                case static_cast<int32_t>(Literal::LIST_AUTOSTORE):
                case static_cast<int32_t>(Literal::LIST_PRESET):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const StationListType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const StationListType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const StationListType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const StationListType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const StationListType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const StationListType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Vector of UInt32
     */
    typedef std::vector<uint32_t> UInt32s;
    /**
     * description: Current tuner source
     */
    struct CurrentSource : CommonAPI::Struct<Source, uint32_t> {
    	
    	CurrentSource() {
    	}
    	CurrentSource(const Source &_source, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _source;
    		std::get<1>(values_) = _handle;
    	}
    	/**
    	 * description: The tuner source
    	 */
    	inline const Source &getSource() const { return std::get<0>(values_); }
    	inline void setSource(const Source &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<1>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const CurrentSource& _other) const {
                return (getSource() == _other.getSource() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const CurrentSource &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: All necessary information for station selection or identification:
    		Send from
     *   tuner device (attributes): All parameters are set to reflect current
     *   state.
    		Send to tuner device:
    		Only one of the four parameters is needed,
     *   the parameters are evaluated like the following:
    		a) tag != 0: tag is used
     *   for station selection (i.e. station selection from list)
    		b) tag == 0,
     *   frequency != 0: frequency is used (i.e. direct frequency input)
    		c) tag == 0,
     *   frequency == 0, preset != 0: preset number is used (i.e. preset recall)
    		d)
     *   tag == 0, frequency == 0, preset == 0: Evaluate seek mode
     */
    struct StationSelector : CommonAPI::Struct<uint64_t, uint32_t, uint32_t, StationSeekMode> {
    	
    	StationSelector() {
    	}
    	StationSelector(const uint64_t &_tag, const uint32_t &_frequency, const uint32_t &_preset, const StationSeekMode &_seekMode)
    	{
    		std::get<0>(values_) = _tag;
    		std::get<1>(values_) = _frequency;
    		std::get<2>(values_) = _preset;
    		std::get<3>(values_) = _seekMode;
    	}
    	/**
    	 * description: Unique station idenfier
    	 */
    	inline const uint64_t &getTag() const { return std::get<0>(values_); }
    	inline void setTag(const uint64_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Frequency [KHz]
    	 */
    	inline const uint32_t &getFrequency() const { return std::get<1>(values_); }
    	inline void setFrequency(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Preset number (0: invalid)
    	 */
    	inline const uint32_t &getPreset() const { return std::get<2>(values_); }
    	inline void setPreset(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Seek mode
    	 */
    	inline const StationSeekMode &getSeekMode() const { return std::get<3>(values_); }
    	inline void setSeekMode(const StationSeekMode &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const StationSelector& _other) const {
                return (getTag() == _other.getTag() && getFrequency() == _other.getFrequency() && getPreset() == _other.getPreset() && getSeekMode() == _other.getSeekMode());
        }
    	inline bool operator!=(const StationSelector &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Station metadata
     */
    struct StationMetadata : CommonAPI::Struct<std::string, std::string, std::string, std::string, std::string, std::string> {
    	
    	StationMetadata() {
    	}
    	StationMetadata(const std::string &_radiotext, const std::string &_imagePath, const std::string &_stationLogo, const std::string &_artist, const std::string &_album, const std::string &_song)
    	{
    		std::get<0>(values_) = _radiotext;
    		std::get<1>(values_) = _imagePath;
    		std::get<2>(values_) = _stationLogo;
    		std::get<3>(values_) = _artist;
    		std::get<4>(values_) = _album;
    		std::get<5>(values_) = _song;
    	}
    	/**
    	 * description: FM RDS Radiotext / DAB Dynamic Label
    	 */
    	inline const std::string &getRadiotext() const { return std::get<0>(values_); }
    	inline void setRadiotext(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: File system path to slideshow or HD album cover image
    	 */
    	inline const std::string &getImagePath() const { return std::get<1>(values_); }
    	inline void setImagePath(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: File system path to HD station logo image
    	 */
    	inline const std::string &getStationLogo() const { return std::get<2>(values_); }
    	inline void setStationLogo(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Artist name (RT+/HD/DLS+)
    	 */
    	inline const std::string &getArtist() const { return std::get<3>(values_); }
    	inline void setArtist(const std::string &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: Album name (RT+/HD/DLS+)
    	 */
    	inline const std::string &getAlbum() const { return std::get<4>(values_); }
    	inline void setAlbum(const std::string &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: Song name (RT+/HD/DLS+)
    	 */
    	inline const std::string &getSong() const { return std::get<5>(values_); }
    	inline void setSong(const std::string &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const StationMetadata& _other) const {
                return (getRadiotext() == _other.getRadiotext() && getImagePath() == _other.getImagePath() && getStationLogo() == _other.getStationLogo() && getArtist() == _other.getArtist() && getAlbum() == _other.getAlbum() && getSong() == _other.getSong());
        }
    	inline bool operator!=(const StationMetadata &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Group information
     */
    struct GroupInfo : CommonAPI::Struct<uint32_t, std::string, uint32_t, std::string> {
    	
    	GroupInfo() {
    	}
    	GroupInfo(const uint32_t &_superId, const std::string &_superName, const uint32_t &_subId, const std::string &_subName)
    	{
    		std::get<0>(values_) = _superId;
    		std::get<1>(values_) = _superName;
    		std::get<2>(values_) = _subId;
    		std::get<3>(values_) = _subName;
    	}
    	/**
    	 * description: Super group identifier
    	 */
    	inline const uint32_t &getSuperId() const { return std::get<0>(values_); }
    	inline void setSuperId(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Super group name (e.g. DAB ensemble name)
    	 */
    	inline const std::string &getSuperName() const { return std::get<1>(values_); }
    	inline void setSuperName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Subelement identifier E.g. HD service index: 0/1: No HD/MPS, 2..8: SPS
    	 */
    	inline const uint32_t &getSubId() const { return std::get<2>(values_); }
    	inline void setSubId(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Subelement name (e.g. DAB subcomponent label)
    	 */
    	inline const std::string &getSubName() const { return std::get<3>(values_); }
    	inline void setSubName(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const GroupInfo& _other) const {
                return (getSuperId() == _other.getSuperId() && getSuperName() == _other.getSuperName() && getSubId() == _other.getSubId() && getSubName() == _other.getSubName());
        }
    	inline bool operator!=(const GroupInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Station names
     */
    struct StationName : CommonAPI::Struct<std::string, GroupInfo> {
    	
    	StationName() {
    	}
    	StationName(const std::string &_station, const GroupInfo &_group)
    	{
    		std::get<0>(values_) = _station;
    		std::get<1>(values_) = _group;
    	}
    	/**
    	 * description: RDS PS code / service name
    	 */
    	inline const std::string &getStation() const { return std::get<0>(values_); }
    	inline void setStation(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Grouping information
    	 */
    	inline const GroupInfo &getGroup() const { return std::get<1>(values_); }
    	inline void setGroup(const GroupInfo &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const StationName& _other) const {
                return (getStation() == _other.getStation() && getGroup() == _other.getGroup());
        }
    	inline bool operator!=(const StationName &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Station genre
     */
    struct StationGenre : CommonAPI::Struct<uint8_t> {
    	
    	StationGenre() {
    	}
    	StationGenre(const uint8_t &_pty)
    	{
    		std::get<0>(values_) = _pty;
    	}
    	/**
    	 * description: PTY code
    	 */
    	inline const uint8_t &getPty() const { return std::get<0>(values_); }
    	inline void setPty(const uint8_t &_value) { std::get<0>(values_) = _value; }
    	inline bool operator==(const StationGenre& _other) const {
                return (getPty() == _other.getPty());
        }
    	inline bool operator!=(const StationGenre &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Addional station flags
     */
    struct StationFlags : CommonAPI::Struct<bool, bool, bool, bool> {
    	
    	StationFlags() {
    		std::get<0>(values_) = false;
    		std::get<1>(values_) = false;
    		std::get<2>(values_) = false;
    		std::get<3>(values_) = false;
    	}
    	StationFlags(const bool &_isMuted, const bool &_isOccupied, const bool &_isLinkedToFM, const bool &_isHD)
    	{
    		std::get<0>(values_) = _isMuted;
    		std::get<1>(values_) = _isOccupied;
    		std::get<2>(values_) = _isLinkedToFM;
    		std::get<3>(values_) = _isHD;
    	}
    	/**
    	 * description: Service is muted
    	 */
    	inline const bool &getIsMuted() const { return std::get<0>(values_); }
    	inline void setIsMuted(const bool _value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Tuner is occupied and cannot be used
    	 */
    	inline const bool &getIsOccupied() const { return std::get<1>(values_); }
    	inline void setIsOccupied(const bool _value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: DAB service is linked to FM
    	 */
    	inline const bool &getIsLinkedToFM() const { return std::get<2>(values_); }
    	inline void setIsLinkedToFM(const bool _value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Station is a HD service
    	 */
    	inline const bool &getIsHD() const { return std::get<3>(values_); }
    	inline void setIsHD(const bool _value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const StationFlags& _other) const {
                return (getIsMuted() == _other.getIsMuted() && getIsOccupied() == _other.getIsOccupied() && getIsLinkedToFM() == _other.getIsLinkedToFM() && getIsHD() == _other.getIsHD());
        }
    	inline bool operator!=(const StationFlags &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Station quality data
     */
    struct StationQuality : CommonAPI::Struct<int32_t, int32_t> {
    	
    	StationQuality() {
    	}
    	StationQuality(const int32_t &_fieldStrength, const int32_t &_quality)
    	{
    		std::get<0>(values_) = _fieldStrength;
    		std::get<1>(values_) = _quality;
    	}
    	/**
    	 * description: Field strenght
    	 */
    	inline const int32_t &getFieldStrength() const { return std::get<0>(values_); }
    	inline void setFieldStrength(const int32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Standard specific quality indicator
    	 */
    	inline const int32_t &getQuality() const { return std::get<1>(values_); }
    	inline void setQuality(const int32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const StationQuality& _other) const {
                return (getFieldStrength() == _other.getFieldStrength() && getQuality() == _other.getQuality());
        }
    	inline bool operator!=(const StationQuality &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Current station data
     */
    struct CurrentStation : CommonAPI::Struct<Source, StationSelector, StationName, StationMetadata, StationGenre, StationFlags, StationQuality, uint32_t> {
    	
    	CurrentStation() {
    	}
    	CurrentStation(const Source &_source, const StationSelector &_sel, const StationName &_name, const StationMetadata &_meta, const StationGenre &_genre, const StationFlags &_flags, const StationQuality &_quality, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _source;
    		std::get<1>(values_) = _sel;
    		std::get<2>(values_) = _name;
    		std::get<3>(values_) = _meta;
    		std::get<4>(values_) = _genre;
    		std::get<5>(values_) = _flags;
    		std::get<6>(values_) = _quality;
    		std::get<7>(values_) = _handle;
    	}
    	/**
    	 * description: The source this current station data belongs to:
    				In case project
    	 *   distinguishs different AM bands source will be =LW or =MW or =SW for AM
    	 *   otherwise =LW|MW|SW. 
    				If project supports a unified DAB/FM view the source
    	 *   will be =DAB|FM for combind DAB/FM otherwise separate source for =DAB and =FM
    	 *   will exist.
    	 */
    	inline const Source &getSource() const { return std::get<0>(values_); }
    	inline void setSource(const Source &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Station identification, seek state
    	 */
    	inline const StationSelector &getSel() const { return std::get<1>(values_); }
    	inline void setSel(const StationSelector &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Station names
    	 */
    	inline const StationName &getName() const { return std::get<2>(values_); }
    	inline void setName(const StationName &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Station metadata
    	 */
    	inline const StationMetadata &getMeta() const { return std::get<3>(values_); }
    	inline void setMeta(const StationMetadata &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: Station genre
    	 */
    	inline const StationGenre &getGenre() const { return std::get<4>(values_); }
    	inline void setGenre(const StationGenre &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: Additional station flags
    	 */
    	inline const StationFlags &getFlags() const { return std::get<5>(values_); }
    	inline void setFlags(const StationFlags &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: Station quality information
    	 */
    	inline const StationQuality &getQuality() const { return std::get<6>(values_); }
    	inline void setQuality(const StationQuality &_value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<7>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<7>(values_) = _value; }
    	inline bool operator==(const CurrentStation& _other) const {
                return (getSource() == _other.getSource() && getSel() == _other.getSel() && getName() == _other.getName() && getMeta() == _other.getMeta() && getGenre() == _other.getGenre() && getFlags() == _other.getFlags() && getQuality() == _other.getQuality() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const CurrentStation &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: List station (reduced data compared to "CurrentStation")
     */
    struct ListStation : CommonAPI::Struct<Source, StationSelector, StationName, StationGenre> {
    	
    	ListStation() {
    	}
    	ListStation(const Source &_source, const StationSelector &_sel, const StationName &_name, const StationGenre &_genre)
    	{
    		std::get<0>(values_) = _source;
    		std::get<1>(values_) = _sel;
    		std::get<2>(values_) = _name;
    		std::get<3>(values_) = _genre;
    	}
    	/**
    	 * description: The source this station list data belongs to:
    				In case project distinguishs
    	 *   different AM bands source will be =LW or =MW or =SW for AM otherwise
    	 *   =LW|MW|SW. 
    				If project supports a unified DAB/FM view the source will be
    	 *   =DAB|FM for combind DAB/FM otherwise separate source for =DAB and =FM will
    	 *   exist.
    	 */
    	inline const Source &getSource() const { return std::get<0>(values_); }
    	inline void setSource(const Source &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Station identification
    	 */
    	inline const StationSelector &getSel() const { return std::get<1>(values_); }
    	inline void setSel(const StationSelector &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Station names
    	 */
    	inline const StationName &getName() const { return std::get<2>(values_); }
    	inline void setName(const StationName &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Station genre
    	 */
    	inline const StationGenre &getGenre() const { return std::get<3>(values_); }
    	inline void setGenre(const StationGenre &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const ListStation& _other) const {
                return (getSource() == _other.getSource() && getSel() == _other.getSel() && getName() == _other.getName() && getGenre() == _other.getGenre());
        }
    	inline bool operator!=(const ListStation &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: List of ListStation
     */
    typedef std::vector<OrinocoTunerTypes::ListStation> ListStations;
    /**
     * description: Station list
     */
    struct StationList : CommonAPI::Struct<ListStations, StationListType, uint32_t> {
    	
    	StationList() {
    	}
    	StationList(const ListStations &_stations, const StationListType &_listType, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _stations;
    		std::get<1>(values_) = _listType;
    		std::get<2>(values_) = _handle;
    	}
    	/**
    	 * description: List of stations
    	 */
    	inline const ListStations &getStations() const { return std::get<0>(values_); }
    	inline void setStations(const ListStations &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Station list type
    	 */
    	inline const StationListType &getListType() const { return std::get<1>(values_); }
    	inline void setListType(const StationListType &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<2>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const StationList& _other) const {
                return (getStations() == _other.getStations() && getListType() == _other.getListType() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const StationList &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Announcement information
     */
    struct AnnouncementStation : CommonAPI::Struct<Source, StationSelector, StationName, AnnouncementState, uint32_t> {
    	
    	AnnouncementStation() {
    	}
    	AnnouncementStation(const Source &_source, const StationSelector &_sel, const StationName &_name, const AnnouncementState &_currentState, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _source;
    		std::get<1>(values_) = _sel;
    		std::get<2>(values_) = _name;
    		std::get<3>(values_) = _currentState;
    		std::get<4>(values_) = _handle;
    	}
    	/**
    	 * description: TP (traffic program) providing source: FM or DAB
    	 */
    	inline const Source &getSource() const { return std::get<0>(values_); }
    	inline void setSource(const Source &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Station identification
    	 */
    	inline const StationSelector &getSel() const { return std::get<1>(values_); }
    	inline void setSel(const StationSelector &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Station names
    	 */
    	inline const StationName &getName() const { return std::get<2>(values_); }
    	inline void setName(const StationName &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Current state of announcement monitoring and announcement itself
    	 */
    	inline const AnnouncementState &getCurrentState() const { return std::get<3>(values_); }
    	inline void setCurrentState(const AnnouncementState &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<4>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const AnnouncementStation& _other) const {
                return (getSource() == _other.getSource() && getSel() == _other.getSel() && getName() == _other.getName() && getCurrentState() == _other.getCurrentState() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const AnnouncementStation &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: AM/FM waveband grid information
     */
    struct AmFmWavebandGrid : CommonAPI::Struct<uint32_t, uint32_t, uint32_t, uint32_t> {
    	
    	AmFmWavebandGrid() {
    	}
    	AmFmWavebandGrid(const uint32_t &_lowerLimit, const uint32_t &_upperLimit, const uint32_t &_stepWidth, const uint32_t &_smallStep)
    	{
    		std::get<0>(values_) = _lowerLimit;
    		std::get<1>(values_) = _upperLimit;
    		std::get<2>(values_) = _stepWidth;
    		std::get<3>(values_) = _smallStep;
    	}
    	/**
    	 * description: Lower limit of band [KHz]
    	 */
    	inline const uint32_t &getLowerLimit() const { return std::get<0>(values_); }
    	inline void setLowerLimit(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Upper limit of band [KHz]
    	 */
    	inline const uint32_t &getUpperLimit() const { return std::get<1>(values_); }
    	inline void setUpperLimit(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Step size used for background lists [KHz]
    	 */
    	inline const uint32_t &getStepWidth() const { return std::get<2>(values_); }
    	inline void setStepWidth(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Smaller step size than "stepWidth" that can be used for manual tuning [KHz]
    	 */
    	inline const uint32_t &getSmallStep() const { return std::get<3>(values_); }
    	inline void setSmallStep(const uint32_t &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const AmFmWavebandGrid& _other) const {
                return (getLowerLimit() == _other.getLowerLimit() && getUpperLimit() == _other.getUpperLimit() && getStepWidth() == _other.getStepWidth() && getSmallStep() == _other.getSmallStep());
        }
    	inline bool operator!=(const AmFmWavebandGrid &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Wavband information for all bands
     */
    struct AmFmWavebandGrids : CommonAPI::Struct<AmFmWavebandGrid, AmFmWavebandGrid, AmFmWavebandGrid, AmFmWavebandGrid> {
    	
    	AmFmWavebandGrids() {
    	}
    	AmFmWavebandGrids(const AmFmWavebandGrid &_fm, const AmFmWavebandGrid &_sw, const AmFmWavebandGrid &_mw, const AmFmWavebandGrid &_lw)
    	{
    		std::get<0>(values_) = _fm;
    		std::get<1>(values_) = _sw;
    		std::get<2>(values_) = _mw;
    		std::get<3>(values_) = _lw;
    	}
    	/**
    	 * description: FM grid
    	 */
    	inline const AmFmWavebandGrid &getFm() const { return std::get<0>(values_); }
    	inline void setFm(const AmFmWavebandGrid &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: SW grid
    	 */
    	inline const AmFmWavebandGrid &getSw() const { return std::get<1>(values_); }
    	inline void setSw(const AmFmWavebandGrid &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: MW grid
    	 */
    	inline const AmFmWavebandGrid &getMw() const { return std::get<2>(values_); }
    	inline void setMw(const AmFmWavebandGrid &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: LW grid
    	 */
    	inline const AmFmWavebandGrid &getLw() const { return std::get<3>(values_); }
    	inline void setLw(const AmFmWavebandGrid &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const AmFmWavebandGrids& _other) const {
                return (getFm() == _other.getFm() && getSw() == _other.getSw() && getMw() == _other.getMw() && getLw() == _other.getLw());
        }
    	inline bool operator!=(const AmFmWavebandGrids &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: AM/FM region dependent configuration
     */
    struct AmFmRegionInfo : CommonAPI::Struct<AmFmRegionCode, AmFmWavebandGrids> {
    	
    	AmFmRegionInfo() {
    	}
    	AmFmRegionInfo(const AmFmRegionCode &_code, const AmFmWavebandGrids &_grid)
    	{
    		std::get<0>(values_) = _code;
    		std::get<1>(values_) = _grid;
    	}
    	/**
    	 * description: The region code
    	 */
    	inline const AmFmRegionCode &getCode() const { return std::get<0>(values_); }
    	inline void setCode(const AmFmRegionCode &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The waveband grid information for all bands
    	 */
    	inline const AmFmWavebandGrids &getGrid() const { return std::get<1>(values_); }
    	inline void setGrid(const AmFmWavebandGrids &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const AmFmRegionInfo& _other) const {
                return (getCode() == _other.getCode() && getGrid() == _other.getGrid());
        }
    	inline bool operator!=(const AmFmRegionInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: DAB region dependent configuration
     */
    struct DabRegionInfo : CommonAPI::Struct<DabRegionCode> {
    	
    	DabRegionInfo() {
    	}
    	DabRegionInfo(const DabRegionCode &_code)
    	{
    		std::get<0>(values_) = _code;
    	}
    	/**
    	 * description: The region code
    	 */
    	inline const DabRegionCode &getCode() const { return std::get<0>(values_); }
    	inline void setCode(const DabRegionCode &_value) { std::get<0>(values_) = _value; }
    	inline bool operator==(const DabRegionInfo& _other) const {
                return (getCode() == _other.getCode());
        }
    	inline bool operator!=(const DabRegionInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.tuner.OrinocoTunerTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 0);
}

}; // struct OrinocoTunerTypes

} // namespace tuner
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
}


namespace std {
    //Hash for Source
    template<>
    struct hash<::v1::com::harman::tuner::OrinocoTunerTypes::Source> {
        inline size_t operator()(const ::v1::com::harman::tuner::OrinocoTunerTypes::Source& source) const {
            return static_cast<int32_t>(source);
        }
    };
    //Hash for StationSeekMode
    template<>
    struct hash<::v1::com::harman::tuner::OrinocoTunerTypes::StationSeekMode> {
        inline size_t operator()(const ::v1::com::harman::tuner::OrinocoTunerTypes::StationSeekMode& stationSeekMode) const {
            return static_cast<int32_t>(stationSeekMode);
        }
    };
    //Hash for AnnouncementState
    template<>
    struct hash<::v1::com::harman::tuner::OrinocoTunerTypes::AnnouncementState> {
        inline size_t operator()(const ::v1::com::harman::tuner::OrinocoTunerTypes::AnnouncementState& announcementState) const {
            return static_cast<int32_t>(announcementState);
        }
    };
    //Hash for AmFmRegionCode
    template<>
    struct hash<::v1::com::harman::tuner::OrinocoTunerTypes::AmFmRegionCode> {
        inline size_t operator()(const ::v1::com::harman::tuner::OrinocoTunerTypes::AmFmRegionCode& amFmRegionCode) const {
            return static_cast<int32_t>(amFmRegionCode);
        }
    };
    //Hash for DabRegionCode
    template<>
    struct hash<::v1::com::harman::tuner::OrinocoTunerTypes::DabRegionCode> {
        inline size_t operator()(const ::v1::com::harman::tuner::OrinocoTunerTypes::DabRegionCode& dabRegionCode) const {
            return static_cast<int32_t>(dabRegionCode);
        }
    };
    //Hash for AmFmCodingFlag
    template<>
    struct hash<::v1::com::harman::tuner::OrinocoTunerTypes::AmFmCodingFlag> {
        inline size_t operator()(const ::v1::com::harman::tuner::OrinocoTunerTypes::AmFmCodingFlag& amFmCodingFlag) const {
            return static_cast<int32_t>(amFmCodingFlag);
        }
    };
    //Hash for DabCodingFlag
    template<>
    struct hash<::v1::com::harman::tuner::OrinocoTunerTypes::DabCodingFlag> {
        inline size_t operator()(const ::v1::com::harman::tuner::OrinocoTunerTypes::DabCodingFlag& dabCodingFlag) const {
            return static_cast<int32_t>(dabCodingFlag);
        }
    };
    //Hash for AmFmHdMode
    template<>
    struct hash<::v1::com::harman::tuner::OrinocoTunerTypes::AmFmHdMode> {
        inline size_t operator()(const ::v1::com::harman::tuner::OrinocoTunerTypes::AmFmHdMode& amFmHdMode) const {
            return static_cast<int32_t>(amFmHdMode);
        }
    };
    //Hash for StationListType
    template<>
    struct hash<::v1::com::harman::tuner::OrinocoTunerTypes::StationListType> {
        inline size_t operator()(const ::v1::com::harman::tuner::OrinocoTunerTypes::StationListType& stationListType) const {
            return static_cast<int32_t>(stationListType);
        }
    };
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_TUNER_Orinoco_Tuner_Types_HPP_
