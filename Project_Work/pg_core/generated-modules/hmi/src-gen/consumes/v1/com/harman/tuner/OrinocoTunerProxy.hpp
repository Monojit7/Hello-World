/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: Orinoco specific tuner interface. This interface is a facade to a bunch of
 *   plattform interfaces in order to provide a simplified access to tuner data and
 *   functionality.
 * author: Dirk Engel
 */
#ifndef V1_COM_HARMAN_TUNER_Orinoco_Tuner_PROXY_HPP_
#define V1_COM_HARMAN_TUNER_Orinoco_Tuner_PROXY_HPP_

#include <v1/com/harman/tuner/OrinocoTunerProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace tuner {

template <typename ... _AttributeExtensions>
class OrinocoTunerProxy
    : virtual public OrinocoTuner, 
      virtual public OrinocoTunerProxyBase,
      virtual public _AttributeExtensions... {
public:
    OrinocoTunerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~OrinocoTunerProxy();

    typedef OrinocoTuner InterfaceType;


    /**
     * description: False: Tuner not ready, requestControlSetRegion has to be called all other
     *   requests will be returned with error. True: Tuner ready to use.
     */
    /**
     * Returns the wrapper class that provides access to the attribute controlReady.
     */
    virtual ControlReadyAttribute& getControlReadyAttribute() {
        return delegate_->getControlReadyAttribute();
    }
    /**
     * description: List of power sync frequencies [KHz]. Each entry controls one amplifier or
     *   power supply. The order of the entries is HW specific.
     */
    /**
     * Returns the wrapper class that provides access to the attribute controlPowerSync.
     */
    virtual ControlPowerSyncAttribute& getControlPowerSyncAttribute() {
        return delegate_->getControlPowerSyncAttribute();
    }
    /**
     * description: The current active tuner source. Controlled by the requests
     *   "audioSetCurrentSource".
     */
    /**
     * Returns the wrapper class that provides access to the attribute audioCurrentSource.
     */
    virtual AudioCurrentSourceAttribute& getAudioCurrentSourceAttribute() {
        return delegate_->getAudioCurrentSourceAttribute();
    }
    /**
     * description: All available information about the current TP station. Announcement monitoring
     *   can be activated/deactivated by "announcementSwitchTp". An active announcement
     *   can be aborted by "announcementActivate".
     */
    /**
     * Returns the wrapper class that provides access to the attribute announcementCurrentStation.
     */
    virtual AnnouncementCurrentStationAttribute& getAnnouncementCurrentStationAttribute() {
        return delegate_->getAnnouncementCurrentStationAttribute();
    }
    /**
     * description: The AM/FM region code and waveband information according to request
     *   "controlSetRegion".
     */
    /**
     * Returns the wrapper class that provides access to the attribute amfmControlRegionInfo.
     */
    virtual AmfmControlRegionInfoAttribute& getAmfmControlRegionInfoAttribute() {
        return delegate_->getAmfmControlRegionInfoAttribute();
    }
    /**
     * description: The current state of the alternative frequency (AF) switch. The switch can be
     *   controlled by the request "amfmControlSetAfSwitch".
     */
    /**
     * Returns the wrapper class that provides access to the attribute amfmControlAfSwitch.
     */
    virtual AmfmControlAfSwitchAttribute& getAmfmControlAfSwitchAttribute() {
        return delegate_->getAmfmControlAfSwitchAttribute();
    }
    /**
     * description: The current state of the regionalization (REG) switch. The switch can be
     *   controlled by the request "amfmControlSetRegSwitch".
     */
    /**
     * Returns the wrapper class that provides access to the attribute amfmControlRegSwitch.
     */
    virtual AmfmControlRegSwitchAttribute& getAmfmControlRegSwitchAttribute() {
        return delegate_->getAmfmControlRegSwitchAttribute();
    }
    /**
     * description: The current HD mode. The switch can be controlled by the request
     *   "amfmControlSetHdMode".
     */
    /**
     * Returns the wrapper class that provides access to the attribute amfmControlHdMode.
     */
    virtual AmfmControlHdModeAttribute& getAmfmControlHdModeAttribute() {
        return delegate_->getAmfmControlHdModeAttribute();
    }
    /**
     * description: The DAB region code according to request "controlSetRegion".
     */
    /**
     * Returns the wrapper class that provides access to the attribute dabControlRegionInfo.
     */
    virtual DabControlRegionInfoAttribute& getDabControlRegionInfoAttribute() {
        return delegate_->getDabControlRegionInfoAttribute();
    }
    /**
     * description: The current state of the service following switch. The switch can be controlled
     *   by the request "dabControlSetFollowingSwitch".
     */
    /**
     * Returns the wrapper class that provides access to the attribute dabControlFollowingSwitch.
     */
    virtual DabControlFollowingSwitchAttribute& getDabControlFollowingSwitchAttribute() {
        return delegate_->getDabControlFollowingSwitchAttribute();
    }

    /**
     * description: Current station update. Updates of different source might happen in parallel
     *   (not only for the current audio source). If FM is the active audio source
     *   according to attribute "audioCurrentSource" this is also the currently active
     *   tuner station which is audible
     */
    /**
     * Returns the wrapper class that provides access to the broadcast stationCurrentStation.
     */
    virtual StationCurrentStationEvent& getStationCurrentStationEvent() {
        return delegate_->getStationCurrentStationEvent();
    }
    /**
     * description: List update. Check listType and source to distinguish between different lists.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast stationStationList.
     */
    virtual StationStationListEvent& getStationStationListEvent() {
        return delegate_->getStationStationListEvent();
    }

    /**
     * description: Set the coding of the AM/FM tuner and DAB tuner. 
    	 	IMPORTANT: This request
     *   must be called first before everything else otherwise the tuner will not start
     *   correctly.
     * Calls controlSetRegion with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void controlSetRegion(const OrinocoTunerTypes::AmFmRegionCode &_amfmRegionCode, const uint32_t &_amfmCodingFlags, const OrinocoTunerTypes::DabRegionInfo &_dabRegionCode, const uint32_t &_dabCodingFlags, const uint8_t &_fmAntennaGain, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls controlSetRegion with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> controlSetRegionAsync(const OrinocoTunerTypes::AmFmRegionCode &_amfmRegionCode, const uint32_t &_amfmCodingFlags, const OrinocoTunerTypes::DabRegionInfo &_dabRegionCode, const uint32_t &_dabCodingFlags, const uint8_t &_fmAntennaGain, ControlSetRegionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Use this method to set the currently active tuner source as soon as the tuner
     *   application is entered or changed. Furthmore, use this method if the tuner
     *   application is exited in combination with "ASRC_NONE".&#13;
    		As result the
     *   attribute "audioCurrentSource" is updated with the given handle.
     * Calls audioSetCurrentSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void audioSetCurrentSource(const OrinocoTunerTypes::Source &_source, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls audioSetCurrentSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> audioSetCurrentSourceAsync(const OrinocoTunerTypes::Source &_source, const uint32_t &_handle, AudioSetCurrentSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Any manipulation of the current station: Selection by list / direct frequency
     *   tuning / preset selection / starting a search run.  &#13;
    		As result the
     *   information "stationCurrentStation" is updated with the given handle.
     * Calls stationSelectStation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stationSelectStation(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stationSelectStation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stationSelectStationAsync(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, StationSelectStationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Store the given station in corresponding preset list and assign the given
     *   preset number for later recalls (via "stationStartTune").&#13;
    		As result the
     *   corresponding information "stationStationList" is updated with the given
     *   handle.
     * Calls stationStorePreset with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stationStorePreset(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stationStorePreset with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stationStorePresetAsync(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, StationStorePresetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Remove given preset number from corresponding preset list.
    		As result the
     *   corresponding information "stationStationList" is updated with the given handle
     * Calls stationDeletePreset with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stationDeletePreset(const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stationDeletePreset with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stationDeletePresetAsync(const uint32_t &_preset, const uint32_t &_handle, StationDeletePresetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Enable/disable the announcement monitoring for FM and DAB.
    		As result the
     *   attribute "announcementCurrentStation" is updated with the given handle
     * Calls announcementSwitchTp with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void announcementSwitchTp(const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls announcementSwitchTp with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> announcementSwitchTpAsync(const bool &_enable, const uint32_t &_handle, AnnouncementSwitchTpAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Abort an active announcement. As a result the attribute
     *   "announcementCurrentStation" is updated with the given handle.
     * Calls announcementAbort with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void announcementAbort(const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls announcementAbort with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> announcementAbortAsync(const uint32_t &_handle, AnnouncementAbortAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Set the desired RDS alternative frequency (AF) state.
    		As result the attribute
     *   "amfmControlAfSwitch" is updated with the given handle.
     * Calls amfmControlSetAfSwitch with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void amfmControlSetAfSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls amfmControlSetAfSwitch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> amfmControlSetAfSwitchAsync(const bool &_enable, AmfmControlSetAfSwitchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Set the desired RDS regionalisation (REG) state.
    		As result the attribute
     *   "amfmControlRegSwitch" is updated with the given handle.
     * Calls amfmControlSetRegSwitch with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void amfmControlSetRegSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls amfmControlSetRegSwitch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> amfmControlSetRegSwitchAsync(const bool &_enable, AmfmControlSetRegSwitchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Set the desired HD mode.
    		As result the attribute "amfmControlHdMode" is
     *   updated with the given handle.
     * Calls amfmControlSetHdMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void amfmControlSetHdMode(const OrinocoTunerTypes::AmFmHdMode &_hdMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls amfmControlSetHdMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> amfmControlSetHdModeAsync(const OrinocoTunerTypes::AmFmHdMode &_hdMode, AmfmControlSetHdModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Set the desired service following at the FollowingMaster.
    		As result the
     *   attribute "dabControlFollowingSwitch" is updated with the given
     *   handle.
    		Note: This switch only affects DAB/FM linking, DAB/DAB is always on
     * Calls dabControlSetFollowingSwitch with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void dabControlSetFollowingSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls dabControlSetFollowingSwitch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> dabControlSetFollowingSwitchAsync(const bool &_enable, DabControlSetFollowingSwitchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Request initial information update at startup (stationCurrentStation,
     *   stationStationList) in order to force an "on change" update.
     * Calls forceInformationUpdate with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void forceInformationUpdate(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls forceInformationUpdate with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> forceInformationUpdateAsync(ForceInformationUpdateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<OrinocoTunerProxyBase> delegate_;
};

typedef OrinocoTunerProxy<> OrinocoTunerProxyDefault;

namespace OrinocoTunerExtensions {
    /**
     * description: False: Tuner not ready, requestControlSetRegion has to be called all other
     *   requests will be returned with error. True: Tuner ready to use.
     */
    template <template <typename > class _ExtensionType>
    class ControlReadyAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::ControlReadyAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::ControlReadyAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ControlReadyAttributeExtension() {}
    #endif
    
        ControlReadyAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getControlReadyAttribute()) {
        }
    
        inline extension_type& getControlReadyAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: List of power sync frequencies [KHz]. Each entry controls one amplifier or
     *   power supply. The order of the entries is HW specific.
     */
    template <template <typename > class _ExtensionType>
    class ControlPowerSyncAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::ControlPowerSyncAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::ControlPowerSyncAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ControlPowerSyncAttributeExtension() {}
    #endif
    
        ControlPowerSyncAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getControlPowerSyncAttribute()) {
        }
    
        inline extension_type& getControlPowerSyncAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current active tuner source. Controlled by the requests
     *   "audioSetCurrentSource".
     */
    template <template <typename > class _ExtensionType>
    class AudioCurrentSourceAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AudioCurrentSourceAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AudioCurrentSourceAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AudioCurrentSourceAttributeExtension() {}
    #endif
    
        AudioCurrentSourceAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAudioCurrentSourceAttribute()) {
        }
    
        inline extension_type& getAudioCurrentSourceAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: All available information about the current TP station. Announcement monitoring
     *   can be activated/deactivated by "announcementSwitchTp". An active announcement
     *   can be aborted by "announcementActivate".
     */
    template <template <typename > class _ExtensionType>
    class AnnouncementCurrentStationAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AnnouncementCurrentStationAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AnnouncementCurrentStationAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AnnouncementCurrentStationAttributeExtension() {}
    #endif
    
        AnnouncementCurrentStationAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAnnouncementCurrentStationAttribute()) {
        }
    
        inline extension_type& getAnnouncementCurrentStationAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The AM/FM region code and waveband information according to request
     *   "controlSetRegion".
     */
    template <template <typename > class _ExtensionType>
    class AmfmControlRegionInfoAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AmfmControlRegionInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AmfmControlRegionInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AmfmControlRegionInfoAttributeExtension() {}
    #endif
    
        AmfmControlRegionInfoAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAmfmControlRegionInfoAttribute()) {
        }
    
        inline extension_type& getAmfmControlRegionInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current state of the alternative frequency (AF) switch. The switch can be
     *   controlled by the request "amfmControlSetAfSwitch".
     */
    template <template <typename > class _ExtensionType>
    class AmfmControlAfSwitchAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AmfmControlAfSwitchAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AmfmControlAfSwitchAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AmfmControlAfSwitchAttributeExtension() {}
    #endif
    
        AmfmControlAfSwitchAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAmfmControlAfSwitchAttribute()) {
        }
    
        inline extension_type& getAmfmControlAfSwitchAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current state of the regionalization (REG) switch. The switch can be
     *   controlled by the request "amfmControlSetRegSwitch".
     */
    template <template <typename > class _ExtensionType>
    class AmfmControlRegSwitchAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AmfmControlRegSwitchAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AmfmControlRegSwitchAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AmfmControlRegSwitchAttributeExtension() {}
    #endif
    
        AmfmControlRegSwitchAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAmfmControlRegSwitchAttribute()) {
        }
    
        inline extension_type& getAmfmControlRegSwitchAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current HD mode. The switch can be controlled by the request
     *   "amfmControlSetHdMode".
     */
    template <template <typename > class _ExtensionType>
    class AmfmControlHdModeAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AmfmControlHdModeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AmfmControlHdModeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AmfmControlHdModeAttributeExtension() {}
    #endif
    
        AmfmControlHdModeAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAmfmControlHdModeAttribute()) {
        }
    
        inline extension_type& getAmfmControlHdModeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The DAB region code according to request "controlSetRegion".
     */
    template <template <typename > class _ExtensionType>
    class DabControlRegionInfoAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::DabControlRegionInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::DabControlRegionInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DabControlRegionInfoAttributeExtension() {}
    #endif
    
        DabControlRegionInfoAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getDabControlRegionInfoAttribute()) {
        }
    
        inline extension_type& getDabControlRegionInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current state of the service following switch. The switch can be controlled
     *   by the request "dabControlSetFollowingSwitch".
     */
    template <template <typename > class _ExtensionType>
    class DabControlFollowingSwitchAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::DabControlFollowingSwitchAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::DabControlFollowingSwitchAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DabControlFollowingSwitchAttributeExtension() {}
    #endif
    
        DabControlFollowingSwitchAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getDabControlFollowingSwitchAttribute()) {
        }
    
        inline extension_type& getDabControlFollowingSwitchAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace OrinocoTunerExtensions

//
// OrinocoTunerProxy Implementation
//
template <typename ... _AttributeExtensions>
OrinocoTunerProxy<_AttributeExtensions...>::OrinocoTunerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<OrinocoTunerProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<OrinocoTunerProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
OrinocoTunerProxy<_AttributeExtensions...>::~OrinocoTunerProxy() {
}

/**
 * description: Set the coding of the AM/FM tuner and DAB tuner. 
	 	IMPORTANT: This request
 *   must be called first before everything else otherwise the tuner will not start
 *   correctly.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::controlSetRegion(const OrinocoTunerTypes::AmFmRegionCode &_amfmRegionCode, const uint32_t &_amfmCodingFlags, const OrinocoTunerTypes::DabRegionInfo &_dabRegionCode, const uint32_t &_dabCodingFlags, const uint8_t &_fmAntennaGain, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_amfmRegionCode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->controlSetRegion(_amfmRegionCode, _amfmCodingFlags, _dabRegionCode, _dabCodingFlags, _fmAntennaGain, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::controlSetRegionAsync(const OrinocoTunerTypes::AmFmRegionCode &_amfmRegionCode, const uint32_t &_amfmCodingFlags, const OrinocoTunerTypes::DabRegionInfo &_dabRegionCode, const uint32_t &_dabCodingFlags, const uint8_t &_fmAntennaGain, ControlSetRegionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_amfmRegionCode.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->controlSetRegionAsync(_amfmRegionCode, _amfmCodingFlags, _dabRegionCode, _dabCodingFlags, _fmAntennaGain, _callback, _info);
}
/**
 * description: Use this method to set the currently active tuner source as soon as the tuner
 *   application is entered or changed. Furthmore, use this method if the tuner
 *   application is exited in combination with "ASRC_NONE".&#13;
		As result the
 *   attribute "audioCurrentSource" is updated with the given handle.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::audioSetCurrentSource(const OrinocoTunerTypes::Source &_source, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_source.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->audioSetCurrentSource(_source, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::audioSetCurrentSourceAsync(const OrinocoTunerTypes::Source &_source, const uint32_t &_handle, AudioSetCurrentSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_source.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->audioSetCurrentSourceAsync(_source, _handle, _callback, _info);
}
/**
 * description: Any manipulation of the current station: Selection by list / direct frequency
 *   tuning / preset selection / starting a search run.  &#13;
		As result the
 *   information "stationCurrentStation" is updated with the given handle.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::stationSelectStation(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->stationSelectStation(_stationSelector, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::stationSelectStationAsync(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, StationSelectStationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stationSelectStationAsync(_stationSelector, _handle, _callback, _info);
}
/**
 * description: Store the given station in corresponding preset list and assign the given
 *   preset number for later recalls (via "stationStartTune").&#13;
		As result the
 *   corresponding information "stationStationList" is updated with the given
 *   handle.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::stationStorePreset(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->stationStorePreset(_stationSelector, _preset, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::stationStorePresetAsync(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, StationStorePresetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stationStorePresetAsync(_stationSelector, _preset, _handle, _callback, _info);
}
/**
 * description: Remove given preset number from corresponding preset list.
		As result the
 *   corresponding information "stationStationList" is updated with the given handle
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::stationDeletePreset(const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->stationDeletePreset(_preset, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::stationDeletePresetAsync(const uint32_t &_preset, const uint32_t &_handle, StationDeletePresetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stationDeletePresetAsync(_preset, _handle, _callback, _info);
}
/**
 * description: Enable/disable the announcement monitoring for FM and DAB.
		As result the
 *   attribute "announcementCurrentStation" is updated with the given handle
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::announcementSwitchTp(const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->announcementSwitchTp(_enable, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::announcementSwitchTpAsync(const bool &_enable, const uint32_t &_handle, AnnouncementSwitchTpAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->announcementSwitchTpAsync(_enable, _handle, _callback, _info);
}
/**
 * description: Abort an active announcement. As a result the attribute
 *   "announcementCurrentStation" is updated with the given handle.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::announcementAbort(const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->announcementAbort(_handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::announcementAbortAsync(const uint32_t &_handle, AnnouncementAbortAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->announcementAbortAsync(_handle, _callback, _info);
}
/**
 * description: Set the desired RDS alternative frequency (AF) state.
		As result the attribute
 *   "amfmControlAfSwitch" is updated with the given handle.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetAfSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->amfmControlSetAfSwitch(_enable, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetAfSwitchAsync(const bool &_enable, AmfmControlSetAfSwitchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->amfmControlSetAfSwitchAsync(_enable, _callback, _info);
}
/**
 * description: Set the desired RDS regionalisation (REG) state.
		As result the attribute
 *   "amfmControlRegSwitch" is updated with the given handle.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetRegSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->amfmControlSetRegSwitch(_enable, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetRegSwitchAsync(const bool &_enable, AmfmControlSetRegSwitchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->amfmControlSetRegSwitchAsync(_enable, _callback, _info);
}
/**
 * description: Set the desired HD mode.
		As result the attribute "amfmControlHdMode" is
 *   updated with the given handle.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetHdMode(const OrinocoTunerTypes::AmFmHdMode &_hdMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_hdMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->amfmControlSetHdMode(_hdMode, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetHdModeAsync(const OrinocoTunerTypes::AmFmHdMode &_hdMode, AmfmControlSetHdModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_hdMode.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->amfmControlSetHdModeAsync(_hdMode, _callback, _info);
}
/**
 * description: Set the desired service following at the FollowingMaster.
		As result the
 *   attribute "dabControlFollowingSwitch" is updated with the given
 *   handle.
		Note: This switch only affects DAB/FM linking, DAB/DAB is always on
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::dabControlSetFollowingSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->dabControlSetFollowingSwitch(_enable, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::dabControlSetFollowingSwitchAsync(const bool &_enable, DabControlSetFollowingSwitchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->dabControlSetFollowingSwitchAsync(_enable, _callback, _info);
}
/**
 * description: Request initial information update at startup (stationCurrentStation,
 *   stationStationList) in order to force an "on change" update.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::forceInformationUpdate(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->forceInformationUpdate(_internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::forceInformationUpdateAsync(ForceInformationUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->forceInformationUpdateAsync(_callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &OrinocoTunerProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool OrinocoTunerProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool OrinocoTunerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& OrinocoTunerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& OrinocoTunerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace tuner
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v1::com::harman::tuner::OrinocoTunerProxy,
    _AttributeExtension> {
    typedef typename ::v1::com::harman::tuner::OrinocoTunerProxy<
            ::v1::com::harman::tuner::OrinocoTunerExtensions::ControlReadyAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::tuner::OrinocoTunerExtensions::ControlPowerSyncAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::tuner::OrinocoTunerExtensions::AudioCurrentSourceAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::tuner::OrinocoTunerExtensions::AnnouncementCurrentStationAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::tuner::OrinocoTunerExtensions::AmfmControlRegionInfoAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::tuner::OrinocoTunerExtensions::AmfmControlAfSwitchAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::tuner::OrinocoTunerExtensions::AmfmControlRegSwitchAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::tuner::OrinocoTunerExtensions::AmfmControlHdModeAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::tuner::OrinocoTunerExtensions::DabControlRegionInfoAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::tuner::OrinocoTunerExtensions::DabControlFollowingSwitchAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_TUNER_Orinoco_Tuner_PROXY_HPP_
