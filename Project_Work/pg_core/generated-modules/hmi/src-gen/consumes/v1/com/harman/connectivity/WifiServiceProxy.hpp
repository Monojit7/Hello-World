/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
#ifndef V1_COM_HARMAN_CONNECTIVITY_Wifi_Service_PROXY_HPP_
#define V1_COM_HARMAN_CONNECTIVITY_Wifi_Service_PROXY_HPP_

#include <v1/com/harman/connectivity/WifiServiceProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace connectivity {

template <typename ... _AttributeExtensions>
class WifiServiceProxy
    : virtual public WifiService, 
      virtual public WifiServiceProxyBase,
      virtual public _AttributeExtensions... {
public:
    WifiServiceProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~WifiServiceProxy();

    typedef WifiService InterfaceType;



    /**
     * Returns the wrapper class that provides access to the broadcast ScanningForNetworks.
     */
    virtual ScanningForNetworksEvent& getScanningForNetworksEvent() {
        return delegate_->getScanningForNetworksEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast scanResults.
     */
    virtual ScanResultsEvent& getScanResultsEvent() {
        return delegate_->getScanResultsEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast joinedNetwork.
     */
    virtual JoinedNetworkEvent& getJoinedNetworkEvent() {
        return delegate_->getJoinedNetworkEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast leftNetwork.
     */
    virtual LeftNetworkEvent& getLeftNetworkEvent() {
        return delegate_->getLeftNetworkEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast enableClientUpdate.
     */
    virtual EnableClientUpdateEvent& getEnableClientUpdateEvent() {
        return delegate_->getEnableClientUpdateEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast WPASuccess.
     */
    virtual WPASuccessEvent& getWPASuccessEvent() {
        return delegate_->getWPASuccessEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast WPAFailure.
     */
    virtual WPAFailureEvent& getWPAFailureEvent() {
        return delegate_->getWPAFailureEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast connectionError.
     */
    virtual ConnectionErrorEvent& getConnectionErrorEvent() {
        return delegate_->getConnectionErrorEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast connectionEstablished.
     */
    virtual ConnectionEstablishedEvent& getConnectionEstablishedEvent() {
        return delegate_->getConnectionEstablishedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast connectionLost.
     */
    virtual ConnectionLostEvent& getConnectionLostEvent() {
        return delegate_->getConnectionLostEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast passwordRequired.
     */
    virtual PasswordRequiredEvent& getPasswordRequiredEvent() {
        return delegate_->getPasswordRequiredEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast MaxNumberKnownNetworksReached.
     */
    virtual MaxNumberKnownNetworksReachedEvent& getMaxNumberKnownNetworksReachedEvent() {
        return delegate_->getMaxNumberKnownNetworksReachedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast enableAPUpdate.
     */
    virtual EnableAPUpdateEvent& getEnableAPUpdateEvent() {
        return delegate_->getEnableAPUpdateEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast clientJoined.
     */
    virtual ClientJoinedEvent& getClientJoinedEvent() {
        return delegate_->getClientJoinedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast clientLeave.
     */
    virtual ClientLeaveEvent& getClientLeaveEvent() {
        return delegate_->getClientLeaveEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast clientWPASuccess.
     */
    virtual ClientWPASuccessEvent& getClientWPASuccessEvent() {
        return delegate_->getClientWPASuccessEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast MaxClientSet.
     */
    virtual MaxClientSetEvent& getMaxClientSetEvent() {
        return delegate_->getMaxClientSetEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast BandSet.
     */
    virtual BandSetEvent& getBandSetEvent() {
        return delegate_->getBandSetEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast modeListUpdate.
     */
    virtual ModeListUpdateEvent& getModeListUpdateEvent() {
        return delegate_->getModeListUpdateEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast IfCreated.
     */
    virtual IfCreatedEvent& getIfCreatedEvent() {
        return delegate_->getIfCreatedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast IfDestroyed.
     */
    virtual IfDestroyedEvent& getIfDestroyedEvent() {
        return delegate_->getIfDestroyedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast roleChanged.
     */
    virtual RoleChangedEvent& getRoleChangedEvent() {
        return delegate_->getRoleChangedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast IfUp.
     */
    virtual IfUpEvent& getIfUpEvent() {
        return delegate_->getIfUpEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast IfDown.
     */
    virtual IfDownEvent& getIfDownEvent() {
        return delegate_->getIfDownEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast wlanCrash.
     */
    virtual WlanCrashEvent& getWlanCrashEvent() {
        return delegate_->getWlanCrashEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast serviceFailure.
     */
    virtual ServiceFailureEvent& getServiceFailureEvent() {
        return delegate_->getServiceFailureEvent();
    }

    /**
     * Calls enableClient with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void enableClient(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName_out, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls enableClient with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> enableClientAsync(const std::string &_interfaceName, EnableClientAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls disableClient with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void disableClient(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName_out, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls disableClient with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> disableClientAsync(const std::string &_interfaceName, DisableClientAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls scanNetworks with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void scanNetworks(const int32_t &_scanTime, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls scanNetworks with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> scanNetworksAsync(const int32_t &_scanTime, ScanNetworksAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stopScanNetwork with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stopScanNetwork(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stopScanNetwork with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stopScanNetworkAsync(const std::string &_interfaceName, StopScanNetworkAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls joinNetwork with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void joinNetwork(const std::string &_ssid, const std::string &_password, const std::string &_hexKey, const ::com::harman::connectivity::WifiTypedefs::stringList &_security, const ::com::harman::connectivity::WifiTypedefs::stringList &_groupCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_pairwiseCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_authentication, const int32_t &_securityOption, const bool &_hidden, const std::string &_ipAddress, const std::string &_subnetMask, const bool &_saveNetwork, const bool &_highestPriority, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, std::string &_Status, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls joinNetwork with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> joinNetworkAsync(const std::string &_ssid, const std::string &_password, const std::string &_hexKey, const ::com::harman::connectivity::WifiTypedefs::stringList &_security, const ::com::harman::connectivity::WifiTypedefs::stringList &_groupCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_pairwiseCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_authentication, const int32_t &_securityOption, const bool &_hidden, const std::string &_ipAddress, const std::string &_subnetMask, const bool &_saveNetwork, const bool &_highestPriority, JoinNetworkAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls leaveNetwork with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void leaveNetwork(CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls leaveNetwork with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> leaveNetworkAsync(LeaveNetworkAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getKnownNetworkList with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getKnownNetworkList(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::WifiTypedefs::WiFiSvcNetworklist &_list, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getKnownNetworkList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getKnownNetworkListAsync(GetKnownNetworkListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getKnownNetworksCount with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getKnownNetworksCount(CommonAPI::CallStatus &_internalCallStatus, int32_t &_count, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getKnownNetworksCount with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getKnownNetworksCountAsync(GetKnownNetworksCountAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls storeAsKnownNetwork with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void storeAsKnownNetwork(const std::string &_ssid, const std::string &_password, const std::string &_hexKey, const ::com::harman::connectivity::WifiTypedefs::stringList &_security, const ::com::harman::connectivity::WifiTypedefs::stringList &_groupCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_pairwiseCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_authentication, const int32_t &_securityOption, const bool &_hidden, const bool &_highestPriority, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls storeAsKnownNetwork with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> storeAsKnownNetworkAsync(const std::string &_ssid, const std::string &_password, const std::string &_hexKey, const ::com::harman::connectivity::WifiTypedefs::stringList &_security, const ::com::harman::connectivity::WifiTypedefs::stringList &_groupCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_pairwiseCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_authentication, const int32_t &_securityOption, const bool &_hidden, const bool &_highestPriority, StoreAsKnownNetworkAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls updateKnownNetworkPriority with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void updateKnownNetworkPriority(const ::com::harman::connectivity::WifiTypedefs::knownNetworkList &_list, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls updateKnownNetworkPriority with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateKnownNetworkPriorityAsync(const ::com::harman::connectivity::WifiTypedefs::knownNetworkList &_list, UpdateKnownNetworkPriorityAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteKnownNetwork with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteKnownNetwork(const std::string &_ssid, const std::string &_bssid, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteKnownNetwork with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deleteKnownNetworkAsync(const std::string &_ssid, const std::string &_bssid, DeleteKnownNetworkAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startPeriodicScanning with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startPeriodicScanning(const int32_t &_interval, const int32_t &_scantime, const bool &_autoconnect, const ::com::harman::connectivity::WifiTypedefs::stringList &_doNotAutoconnect, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startPeriodicScanning with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startPeriodicScanningAsync(const int32_t &_interval, const int32_t &_scantime, const bool &_autoconnect, const ::com::harman::connectivity::WifiTypedefs::stringList &_doNotAutoconnect, StartPeriodicScanningAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stopPeriodicScanning with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stopPeriodicScanning(CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stopPeriodicScanning with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stopPeriodicScanningAsync(StopPeriodicScanningAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getClientStatus with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getClientStatus(CommonAPI::CallStatus &_internalCallStatus, int32_t &_assocState, std::string &_bssid, std::string &_securityState, int32_t &_rssi, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getClientStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getClientStatusAsync(GetClientStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getClientAddress with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getClientAddress(CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName, std::string &_ipAddress, std::string &_subnet, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getClientAddress with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getClientAddressAsync(GetClientAddressAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls enableAP with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void enableAP(const std::string &_interfaceName, const int32_t &_Keyindex, const ::com::harman::connectivity::WifiTypedefs::stringList &_Keylist, const std::string &_password, const std::string &_Encryption, const std::string &_Authentication, const int32_t &_Channel, const std::string &_opMode, const std::string &_CountryCode, const std::string &_ssid, const ::com::harman::connectivity::WifiTypedefs::stringList &_eWPSModeList, const bool &_broadcast_On, const std::string &_filter_Mode, const ::com::harman::connectivity::WifiTypedefs::stringList &_mac_list, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls enableAP with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> enableAPAsync(const std::string &_interfaceName, const int32_t &_Keyindex, const ::com::harman::connectivity::WifiTypedefs::stringList &_Keylist, const std::string &_password, const std::string &_Encryption, const std::string &_Authentication, const int32_t &_Channel, const std::string &_opMode, const std::string &_CountryCode, const std::string &_ssid, const ::com::harman::connectivity::WifiTypedefs::stringList &_eWPSModeList, const bool &_broadcast_On, const std::string &_filter_Mode, const ::com::harman::connectivity::WifiTypedefs::stringList &_mac_list, EnableAPAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls disableAP with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void disableAP(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls disableAP with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> disableAPAsync(const std::string &_interfaceName, DisableAPAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getAccessPointProperties with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getAccessPointProperties(CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName, int32_t &_Keyindex, ::com::harman::connectivity::WifiTypedefs::stringList &_Keylist, std::string &_Encryption, std::string &_Authentication, int32_t &_Channel, std::string &_opMode, std::string &_CountryCode, std::string &_ssid, ::com::harman::connectivity::WifiTypedefs::stringList &_eWPSModeList, bool &_broadcast_On, std::string &_filter_Mode, ::com::harman::connectivity::WifiTypedefs::stringList &_mac_list, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getAccessPointProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getAccessPointPropertiesAsync(GetAccessPointPropertiesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getClientList with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getClientList(CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName, ::com::harman::connectivity::WifiTypedefs::clientNodeList &_mClientList, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getClientList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getClientListAsync(GetClientListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMaxClient with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMaxClient(const int32_t &_maxClient, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMaxClient with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMaxClientAsync(const int32_t &_maxClient, SetMaxClientAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMaxClient with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMaxClient(CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMaxClient with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMaxClientAsync(GetMaxClientAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setRadioPower with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setRadioPower(const bool &_RadioPower, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setRadioPower with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setRadioPowerAsync(const bool &_RadioPower, SetRadioPowerAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setBand with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setBand(const std::string &_band, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setBand with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setBandAsync(const std::string &_band, SetBandAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBand with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getBand(CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBand with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getBandAsync(GetBandAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setOperationMode11ac with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setOperationMode11ac(const int32_t &_enable, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setOperationMode11ac with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setOperationMode11acAsync(const int32_t &_enable, SetOperationMode11acAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getOperationMode11ac with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getOperationMode11ac(CommonAPI::CallStatus &_internalCallStatus, int32_t &_enable, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getOperationMode11ac with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getOperationMode11acAsync(GetOperationMode11acAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMode(const ::com::harman::connectivity::WifiTypedefs::interfaceModeList &_list, CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::WifiTypedefs::interfaceModeList &_Interfaces_Created, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setModeAsync(const ::com::harman::connectivity::WifiTypedefs::interfaceModeList &_list, SetModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getModeList with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getModeList(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::WifiTypedefs::interfaceModeList &_list, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getModeList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getModeListAsync(GetModeListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getActiveRoles with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getActiveRoles(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::WifiTypedefs::stringList &_roles, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getActiveRoles with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getActiveRolesAsync(GetActiveRolesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getInterfaceByRole with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getInterfaceByRole(const std::string &_role, CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getInterfaceByRole with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getInterfaceByRoleAsync(const std::string &_role, GetInterfaceByRoleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRoleByInterface with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getRoleByInterface(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_role, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRoleByInterface with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getRoleByInterfaceAsync(const std::string &_interfaceName, GetRoleByInterfaceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMacAddress with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMacAddress(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_macAddr, std::string &_role, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMacAddress with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMacAddressAsync(const std::string &_interfaceName, GetMacAddressAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getConnectionStatus with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getConnectionStatus(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::WifiTypedefs::ConnectionStatusList &_list, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getConnectionStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getConnectionStatusAsync(GetConnectionStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<WifiServiceProxyBase> delegate_;
};

typedef WifiServiceProxy<> WifiServiceProxyDefault;


//
// WifiServiceProxy Implementation
//
template <typename ... _AttributeExtensions>
WifiServiceProxy<_AttributeExtensions...>::WifiServiceProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<WifiServiceProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<WifiServiceProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
WifiServiceProxy<_AttributeExtensions...>::~WifiServiceProxy() {
}

template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::enableClient(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName_out, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->enableClient(_interfaceName, _internalCallStatus, _interfaceName_out, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::enableClientAsync(const std::string &_interfaceName, EnableClientAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->enableClientAsync(_interfaceName, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::disableClient(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName_out, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->disableClient(_interfaceName, _internalCallStatus, _interfaceName_out, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::disableClientAsync(const std::string &_interfaceName, DisableClientAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->disableClientAsync(_interfaceName, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::scanNetworks(const int32_t &_scanTime, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->scanNetworks(_scanTime, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::scanNetworksAsync(const int32_t &_scanTime, ScanNetworksAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->scanNetworksAsync(_scanTime, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::stopScanNetwork(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->stopScanNetwork(_interfaceName, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::stopScanNetworkAsync(const std::string &_interfaceName, StopScanNetworkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stopScanNetworkAsync(_interfaceName, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::joinNetwork(const std::string &_ssid, const std::string &_password, const std::string &_hexKey, const ::com::harman::connectivity::WifiTypedefs::stringList &_security, const ::com::harman::connectivity::WifiTypedefs::stringList &_groupCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_pairwiseCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_authentication, const int32_t &_securityOption, const bool &_hidden, const std::string &_ipAddress, const std::string &_subnetMask, const bool &_saveNetwork, const bool &_highestPriority, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, std::string &_Status, const CommonAPI::CallInfo *_info) {
    delegate_->joinNetwork(_ssid, _password, _hexKey, _security, _groupCipher, _pairwiseCipher, _authentication, _securityOption, _hidden, _ipAddress, _subnetMask, _saveNetwork, _highestPriority, _internalCallStatus, _Result, _Code, _Status, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::joinNetworkAsync(const std::string &_ssid, const std::string &_password, const std::string &_hexKey, const ::com::harman::connectivity::WifiTypedefs::stringList &_security, const ::com::harman::connectivity::WifiTypedefs::stringList &_groupCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_pairwiseCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_authentication, const int32_t &_securityOption, const bool &_hidden, const std::string &_ipAddress, const std::string &_subnetMask, const bool &_saveNetwork, const bool &_highestPriority, JoinNetworkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->joinNetworkAsync(_ssid, _password, _hexKey, _security, _groupCipher, _pairwiseCipher, _authentication, _securityOption, _hidden, _ipAddress, _subnetMask, _saveNetwork, _highestPriority, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::leaveNetwork(CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->leaveNetwork(_internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::leaveNetworkAsync(LeaveNetworkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->leaveNetworkAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getKnownNetworkList(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::WifiTypedefs::WiFiSvcNetworklist &_list, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getKnownNetworkList(_internalCallStatus, _list, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getKnownNetworkListAsync(GetKnownNetworkListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getKnownNetworkListAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getKnownNetworksCount(CommonAPI::CallStatus &_internalCallStatus, int32_t &_count, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getKnownNetworksCount(_internalCallStatus, _count, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getKnownNetworksCountAsync(GetKnownNetworksCountAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getKnownNetworksCountAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::storeAsKnownNetwork(const std::string &_ssid, const std::string &_password, const std::string &_hexKey, const ::com::harman::connectivity::WifiTypedefs::stringList &_security, const ::com::harman::connectivity::WifiTypedefs::stringList &_groupCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_pairwiseCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_authentication, const int32_t &_securityOption, const bool &_hidden, const bool &_highestPriority, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->storeAsKnownNetwork(_ssid, _password, _hexKey, _security, _groupCipher, _pairwiseCipher, _authentication, _securityOption, _hidden, _highestPriority, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::storeAsKnownNetworkAsync(const std::string &_ssid, const std::string &_password, const std::string &_hexKey, const ::com::harman::connectivity::WifiTypedefs::stringList &_security, const ::com::harman::connectivity::WifiTypedefs::stringList &_groupCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_pairwiseCipher, const ::com::harman::connectivity::WifiTypedefs::stringList &_authentication, const int32_t &_securityOption, const bool &_hidden, const bool &_highestPriority, StoreAsKnownNetworkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->storeAsKnownNetworkAsync(_ssid, _password, _hexKey, _security, _groupCipher, _pairwiseCipher, _authentication, _securityOption, _hidden, _highestPriority, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::updateKnownNetworkPriority(const ::com::harman::connectivity::WifiTypedefs::knownNetworkList &_list, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->updateKnownNetworkPriority(_list, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::updateKnownNetworkPriorityAsync(const ::com::harman::connectivity::WifiTypedefs::knownNetworkList &_list, UpdateKnownNetworkPriorityAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->updateKnownNetworkPriorityAsync(_list, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::deleteKnownNetwork(const std::string &_ssid, const std::string &_bssid, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->deleteKnownNetwork(_ssid, _bssid, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::deleteKnownNetworkAsync(const std::string &_ssid, const std::string &_bssid, DeleteKnownNetworkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deleteKnownNetworkAsync(_ssid, _bssid, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::startPeriodicScanning(const int32_t &_interval, const int32_t &_scantime, const bool &_autoconnect, const ::com::harman::connectivity::WifiTypedefs::stringList &_doNotAutoconnect, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->startPeriodicScanning(_interval, _scantime, _autoconnect, _doNotAutoconnect, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::startPeriodicScanningAsync(const int32_t &_interval, const int32_t &_scantime, const bool &_autoconnect, const ::com::harman::connectivity::WifiTypedefs::stringList &_doNotAutoconnect, StartPeriodicScanningAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startPeriodicScanningAsync(_interval, _scantime, _autoconnect, _doNotAutoconnect, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::stopPeriodicScanning(CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->stopPeriodicScanning(_internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::stopPeriodicScanningAsync(StopPeriodicScanningAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stopPeriodicScanningAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getClientStatus(CommonAPI::CallStatus &_internalCallStatus, int32_t &_assocState, std::string &_bssid, std::string &_securityState, int32_t &_rssi, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getClientStatus(_internalCallStatus, _assocState, _bssid, _securityState, _rssi, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getClientStatusAsync(GetClientStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getClientStatusAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getClientAddress(CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName, std::string &_ipAddress, std::string &_subnet, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getClientAddress(_internalCallStatus, _interfaceName, _ipAddress, _subnet, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getClientAddressAsync(GetClientAddressAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getClientAddressAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::enableAP(const std::string &_interfaceName, const int32_t &_Keyindex, const ::com::harman::connectivity::WifiTypedefs::stringList &_Keylist, const std::string &_password, const std::string &_Encryption, const std::string &_Authentication, const int32_t &_Channel, const std::string &_opMode, const std::string &_CountryCode, const std::string &_ssid, const ::com::harman::connectivity::WifiTypedefs::stringList &_eWPSModeList, const bool &_broadcast_On, const std::string &_filter_Mode, const ::com::harman::connectivity::WifiTypedefs::stringList &_mac_list, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->enableAP(_interfaceName, _Keyindex, _Keylist, _password, _Encryption, _Authentication, _Channel, _opMode, _CountryCode, _ssid, _eWPSModeList, _broadcast_On, _filter_Mode, _mac_list, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::enableAPAsync(const std::string &_interfaceName, const int32_t &_Keyindex, const ::com::harman::connectivity::WifiTypedefs::stringList &_Keylist, const std::string &_password, const std::string &_Encryption, const std::string &_Authentication, const int32_t &_Channel, const std::string &_opMode, const std::string &_CountryCode, const std::string &_ssid, const ::com::harman::connectivity::WifiTypedefs::stringList &_eWPSModeList, const bool &_broadcast_On, const std::string &_filter_Mode, const ::com::harman::connectivity::WifiTypedefs::stringList &_mac_list, EnableAPAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->enableAPAsync(_interfaceName, _Keyindex, _Keylist, _password, _Encryption, _Authentication, _Channel, _opMode, _CountryCode, _ssid, _eWPSModeList, _broadcast_On, _filter_Mode, _mac_list, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::disableAP(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->disableAP(_interfaceName, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::disableAPAsync(const std::string &_interfaceName, DisableAPAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->disableAPAsync(_interfaceName, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getAccessPointProperties(CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName, int32_t &_Keyindex, ::com::harman::connectivity::WifiTypedefs::stringList &_Keylist, std::string &_Encryption, std::string &_Authentication, int32_t &_Channel, std::string &_opMode, std::string &_CountryCode, std::string &_ssid, ::com::harman::connectivity::WifiTypedefs::stringList &_eWPSModeList, bool &_broadcast_On, std::string &_filter_Mode, ::com::harman::connectivity::WifiTypedefs::stringList &_mac_list, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getAccessPointProperties(_internalCallStatus, _interfaceName, _Keyindex, _Keylist, _Encryption, _Authentication, _Channel, _opMode, _CountryCode, _ssid, _eWPSModeList, _broadcast_On, _filter_Mode, _mac_list, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getAccessPointPropertiesAsync(GetAccessPointPropertiesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getAccessPointPropertiesAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getClientList(CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName, ::com::harman::connectivity::WifiTypedefs::clientNodeList &_mClientList, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getClientList(_internalCallStatus, _interfaceName, _mClientList, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getClientListAsync(GetClientListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getClientListAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::setMaxClient(const int32_t &_maxClient, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->setMaxClient(_maxClient, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::setMaxClientAsync(const int32_t &_maxClient, SetMaxClientAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMaxClientAsync(_maxClient, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getMaxClient(CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getMaxClient(_internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getMaxClientAsync(GetMaxClientAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMaxClientAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::setRadioPower(const bool &_RadioPower, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->setRadioPower(_RadioPower, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::setRadioPowerAsync(const bool &_RadioPower, SetRadioPowerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setRadioPowerAsync(_RadioPower, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::setBand(const std::string &_band, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->setBand(_band, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::setBandAsync(const std::string &_band, SetBandAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setBandAsync(_band, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getBand(CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getBand(_internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getBandAsync(GetBandAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getBandAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::setOperationMode11ac(const int32_t &_enable, CommonAPI::CallStatus &_internalCallStatus, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->setOperationMode11ac(_enable, _internalCallStatus, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::setOperationMode11acAsync(const int32_t &_enable, SetOperationMode11acAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setOperationMode11acAsync(_enable, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getOperationMode11ac(CommonAPI::CallStatus &_internalCallStatus, int32_t &_enable, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getOperationMode11ac(_internalCallStatus, _enable, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getOperationMode11acAsync(GetOperationMode11acAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getOperationMode11acAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::setMode(const ::com::harman::connectivity::WifiTypedefs::interfaceModeList &_list, CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::WifiTypedefs::interfaceModeList &_Interfaces_Created, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->setMode(_list, _internalCallStatus, _Interfaces_Created, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::setModeAsync(const ::com::harman::connectivity::WifiTypedefs::interfaceModeList &_list, SetModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setModeAsync(_list, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getModeList(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::WifiTypedefs::interfaceModeList &_list, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getModeList(_internalCallStatus, _list, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getModeListAsync(GetModeListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getModeListAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getActiveRoles(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::WifiTypedefs::stringList &_roles, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getActiveRoles(_internalCallStatus, _roles, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getActiveRolesAsync(GetActiveRolesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getActiveRolesAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getInterfaceByRole(const std::string &_role, CommonAPI::CallStatus &_internalCallStatus, std::string &_interfaceName, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getInterfaceByRole(_role, _internalCallStatus, _interfaceName, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getInterfaceByRoleAsync(const std::string &_role, GetInterfaceByRoleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getInterfaceByRoleAsync(_role, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getRoleByInterface(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_role, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getRoleByInterface(_interfaceName, _internalCallStatus, _role, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getRoleByInterfaceAsync(const std::string &_interfaceName, GetRoleByInterfaceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getRoleByInterfaceAsync(_interfaceName, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getMacAddress(const std::string &_interfaceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_macAddr, std::string &_role, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getMacAddress(_interfaceName, _internalCallStatus, _macAddr, _role, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getMacAddressAsync(const std::string &_interfaceName, GetMacAddressAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMacAddressAsync(_interfaceName, _callback, _info);
}
template <typename ... _AttributeExtensions>
void WifiServiceProxy<_AttributeExtensions...>::getConnectionStatus(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::WifiTypedefs::ConnectionStatusList &_list, std::string &_Result, int32_t &_Code, const CommonAPI::CallInfo *_info) {
    delegate_->getConnectionStatus(_internalCallStatus, _list, _Result, _Code, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> WifiServiceProxy<_AttributeExtensions...>::getConnectionStatusAsync(GetConnectionStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getConnectionStatusAsync(_callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &WifiServiceProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool WifiServiceProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool WifiServiceProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& WifiServiceProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& WifiServiceProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace connectivity
} // namespace harman
} // namespace com
} // namespace v1



// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_CONNECTIVITY_Wifi_Service_PROXY_HPP_
