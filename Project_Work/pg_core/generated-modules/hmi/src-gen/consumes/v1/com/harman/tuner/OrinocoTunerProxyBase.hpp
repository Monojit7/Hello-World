/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
/**
 * description: Orinoco specific tuner interface. This interface is a facade to a bunch of
 *   plattform interfaces in order to provide a simplified access to tuner data and
 *   functionality.
 * author: Dirk Engel
 */
#ifndef V1_COM_HARMAN_TUNER_Orinoco_Tuner_PROXY_BASE_HPP_
#define V1_COM_HARMAN_TUNER_Orinoco_Tuner_PROXY_BASE_HPP_

#include <v1/com/harman/tuner/OrinocoTuner.hpp>


#include <v1/com/harman/tuner/OrinocoTunerTypes.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <cstdint>
#include <vector>

#include <CommonAPI/Attribute.hpp>
#include <CommonAPI/Event.hpp>
#include <CommonAPI/Proxy.hpp>
#include <functional>
#include <future>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace tuner {

class OrinocoTunerProxyBase
    : virtual public CommonAPI::Proxy {
public:
    typedef CommonAPI::ObservableReadonlyAttribute<bool> ControlReadyAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::tuner::OrinocoTunerTypes::UInt32s> ControlPowerSyncAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::tuner::OrinocoTunerTypes::CurrentSource> AudioCurrentSourceAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::tuner::OrinocoTunerTypes::AnnouncementStation> AnnouncementCurrentStationAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::tuner::OrinocoTunerTypes::AmFmRegionInfo> AmfmControlRegionInfoAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<bool> AmfmControlAfSwitchAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<bool> AmfmControlRegSwitchAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::tuner::OrinocoTunerTypes::AmFmHdMode> AmfmControlHdModeAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::tuner::OrinocoTunerTypes::DabRegionInfo> DabControlRegionInfoAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<bool> DabControlFollowingSwitchAttribute;
    typedef CommonAPI::Event<
        ::v1::com::harman::tuner::OrinocoTunerTypes::CurrentStation
    > StationCurrentStationEvent;
    typedef CommonAPI::Event<
        ::v1::com::harman::tuner::OrinocoTunerTypes::StationList
    > StationStationListEvent;

    typedef std::function<void(const CommonAPI::CallStatus&)> ControlSetRegionAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AudioSetCurrentSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> StationSelectStationAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> StationStorePresetAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> StationDeletePresetAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AnnouncementSwitchTpAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AnnouncementAbortAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AmfmControlSetAfSwitchAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AmfmControlSetRegSwitchAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> AmfmControlSetHdModeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> DabControlSetFollowingSwitchAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> ForceInformationUpdateAsyncCallback;

    /**
     * description: False: Tuner not ready, requestControlSetRegion has to be called all other
     *   requests will be returned with error. True: Tuner ready to use.
     */
    virtual ControlReadyAttribute& getControlReadyAttribute() = 0;
    /**
     * description: List of power sync frequencies [KHz]. Each entry controls one amplifier or
     *   power supply. The order of the entries is HW specific.
     */
    virtual ControlPowerSyncAttribute& getControlPowerSyncAttribute() = 0;
    /**
     * description: The current active tuner source. Controlled by the requests
     *   "audioSetCurrentSource".
     */
    virtual AudioCurrentSourceAttribute& getAudioCurrentSourceAttribute() = 0;
    /**
     * description: All available information about the current TP station. Announcement monitoring
     *   can be activated/deactivated by "announcementSwitchTp". An active announcement
     *   can be aborted by "announcementActivate".
     */
    virtual AnnouncementCurrentStationAttribute& getAnnouncementCurrentStationAttribute() = 0;
    /**
     * description: The AM/FM region code and waveband information according to request
     *   "controlSetRegion".
     */
    virtual AmfmControlRegionInfoAttribute& getAmfmControlRegionInfoAttribute() = 0;
    /**
     * description: The current state of the alternative frequency (AF) switch. The switch can be
     *   controlled by the request "amfmControlSetAfSwitch".
     */
    virtual AmfmControlAfSwitchAttribute& getAmfmControlAfSwitchAttribute() = 0;
    /**
     * description: The current state of the regionalization (REG) switch. The switch can be
     *   controlled by the request "amfmControlSetRegSwitch".
     */
    virtual AmfmControlRegSwitchAttribute& getAmfmControlRegSwitchAttribute() = 0;
    /**
     * description: The current HD mode. The switch can be controlled by the request
     *   "amfmControlSetHdMode".
     */
    virtual AmfmControlHdModeAttribute& getAmfmControlHdModeAttribute() = 0;
    /**
     * description: The DAB region code according to request "controlSetRegion".
     */
    virtual DabControlRegionInfoAttribute& getDabControlRegionInfoAttribute() = 0;
    /**
     * description: The current state of the service following switch. The switch can be controlled
     *   by the request "dabControlSetFollowingSwitch".
     */
    virtual DabControlFollowingSwitchAttribute& getDabControlFollowingSwitchAttribute() = 0;

    /**
     * description: Current station update. Updates of different source might happen in parallel
     *   (not only for the current audio source). If FM is the active audio source
     *   according to attribute "audioCurrentSource" this is also the currently active
     *   tuner station which is audible
     */
    virtual StationCurrentStationEvent& getStationCurrentStationEvent() = 0;
    /**
     * description: List update. Check listType and source to distinguish between different lists.
     */
    virtual StationStationListEvent& getStationStationListEvent() = 0;

    /**
     * description: Set the coding of the AM/FM tuner and DAB tuner. 
    	 	IMPORTANT: This request
     *   must be called first before everything else otherwise the tuner will not start
     *   correctly.
     */
    virtual void controlSetRegion(const OrinocoTunerTypes::AmFmRegionCode &_amfmRegionCode, const uint32_t &_amfmCodingFlags, const OrinocoTunerTypes::DabRegionInfo &_dabRegionCode, const uint32_t &_dabCodingFlags, const uint8_t &_fmAntennaGain, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> controlSetRegionAsync(const OrinocoTunerTypes::AmFmRegionCode &_amfmRegionCode, const uint32_t &_amfmCodingFlags, const OrinocoTunerTypes::DabRegionInfo &_dabRegionCode, const uint32_t &_dabCodingFlags, const uint8_t &_fmAntennaGain, ControlSetRegionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Use this method to set the currently active tuner source as soon as the tuner
     *   application is entered or changed. Furthmore, use this method if the tuner
     *   application is exited in combination with "ASRC_NONE".&#13;
    		As result the
     *   attribute "audioCurrentSource" is updated with the given handle.
     */
    virtual void audioSetCurrentSource(const OrinocoTunerTypes::Source &_source, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> audioSetCurrentSourceAsync(const OrinocoTunerTypes::Source &_source, const uint32_t &_handle, AudioSetCurrentSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Any manipulation of the current station: Selection by list / direct frequency
     *   tuning / preset selection / starting a search run.  &#13;
    		As result the
     *   information "stationCurrentStation" is updated with the given handle.
     */
    virtual void stationSelectStation(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> stationSelectStationAsync(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, StationSelectStationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Store the given station in corresponding preset list and assign the given
     *   preset number for later recalls (via "stationStartTune").&#13;
    		As result the
     *   corresponding information "stationStationList" is updated with the given
     *   handle.
     */
    virtual void stationStorePreset(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> stationStorePresetAsync(const OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, StationStorePresetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Remove given preset number from corresponding preset list.
    		As result the
     *   corresponding information "stationStationList" is updated with the given handle
     */
    virtual void stationDeletePreset(const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> stationDeletePresetAsync(const uint32_t &_preset, const uint32_t &_handle, StationDeletePresetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Enable/disable the announcement monitoring for FM and DAB.
    		As result the
     *   attribute "announcementCurrentStation" is updated with the given handle
     */
    virtual void announcementSwitchTp(const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> announcementSwitchTpAsync(const bool &_enable, const uint32_t &_handle, AnnouncementSwitchTpAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Abort an active announcement. As a result the attribute
     *   "announcementCurrentStation" is updated with the given handle.
     */
    virtual void announcementAbort(const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> announcementAbortAsync(const uint32_t &_handle, AnnouncementAbortAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Set the desired RDS alternative frequency (AF) state.
    		As result the attribute
     *   "amfmControlAfSwitch" is updated with the given handle.
     */
    virtual void amfmControlSetAfSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> amfmControlSetAfSwitchAsync(const bool &_enable, AmfmControlSetAfSwitchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Set the desired RDS regionalisation (REG) state.
    		As result the attribute
     *   "amfmControlRegSwitch" is updated with the given handle.
     */
    virtual void amfmControlSetRegSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> amfmControlSetRegSwitchAsync(const bool &_enable, AmfmControlSetRegSwitchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Set the desired HD mode.
    		As result the attribute "amfmControlHdMode" is
     *   updated with the given handle.
     */
    virtual void amfmControlSetHdMode(const OrinocoTunerTypes::AmFmHdMode &_hdMode, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> amfmControlSetHdModeAsync(const OrinocoTunerTypes::AmFmHdMode &_hdMode, AmfmControlSetHdModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Set the desired service following at the FollowingMaster.
    		As result the
     *   attribute "dabControlFollowingSwitch" is updated with the given
     *   handle.
    		Note: This switch only affects DAB/FM linking, DAB/DAB is always on
     */
    virtual void dabControlSetFollowingSwitch(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> dabControlSetFollowingSwitchAsync(const bool &_enable, DabControlSetFollowingSwitchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Request initial information update at startup (stationCurrentStation,
     *   stationStationList) in order to force an "on change" update.
     */
    virtual void forceInformationUpdate(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> forceInformationUpdateAsync(ForceInformationUpdateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
};

} // namespace tuner
} // namespace harman
} // namespace com
} // namespace v1


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_TUNER_Orinoco_Tuner_PROXY_BASE_HPP_
