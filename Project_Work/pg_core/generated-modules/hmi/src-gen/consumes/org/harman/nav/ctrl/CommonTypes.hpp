/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
#ifndef ORG_HARMAN_NAV_CTRL_Common_Types_HPP_
#define ORG_HARMAN_NAV_CTRL_Common_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/ByteBuffer.hpp>
#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace harman {
namespace nav {
namespace ctrl {

struct CommonTypes {
    /**
     * description: version.
     */
    struct Version : CommonAPI::Struct<uint16_t, uint16_t, uint16_t, std::string> {
    	
    	Version() {
    	}
    	Version(const uint16_t &_versionMajor, const uint16_t &_versionMinor, const uint16_t &_versionMicro, const std::string &_date)
    	{
    		std::get<0>(values_) = _versionMajor;
    		std::get<1>(values_) = _versionMinor;
    		std::get<2>(values_) = _versionMicro;
    		std::get<3>(values_) = _date;
    	}
    	/**
    	 * description: when the major changes, then backward compatibility with previous releases is
    	 *   not granted.
    	 */
    	inline const uint16_t &getVersionMajor() const { return std::get<0>(values_); }
    	inline void setVersionMajor(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: when the minor changes, then backward compatibility with previous releases is
    	 *   granted, but something changed in the implementation of the API (e.g. new
    	 *   methods may have been added).
    	 */
    	inline const uint16_t &getVersionMinor() const { return std::get<1>(values_); }
    	inline void setVersionMinor(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: when the micro changes, then backward compatibility with previous releases is
    	 *   granted (bug fixes or documentation modifications).
    	 */
    	inline const uint16_t &getVersionMicro() const { return std::get<2>(values_); }
    	inline void setVersionMicro(const uint16_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: release date (e.g. 21-06-2011).
    	 */
    	inline const std::string &getDate() const { return std::get<3>(values_); }
    	inline void setDate(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const Version& _other) const {
                return (getVersionMajor() == _other.getVersionMajor() && getVersionMinor() == _other.getVersionMinor() && getVersionMicro() == _other.getVersionMicro() && getDate() == _other.getDate());
        }
    	inline bool operator!=(const Version &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef uint32_t Handle;
    struct Coordinate2D : CommonAPI::Struct<double, double> {
    	
    	Coordinate2D() {
    	}
    	Coordinate2D(const double &_latitude, const double &_longitude)
    	{
    		std::get<0>(values_) = _latitude;
    		std::get<1>(values_) = _longitude;
    	}
    	inline const double &getLatitude() const { return std::get<0>(values_); }
    	inline void setLatitude(const double &_value) { std::get<0>(values_) = _value; }
    	inline const double &getLongitude() const { return std::get<1>(values_); }
    	inline void setLongitude(const double &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const Coordinate2D& _other) const {
                return (getLatitude() == _other.getLatitude() && getLongitude() == _other.getLongitude());
        }
    	inline bool operator!=(const Coordinate2D &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct Coordinate3D : CommonAPI::Struct<double, double, int32_t> {
    	
    	Coordinate3D() {
    	}
    	Coordinate3D(const double &_latitude, const double &_longitude, const int32_t &_altitude)
    	{
    		std::get<0>(values_) = _latitude;
    		std::get<1>(values_) = _longitude;
    		std::get<2>(values_) = _altitude;
    	}
    	inline const double &getLatitude() const { return std::get<0>(values_); }
    	inline void setLatitude(const double &_value) { std::get<0>(values_) = _value; }
    	inline const double &getLongitude() const { return std::get<1>(values_); }
    	inline void setLongitude(const double &_value) { std::get<1>(values_) = _value; }
    	inline const int32_t &getAltitude() const { return std::get<2>(values_); }
    	inline void setAltitude(const int32_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const Coordinate3D& _other) const {
                return (getLatitude() == _other.getLatitude() && getLongitude() == _other.getLongitude() && getAltitude() == _other.getAltitude());
        }
    	inline bool operator!=(const Coordinate3D &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<CommonTypes::Coordinate2D> Polygon;
    typedef Polygon Area;
    struct Rectangle : CommonAPI::Struct<Coordinate2D, Coordinate2D> {
    	
    	Rectangle() {
    	}
    	Rectangle(const Coordinate2D &_topLeft, const Coordinate2D &_bottomRight)
    	{
    		std::get<0>(values_) = _topLeft;
    		std::get<1>(values_) = _bottomRight;
    	}
    	inline const Coordinate2D &getTopLeft() const { return std::get<0>(values_); }
    	inline void setTopLeft(const Coordinate2D &_value) { std::get<0>(values_) = _value; }
    	inline const Coordinate2D &getBottomRight() const { return std::get<1>(values_); }
    	inline void setBottomRight(const Coordinate2D &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const Rectangle& _other) const {
                return (getTopLeft() == _other.getTopLeft() && getBottomRight() == _other.getBottomRight());
        }
    	inline bool operator!=(const Rectangle &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct BasicEnum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0
        };
        
        BasicEnum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        BasicEnum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const BasicEnum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const BasicEnum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const BasicEnum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const BasicEnum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const BasicEnum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const BasicEnum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef uint64_t Timestamp;
    typedef double Distance;
    typedef CommonAPI::ByteBuffer LinkId;
    /**
     * description: Type to represent distances and lengths. Unit is decimeter (=0.1 m = 10 cm).
     *   This unit was chosen because:
    		- it is small enough to represent "feet"
     *   distances in a unique way (e.g. when distances to maneuver points are
     *   displayed in feet units), and
    		- for smaller units, like cm or mm, the
     *   maximum 32 bit value would be close to possible route lengths (2^32 dm ~
     *   400,000 km, which is 10 times around the world).
    		This type was chosen to be
     *   "unsigned" because no use case with negative distances was found.
     */
    typedef uint32_t TDistance_dm;
    typedef uint32_t TTime_sec;
    struct SIcon : CommonAPI::Struct<int32_t> {
    	
    	SIcon() {
    	}
    	SIcon(const int32_t &_dummy)
    	{
    		std::get<0>(values_) = _dummy;
    	}
    	inline const int32_t &getDummy() const { return std::get<0>(values_); }
    	inline void setDummy(const int32_t &_value) { std::get<0>(values_) = _value; }
    	inline bool operator==(const SIcon& _other) const {
                return (getDummy() == _other.getDummy());
        }
    	inline bool operator!=(const SIcon &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.harman.nav.ctrl.CommonTypes";
    return typeCollectionName;
}


}; // struct CommonTypes

} // namespace ctrl
} // namespace nav
} // namespace harman
} // namespace org

namespace CommonAPI {
}


namespace std {
    //Hash for BasicEnum
    template<>
    struct hash<::org::harman::nav::ctrl::CommonTypes::BasicEnum> {
        inline size_t operator()(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum& basicEnum) const {
            return static_cast<int32_t>(basicEnum);
        }
    };
}



#endif // ORG_HARMAN_NAV_CTRL_Common_Types_HPP_
