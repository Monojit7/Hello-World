/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Tue Jun 21 15:32:43 IST 2016
*/
#ifndef ORG_HARMAN_NAV_CTRL_CONFIGURATION_Configuration_Types_HPP_
#define ORG_HARMAN_NAV_CTRL_CONFIGURATION_Configuration_Types_HPP_


#include <org/harman/nav/ctrl/CommonTypes.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace harman {
namespace nav {
namespace ctrl {
namespace configuration {

struct ConfigurationTypes {
    
    struct GetVersionError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            GET_VERSION_FAILED = 1
        };
        
        GetVersionError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GetVersionError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GetVersionError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::GET_VERSION_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GetVersionError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GetVersionError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GetVersionError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GetVersionError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GetVersionError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GetVersionError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct SetUnitsOfMeasurementError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            SET_UNITS_OF_MEASUREMENTS_FAILED = 1
        };
        
        SetUnitsOfMeasurementError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        SetUnitsOfMeasurementError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        SetUnitsOfMeasurementError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::SET_UNITS_OF_MEASUREMENTS_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SetUnitsOfMeasurementError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SetUnitsOfMeasurementError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SetUnitsOfMeasurementError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SetUnitsOfMeasurementError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SetUnitsOfMeasurementError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SetUnitsOfMeasurementError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GetUnitsOfMeasurementError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            GET_UNITS_OF_MEASUREMENTS_FAILED = 1
        };
        
        GetUnitsOfMeasurementError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GetUnitsOfMeasurementError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GetUnitsOfMeasurementError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::GET_UNITS_OF_MEASUREMENTS_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GetUnitsOfMeasurementError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GetUnitsOfMeasurementError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GetUnitsOfMeasurementError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GetUnitsOfMeasurementError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GetUnitsOfMeasurementError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GetUnitsOfMeasurementError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GetSupportedUnitsOfMeasurementError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            GET_SUPPORTED_UNITS_OF_MEASUREMENTS_FAILED = 1
        };
        
        GetSupportedUnitsOfMeasurementError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GetSupportedUnitsOfMeasurementError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GetSupportedUnitsOfMeasurementError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::GET_SUPPORTED_UNITS_OF_MEASUREMENTS_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GetSupportedUnitsOfMeasurementError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GetSupportedUnitsOfMeasurementError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GetSupportedUnitsOfMeasurementError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GetSupportedUnitsOfMeasurementError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GetSupportedUnitsOfMeasurementError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GetSupportedUnitsOfMeasurementError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct SetTimeFormatError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            SET_TIME_FORMAT_FAILED = 1
        };
        
        SetTimeFormatError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        SetTimeFormatError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        SetTimeFormatError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::SET_TIME_FORMAT_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SetTimeFormatError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SetTimeFormatError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SetTimeFormatError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SetTimeFormatError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SetTimeFormatError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SetTimeFormatError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GetTimeFormatError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            GET_TIME_FORMAT_FAILED = 1
        };
        
        GetTimeFormatError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GetTimeFormatError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GetTimeFormatError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::GET_TIME_FORMAT_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GetTimeFormatError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GetTimeFormatError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GetTimeFormatError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GetTimeFormatError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GetTimeFormatError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GetTimeFormatError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GetSupportedTimeFormatsError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            GET_SUPPORTED_TIME_FORMAT_FAILED = 1
        };
        
        GetSupportedTimeFormatsError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GetSupportedTimeFormatsError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GetSupportedTimeFormatsError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::GET_SUPPORTED_TIME_FORMAT_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GetSupportedTimeFormatsError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GetSupportedTimeFormatsError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GetSupportedTimeFormatsError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GetSupportedTimeFormatsError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GetSupportedTimeFormatsError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GetSupportedTimeFormatsError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct SetCoordinatesFormatError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            SET_COORDINATES_FORMAT_FAILED = 1
        };
        
        SetCoordinatesFormatError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        SetCoordinatesFormatError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        SetCoordinatesFormatError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::SET_COORDINATES_FORMAT_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SetCoordinatesFormatError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SetCoordinatesFormatError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SetCoordinatesFormatError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SetCoordinatesFormatError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SetCoordinatesFormatError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SetCoordinatesFormatError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GetCoordinatesFormatError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            GET_COORDINATES_FORMAT_FAILED = 1
        };
        
        GetCoordinatesFormatError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GetCoordinatesFormatError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GetCoordinatesFormatError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::GET_COORDINATES_FORMAT_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GetCoordinatesFormatError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GetCoordinatesFormatError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GetCoordinatesFormatError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GetCoordinatesFormatError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GetCoordinatesFormatError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GetCoordinatesFormatError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GetSupportedCoordinatesFormatsError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            GET_SUPPORTED_COORDINATES_FORMAT_FAILED = 1
        };
        
        GetSupportedCoordinatesFormatsError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GetSupportedCoordinatesFormatsError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GetSupportedCoordinatesFormatsError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::GET_SUPPORTED_COORDINATES_FORMAT_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GetSupportedCoordinatesFormatsError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GetSupportedCoordinatesFormatsError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GetSupportedCoordinatesFormatsError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GetSupportedCoordinatesFormatsError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GetSupportedCoordinatesFormatsError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GetSupportedCoordinatesFormatsError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct SetLocaleError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            SET_LOCALE_FAILED = 1
        };
        
        SetLocaleError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        SetLocaleError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        SetLocaleError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::SET_LOCALE_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SetLocaleError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SetLocaleError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SetLocaleError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SetLocaleError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SetLocaleError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SetLocaleError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GetLocaleError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            GET_LOCALE_FAILED = 1
        };
        
        GetLocaleError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GetLocaleError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GetLocaleError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::GET_LOCALE_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GetLocaleError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GetLocaleError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GetLocaleError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GetLocaleError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GetLocaleError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GetLocaleError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GetLocalesError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            GET_LOCALES_FAILED = 1
        };
        
        GetLocalesError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GetLocalesError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GetLocalesError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::GET_LOCALES_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GetLocalesError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GetLocalesError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GetLocalesError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GetLocalesError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GetLocalesError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GetLocalesError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct SetStyleThemeError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            SET_STYLE_THEME_FAILED = 1
        };
        
        SetStyleThemeError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        SetStyleThemeError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        SetStyleThemeError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::SET_STYLE_THEME_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SetStyleThemeError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SetStyleThemeError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SetStyleThemeError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SetStyleThemeError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SetStyleThemeError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SetStyleThemeError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GetStyleThemeError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            GET_STYLE_THEME_FAILED = 1
        };
        
        GetStyleThemeError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GetStyleThemeError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GetStyleThemeError &operator=(const ::org::harman::nav::ctrl::CommonTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::GET_STYLE_THEME_FAILED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GetStyleThemeError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GetStyleThemeError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GetStyleThemeError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GetStyleThemeError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GetStyleThemeError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GetStyleThemeError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct UnitOfMeasurementKey : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            LENGTH = 1
        };
        
        UnitOfMeasurementKey() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        UnitOfMeasurementKey(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::LENGTH):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const UnitOfMeasurementKey &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const UnitOfMeasurementKey &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const UnitOfMeasurementKey &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const UnitOfMeasurementKey &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const UnitOfMeasurementKey &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const UnitOfMeasurementKey &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct UnitOfMeasurementValue : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            METER = 1,
            MILE = 2,
            KM = 3,
            YARD = 4,
            FOOT = 5
        };
        
        UnitOfMeasurementValue() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        UnitOfMeasurementValue(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::METER):
                case static_cast<int32_t>(Literal::MILE):
                case static_cast<int32_t>(Literal::KM):
                case static_cast<int32_t>(Literal::YARD):
                case static_cast<int32_t>(Literal::FOOT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const UnitOfMeasurementValue &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const UnitOfMeasurementValue &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const UnitOfMeasurementValue &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const UnitOfMeasurementValue &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const UnitOfMeasurementValue &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const UnitOfMeasurementValue &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct TimeFormat : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            TIME12H = 1,
            TIME24H = 2
        };
        
        TimeFormat() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        TimeFormat(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::TIME12H):
                case static_cast<int32_t>(Literal::TIME24H):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TimeFormat &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TimeFormat &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TimeFormat &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TimeFormat &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TimeFormat &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TimeFormat &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct CoordinatesFormat : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            DEGREES = 1,
            MINUTES = 2,
            SECONDS = 3
        };
        
        CoordinatesFormat() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        CoordinatesFormat(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::DEGREES):
                case static_cast<int32_t>(Literal::MINUTES):
                case static_cast<int32_t>(Literal::SECONDS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const CoordinatesFormat &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const CoordinatesFormat &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const CoordinatesFormat &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const CoordinatesFormat &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const CoordinatesFormat &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const CoordinatesFormat &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct Setting : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            UNITS_OF_MEASUREMENT = 1,
            LOCALE = 2,
            TIME_FORMAT = 3,
            COORDINATES_FORMAT = 4,
            STYLE_THEME = 5
        };
        
        Setting() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        Setting(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::UNITS_OF_MEASUREMENT):
                case static_cast<int32_t>(Literal::LOCALE):
                case static_cast<int32_t>(Literal::TIME_FORMAT):
                case static_cast<int32_t>(Literal::COORDINATES_FORMAT):
                case static_cast<int32_t>(Literal::STYLE_THEME):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Setting &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Setting &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Setting &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Setting &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Setting &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Setting &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct StyleTheme : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            STYLE_DAY = 1,
            STYLE_NIGHT = 2
        };
        
        StyleTheme() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        StyleTheme(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::STYLE_DAY):
                case static_cast<int32_t>(Literal::STYLE_NIGHT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const StyleTheme &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const StyleTheme &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const StyleTheme &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const StyleTheme &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const StyleTheme &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const StyleTheme &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Version info. consists of major, minor, micro and release date.
     */
    struct NavigationVersion : CommonAPI::Struct<uint16_t, uint16_t, uint16_t, std::string> {
    	
    	NavigationVersion() {
    	}
    	NavigationVersion(const uint16_t &_navigationMajor, const uint16_t &_navigationMinor, const uint16_t &_navigationMicro, const std::string &_navigationDate)
    	{
    		std::get<0>(values_) = _navigationMajor;
    		std::get<1>(values_) = _navigationMinor;
    		std::get<2>(values_) = _navigationMicro;
    		std::get<3>(values_) = _navigationDate;
    	}
    	inline const uint16_t &getNavigationMajor() const { return std::get<0>(values_); }
    	inline void setNavigationMajor(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	inline const uint16_t &getNavigationMinor() const { return std::get<1>(values_); }
    	inline void setNavigationMinor(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline const uint16_t &getNavigationMicro() const { return std::get<2>(values_); }
    	inline void setNavigationMicro(const uint16_t &_value) { std::get<2>(values_) = _value; }
    	inline const std::string &getNavigationDate() const { return std::get<3>(values_); }
    	inline void setNavigationDate(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const NavigationVersion& _other) const {
                return (getNavigationMajor() == _other.getNavigationMajor() && getNavigationMinor() == _other.getNavigationMinor() && getNavigationMicro() == _other.getNavigationMicro() && getNavigationDate() == _other.getNavigationDate());
        }
    	inline bool operator!=(const NavigationVersion &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Structure for UnitsOfMeasurement.
     */
    struct UnitOfMeasurement : CommonAPI::Struct<UnitOfMeasurementKey, UnitOfMeasurementValue> {
    	
    	UnitOfMeasurement() {
    	}
    	UnitOfMeasurement(const UnitOfMeasurementKey &_unitOfMeasurementKey, const UnitOfMeasurementValue &_unitOfMeasurementValue)
    	{
    		std::get<0>(values_) = _unitOfMeasurementKey;
    		std::get<1>(values_) = _unitOfMeasurementValue;
    	}
    	inline const UnitOfMeasurementKey &getUnitOfMeasurementKey() const { return std::get<0>(values_); }
    	inline void setUnitOfMeasurementKey(const UnitOfMeasurementKey &_value) { std::get<0>(values_) = _value; }
    	inline const UnitOfMeasurementValue &getUnitOfMeasurementValue() const { return std::get<1>(values_); }
    	inline void setUnitOfMeasurementValue(const UnitOfMeasurementValue &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const UnitOfMeasurement& _other) const {
                return (getUnitOfMeasurementKey() == _other.getUnitOfMeasurementKey() && getUnitOfMeasurementValue() == _other.getUnitOfMeasurementValue());
        }
    	inline bool operator!=(const UnitOfMeasurement &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Locale consists of language and country and script.
     */
    struct Locale : CommonAPI::Struct<std::string, std::string, std::string> {
    	
    	Locale() {
    	}
    	Locale(const std::string &_language, const std::string &_country, const std::string &_scriptCode)
    	{
    		std::get<0>(values_) = _language;
    		std::get<1>(values_) = _country;
    		std::get<2>(values_) = _scriptCode;
    	}
    	/**
    	 * description: languageCode = ISO 639?3 language code (lower case)
    	 */
    	inline const std::string &getLanguage() const { return std::get<0>(values_); }
    	inline void setLanguage(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: countryCode = ISO 3166?1 alpha 3 country code (upper case)
    	 */
    	inline const std::string &getCountry() const { return std::get<1>(values_); }
    	inline void setCountry(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: scriptCode= ISO 15924 alpha 4 script code (upper case)
    	 */
    	inline const std::string &getScriptCode() const { return std::get<2>(values_); }
    	inline void setScriptCode(const std::string &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const Locale& _other) const {
                return (getLanguage() == _other.getLanguage() && getCountry() == _other.getCountry() && getScriptCode() == _other.getScriptCode());
        }
    	inline bool operator!=(const Locale &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: List for Units of measurement.
     */
    typedef std::vector<ConfigurationTypes::UnitOfMeasurement> UnitsOfMeasurement;
    /**
     * description: List for time format.
     */
    typedef std::vector<ConfigurationTypes::TimeFormat> TimeFormats;
    /**
     * description: List for locales.
     */
    typedef std::vector<ConfigurationTypes::Locale> Locales;
    /**
     * description: List for settings.
     */
    typedef std::vector<ConfigurationTypes::Setting> Settings;
    /**
     * description: List for coordinates formats.
     */
    typedef std::vector<ConfigurationTypes::CoordinatesFormat> CoordinatesFormats;



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.harman.nav.ctrl.configuration.ConfigurationTypes";
    return typeCollectionName;
}


}; // struct ConfigurationTypes

} // namespace configuration
} // namespace ctrl
} // namespace nav
} // namespace harman
} // namespace org

namespace CommonAPI {
}


namespace std {
    //Hash for GetVersionError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetVersionError& getVersionError) const {
            return static_cast<int32_t>(getVersionError);
        }
    };
    //Hash for SetUnitsOfMeasurementError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetUnitsOfMeasurementError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetUnitsOfMeasurementError& setUnitsOfMeasurementError) const {
            return static_cast<int32_t>(setUnitsOfMeasurementError);
        }
    };
    //Hash for GetUnitsOfMeasurementError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetUnitsOfMeasurementError& getUnitsOfMeasurementError) const {
            return static_cast<int32_t>(getUnitsOfMeasurementError);
        }
    };
    //Hash for GetSupportedUnitsOfMeasurementError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedUnitsOfMeasurementError& getSupportedUnitsOfMeasurementError) const {
            return static_cast<int32_t>(getSupportedUnitsOfMeasurementError);
        }
    };
    //Hash for SetTimeFormatError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetTimeFormatError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetTimeFormatError& setTimeFormatError) const {
            return static_cast<int32_t>(setTimeFormatError);
        }
    };
    //Hash for GetTimeFormatError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetTimeFormatError& getTimeFormatError) const {
            return static_cast<int32_t>(getTimeFormatError);
        }
    };
    //Hash for GetSupportedTimeFormatsError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedTimeFormatsError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedTimeFormatsError& getSupportedTimeFormatsError) const {
            return static_cast<int32_t>(getSupportedTimeFormatsError);
        }
    };
    //Hash for SetCoordinatesFormatError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetCoordinatesFormatError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetCoordinatesFormatError& setCoordinatesFormatError) const {
            return static_cast<int32_t>(setCoordinatesFormatError);
        }
    };
    //Hash for GetCoordinatesFormatError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetCoordinatesFormatError& getCoordinatesFormatError) const {
            return static_cast<int32_t>(getCoordinatesFormatError);
        }
    };
    //Hash for GetSupportedCoordinatesFormatsError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetSupportedCoordinatesFormatsError& getSupportedCoordinatesFormatsError) const {
            return static_cast<int32_t>(getSupportedCoordinatesFormatsError);
        }
    };
    //Hash for SetLocaleError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetLocaleError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetLocaleError& setLocaleError) const {
            return static_cast<int32_t>(setLocaleError);
        }
    };
    //Hash for GetLocaleError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocaleError& getLocaleError) const {
            return static_cast<int32_t>(getLocaleError);
        }
    };
    //Hash for GetLocalesError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetLocalesError& getLocalesError) const {
            return static_cast<int32_t>(getLocalesError);
        }
    };
    //Hash for SetStyleThemeError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetStyleThemeError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::SetStyleThemeError& setStyleThemeError) const {
            return static_cast<int32_t>(setStyleThemeError);
        }
    };
    //Hash for GetStyleThemeError
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetStyleThemeError> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::GetStyleThemeError& getStyleThemeError) const {
            return static_cast<int32_t>(getStyleThemeError);
        }
    };
    //Hash for UnitOfMeasurementKey
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitOfMeasurementKey> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitOfMeasurementKey& unitOfMeasurementKey) const {
            return static_cast<int32_t>(unitOfMeasurementKey);
        }
    };
    //Hash for UnitOfMeasurementValue
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitOfMeasurementValue> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::UnitOfMeasurementValue& unitOfMeasurementValue) const {
            return static_cast<int32_t>(unitOfMeasurementValue);
        }
    };
    //Hash for TimeFormat
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::TimeFormat& timeFormat) const {
            return static_cast<int32_t>(timeFormat);
        }
    };
    //Hash for CoordinatesFormat
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::CoordinatesFormat& coordinatesFormat) const {
            return static_cast<int32_t>(coordinatesFormat);
        }
    };
    //Hash for Setting
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::Setting> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::Setting& setting) const {
            return static_cast<int32_t>(setting);
        }
    };
    //Hash for StyleTheme
    template<>
    struct hash<::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme> {
        inline size_t operator()(const ::org::harman::nav::ctrl::configuration::ConfigurationTypes::StyleTheme& styleTheme) const {
            return static_cast<int32_t>(styleTheme);
        }
    };
}



#endif // ORG_HARMAN_NAV_CTRL_CONFIGURATION_Configuration_Types_HPP_
