/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Wed Oct 26 18:16:09 IST 2016
*/
/**
 * description: Device Manager interfaces provide device detection control
	and get device
 *   informations.
 * author: ydou
 */
#ifndef V1_COM_HARMAN_MEDIA_Device_Manager_PROXY_HPP_
#define V1_COM_HARMAN_MEDIA_Device_Manager_PROXY_HPP_

#include <v1/com/harman/media/DeviceManagerProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace media {

template <typename ... _AttributeExtensions>
class DeviceManagerProxy
    : virtual public DeviceManager, 
      virtual public DeviceManagerProxyBase,
      virtual public _AttributeExtensions... {
public:
    DeviceManagerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~DeviceManagerProxy();

    typedef DeviceManager InterfaceType;



    /**
     * description: Emit an event to Top when insert or remove a device.
     * author: ydou
     */
    /**
     * Returns the wrapper class that provides access to the broadcast onMediumChanged.
     */
    virtual OnMediumChangedEvent& getOnMediumChangedEvent() {
        return delegate_->getOnMediumChangedEvent();
    }
    /**
     * description: Emit an event to show the sync progress of a device.
            	mediumId: the
     *   unique device id.
            	progress: the sync progress.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast syncProgress.
     */
    virtual SyncProgressEvent& getSyncProgressEvent() {
        return delegate_->getSyncProgressEvent();
    }
    /**
     * description: Emit an event to show the device error.
            	mediumId: the unique device
     *   id.
            	e: error code.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast deviceError.
     */
    virtual DeviceErrorEvent& getDeviceErrorEvent() {
        return delegate_->getDeviceErrorEvent();
    }

    /**
     * description: Trigger the Device Manager to init & work for device detection.
     * author: ydou
     * Calls startDeviceDetection with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startDeviceDetection(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tBaseError &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startDeviceDetection with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startDeviceDetectionAsync(StartDeviceDetectionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Get the current connecting devices to Top with the detail information.
     * author: ydou
     * Calls getDevices with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getDevices(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tBaseError &_error, ::v1::com::harman::media::BaseType::tMediumInfoList &_mediumList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getDevices with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getDevicesAsync(GetDevicesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: allocate a shadow device
    					   onMediumChanged broadcast will be emitted if
     *   allocate success.
    			mediumId: device id which connectted to the
     *   target.
    			type: must be 'MT_SHADOW' for allocating a shadow device.
    			name:
     *   the name for the allocated device.
     * Calls allocateDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void allocateDevice(const uint32_t &_mediumId, const ::v1::com::harman::media::BaseType::tMediumType &_type, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls allocateDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> allocateDeviceAsync(const uint32_t &_mediumId, const ::v1::com::harman::media::BaseType::tMediumType &_type, const std::string &_name, AllocateDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: free a shadow device which allocated with allocateDevice
     *   interface.
    			onMediumChanged broadcast will be emitted if free
     *   success.
    
    			mediumId: device id which connectted to the target.
    			handleId:
     *   shadow device handle.
     * Calls freeDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void freeDevice(const uint32_t &_mediumId, const uint32_t &_handleId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls freeDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> freeDeviceAsync(const uint32_t &_mediumId, const uint32_t &_handleId, FreeDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: get device items information.
    
    			mediumId: device id which connectted to the
     *   target.
    			itemsInfo: imtes information will be returned.
    			e: error code.
     * Calls getDeviceItemsInfo with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getDeviceItemsInfo(const uint32_t &_meidumId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tItemsInfo &_itemsInfo, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getDeviceItemsInfo with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getDeviceItemsInfoAsync(const uint32_t &_meidumId, GetDeviceItemsInfoAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: get device firmware information.
    
    			mediumId: device id which connectted to
     *   the target.
    			fmInfo: firmware information will be returned.
    			e: error code.
     * Calls getDeviceFirmwareInfo with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getDeviceFirmwareInfo(const uint32_t &_meidumId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tFirmwareInfo &_fmInfo, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getDeviceFirmwareInfo with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getDeviceFirmwareInfoAsync(const uint32_t &_meidumId, GetDeviceFirmwareInfoAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: get device hardware information.
    
    			mediumId: device id which connectted to
     *   the target.
    			hwInfo: hardware information will be returned.
    			e: error code.
     * Calls getDeviceHarwareInfo with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getDeviceHarwareInfo(const uint32_t &_meidumId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tHardwareInfo &_hwInfo, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getDeviceHarwareInfo with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getDeviceHarwareInfoAsync(const uint32_t &_meidumId, GetDeviceHarwareInfoAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: get the remote player capability for BT device.
    
    			mediumId: device id which
     *   connectted to the target.
    			caps: remote player capabilities.
    			e: error
     *   code.
     * Calls getRemotePlayerCapability with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getRemotePlayerCapability(const uint32_t &_mediumId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tRemotePlayerCapability &_caps, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRemotePlayerCapability with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getRemotePlayerCapabilityAsync(const uint32_t &_mediumId, GetRemotePlayerCapabilityAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<DeviceManagerProxyBase> delegate_;
};

typedef DeviceManagerProxy<> DeviceManagerProxyDefault;


//
// DeviceManagerProxy Implementation
//
template <typename ... _AttributeExtensions>
DeviceManagerProxy<_AttributeExtensions...>::DeviceManagerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<DeviceManagerProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<DeviceManagerProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
DeviceManagerProxy<_AttributeExtensions...>::~DeviceManagerProxy() {
}

/**
 * description: Trigger the Device Manager to init & work for device detection.
 * author: ydou
 */
template <typename ... _AttributeExtensions>
void DeviceManagerProxy<_AttributeExtensions...>::startDeviceDetection(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tBaseError &_error, const CommonAPI::CallInfo *_info) {
    delegate_->startDeviceDetection(_internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DeviceManagerProxy<_AttributeExtensions...>::startDeviceDetectionAsync(StartDeviceDetectionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startDeviceDetectionAsync(_callback, _info);
}
/**
 * description: Get the current connecting devices to Top with the detail information.
 * author: ydou
 */
template <typename ... _AttributeExtensions>
void DeviceManagerProxy<_AttributeExtensions...>::getDevices(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tBaseError &_error, ::v1::com::harman::media::BaseType::tMediumInfoList &_mediumList, const CommonAPI::CallInfo *_info) {
    delegate_->getDevices(_internalCallStatus, _error, _mediumList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DeviceManagerProxy<_AttributeExtensions...>::getDevicesAsync(GetDevicesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getDevicesAsync(_callback, _info);
}
/**
 * description: allocate a shadow device
					   onMediumChanged broadcast will be emitted if
 *   allocate success.
			mediumId: device id which connectted to the
 *   target.
			type: must be 'MT_SHADOW' for allocating a shadow device.
			name:
 *   the name for the allocated device.
 */
template <typename ... _AttributeExtensions>
void DeviceManagerProxy<_AttributeExtensions...>::allocateDevice(const uint32_t &_mediumId, const ::v1::com::harman::media::BaseType::tMediumType &_type, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info) {
    if (!_type.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->allocateDevice(_mediumId, _type, _name, _internalCallStatus, _e, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DeviceManagerProxy<_AttributeExtensions...>::allocateDeviceAsync(const uint32_t &_mediumId, const ::v1::com::harman::media::BaseType::tMediumType &_type, const std::string &_name, AllocateDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_type.validate()) {
        ::v1::com::harman::media::BaseType::tBaseError e = ::v1::com::harman::media::BaseType::tBaseError::S_OK;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, e);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->allocateDeviceAsync(_mediumId, _type, _name, _callback, _info);
}
/**
 * description: free a shadow device which allocated with allocateDevice
 *   interface.
			onMediumChanged broadcast will be emitted if free
 *   success.

			mediumId: device id which connectted to the target.
			handleId:
 *   shadow device handle.
 */
template <typename ... _AttributeExtensions>
void DeviceManagerProxy<_AttributeExtensions...>::freeDevice(const uint32_t &_mediumId, const uint32_t &_handleId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info) {
    delegate_->freeDevice(_mediumId, _handleId, _internalCallStatus, _e, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DeviceManagerProxy<_AttributeExtensions...>::freeDeviceAsync(const uint32_t &_mediumId, const uint32_t &_handleId, FreeDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->freeDeviceAsync(_mediumId, _handleId, _callback, _info);
}
/**
 * description: get device items information.

			mediumId: device id which connectted to the
 *   target.
			itemsInfo: imtes information will be returned.
			e: error code.
 */
template <typename ... _AttributeExtensions>
void DeviceManagerProxy<_AttributeExtensions...>::getDeviceItemsInfo(const uint32_t &_meidumId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tItemsInfo &_itemsInfo, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info) {
    delegate_->getDeviceItemsInfo(_meidumId, _internalCallStatus, _itemsInfo, _e, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DeviceManagerProxy<_AttributeExtensions...>::getDeviceItemsInfoAsync(const uint32_t &_meidumId, GetDeviceItemsInfoAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getDeviceItemsInfoAsync(_meidumId, _callback, _info);
}
/**
 * description: get device firmware information.

			mediumId: device id which connectted to
 *   the target.
			fmInfo: firmware information will be returned.
			e: error code.
 */
template <typename ... _AttributeExtensions>
void DeviceManagerProxy<_AttributeExtensions...>::getDeviceFirmwareInfo(const uint32_t &_meidumId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tFirmwareInfo &_fmInfo, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info) {
    delegate_->getDeviceFirmwareInfo(_meidumId, _internalCallStatus, _fmInfo, _e, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DeviceManagerProxy<_AttributeExtensions...>::getDeviceFirmwareInfoAsync(const uint32_t &_meidumId, GetDeviceFirmwareInfoAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getDeviceFirmwareInfoAsync(_meidumId, _callback, _info);
}
/**
 * description: get device hardware information.

			mediumId: device id which connectted to
 *   the target.
			hwInfo: hardware information will be returned.
			e: error code.
 */
template <typename ... _AttributeExtensions>
void DeviceManagerProxy<_AttributeExtensions...>::getDeviceHarwareInfo(const uint32_t &_meidumId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tHardwareInfo &_hwInfo, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info) {
    delegate_->getDeviceHarwareInfo(_meidumId, _internalCallStatus, _hwInfo, _e, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DeviceManagerProxy<_AttributeExtensions...>::getDeviceHarwareInfoAsync(const uint32_t &_meidumId, GetDeviceHarwareInfoAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getDeviceHarwareInfoAsync(_meidumId, _callback, _info);
}
/**
 * description: get the remote player capability for BT device.

			mediumId: device id which
 *   connectted to the target.
			caps: remote player capabilities.
			e: error
 *   code.
 */
template <typename ... _AttributeExtensions>
void DeviceManagerProxy<_AttributeExtensions...>::getRemotePlayerCapability(const uint32_t &_mediumId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::media::BaseType::tRemotePlayerCapability &_caps, ::v1::com::harman::media::BaseType::tBaseError &_e, const CommonAPI::CallInfo *_info) {
    delegate_->getRemotePlayerCapability(_mediumId, _internalCallStatus, _caps, _e, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> DeviceManagerProxy<_AttributeExtensions...>::getRemotePlayerCapabilityAsync(const uint32_t &_mediumId, GetRemotePlayerCapabilityAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getRemotePlayerCapabilityAsync(_mediumId, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &DeviceManagerProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool DeviceManagerProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool DeviceManagerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& DeviceManagerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& DeviceManagerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace media
} // namespace harman
} // namespace com
} // namespace v1



// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_MEDIA_Device_Manager_PROXY_HPP_
