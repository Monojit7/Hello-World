/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Wed Oct 26 18:16:09 IST 2016
*/
#include <v3/org/genivi/am/routinginterface/RoutingControlObserverStubDefault.hpp>
#include <assert.h>

namespace v3 {
namespace org {
namespace genivi {
namespace am {
namespace routinginterface {

RoutingControlObserverStubDefault::RoutingControlObserverStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(RoutingControlObserver::getInterfaceVersion()) {
}

const CommonAPI::Version& RoutingControlObserverStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

RoutingControlObserverStubRemoteEvent* RoutingControlObserverStubDefault::initStubAdapter(const std::shared_ptr<RoutingControlObserverStubAdapter> &_adapter) {
    CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}

const ::v3::org::genivi::am_t::am_RoutingReady_e& RoutingControlObserverStubDefault::getRoutingReadyAttribute() {
    return routingReadyAttributeValue_;
}

const ::v3::org::genivi::am_t::am_RoutingReady_e& RoutingControlObserverStubDefault::getRoutingReadyAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getRoutingReadyAttribute();
}

void RoutingControlObserverStubDefault::setRoutingReadyAttribute(::v3::org::genivi::am_t::am_RoutingReady_e _value) {
    const bool valueChanged = trySetRoutingReadyAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<RoutingControlObserverStubAdapter, RoutingControlObserverStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireRoutingReadyAttributeChanged(routingReadyAttributeValue_);
    }
}

bool RoutingControlObserverStubDefault::trySetRoutingReadyAttribute(::v3::org::genivi::am_t::am_RoutingReady_e _value) {
    if (!validateRoutingReadyAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (routingReadyAttributeValue_ != _value);
    routingReadyAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool RoutingControlObserverStubDefault::validateRoutingReadyAttributeRequestedValue(const ::v3::org::genivi::am_t::am_RoutingReady_e &_value) {
    (void)_value;
	return _value.validate();
}



/**
 * description: Registers a domain.
(at)return E_OK on success, E_ALREADY_EXISTENT if already
 *   registered E_UNKNOWN on error
 */
void RoutingControlObserverStubDefault::registerDomain(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_Domain_s _domainData, std::string _returnBusname, std::string _returnInterface, registerDomainReply_t _reply) {
    (void)_client;
    (void) _domainData;
    (void) _returnBusname;
    (void) _returnInterface;
    ::v3::org::genivi::am_t::am_domainID_t domainID = 0u;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(domainID, amError);
}

/**
 * description: Deregisters a domain. All sources, sinks, gateways and crossfaders from that
 *   domain will be removed as well.
(at)return E_OK on success, E_NON_EXISTENT if
 *   not found E_UNKNOWN on error
 */
void RoutingControlObserverStubDefault::deregisterDomain(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_domainID_t _domainID, deregisterDomainReply_t _reply) {
    (void)_client;
    (void) _domainID;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(amError);
}

/**
 * description: This function returns the ID to the given domain name. If already a domain is
 *   registered with this name, it will return the corresponding ID, if not it will
 *   reserve an ID but not register the domain. The other parameters of the domain
 *   will be overwritten when the domain is registered.
(at)return E_OK on success,
 *   E_UNKNOWN on error
    please use pulseAudio as the name to peek domainID. now
 *   all the sources and sinks are defined in domain pulseAudio.
 */
void RoutingControlObserverStubDefault::peekDomain(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _name, peekDomainReply_t _reply) {
    (void)_client;
    (void) _name;
    ::v3::org::genivi::am_t::am_domainID_t domainID = 0u;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(domainID, amError);
}

/**
 * description: Registers a sink. If the sink is part of a gateway, the list connection formats
 *   are copied to the gateway information
(at)return E_OK on success,
 *   E_ALREADY_EXISTENT if already registered E_UNKNOWN on error
 */
void RoutingControlObserverStubDefault::registerSink(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_Sink_s _sinkData, registerSinkReply_t _reply) {
    (void)_client;
    (void) _sinkData;
    ::v3::org::genivi::am_t::am_sinkID_t sinkID = 0u;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(sinkID, amError);
}

/**
 * description: Deregisters a sink.
(at)return E_OK on success, E_NON_EXISTENT if not found
 *   E_UNKNOWN on error
 */
void RoutingControlObserverStubDefault::deregisterSink(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sinkID_t _sinkID, deregisterSinkReply_t _reply) {
    (void)_client;
    (void) _sinkID;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(amError);
}

/**
 * description: This function returns the ID to the given sink name. If already a sink is
 *   registered with this name, it will return the corresponding ID, if not it will
 *   reserve an ID but not register the sink. The other parameters of the sink will
 *   be overwritten when the sink is registered.
(at)return E_OK on success,
 *   E_UNKNOWN on error
 */
void RoutingControlObserverStubDefault::peekSink(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _name, peekSinkReply_t _reply) {
    (void)_client;
    (void) _name;
    ::v3::org::genivi::am_t::am_sinkID_t sinkID = 0u;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(sinkID, amError);
}

/**
 * description: This function peeks a sink class ID. It is used by the RoutingPlugins to
 *   determine the sink class IDs of a sink class.
(at)return E_OK on success,
 *   E_DATABASE_ERROR on error
 */
void RoutingControlObserverStubDefault::peekSinkClassID(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _name, peekSinkClassIDReply_t _reply) {
    (void)_client;
    (void) _name;
    ::v3::org::genivi::am_t::am_sinkClass_t sinkClassID = 0u;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(sinkClassID, amError);
}

/**
 * description: Updates data of a sink.
(at)return E_OK on success, E_NON_EXISTENT if the sink
 *   ID is not valid.
 */
void RoutingControlObserverStubDefault::updateSink(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sinkID_t _sinkID, ::v3::org::genivi::am_t::am_sinkClass_t _sinkClassID, ::v3::org::genivi::am_t::am_SoundProperty_L _listSoundProperties, ::v3::org::genivi::am_t::am_ConnectionFormat_L _listConnectionFormats, ::v3::org::genivi::am_t::am_MainSoundProperty_L _listMainSoundProperties, updateSinkReply_t _reply) {
    (void)_client;
    (void) _sinkID;
    (void) _sinkClassID;
    (void) _listSoundProperties;
    (void) _listConnectionFormats;
    (void) _listMainSoundProperties;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(amError);
}

/**
 * description: Registers a source.  If the source is part of a gateway, the list connection
 *   formats are copied to the gateway information
(at)return E_OK on success,
 *   E_UNKNOWN on error, E_ALREADY_EXIST if either name or source ID already exists
 */
void RoutingControlObserverStubDefault::registerSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_Source_s _sourceData, registerSourceReply_t _reply) {
    (void)_client;
    (void) _sourceData;
    ::v3::org::genivi::am_t::am_sourceID_t sourceID = 0u;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(sourceID, amError);
}

/**
 * description: Deregisters a source.
(at)return E_OK on success, E_NON_EXISTENT if not found
 *   E_UNKNOWN on error
 */
void RoutingControlObserverStubDefault::deregisterSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sourceID_t _sourceID, deregisterSourceReply_t _reply) {
    (void)_client;
    (void) _sourceID;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(amError);
}

/**
 * description: This function returns the ID to the given source name. If already a source is
 *   registered with this name, it will return the corresponding ID, if not it will
 *   reserve an ID but not register the source. The other parameters of the source
 *   will be overwritten when the source is registered.
(at)return E_OK on success,
 *   E_UNKNOWN on error
 */
void RoutingControlObserverStubDefault::peekSource(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _name, peekSourceReply_t _reply) {
    (void)_client;
    (void) _name;
    ::v3::org::genivi::am_t::am_sourceID_t sourceID = 0u;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(sourceID, amError);
}

/**
 * description: Peeks a source class ID. It is used by the RoutingPlugins to determine the
 *   source class IDs of a source class.
(at)return E_OK on success,
 *   E_DATABASE_ERROR on error
 */
void RoutingControlObserverStubDefault::peekSourceClassID(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _name, peekSourceClassIDReply_t _reply) {
    (void)_client;
    (void) _name;
    ::v3::org::genivi::am_t::am_sourceClass_t sourceClassID = 0u;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(sourceClassID, amError);
}

/**
 * description: Updates data of a source.
(at)return E_OK on success, E_NON_EXISTENT if the
 *   source ID in the struct is not valid. 
Please note that only the following
 *   data out of am_Source_s have effect when they are
 *   changed:
sourceClassID,
listSoundProperties,
listConnectionFormats,
listMainSou
 *  ndProperties
 */
void RoutingControlObserverStubDefault::updateSource(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sourceID_t _sourceID, ::v3::org::genivi::am_t::am_sourceClass_t _sourceClassID, ::v3::org::genivi::am_t::am_SoundProperty_L _listSoundProperties, ::v3::org::genivi::am_t::am_ConnectionFormat_L _listConnectionFormats, ::v3::org::genivi::am_t::am_MainSoundProperty_L _listMainSoundProperties, updateSourceReply_t _reply) {
    (void)_client;
    (void) _sourceID;
    (void) _sourceClassID;
    (void) _listSoundProperties;
    (void) _listConnectionFormats;
    (void) _listMainSoundProperties;
    ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!amError.validate()) {
        return;
    }
    _reply(amError);
}

/**
 * description: Is called when a low level interrupt changes it status.
 */
void RoutingControlObserverStubDefault::hookInterruptStatusChange(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sourceID_t _sourceID, ::v3::org::genivi::am_t::am_InterruptState_e _interruptState, hookInterruptStatusChangeReply_t _reply) {
    (void)_client;
    (void) _sourceID;
    (void) _interruptState;
    _reply();
}

/**
 * description: This hook is called when all elements from a domain are registered.
Is used by
 *   the Controller to know when all expected domains are finally registered.
 */
void RoutingControlObserverStubDefault::hookDomainRegistrationComplete(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_domainID_t _domainID, hookDomainRegistrationCompleteReply_t _reply) {
    (void)_client;
    (void) _domainID;
    _reply();
}

/**
 * description: Is called when a sink changes its availability.
 */
void RoutingControlObserverStubDefault::hookSinkAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sinkID_t _sinkID, ::v3::org::genivi::am_t::am_Availability_s _availability, hookSinkAvailablityStatusChangeReply_t _reply) {
    (void)_client;
    (void) _sinkID;
    (void) _availability;
    _reply();
}

/**
 * description: Is called when a source changes its availability.
 */
void RoutingControlObserverStubDefault::hookSourceAvailablityStatusChange(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_sourceID_t _sourceID, ::v3::org::genivi::am_t::am_Availability_s _availability, hookSourceAvailablityStatusChangeReply_t _reply) {
    (void)_client;
    (void) _sourceID;
    (void) _availability;
    _reply();
}

/**
 * description: Is called when a domain changes its status. This used for early domains only.
 */
void RoutingControlObserverStubDefault::hookDomainStateChange(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_domainID_t _domainID, ::v3::org::genivi::am_t::am_DomainState_e _domainState, hookDomainStateChangeReply_t _reply) {
    (void)_client;
    (void) _domainID;
    (void) _domainState;
    _reply();
}

/**
 * description: This function is used to send out all data that has been changed in an early
 *   state.
 */
void RoutingControlObserverStubDefault::sendChangedData(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_EarlyData_L _earlyData, sendChangedDataReply_t _reply) {
    (void)_client;
    (void) _earlyData;
    _reply();
}

/**
 * description: This function send parameters of limiter. If there is no error it will return
 *   0. If not it will return -1.
 */
void RoutingControlObserverStubDefault::sendLimiter(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_limiterStruct_param _limiter, sendLimiterReply_t _reply) {
    (void)_client;
    (void) _limiter;
    ::v3::org::genivi::am_t::am_Error_e hqError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!hqError.validate()) {
        return;
    }
    _reply(hqError);
}

/**
 * description: This function send parameters of EQ filter. If there is no error it will return
 *   0. If not it will return -1.
 */
void RoutingControlObserverStubDefault::sendEQFilter(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_eqFilterStruct_param _bsFilter, sendEQFilterReply_t _reply) {
    (void)_client;
    (void) _bsFilter;
    ::v3::org::genivi::am_t::am_Error_e qhError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!qhError.validate()) {
        return;
    }
    _reply(qhError);
}

/**
 * description: This function send parameters of delay time. If there is no error it will
 *   return 0. If not it will return -1.
 */
void RoutingControlObserverStubDefault::sendDelayTime(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_delayTimeStruct_param _delayTime, sendDelayTimeReply_t _reply) {
    (void)_client;
    (void) _delayTime;
    ::v3::org::genivi::am_t::am_Error_e qhError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!qhError.validate()) {
        return;
    }
    _reply(qhError);
}

/**
 * description: This function send parameters of loudness. If there is no error it will return
 *   0. If not it will return -1.
 */
void RoutingControlObserverStubDefault::sendLoudness(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_londnessStruct_param _bs, sendLoudnessReply_t _reply) {
    (void)_client;
    (void) _bs;
    ::v3::org::genivi::am_t::am_Error_e qhError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!qhError.validate()) {
        return;
    }
    _reply(qhError);
}

/**
 * description: This function send parameters of channel gain. If there is no error it will
 *   return 0. If not it will return -1.
 */
void RoutingControlObserverStubDefault::sendChannelGain(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_channelGainStruct_param _bs, sendChannelGainReply_t _reply) {
    (void)_client;
    (void) _bs;
    ::v3::org::genivi::am_t::am_Error_e qhError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!qhError.validate()) {
        return;
    }
    _reply(qhError);
}

/**
 * description: This function send parameters of maximum volume of source. If there is no error
 *   it will return 0. If not it will return -1.
 */
void RoutingControlObserverStubDefault::sendVolumeMax(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_sourceID_t _sourceID, ::v3::org::genivi::am_t::hq_volume_t _volume, sendVolumeMaxReply_t _reply) {
    (void)_client;
    (void) _sourceID;
    (void) _volume;
    ::v3::org::genivi::am_t::am_Error_e qhError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!qhError.validate()) {
        return;
    }
    _reply(qhError);
}

/**
 * description: This function send parameters of minimum volume of source. If there is no error
 *   it will return 0. If not it will return -1.
 */
void RoutingControlObserverStubDefault::sendVolumeMin(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_sourceID_t _sourceID, ::v3::org::genivi::am_t::hq_volume_t _volume, sendVolumeMinReply_t _reply) {
    (void)_client;
    (void) _sourceID;
    (void) _volume;
    ::v3::org::genivi::am_t::am_Error_e qhError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!qhError.validate()) {
        return;
    }
    _reply(qhError);
}

/**
 * description: This function send parameters of absolute volume of source. If there is no
 *   error it will return 0. If not it will return -1.
 */
void RoutingControlObserverStubDefault::sendVolumeAbs(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_sourceID_t _sourceID, ::v3::org::genivi::am_t::hq_volume_t _volume, sendVolumeAbsReply_t _reply) {
    (void)_client;
    (void) _sourceID;
    (void) _volume;
    ::v3::org::genivi::am_t::am_Error_e qhError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!qhError.validate()) {
        return;
    }
    _reply(qhError);
}

/**
 * description: This function send parameters of ratio volume of source. If there is no error
 *   it will return 0. If not it will return -1.
 */
void RoutingControlObserverStubDefault::sendVolumeRatio(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::hq_sourceID_t _sourceID, ::v3::org::genivi::am_t::hq_volume_t _volume, sendVolumeRatioReply_t _reply) {
    (void)_client;
    (void) _sourceID;
    (void) _volume;
    ::v3::org::genivi::am_t::am_Error_e qhError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
    if (!qhError.validate()) {
        return;
    }
    _reply(qhError);
}




RoutingControlObserverStubDefault::RemoteEventHandler::RemoteEventHandler(RoutingControlObserverStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace routinginterface
} // namespace am
} // namespace genivi
} // namespace org
} // namespace v3
