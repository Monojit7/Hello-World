/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Thu Sep 22 00:23:23 IST 2016
*/
#include <v1/com/harman/btpres/CallManagerStubDefault.hpp>
#include <assert.h>

namespace v1 {
namespace com {
namespace harman {
namespace btpres {

CallManagerStubDefault::CallManagerStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(CallManager::getInterfaceVersion()) {
}

const CommonAPI::Version& CallManagerStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

CallManagerStubRemoteEvent* CallManagerStubDefault::initStubAdapter(const std::shared_ptr<CallManagerStubAdapter> &_adapter) {
    CommonAPI::Stub<CallManagerStubAdapter, CallManagerStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}

const ::v1::com::harman::btpres::BTPresTypes::hfpSupportedFeaturesList& CallManagerStubDefault::getHfFeaturesListAttribute() {
    return hfFeaturesListAttributeValue_;
}

const ::v1::com::harman::btpres::BTPresTypes::hfpSupportedFeaturesList& CallManagerStubDefault::getHfFeaturesListAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getHfFeaturesListAttribute();
}

void CallManagerStubDefault::setHfFeaturesListAttribute(::v1::com::harman::btpres::BTPresTypes::hfpSupportedFeaturesList _value) {
    const bool valueChanged = trySetHfFeaturesListAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<CallManagerStubAdapter, CallManagerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireHfFeaturesListAttributeChanged(hfFeaturesListAttributeValue_);
    }
}

bool CallManagerStubDefault::trySetHfFeaturesListAttribute(::v1::com::harman::btpres::BTPresTypes::hfpSupportedFeaturesList _value) {
    if (!validateHfFeaturesListAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (hfFeaturesListAttributeValue_ != _value);
    hfFeaturesListAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool CallManagerStubDefault::validateHfFeaturesListAttributeRequestedValue(const ::v1::com::harman::btpres::BTPresTypes::hfpSupportedFeaturesList &_value) {
    (void)_value;
	return true;
}


const ::v1::com::harman::btpres::BTPresTypes::networkOperatorInfoList& CallManagerStubDefault::getOperatorInfoListAttribute() {
    return operatorInfoListAttributeValue_;
}

const ::v1::com::harman::btpres::BTPresTypes::networkOperatorInfoList& CallManagerStubDefault::getOperatorInfoListAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getOperatorInfoListAttribute();
}

void CallManagerStubDefault::setOperatorInfoListAttribute(::v1::com::harman::btpres::BTPresTypes::networkOperatorInfoList _value) {
    const bool valueChanged = trySetOperatorInfoListAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<CallManagerStubAdapter, CallManagerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireOperatorInfoListAttributeChanged(operatorInfoListAttributeValue_);
    }
}

bool CallManagerStubDefault::trySetOperatorInfoListAttribute(::v1::com::harman::btpres::BTPresTypes::networkOperatorInfoList _value) {
    if (!validateOperatorInfoListAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (operatorInfoListAttributeValue_ != _value);
    operatorInfoListAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool CallManagerStubDefault::validateOperatorInfoListAttributeRequestedValue(const ::v1::com::harman::btpres::BTPresTypes::networkOperatorInfoList &_value) {
    (void)_value;
	return true;
}


const ::v1::com::harman::btpres::BTPresTypes::signalChargeInfoList& CallManagerStubDefault::getRssiChargeInfoListAttribute() {
    return rssiChargeInfoListAttributeValue_;
}

const ::v1::com::harman::btpres::BTPresTypes::signalChargeInfoList& CallManagerStubDefault::getRssiChargeInfoListAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getRssiChargeInfoListAttribute();
}

void CallManagerStubDefault::setRssiChargeInfoListAttribute(::v1::com::harman::btpres::BTPresTypes::signalChargeInfoList _value) {
    const bool valueChanged = trySetRssiChargeInfoListAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<CallManagerStubAdapter, CallManagerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireRssiChargeInfoListAttributeChanged(rssiChargeInfoListAttributeValue_);
    }
}

bool CallManagerStubDefault::trySetRssiChargeInfoListAttribute(::v1::com::harman::btpres::BTPresTypes::signalChargeInfoList _value) {
    if (!validateRssiChargeInfoListAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (rssiChargeInfoListAttributeValue_ != _value);
    rssiChargeInfoListAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool CallManagerStubDefault::validateRssiChargeInfoListAttributeRequestedValue(const ::v1::com::harman::btpres::BTPresTypes::signalChargeInfoList &_value) {
    (void)_value;
	return true;
}


const ::v1::com::harman::btpres::BTPresTypes::callstateInfoList& CallManagerStubDefault::getCallStateInfoAttribute() {
    return callStateInfoAttributeValue_;
}

const ::v1::com::harman::btpres::BTPresTypes::callstateInfoList& CallManagerStubDefault::getCallStateInfoAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getCallStateInfoAttribute();
}

void CallManagerStubDefault::setCallStateInfoAttribute(::v1::com::harman::btpres::BTPresTypes::callstateInfoList _value) {
    const bool valueChanged = trySetCallStateInfoAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<CallManagerStubAdapter, CallManagerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireCallStateInfoAttributeChanged(callStateInfoAttributeValue_);
    }
}

bool CallManagerStubDefault::trySetCallStateInfoAttribute(::v1::com::harman::btpres::BTPresTypes::callstateInfoList _value) {
    if (!validateCallStateInfoAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (callStateInfoAttributeValue_ != _value);
    callStateInfoAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool CallManagerStubDefault::validateCallStateInfoAttributeRequestedValue(const ::v1::com::harman::btpres::BTPresTypes::callstateInfoList &_value) {
    (void)_value;
	return true;
}


const ::v1::com::harman::btpres::BTPresTypes::hfModeStatusList& CallManagerStubDefault::getHfModeAttribute() {
    return hfModeAttributeValue_;
}

const ::v1::com::harman::btpres::BTPresTypes::hfModeStatusList& CallManagerStubDefault::getHfModeAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getHfModeAttribute();
}

void CallManagerStubDefault::setHfModeAttribute(::v1::com::harman::btpres::BTPresTypes::hfModeStatusList _value) {
    const bool valueChanged = trySetHfModeAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<CallManagerStubAdapter, CallManagerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireHfModeAttributeChanged(hfModeAttributeValue_);
    }
}

bool CallManagerStubDefault::trySetHfModeAttribute(::v1::com::harman::btpres::BTPresTypes::hfModeStatusList _value) {
    if (!validateHfModeAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (hfModeAttributeValue_ != _value);
    hfModeAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool CallManagerStubDefault::validateHfModeAttributeRequestedValue(const ::v1::com::harman::btpres::BTPresTypes::hfModeStatusList &_value) {
    (void)_value;
	return true;
}


const ::v1::com::harman::btpres::BTPresTypes::callDurationList& CallManagerStubDefault::getCallDurationAttribute() {
    return callDurationAttributeValue_;
}

const ::v1::com::harman::btpres::BTPresTypes::callDurationList& CallManagerStubDefault::getCallDurationAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getCallDurationAttribute();
}

void CallManagerStubDefault::setCallDurationAttribute(::v1::com::harman::btpres::BTPresTypes::callDurationList _value) {
    const bool valueChanged = trySetCallDurationAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<CallManagerStubAdapter, CallManagerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireCallDurationAttributeChanged(callDurationAttributeValue_);
    }
}

bool CallManagerStubDefault::trySetCallDurationAttribute(::v1::com::harman::btpres::BTPresTypes::callDurationList _value) {
    if (!validateCallDurationAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (callDurationAttributeValue_ != _value);
    callDurationAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool CallManagerStubDefault::validateCallDurationAttributeRequestedValue(const ::v1::com::harman::btpres::BTPresTypes::callDurationList &_value) {
    (void)_value;
	return true;
}


const ::v1::com::harman::btpres::BTPresTypes::audioStatusList& CallManagerStubDefault::getAudioStatusAttribute() {
    return audioStatusAttributeValue_;
}

const ::v1::com::harman::btpres::BTPresTypes::audioStatusList& CallManagerStubDefault::getAudioStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getAudioStatusAttribute();
}

void CallManagerStubDefault::setAudioStatusAttribute(::v1::com::harman::btpres::BTPresTypes::audioStatusList _value) {
    const bool valueChanged = trySetAudioStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<CallManagerStubAdapter, CallManagerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireAudioStatusAttributeChanged(audioStatusAttributeValue_);
    }
}

bool CallManagerStubDefault::trySetAudioStatusAttribute(::v1::com::harman::btpres::BTPresTypes::audioStatusList _value) {
    if (!validateAudioStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (audioStatusAttributeValue_ != _value);
    audioStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool CallManagerStubDefault::validateAudioStatusAttributeRequestedValue(const ::v1::com::harman::btpres::BTPresTypes::audioStatusList &_value) {
    (void)_value;
	return true;
}


const ::v1::com::harman::btpres::BTPresTypes::vrModeStatusList& CallManagerStubDefault::getVrModeAttribute() {
    return vrModeAttributeValue_;
}

const ::v1::com::harman::btpres::BTPresTypes::vrModeStatusList& CallManagerStubDefault::getVrModeAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getVrModeAttribute();
}

void CallManagerStubDefault::setVrModeAttribute(::v1::com::harman::btpres::BTPresTypes::vrModeStatusList _value) {
    const bool valueChanged = trySetVrModeAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<CallManagerStubAdapter, CallManagerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireVrModeAttributeChanged(vrModeAttributeValue_);
    }
}

bool CallManagerStubDefault::trySetVrModeAttribute(::v1::com::harman::btpres::BTPresTypes::vrModeStatusList _value) {
    if (!validateVrModeAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (vrModeAttributeValue_ != _value);
    vrModeAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool CallManagerStubDefault::validateVrModeAttributeRequestedValue(const ::v1::com::harman::btpres::BTPresTypes::vrModeStatusList &_value) {
    (void)_value;
	return true;
}



/**
 * description: Used to initate call from head unit HMI.
 * param: inAddress (String)    	: BD Address of the device to get the properties
	     
 *   : dialNumber (String)	        : Number to be dialled
	      : contactName
 *   (String)    	: Contact Name if available
	      : imageUrl (String)	        :
 *   Image URL if available
	returns: errorCode (eErrorType)	: API execution output
 */
void CallManagerStubDefault::dial(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, std::string _dialNumber, std::string _contactName, std::string _imageUrl, ::v1::com::harman::btpres::BTPresTypes::eTelType _numType, dialReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _dialNumber;
    (void) _contactName;
    (void) _imageUrl;
    (void) _numType;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Used to send DTMF tone from head unit to phone.
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   dtmfTone (String)	: DTMF tone to be sent
	returns: errorCode (errorCode)	: API
 *   execution ouput
 */
void CallManagerStubDefault::sendDtmfTone(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, std::string _dtmfTone, sendDtmfToneReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _dtmfTone;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Accept incoming call from Head Unit
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   transfer (Boolean)	: Whether the call has to be transferred to Handset mode
 *   upon acceptance
	returns: errorCode (eErrorType): API execution output
 */
void CallManagerStubDefault::acceptIncomingCall(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, bool _transfer, acceptIncomingCallReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _transfer;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: End call for passed call ID
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   callId (Int32)          : Call ID of the phone call to be ended
	returns:
 *   errorCode (eErrorType): API execution output
 */
void CallManagerStubDefault::endCall(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, int8_t _callId, endCallReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _callId;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: End currently active call for a particular device
 * param: inAddress (String)      : BD Address of the device to get the
 *   properties
	returns: errorCode (eErrorType): API execution output
 */
void CallManagerStubDefault::endActiveCall(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, endActiveCallReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Ends all available calls
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
void CallManagerStubDefault::endAllCalls(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, endAllCallsReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Reject incoming calls
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
void CallManagerStubDefault::rejectIncomingCall(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, rejectIncomingCallReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Put current active call on hold
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
void CallManagerStubDefault::holdActiveCall(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, holdActiveCallReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Activate the held from head unit
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
void CallManagerStubDefault::resumeHeldCall(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, resumeHeldCallReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Conference available calls from Head Unit
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
void CallManagerStubDefault::conferenceCall(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, conferenceCallReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Interface is used by HMI to select a particular call in case two phone are
 *   connected each with a phone call.
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   callId (Int32)          : Call ID of the phone call to be selected
	returns:
 *   errorCode (eErrorType): API execution output
 */
void CallManagerStubDefault::selectCall(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, int8_t _callId, selectCallReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _callId;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Interface is used by HMI to transfer call audio from Handsfree to Handset and
 *   vise versa
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   hfMode (Boolean)	: Handsfree Mode requested from the HMI
	returns: errorCode
 *   (eErrorType): API execution output
 */
void CallManagerStubDefault::setHfMode(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, bool _hfMode, setHfModeReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _hfMode;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Interface is used by HMI to active Phone VR mode from Head Unit
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   mode (Boolean)		: VR Mode requested from the HMI
	returns: errorCode
 *   (eErrorType): API execution output
 */
void CallManagerStubDefault::setVRMode(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, bool _mode, setVRModeReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    (void) _mode;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}

/**
 * description: Interface is used by HMI to swap the active call available on Head Unit
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
void CallManagerStubDefault::swapCalls(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _inAddress, swapCallsReply_t _reply) {
    (void)_client;
    (void) _inAddress;
    ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
    if (!errorCode.validate()) {
        return;
    }
    _reply(errorCode);
}




CallManagerStubDefault::RemoteEventHandler::RemoteEventHandler(CallManagerStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace btpres
} // namespace harman
} // namespace com
} // namespace v1
