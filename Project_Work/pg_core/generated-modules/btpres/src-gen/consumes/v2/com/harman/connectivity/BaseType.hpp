/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Thu Sep 22 00:23:23 IST 2016
*/
#ifndef V2_COM_HARMAN_CONNECTIVITY_Base_Type_HPP_
#define V2_COM_HARMAN_CONNECTIVITY_Base_Type_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v2 {
namespace com {
namespace harman {
namespace connectivity {

struct BaseType {
    
    struct foldertype : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INBOX = 0,
            OUTBOX = 1,
            SENT = 2,
            DELETED = 3,
            DRAFT = 4
        };
        
        foldertype() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INBOX)) {}
        foldertype(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INBOX):
                case static_cast<int32_t>(Literal::OUTBOX):
                case static_cast<int32_t>(Literal::SENT):
                case static_cast<int32_t>(Literal::DELETED):
                case static_cast<int32_t>(Literal::DRAFT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const foldertype &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const foldertype &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const foldertype &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const foldertype &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const foldertype &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const foldertype &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct smsnotification : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DELIVERY_SUCCESS = 0,
            DELIVERY_FAILURE = 1,
            SENDING_SUCCESS = 2,
            SENDING_FAILURE = 3,
            MEMORY_FULL = 4,
            MEMORY_AVAILABLE = 5,
            DELETED = 6,
            SHIFTED = 7,
            LOST_NOTIFICATIONS = 8
        };
        
        smsnotification() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DELIVERY_SUCCESS)) {}
        smsnotification(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DELIVERY_SUCCESS):
                case static_cast<int32_t>(Literal::DELIVERY_FAILURE):
                case static_cast<int32_t>(Literal::SENDING_SUCCESS):
                case static_cast<int32_t>(Literal::SENDING_FAILURE):
                case static_cast<int32_t>(Literal::MEMORY_FULL):
                case static_cast<int32_t>(Literal::MEMORY_AVAILABLE):
                case static_cast<int32_t>(Literal::DELETED):
                case static_cast<int32_t>(Literal::SHIFTED):
                case static_cast<int32_t>(Literal::LOST_NOTIFICATIONS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const smsnotification &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const smsnotification &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const smsnotification &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const smsnotification &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const smsnotification &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const smsnotification &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct phonebookentry : CommonAPI::Struct<std::string, std::string> {
    	
    	phonebookentry() {
    	}
    	phonebookentry(const std::string &_formattedName, const std::string &_MobileNumber)
    	{
    		std::get<0>(values_) = _formattedName;
    		std::get<1>(values_) = _MobileNumber;
    	}
    	inline const std::string &getFormattedName() const { return std::get<0>(values_); }
    	inline void setFormattedName(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getMobileNumber() const { return std::get<1>(values_); }
    	inline void setMobileNumber(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const phonebookentry& _other) const {
                return (getFormattedName() == _other.getFormattedName() && getMobileNumber() == _other.getMobileNumber());
        }
    	inline bool operator!=(const phonebookentry &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct callstackentry : CommonAPI::Struct<std::string, std::string, std::string> {
    	
    	callstackentry() {
    	}
    	callstackentry(const std::string &_formattedName, const std::string &_Number, const std::string &_TimeStamp)
    	{
    		std::get<0>(values_) = _formattedName;
    		std::get<1>(values_) = _Number;
    		std::get<2>(values_) = _TimeStamp;
    	}
    	inline const std::string &getFormattedName() const { return std::get<0>(values_); }
    	inline void setFormattedName(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getNumber() const { return std::get<1>(values_); }
    	inline void setNumber(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline const std::string &getTimeStamp() const { return std::get<2>(values_); }
    	inline void setTimeStamp(const std::string &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const callstackentry& _other) const {
                return (getFormattedName() == _other.getFormattedName() && getNumber() == _other.getNumber() && getTimeStamp() == _other.getTimeStamp());
        }
    	inline bool operator!=(const callstackentry &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct smsentry : CommonAPI::Struct<std::string, std::string, std::string, std::string, std::string, std::string, int32_t, bool> {
    	
    	smsentry() {
    		std::get<7>(values_) = false;
    	}
    	smsentry(const std::string &_smsBody, const std::string &_smsFrom, const std::string &_smsTo, const std::string &_timeStamp, const std::string &_smsName, const std::string &_url, const int32_t &_msg_id, const bool &_sms_read_status)
    	{
    		std::get<0>(values_) = _smsBody;
    		std::get<1>(values_) = _smsFrom;
    		std::get<2>(values_) = _smsTo;
    		std::get<3>(values_) = _timeStamp;
    		std::get<4>(values_) = _smsName;
    		std::get<5>(values_) = _url;
    		std::get<6>(values_) = _msg_id;
    		std::get<7>(values_) = _sms_read_status;
    	}
    	inline const std::string &getSmsBody() const { return std::get<0>(values_); }
    	inline void setSmsBody(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getSmsFrom() const { return std::get<1>(values_); }
    	inline void setSmsFrom(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline const std::string &getSmsTo() const { return std::get<2>(values_); }
    	inline void setSmsTo(const std::string &_value) { std::get<2>(values_) = _value; }
    	inline const std::string &getTimeStamp() const { return std::get<3>(values_); }
    	inline void setTimeStamp(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline const std::string &getSmsName() const { return std::get<4>(values_); }
    	inline void setSmsName(const std::string &_value) { std::get<4>(values_) = _value; }
    	inline const std::string &getUrl() const { return std::get<5>(values_); }
    	inline void setUrl(const std::string &_value) { std::get<5>(values_) = _value; }
    	inline const int32_t &getMsg_id() const { return std::get<6>(values_); }
    	inline void setMsg_id(const int32_t &_value) { std::get<6>(values_) = _value; }
    	inline const bool &getSms_read_status() const { return std::get<7>(values_); }
    	inline void setSms_read_status(const bool _value) { std::get<7>(values_) = _value; }
    	inline bool operator==(const smsentry& _other) const {
                return (getSmsBody() == _other.getSmsBody() && getSmsFrom() == _other.getSmsFrom() && getSmsTo() == _other.getSmsTo() && getTimeStamp() == _other.getTimeStamp() && getSmsName() == _other.getSmsName() && getUrl() == _other.getUrl() && getMsg_id() == _other.getMsg_id() && getSms_read_status() == _other.getSms_read_status());
        }
    	inline bool operator!=(const smsentry &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct alphaentry : CommonAPI::Struct<std::string, int32_t> {
    	
    	alphaentry() {
    	}
    	alphaentry(const std::string &_alpha, const int32_t &_startId)
    	{
    		std::get<0>(values_) = _alpha;
    		std::get<1>(values_) = _startId;
    	}
    	inline const std::string &getAlpha() const { return std::get<0>(values_); }
    	inline void setAlpha(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const int32_t &getStartId() const { return std::get<1>(values_); }
    	inline void setStartId(const int32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const alphaentry& _other) const {
                return (getAlpha() == _other.getAlpha() && getStartId() == _other.getStartId());
        }
    	inline bool operator!=(const alphaentry &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<BaseType::phonebookentry> phonebook;
    typedef std::vector<BaseType::callstackentry> callstack;
    typedef std::vector<std::string> arString;
    typedef std::vector<BaseType::smsentry> arSMS;
    typedef std::vector<BaseType::alphaentry> arAlphaTable;



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.connectivity.BaseType";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(2, 0);
}

}; // struct BaseType

} // namespace connectivity
} // namespace harman
} // namespace com
} // namespace v2

namespace CommonAPI {
}


namespace std {
    //Hash for foldertype
    template<>
    struct hash<::v2::com::harman::connectivity::BaseType::foldertype> {
        inline size_t operator()(const ::v2::com::harman::connectivity::BaseType::foldertype& foldertype) const {
            return static_cast<int32_t>(foldertype);
        }
    };
    //Hash for smsnotification
    template<>
    struct hash<::v2::com::harman::connectivity::BaseType::smsnotification> {
        inline size_t operator()(const ::v2::com::harman::connectivity::BaseType::smsnotification& smsnotification) const {
            return static_cast<int32_t>(smsnotification);
        }
    };
}


// Compatibility
namespace v2_0 = v2;

#endif // V2_COM_HARMAN_CONNECTIVITY_Base_Type_HPP_
