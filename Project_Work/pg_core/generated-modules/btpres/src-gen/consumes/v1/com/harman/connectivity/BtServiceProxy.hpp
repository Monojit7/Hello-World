/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Thu Sep 22 00:23:23 IST 2016
*/
#ifndef V1_COM_HARMAN_CONNECTIVITY_Bt_Service_PROXY_HPP_
#define V1_COM_HARMAN_CONNECTIVITY_Bt_Service_PROXY_HPP_

#include <v1/com/harman/connectivity/BtServiceProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace connectivity {

template <typename ... _AttributeExtensions>
class BtServiceProxy
    : virtual public BtService, 
      virtual public BtServiceProxyBase,
      virtual public _AttributeExtensions... {
public:
    BtServiceProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~BtServiceProxy();

    typedef BtService InterfaceType;



    /**
     * Returns the wrapper class that provides access to the broadcast bluetoothStatus.
     */
    virtual BluetoothStatusEvent& getBluetoothStatusEvent() {
        return delegate_->getBluetoothStatusEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast onOffState.
     */
    virtual OnOffStateEvent& getOnOffStateEvent() {
        return delegate_->getOnOffStateEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast localDevAddr.
     */
    virtual LocalDevAddrEvent& getLocalDevAddrEvent() {
        return delegate_->getLocalDevAddrEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast passkey.
     */
    virtual PasskeyEvent& getPasskeyEvent() {
        return delegate_->getPasskeyEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast signalQuality.
     */
    virtual SignalQualityEvent& getSignalQualityEvent() {
        return delegate_->getSignalQualityEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast vrMode.
     */
    virtual VrModeEvent& getVrModeEvent() {
        return delegate_->getVrModeEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast networkOperator.
     */
    virtual NetworkOperatorEvent& getNetworkOperatorEvent() {
        return delegate_->getNetworkOperatorEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast supportedFeatures.
     */
    virtual SupportedFeaturesEvent& getSupportedFeaturesEvent() {
        return delegate_->getSupportedFeaturesEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast deviceSearchList.
     */
    virtual DeviceSearchListEvent& getDeviceSearchListEvent() {
        return delegate_->getDeviceSearchListEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast standardBondingRequest.
     */
    virtual StandardBondingRequestEvent& getStandardBondingRequestEvent() {
        return delegate_->getStandardBondingRequestEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast secureSimpleBondingRequest.
     */
    virtual SecureSimpleBondingRequestEvent& getSecureSimpleBondingRequestEvent() {
        return delegate_->getSecureSimpleBondingRequestEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast serviceConnectionRequest.
     */
    virtual ServiceConnectionRequestEvent& getServiceConnectionRequestEvent() {
        return delegate_->getServiceConnectionRequestEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast serviceConnected.
     */
    virtual ServiceConnectedEvent& getServiceConnectedEvent() {
        return delegate_->getServiceConnectedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast serviceDisconnected.
     */
    virtual ServiceDisconnectedEvent& getServiceDisconnectedEvent() {
        return delegate_->getServiceDisconnectedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast deviceDisconnected.
     */
    virtual DeviceDisconnectedEvent& getDeviceDisconnectedEvent() {
        return delegate_->getDeviceDisconnectedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast serviceConnectionError.
     */
    virtual ServiceConnectionErrorEvent& getServiceConnectionErrorEvent() {
        return delegate_->getServiceConnectionErrorEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast bondedDeviceProfileListChanged.
     */
    virtual BondedDeviceProfileListChangedEvent& getBondedDeviceProfileListChangedEvent() {
        return delegate_->getBondedDeviceProfileListChangedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast bondedDeviceServiceListChanged.
     */
    virtual BondedDeviceServiceListChangedEvent& getBondedDeviceServiceListChangedEvent() {
        return delegate_->getBondedDeviceServiceListChangedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast deviceDeleted.
     */
    virtual DeviceDeletedEvent& getDeviceDeletedEvent() {
        return delegate_->getDeviceDeletedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast networkIfUp.
     */
    virtual NetworkIfUpEvent& getNetworkIfUpEvent() {
        return delegate_->getNetworkIfUpEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast networkIfDown.
     */
    virtual NetworkIfDownEvent& getNetworkIfDownEvent() {
        return delegate_->getNetworkIfDownEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast bondingStatus.
     */
    virtual BondingStatusEvent& getBondingStatusEvent() {
        return delegate_->getBondingStatusEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast incomingCallInfo.
     */
    virtual IncomingCallInfoEvent& getIncomingCallInfoEvent() {
        return delegate_->getIncomingCallInfoEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast handsFreeMode.
     */
    virtual HandsFreeModeEvent& getHandsFreeModeEvent() {
        return delegate_->getHandsFreeModeEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast audioStatus.
     */
    virtual AudioStatusEvent& getAudioStatusEvent() {
        return delegate_->getAudioStatusEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast batteryCharge.
     */
    virtual BatteryChargeEvent& getBatteryChargeEvent() {
        return delegate_->getBatteryChargeEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast networkOperatorChanged.
     */
    virtual NetworkOperatorChangedEvent& getNetworkOperatorChangedEvent() {
        return delegate_->getNetworkOperatorChangedEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast networkRegistrationState.
     */
    virtual NetworkRegistrationStateEvent& getNetworkRegistrationStateEvent() {
        return delegate_->getNetworkRegistrationStateEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast callStatus.
     */
    virtual CallStatusEvent& getCallStatusEvent() {
        return delegate_->getCallStatusEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast callListUpdate.
     */
    virtual CallListUpdateEvent& getCallListUpdateEvent() {
        return delegate_->getCallListUpdateEvent();
    }

    /**
     * Calls setIgnitionState with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setIgnitionState(const bool &_ignitionState, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setIgnitionState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setIgnitionStateAsync(const bool &_ignitionState, SetIgnitionStateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPropBluetoothStatus with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getPropBluetoothStatus(CommonAPI::CallStatus &_internalCallStatus, bool &_Status, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPropBluetoothStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getPropBluetoothStatusAsync(GetPropBluetoothStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSignalQuality with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSignalQuality(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_signalQual, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSignalQuality with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSignalQualityAsync(const std::string &_inAddress, GetSignalQualityAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBatteryCharge with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getBatteryCharge(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_batteryCharge, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBatteryCharge with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getBatteryChargeAsync(const std::string &_inAddress, GetBatteryChargeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPropLocalDeviceAddress with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getPropLocalDeviceAddress(CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPropLocalDeviceAddress with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getPropLocalDeviceAddressAsync(GetPropLocalDeviceAddressAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPropLocalDeviceName with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getPropLocalDeviceName(CommonAPI::CallStatus &_internalCallStatus, std::string &_name, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPropLocalDeviceName with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getPropLocalDeviceNameAsync(GetPropLocalDeviceNameAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getHfpConnectionStatus with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getHfpConnectionStatus(CommonAPI::CallStatus &_internalCallStatus, bool &_Status, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getHfpConnectionStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getHfpConnectionStatusAsync(GetHfpConnectionStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPropBondedDeviceList with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getPropBondedDeviceList(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::btTypedefs::bondedDevList &_list, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPropBondedDeviceList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getPropBondedDeviceListAsync(GetPropBondedDeviceListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedFeatures with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedFeatures(const std::string &_inAddrress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, ::com::harman::connectivity::btTypedefs::stringList &_featureList, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedFeatures with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedFeaturesAsync(const std::string &_inAddrress, GetSupportedFeaturesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNetworkAvailability with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getNetworkAvailability(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, bool &_netwrkStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNetworkAvailability with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getNetworkAvailabilityAsync(const std::string &_inAddress, GetNetworkAvailabilityAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNetworkRegistrationState with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getNetworkRegistrationState(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_regState, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNetworkRegistrationState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getNetworkRegistrationStateAsync(const std::string &_inAddress, GetNetworkRegistrationStateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSubscriberNumber with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSubscriberNumber(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_subscrbNum, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSubscriberNumber with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSubscriberNumberAsync(const std::string &_inAddress, GetSubscriberNumberAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getlastConnectedDevice with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getlastConnectedDevice(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::btTypedefs::lastConnectedDevList &_list, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getlastConnectedDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getlastConnectedDeviceAsync(GetlastConnectedDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCallStateEventData with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCallStateEventData(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, ::com::harman::connectivity::btTypedefs::callstateInfoList &_list, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCallStateEventData with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCallStateEventDataAsync(const std::string &_inAddress, GetCallStateEventDataAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sppInterfaces with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sppInterfaces(CommonAPI::CallStatus &_internalCallStatus, std::vector<std::string> &_devA, std::vector<std::string> &_devB, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sppInterfaces with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sppInterfacesAsync(SppInterfacesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls enterBondingMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void enterBondingMode(const uint32_t &_timeout, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls enterBondingMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> enterBondingModeAsync(const uint32_t &_timeout, EnterBondingModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls exitBondingMode with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void exitBondingMode(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls exitBondingMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> exitBondingModeAsync(ExitBondingModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls changePriority with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void changePriority(const std::string &_inAddress, const std::string &_service, const int32_t &_priority, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls changePriority with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> changePriorityAsync(const std::string &_inAddress, const std::string &_service, const int32_t &_priority, ChangePriorityAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startDeviceSearch with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startDeviceSearch(const uint32_t &_maxDevice, const uint32_t &_timeout, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startDeviceSearch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startDeviceSearchAsync(const uint32_t &_maxDevice, const uint32_t &_timeout, StartDeviceSearchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stopDeviceSearch with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stopDeviceSearch(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stopDeviceSearch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stopDeviceSearchAsync(StopDeviceSearchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls secureSimpleBondingReply with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void secureSimpleBondingReply(const std::string &_inAddress, const bool &_accept, const bool &_trusted, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls secureSimpleBondingReply with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> secureSimpleBondingReplyAsync(const std::string &_inAddress, const bool &_accept, const bool &_trusted, SecureSimpleBondingReplyAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteDevice(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deleteDeviceAsync(const std::string &_inAddress, DeleteDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteAllDevices with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteAllDevices(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteAllDevices with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deleteAllDevicesAsync(DeleteAllDevicesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startServiceConnection with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startServiceConnection(const std::string &_inAddress, const std::string &_service, const std::string &_instanceName, const std::string &_replaceAddr, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_devName, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startServiceConnection with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startServiceConnectionAsync(const std::string &_inAddress, const std::string &_service, const std::string &_instanceName, const std::string &_replaceAddr, StartServiceConnectionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls allowServiceConnection with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void allowServiceConnection(const std::string &_inAddress, const std::string &_service, const bool &_allow, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls allowServiceConnection with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> allowServiceConnectionAsync(const std::string &_inAddress, const std::string &_service, const bool &_allow, AllowServiceConnectionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startServiceDisconnection with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startServiceDisconnection(const std::string &_inAddress, const std::string &_service, const bool &_internalReq, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startServiceDisconnection with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startServiceDisconnectionAsync(const std::string &_inAddress, const std::string &_service, const bool &_internalReq, StartServiceDisconnectionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls serviceConnectionReply with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void serviceConnectionReply(const std::string &_inAddress, const std::string &_service, const bool &_accept, const std::string &_instanceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_devName, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls serviceConnectionReply with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> serviceConnectionReplyAsync(const std::string &_inAddress, const std::string &_service, const bool &_accept, const std::string &_instanceName, ServiceConnectionReplyAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBondedDeviceServiceList with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getBondedDeviceServiceList(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBondedDeviceServiceList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getBondedDeviceServiceListAsync(const std::string &_inAddress, GetBondedDeviceServiceListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRadioStatus with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getRadioStatus(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::btTypedefs::stringList &_addrList, ::com::harman::connectivity::btTypedefs::stringList &_connRoleList, ::com::harman::connectivity::btTypedefs::integerList &_linkQualitylist, ::com::harman::connectivity::btTypedefs::integerList &_rssiList, ::com::harman::connectivity::btTypedefs::integerList &_txPowerList, ::com::harman::connectivity::btTypedefs::stringList &_modeTypeList, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRadioStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getRadioStatusAsync(GetRadioStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls renameBondedDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void renameBondedDevice(const std::string &_inAddress, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls renameBondedDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> renameBondedDeviceAsync(const std::string &_inAddress, const std::string &_name, RenameBondedDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls renameLocalDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void renameLocalDevice(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls renameLocalDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> renameLocalDeviceAsync(const std::string &_name, RenameLocalDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startAutoConnect with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startAutoConnect(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startAutoConnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startAutoConnectAsync(StartAutoConnectAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls pauseAutoConnect with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void pauseAutoConnect(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls pauseAutoConnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> pauseAutoConnectAsync(PauseAutoConnectAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stopAutoConnect with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stopAutoConnect(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stopAutoConnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stopAutoConnectAsync(StopAutoConnectAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setAutoConnectServices with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setAutoConnectServices(const std::string &_serviceName, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setAutoConnectServices with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setAutoConnectServicesAsync(const std::string &_serviceName, SetAutoConnectServicesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls clearAutoConnectServices with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void clearAutoConnectServices(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls clearAutoConnectServices with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> clearAutoConnectServicesAsync(ClearAutoConnectServicesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNetworkOperatorInfo with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getNetworkOperatorInfo(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_code, std::string &_longName, std::string &_shortName, std::string &_mode, std::string &_accTech, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNetworkOperatorInfo with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getNetworkOperatorInfoAsync(const std::string &_inAddress, GetNetworkOperatorInfoAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBondedDeviceList with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getBondedDeviceList(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::btTypedefs::bondedDevList &_list, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBondedDeviceList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getBondedDeviceListAsync(GetBondedDeviceListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setBluetoothOn with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setBluetoothOn(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setBluetoothOn with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setBluetoothOnAsync(SetBluetoothOnAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setBluetoothOff with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setBluetoothOff(const bool &_doNotStore, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setBluetoothOff with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setBluetoothOffAsync(const bool &_doNotStore, SetBluetoothOffAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls serviceListQuery with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void serviceListQuery(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, ::com::harman::connectivity::btTypedefs::serviceList &_list, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls serviceListQuery with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> serviceListQueryAsync(const std::string &_inAddress, ServiceListQueryAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setPin with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setPin(const std::string &_passkey, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setPin with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setPinAsync(const std::string &_passkey, SetPinAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls dial with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void dial(const std::string &_inAddress, const std::string &_num, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_callId, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls dial with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> dialAsync(const std::string &_inAddress, const std::string &_num, DialAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls reDial with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void reDial(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_callId, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls reDial with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> reDialAsync(const std::string &_inAddress, ReDialAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendDtmfTone with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendDtmfTone(const std::string &_inAddress, const std::string &_dtmfTone, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendDtmfTone with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendDtmfToneAsync(const std::string &_inAddress, const std::string &_dtmfTone, SendDtmfToneAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls acceptIncomingCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void acceptIncomingCall(const std::string &_inAddress, const bool &_transfer, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls acceptIncomingCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> acceptIncomingCallAsync(const std::string &_inAddress, const bool &_transfer, AcceptIncomingCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls endCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void endCall(const std::string &_inAddress, const int32_t &_callId, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls endCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> endCallAsync(const std::string &_inAddress, const int32_t &_callId, EndCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls endActiveCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void endActiveCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls endActiveCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> endActiveCallAsync(const std::string &_inAddress, EndActiveCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls endAllCalls with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void endAllCalls(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls endAllCalls with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> endAllCallsAsync(const std::string &_inAddress, EndAllCallsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls rejectIncomingCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void rejectIncomingCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls rejectIncomingCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> rejectIncomingCallAsync(const std::string &_inAddress, RejectIncomingCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls holdActiveCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void holdActiveCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls holdActiveCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> holdActiveCallAsync(const std::string &_inAddress, HoldActiveCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls resumeHeldCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void resumeHeldCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls resumeHeldCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> resumeHeldCallAsync(const std::string &_inAddress, ResumeHeldCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls conferenceCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void conferenceCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls conferenceCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> conferenceCallAsync(const std::string &_inAddress, ConferenceCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls selectCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void selectCall(const std::string &_inAddress, const int32_t &_callId, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls selectCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> selectCallAsync(const std::string &_inAddress, const int32_t &_callId, SelectCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setHfMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setHfMode(const std::string &_inAddress, const bool &_hfMode, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setHfMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setHfModeAsync(const std::string &_inAddress, const bool &_hfMode, SetHfModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSSPDebugMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSSPDebugMode(const int32_t &_debugMode, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSSPDebugMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSSPDebugModeAsync(const int32_t &_debugMode, SetSSPDebugModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setVRMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setVRMode(const std::string &_inAddress, const bool &_mode, CommonAPI::CallStatus &_internalCallStatus, std::string &_OutAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setVRMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setVRModeAsync(const std::string &_inAddress, const bool &_mode, SetVRModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setEyesFree with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setEyesFree(const std::string &_inAddress, const bool &_toSet, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setEyesFree with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setEyesFreeAsync(const std::string &_inAddress, const bool &_toSet, SetEyesFreeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls clearTransferTimeout with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void clearTransferTimeout(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls clearTransferTimeout with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> clearTransferTimeoutAsync(ClearTransferTimeoutAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls swapCalls with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void swapCalls(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls swapCalls with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> swapCallsAsync(const std::string &_inAddress, SwapCallsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<BtServiceProxyBase> delegate_;
};

typedef BtServiceProxy<> BtServiceProxyDefault;


//
// BtServiceProxy Implementation
//
template <typename ... _AttributeExtensions>
BtServiceProxy<_AttributeExtensions...>::BtServiceProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<BtServiceProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<BtServiceProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
BtServiceProxy<_AttributeExtensions...>::~BtServiceProxy() {
}

template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::setIgnitionState(const bool &_ignitionState, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setIgnitionState(_ignitionState, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::setIgnitionStateAsync(const bool &_ignitionState, SetIgnitionStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setIgnitionStateAsync(_ignitionState, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getPropBluetoothStatus(CommonAPI::CallStatus &_internalCallStatus, bool &_Status, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getPropBluetoothStatus(_internalCallStatus, _Status, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getPropBluetoothStatusAsync(GetPropBluetoothStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getPropBluetoothStatusAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getSignalQuality(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_signalQual, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getSignalQuality(_inAddress, _internalCallStatus, _outAddress, _signalQual, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getSignalQualityAsync(const std::string &_inAddress, GetSignalQualityAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSignalQualityAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getBatteryCharge(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_batteryCharge, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getBatteryCharge(_inAddress, _internalCallStatus, _outAddress, _batteryCharge, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getBatteryChargeAsync(const std::string &_inAddress, GetBatteryChargeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getBatteryChargeAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getPropLocalDeviceAddress(CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getPropLocalDeviceAddress(_internalCallStatus, _outAddress, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getPropLocalDeviceAddressAsync(GetPropLocalDeviceAddressAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getPropLocalDeviceAddressAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getPropLocalDeviceName(CommonAPI::CallStatus &_internalCallStatus, std::string &_name, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getPropLocalDeviceName(_internalCallStatus, _name, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getPropLocalDeviceNameAsync(GetPropLocalDeviceNameAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getPropLocalDeviceNameAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getHfpConnectionStatus(CommonAPI::CallStatus &_internalCallStatus, bool &_Status, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getHfpConnectionStatus(_internalCallStatus, _Status, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getHfpConnectionStatusAsync(GetHfpConnectionStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getHfpConnectionStatusAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getPropBondedDeviceList(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::btTypedefs::bondedDevList &_list, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getPropBondedDeviceList(_internalCallStatus, _list, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getPropBondedDeviceListAsync(GetPropBondedDeviceListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getPropBondedDeviceListAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getSupportedFeatures(const std::string &_inAddrress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, ::com::harman::connectivity::btTypedefs::stringList &_featureList, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedFeatures(_inAddrress, _internalCallStatus, _outAddress, _featureList, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getSupportedFeaturesAsync(const std::string &_inAddrress, GetSupportedFeaturesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedFeaturesAsync(_inAddrress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getNetworkAvailability(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, bool &_netwrkStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getNetworkAvailability(_inAddress, _internalCallStatus, _outAddress, _netwrkStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getNetworkAvailabilityAsync(const std::string &_inAddress, GetNetworkAvailabilityAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getNetworkAvailabilityAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getNetworkRegistrationState(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_regState, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getNetworkRegistrationState(_inAddress, _internalCallStatus, _outAddress, _regState, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getNetworkRegistrationStateAsync(const std::string &_inAddress, GetNetworkRegistrationStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getNetworkRegistrationStateAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getSubscriberNumber(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_subscrbNum, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->getSubscriberNumber(_inAddress, _internalCallStatus, _outAddress, _subscrbNum, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getSubscriberNumberAsync(const std::string &_inAddress, GetSubscriberNumberAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSubscriberNumberAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getlastConnectedDevice(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::btTypedefs::lastConnectedDevList &_list, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->getlastConnectedDevice(_internalCallStatus, _list, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getlastConnectedDeviceAsync(GetlastConnectedDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getlastConnectedDeviceAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getCallStateEventData(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, ::com::harman::connectivity::btTypedefs::callstateInfoList &_list, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->getCallStateEventData(_inAddress, _internalCallStatus, _outAddress, _list, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getCallStateEventDataAsync(const std::string &_inAddress, GetCallStateEventDataAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCallStateEventDataAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::sppInterfaces(CommonAPI::CallStatus &_internalCallStatus, std::vector<std::string> &_devA, std::vector<std::string> &_devB, const CommonAPI::CallInfo *_info) {
    delegate_->sppInterfaces(_internalCallStatus, _devA, _devB, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::sppInterfacesAsync(SppInterfacesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sppInterfacesAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::enterBondingMode(const uint32_t &_timeout, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->enterBondingMode(_timeout, _internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::enterBondingModeAsync(const uint32_t &_timeout, EnterBondingModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->enterBondingModeAsync(_timeout, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::exitBondingMode(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->exitBondingMode(_internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::exitBondingModeAsync(ExitBondingModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->exitBondingModeAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::changePriority(const std::string &_inAddress, const std::string &_service, const int32_t &_priority, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->changePriority(_inAddress, _service, _priority, _internalCallStatus, _outAddress, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::changePriorityAsync(const std::string &_inAddress, const std::string &_service, const int32_t &_priority, ChangePriorityAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->changePriorityAsync(_inAddress, _service, _priority, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::startDeviceSearch(const uint32_t &_maxDevice, const uint32_t &_timeout, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->startDeviceSearch(_maxDevice, _timeout, _internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::startDeviceSearchAsync(const uint32_t &_maxDevice, const uint32_t &_timeout, StartDeviceSearchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startDeviceSearchAsync(_maxDevice, _timeout, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::stopDeviceSearch(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->stopDeviceSearch(_internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::stopDeviceSearchAsync(StopDeviceSearchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stopDeviceSearchAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::secureSimpleBondingReply(const std::string &_inAddress, const bool &_accept, const bool &_trusted, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->secureSimpleBondingReply(_inAddress, _accept, _trusted, _internalCallStatus, _outAddress, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::secureSimpleBondingReplyAsync(const std::string &_inAddress, const bool &_accept, const bool &_trusted, SecureSimpleBondingReplyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->secureSimpleBondingReplyAsync(_inAddress, _accept, _trusted, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::deleteDevice(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->deleteDevice(_inAddress, _internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::deleteDeviceAsync(const std::string &_inAddress, DeleteDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deleteDeviceAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::deleteAllDevices(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->deleteAllDevices(_internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::deleteAllDevicesAsync(DeleteAllDevicesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deleteAllDevicesAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::startServiceConnection(const std::string &_inAddress, const std::string &_service, const std::string &_instanceName, const std::string &_replaceAddr, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_devName, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->startServiceConnection(_inAddress, _service, _instanceName, _replaceAddr, _internalCallStatus, _outAddress, _devName, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::startServiceConnectionAsync(const std::string &_inAddress, const std::string &_service, const std::string &_instanceName, const std::string &_replaceAddr, StartServiceConnectionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startServiceConnectionAsync(_inAddress, _service, _instanceName, _replaceAddr, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::allowServiceConnection(const std::string &_inAddress, const std::string &_service, const bool &_allow, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->allowServiceConnection(_inAddress, _service, _allow, _internalCallStatus, _outAddress, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::allowServiceConnectionAsync(const std::string &_inAddress, const std::string &_service, const bool &_allow, AllowServiceConnectionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->allowServiceConnectionAsync(_inAddress, _service, _allow, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::startServiceDisconnection(const std::string &_inAddress, const std::string &_service, const bool &_internalReq, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->startServiceDisconnection(_inAddress, _service, _internalReq, _internalCallStatus, _outAddress, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::startServiceDisconnectionAsync(const std::string &_inAddress, const std::string &_service, const bool &_internalReq, StartServiceDisconnectionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startServiceDisconnectionAsync(_inAddress, _service, _internalReq, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::serviceConnectionReply(const std::string &_inAddress, const std::string &_service, const bool &_accept, const std::string &_instanceName, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_devName, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->serviceConnectionReply(_inAddress, _service, _accept, _instanceName, _internalCallStatus, _outAddress, _devName, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::serviceConnectionReplyAsync(const std::string &_inAddress, const std::string &_service, const bool &_accept, const std::string &_instanceName, ServiceConnectionReplyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->serviceConnectionReplyAsync(_inAddress, _service, _accept, _instanceName, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getBondedDeviceServiceList(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->getBondedDeviceServiceList(_inAddress, _internalCallStatus, _outAddress, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getBondedDeviceServiceListAsync(const std::string &_inAddress, GetBondedDeviceServiceListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getBondedDeviceServiceListAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getRadioStatus(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::btTypedefs::stringList &_addrList, ::com::harman::connectivity::btTypedefs::stringList &_connRoleList, ::com::harman::connectivity::btTypedefs::integerList &_linkQualitylist, ::com::harman::connectivity::btTypedefs::integerList &_rssiList, ::com::harman::connectivity::btTypedefs::integerList &_txPowerList, ::com::harman::connectivity::btTypedefs::stringList &_modeTypeList, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->getRadioStatus(_internalCallStatus, _addrList, _connRoleList, _linkQualitylist, _rssiList, _txPowerList, _modeTypeList, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getRadioStatusAsync(GetRadioStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getRadioStatusAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::renameBondedDevice(const std::string &_inAddress, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->renameBondedDevice(_inAddress, _name, _internalCallStatus, _outAddress, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::renameBondedDeviceAsync(const std::string &_inAddress, const std::string &_name, RenameBondedDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->renameBondedDeviceAsync(_inAddress, _name, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::renameLocalDevice(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->renameLocalDevice(_name, _internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::renameLocalDeviceAsync(const std::string &_name, RenameLocalDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->renameLocalDeviceAsync(_name, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::startAutoConnect(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->startAutoConnect(_internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::startAutoConnectAsync(StartAutoConnectAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startAutoConnectAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::pauseAutoConnect(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->pauseAutoConnect(_internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::pauseAutoConnectAsync(PauseAutoConnectAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->pauseAutoConnectAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::stopAutoConnect(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->stopAutoConnect(_internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::stopAutoConnectAsync(StopAutoConnectAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stopAutoConnectAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::setAutoConnectServices(const std::string &_serviceName, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->setAutoConnectServices(_serviceName, _internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::setAutoConnectServicesAsync(const std::string &_serviceName, SetAutoConnectServicesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setAutoConnectServicesAsync(_serviceName, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::clearAutoConnectServices(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->clearAutoConnectServices(_internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::clearAutoConnectServicesAsync(ClearAutoConnectServicesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->clearAutoConnectServicesAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getNetworkOperatorInfo(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_code, std::string &_longName, std::string &_shortName, std::string &_mode, std::string &_accTech, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->getNetworkOperatorInfo(_inAddress, _internalCallStatus, _outAddress, _code, _longName, _shortName, _mode, _accTech, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getNetworkOperatorInfoAsync(const std::string &_inAddress, GetNetworkOperatorInfoAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getNetworkOperatorInfoAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::getBondedDeviceList(CommonAPI::CallStatus &_internalCallStatus, ::com::harman::connectivity::btTypedefs::bondedDevList &_list, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->getBondedDeviceList(_internalCallStatus, _list, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::getBondedDeviceListAsync(GetBondedDeviceListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getBondedDeviceListAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::setBluetoothOn(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->setBluetoothOn(_internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::setBluetoothOnAsync(SetBluetoothOnAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setBluetoothOnAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::setBluetoothOff(const bool &_doNotStore, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->setBluetoothOff(_doNotStore, _internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::setBluetoothOffAsync(const bool &_doNotStore, SetBluetoothOffAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setBluetoothOffAsync(_doNotStore, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::serviceListQuery(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, ::com::harman::connectivity::btTypedefs::serviceList &_list, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->serviceListQuery(_inAddress, _internalCallStatus, _outAddress, _list, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::serviceListQueryAsync(const std::string &_inAddress, ServiceListQueryAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->serviceListQueryAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::setPin(const std::string &_passkey, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->setPin(_passkey, _internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::setPinAsync(const std::string &_passkey, SetPinAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setPinAsync(_passkey, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::dial(const std::string &_inAddress, const std::string &_num, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_callId, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->dial(_inAddress, _num, _internalCallStatus, _outAddress, _reason, _callId, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::dialAsync(const std::string &_inAddress, const std::string &_num, DialAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->dialAsync(_inAddress, _num, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::reDial(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_callId, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->reDial(_inAddress, _internalCallStatus, _outAddress, _reason, _callId, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::reDialAsync(const std::string &_inAddress, ReDialAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->reDialAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::sendDtmfTone(const std::string &_inAddress, const std::string &_dtmfTone, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->sendDtmfTone(_inAddress, _dtmfTone, _internalCallStatus, _outAddress, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::sendDtmfToneAsync(const std::string &_inAddress, const std::string &_dtmfTone, SendDtmfToneAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendDtmfToneAsync(_inAddress, _dtmfTone, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::acceptIncomingCall(const std::string &_inAddress, const bool &_transfer, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->acceptIncomingCall(_inAddress, _transfer, _internalCallStatus, _outAddress, _reason, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::acceptIncomingCallAsync(const std::string &_inAddress, const bool &_transfer, AcceptIncomingCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->acceptIncomingCallAsync(_inAddress, _transfer, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::endCall(const std::string &_inAddress, const int32_t &_callId, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->endCall(_inAddress, _callId, _internalCallStatus, _outAddress, _reason, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::endCallAsync(const std::string &_inAddress, const int32_t &_callId, EndCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->endCallAsync(_inAddress, _callId, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::endActiveCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->endActiveCall(_inAddress, _internalCallStatus, _outAddress, _reason, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::endActiveCallAsync(const std::string &_inAddress, EndActiveCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->endActiveCallAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::endAllCalls(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->endAllCalls(_inAddress, _internalCallStatus, _outAddress, _reason, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::endAllCallsAsync(const std::string &_inAddress, EndAllCallsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->endAllCallsAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::rejectIncomingCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->rejectIncomingCall(_inAddress, _internalCallStatus, _outAddress, _reason, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::rejectIncomingCallAsync(const std::string &_inAddress, RejectIncomingCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->rejectIncomingCallAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::holdActiveCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->holdActiveCall(_inAddress, _internalCallStatus, _outAddress, _reason, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::holdActiveCallAsync(const std::string &_inAddress, HoldActiveCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->holdActiveCallAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::resumeHeldCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->resumeHeldCall(_inAddress, _internalCallStatus, _outAddress, _reason, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::resumeHeldCallAsync(const std::string &_inAddress, ResumeHeldCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->resumeHeldCallAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::conferenceCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->conferenceCall(_inAddress, _internalCallStatus, _outAddress, _reason, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::conferenceCallAsync(const std::string &_inAddress, ConferenceCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->conferenceCallAsync(_inAddress, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::selectCall(const std::string &_inAddress, const int32_t &_callId, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->selectCall(_inAddress, _callId, _internalCallStatus, _outAddress, _reason, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::selectCallAsync(const std::string &_inAddress, const int32_t &_callId, SelectCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->selectCallAsync(_inAddress, _callId, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::setHfMode(const std::string &_inAddress, const bool &_hfMode, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->setHfMode(_inAddress, _hfMode, _internalCallStatus, _outAddress, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::setHfModeAsync(const std::string &_inAddress, const bool &_hfMode, SetHfModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setHfModeAsync(_inAddress, _hfMode, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::setSSPDebugMode(const int32_t &_debugMode, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->setSSPDebugMode(_debugMode, _internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::setSSPDebugModeAsync(const int32_t &_debugMode, SetSSPDebugModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setSSPDebugModeAsync(_debugMode, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::setVRMode(const std::string &_inAddress, const bool &_mode, CommonAPI::CallStatus &_internalCallStatus, std::string &_OutAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->setVRMode(_inAddress, _mode, _internalCallStatus, _OutAddress, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::setVRModeAsync(const std::string &_inAddress, const bool &_mode, SetVRModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setVRModeAsync(_inAddress, _mode, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::setEyesFree(const std::string &_inAddress, const bool &_toSet, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->setEyesFree(_inAddress, _toSet, _internalCallStatus, _outAddress, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::setEyesFreeAsync(const std::string &_inAddress, const bool &_toSet, SetEyesFreeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setEyesFreeAsync(_inAddress, _toSet, _callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::clearTransferTimeout(CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->clearTransferTimeout(_internalCallStatus, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::clearTransferTimeoutAsync(ClearTransferTimeoutAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->clearTransferTimeoutAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void BtServiceProxy<_AttributeExtensions...>::swapCalls(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_reason, int32_t &_errorCode, std::string &_errorDesc, const CommonAPI::CallInfo *_info) {
    delegate_->swapCalls(_inAddress, _internalCallStatus, _outAddress, _reason, _errorCode, _errorDesc, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> BtServiceProxy<_AttributeExtensions...>::swapCallsAsync(const std::string &_inAddress, SwapCallsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->swapCallsAsync(_inAddress, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &BtServiceProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool BtServiceProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool BtServiceProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& BtServiceProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& BtServiceProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace connectivity
} // namespace harman
} // namespace com
} // namespace v1



// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_CONNECTIVITY_Bt_Service_PROXY_HPP_
