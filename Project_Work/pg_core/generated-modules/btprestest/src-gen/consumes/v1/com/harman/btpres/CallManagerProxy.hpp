/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by Voice CodeGen Version: R1_v1.3.0
* generated on: Thu Sep 22 00:23:23 IST 2016
*/
#ifndef V1_COM_HARMAN_BTPRES_Call_Manager_PROXY_HPP_
#define V1_COM_HARMAN_BTPRES_Call_Manager_PROXY_HPP_

#include <v1/com/harman/btpres/CallManagerProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace btpres {

template <typename ... _AttributeExtensions>
class CallManagerProxy
    : virtual public CallManager, 
      virtual public CallManagerProxyBase,
      virtual public _AttributeExtensions... {
public:
    CallManagerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~CallManagerProxy();

    typedef CallManager InterfaceType;


    /**
     * description: broadcast Handsfree supported features to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute hfFeaturesList.
     */
    virtual HfFeaturesListAttribute& getHfFeaturesListAttribute() {
        return delegate_->getHfFeaturesListAttribute();
    }
    /**
     * description: broadcast phone network operator information to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute operatorInfoList.
     */
    virtual OperatorInfoListAttribute& getOperatorInfoListAttribute() {
        return delegate_->getOperatorInfoListAttribute();
    }
    /**
     * description: broadcast signal and charge levels to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute rssiChargeInfoList.
     */
    virtual RssiChargeInfoListAttribute& getRssiChargeInfoListAttribute() {
        return delegate_->getRssiChargeInfoListAttribute();
    }
    /**
     * description: broadcast callstate status to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute callStateInfo.
     */
    virtual CallStateInfoAttribute& getCallStateInfoAttribute() {
        return delegate_->getCallStateInfoAttribute();
    }
    /**
     * description: broadcast HF mode status to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute hfMode.
     */
    virtual HfModeAttribute& getHfModeAttribute() {
        return delegate_->getHfModeAttribute();
    }
    /**
     * description: broadcast call duration to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute callDuration.
     */
    virtual CallDurationAttribute& getCallDurationAttribute() {
        return delegate_->getCallDurationAttribute();
    }
    /**
     * description: broadcast SCO audio status to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute audioStatus.
     */
    virtual AudioStatusAttribute& getAudioStatusAttribute() {
        return delegate_->getAudioStatusAttribute();
    }
    /**
     * description: broadcast VR status to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute vrMode.
     */
    virtual VrModeAttribute& getVrModeAttribute() {
        return delegate_->getVrModeAttribute();
    }


    /**
     * description: Used to initate call from head unit HMI.
     * param: inAddress (String)    	: BD Address of the device to get the properties
    	     
     *   : dialNumber (String)	        : Number to be dialled
    	      : contactName
     *   (String)    	: Contact Name if available
    	      : imageUrl (String)	        :
     *   Image URL if available
    	returns: errorCode (eErrorType)	: API execution output
     * Calls dial with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void dial(const std::string &_inAddress, const std::string &_dialNumber, const std::string &_contactName, const std::string &_imageUrl, const ::v1::com::harman::btpres::BTPresTypes::eTelType &_numType, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls dial with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> dialAsync(const std::string &_inAddress, const std::string &_dialNumber, const std::string &_contactName, const std::string &_imageUrl, const ::v1::com::harman::btpres::BTPresTypes::eTelType &_numType, DialAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to send DTMF tone from head unit to phone.
     * param: inAddress (String)	: BD Address of the device to get the properties
    	      :
     *   dtmfTone (String)	: DTMF tone to be sent
    	returns: errorCode (errorCode)	: API
     *   execution ouput
     * Calls sendDtmfTone with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendDtmfTone(const std::string &_inAddress, const std::string &_dtmfTone, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendDtmfTone with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendDtmfToneAsync(const std::string &_inAddress, const std::string &_dtmfTone, SendDtmfToneAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Accept incoming call from Head Unit
     * param: inAddress (String)	: BD Address of the device to get the properties
    	      :
     *   transfer (Boolean)	: Whether the call has to be transferred to Handset mode
     *   upon acceptance
    	returns: errorCode (eErrorType): API execution output
     * Calls acceptIncomingCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void acceptIncomingCall(const std::string &_inAddress, const bool &_transfer, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls acceptIncomingCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> acceptIncomingCallAsync(const std::string &_inAddress, const bool &_transfer, AcceptIncomingCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: End call for passed call ID
     * param: inAddress (String)	: BD Address of the device to get the properties
    	      :
     *   callId (Int32)          : Call ID of the phone call to be ended
    	returns:
     *   errorCode (eErrorType): API execution output
     * Calls endCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void endCall(const std::string &_inAddress, const int8_t &_callId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls endCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> endCallAsync(const std::string &_inAddress, const int8_t &_callId, EndCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: End currently active call for a particular device
     * param: inAddress (String)      : BD Address of the device to get the
     *   properties
    	returns: errorCode (eErrorType): API execution output
     * Calls endActiveCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void endActiveCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls endActiveCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> endActiveCallAsync(const std::string &_inAddress, EndActiveCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Ends all available calls
     * param: inAddress (String)	: BD Address of the device to get the properties
    	returns:
     *   errorCode (eErrorType): API execution output
     * Calls endAllCalls with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void endAllCalls(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls endAllCalls with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> endAllCallsAsync(const std::string &_inAddress, EndAllCallsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Reject incoming calls
     * param: inAddress (String)	: BD Address of the device to get the properties
    	returns:
     *   errorCode (eErrorType): API execution output
     * Calls rejectIncomingCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void rejectIncomingCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls rejectIncomingCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> rejectIncomingCallAsync(const std::string &_inAddress, RejectIncomingCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Put current active call on hold
     * param: inAddress (String)	: BD Address of the device to get the properties
    	returns:
     *   errorCode (eErrorType): API execution output
     * Calls holdActiveCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void holdActiveCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls holdActiveCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> holdActiveCallAsync(const std::string &_inAddress, HoldActiveCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Activate the held from head unit
     * param: inAddress (String)	: BD Address of the device to get the properties
    	returns:
     *   errorCode (eErrorType): API execution output
     * Calls resumeHeldCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void resumeHeldCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls resumeHeldCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> resumeHeldCallAsync(const std::string &_inAddress, ResumeHeldCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Conference available calls from Head Unit
     * param: inAddress (String)	: BD Address of the device to get the properties
    	returns:
     *   errorCode (eErrorType): API execution output
     * Calls conferenceCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void conferenceCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls conferenceCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> conferenceCallAsync(const std::string &_inAddress, ConferenceCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Interface is used by HMI to select a particular call in case two phone are
     *   connected each with a phone call.
     * param: inAddress (String)	: BD Address of the device to get the properties
    	      :
     *   callId (Int32)          : Call ID of the phone call to be selected
    	returns:
     *   errorCode (eErrorType): API execution output
     * Calls selectCall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void selectCall(const std::string &_inAddress, const int8_t &_callId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls selectCall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> selectCallAsync(const std::string &_inAddress, const int8_t &_callId, SelectCallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Interface is used by HMI to transfer call audio from Handsfree to Handset and
     *   vise versa
     * param: inAddress (String)	: BD Address of the device to get the properties
    	      :
     *   hfMode (Boolean)	: Handsfree Mode requested from the HMI
    	returns: errorCode
     *   (eErrorType): API execution output
     * Calls setHfMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setHfMode(const std::string &_inAddress, const bool &_hfMode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setHfMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setHfModeAsync(const std::string &_inAddress, const bool &_hfMode, SetHfModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Interface is used by HMI to active Phone VR mode from Head Unit
     * param: inAddress (String)	: BD Address of the device to get the properties
    	      :
     *   mode (Boolean)		: VR Mode requested from the HMI
    	returns: errorCode
     *   (eErrorType): API execution output
     * Calls setVRMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setVRMode(const std::string &_inAddress, const bool &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setVRMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setVRModeAsync(const std::string &_inAddress, const bool &_mode, SetVRModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Interface is used by HMI to swap the active call available on Head Unit
     * param: inAddress (String)	: BD Address of the device to get the properties
    	returns:
     *   errorCode (eErrorType): API execution output
     * Calls swapCalls with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void swapCalls(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls swapCalls with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> swapCallsAsync(const std::string &_inAddress, SwapCallsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<CallManagerProxyBase> delegate_;
};

typedef CallManagerProxy<> CallManagerProxyDefault;

namespace CallManagerExtensions {
    /**
     * description: broadcast Handsfree supported features to registered clients
     */
    template <template <typename > class _ExtensionType>
    class HfFeaturesListAttributeExtension {
     public:
        typedef _ExtensionType<CallManagerProxyBase::HfFeaturesListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<CallManagerProxyBase::HfFeaturesListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        HfFeaturesListAttributeExtension() {}
    #endif
    
        HfFeaturesListAttributeExtension(CallManagerProxyBase& proxy): attributeExtension_(proxy.getHfFeaturesListAttribute()) {
        }
    
        inline extension_type& getHfFeaturesListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: broadcast phone network operator information to registered clients
     */
    template <template <typename > class _ExtensionType>
    class OperatorInfoListAttributeExtension {
     public:
        typedef _ExtensionType<CallManagerProxyBase::OperatorInfoListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<CallManagerProxyBase::OperatorInfoListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        OperatorInfoListAttributeExtension() {}
    #endif
    
        OperatorInfoListAttributeExtension(CallManagerProxyBase& proxy): attributeExtension_(proxy.getOperatorInfoListAttribute()) {
        }
    
        inline extension_type& getOperatorInfoListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: broadcast signal and charge levels to registered clients
     */
    template <template <typename > class _ExtensionType>
    class RssiChargeInfoListAttributeExtension {
     public:
        typedef _ExtensionType<CallManagerProxyBase::RssiChargeInfoListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<CallManagerProxyBase::RssiChargeInfoListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        RssiChargeInfoListAttributeExtension() {}
    #endif
    
        RssiChargeInfoListAttributeExtension(CallManagerProxyBase& proxy): attributeExtension_(proxy.getRssiChargeInfoListAttribute()) {
        }
    
        inline extension_type& getRssiChargeInfoListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: broadcast callstate status to registered clients
     */
    template <template <typename > class _ExtensionType>
    class CallStateInfoAttributeExtension {
     public:
        typedef _ExtensionType<CallManagerProxyBase::CallStateInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<CallManagerProxyBase::CallStateInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        CallStateInfoAttributeExtension() {}
    #endif
    
        CallStateInfoAttributeExtension(CallManagerProxyBase& proxy): attributeExtension_(proxy.getCallStateInfoAttribute()) {
        }
    
        inline extension_type& getCallStateInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: broadcast HF mode status to registered clients
     */
    template <template <typename > class _ExtensionType>
    class HfModeAttributeExtension {
     public:
        typedef _ExtensionType<CallManagerProxyBase::HfModeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<CallManagerProxyBase::HfModeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        HfModeAttributeExtension() {}
    #endif
    
        HfModeAttributeExtension(CallManagerProxyBase& proxy): attributeExtension_(proxy.getHfModeAttribute()) {
        }
    
        inline extension_type& getHfModeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: broadcast call duration to registered clients
     */
    template <template <typename > class _ExtensionType>
    class CallDurationAttributeExtension {
     public:
        typedef _ExtensionType<CallManagerProxyBase::CallDurationAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<CallManagerProxyBase::CallDurationAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        CallDurationAttributeExtension() {}
    #endif
    
        CallDurationAttributeExtension(CallManagerProxyBase& proxy): attributeExtension_(proxy.getCallDurationAttribute()) {
        }
    
        inline extension_type& getCallDurationAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: broadcast SCO audio status to registered clients
     */
    template <template <typename > class _ExtensionType>
    class AudioStatusAttributeExtension {
     public:
        typedef _ExtensionType<CallManagerProxyBase::AudioStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<CallManagerProxyBase::AudioStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AudioStatusAttributeExtension() {}
    #endif
    
        AudioStatusAttributeExtension(CallManagerProxyBase& proxy): attributeExtension_(proxy.getAudioStatusAttribute()) {
        }
    
        inline extension_type& getAudioStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: broadcast VR status to registered clients
     */
    template <template <typename > class _ExtensionType>
    class VrModeAttributeExtension {
     public:
        typedef _ExtensionType<CallManagerProxyBase::VrModeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<CallManagerProxyBase::VrModeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        VrModeAttributeExtension() {}
    #endif
    
        VrModeAttributeExtension(CallManagerProxyBase& proxy): attributeExtension_(proxy.getVrModeAttribute()) {
        }
    
        inline extension_type& getVrModeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace CallManagerExtensions

//
// CallManagerProxy Implementation
//
template <typename ... _AttributeExtensions>
CallManagerProxy<_AttributeExtensions...>::CallManagerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<CallManagerProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<CallManagerProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
CallManagerProxy<_AttributeExtensions...>::~CallManagerProxy() {
}

/**
 * description: Used to initate call from head unit HMI.
 * param: inAddress (String)    	: BD Address of the device to get the properties
	     
 *   : dialNumber (String)	        : Number to be dialled
	      : contactName
 *   (String)    	: Contact Name if available
	      : imageUrl (String)	        :
 *   Image URL if available
	returns: errorCode (eErrorType)	: API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::dial(const std::string &_inAddress, const std::string &_dialNumber, const std::string &_contactName, const std::string &_imageUrl, const ::v1::com::harman::btpres::BTPresTypes::eTelType &_numType, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    if (!_numType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->dial(_inAddress, _dialNumber, _contactName, _imageUrl, _numType, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::dialAsync(const std::string &_inAddress, const std::string &_dialNumber, const std::string &_contactName, const std::string &_imageUrl, const ::v1::com::harman::btpres::BTPresTypes::eTelType &_numType, DialAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_numType.validate()) {
        ::v1::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v1::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->dialAsync(_inAddress, _dialNumber, _contactName, _imageUrl, _numType, _callback, _info);
}
/**
 * description: Used to send DTMF tone from head unit to phone.
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   dtmfTone (String)	: DTMF tone to be sent
	returns: errorCode (errorCode)	: API
 *   execution ouput
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::sendDtmfTone(const std::string &_inAddress, const std::string &_dtmfTone, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->sendDtmfTone(_inAddress, _dtmfTone, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::sendDtmfToneAsync(const std::string &_inAddress, const std::string &_dtmfTone, SendDtmfToneAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendDtmfToneAsync(_inAddress, _dtmfTone, _callback, _info);
}
/**
 * description: Accept incoming call from Head Unit
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   transfer (Boolean)	: Whether the call has to be transferred to Handset mode
 *   upon acceptance
	returns: errorCode (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::acceptIncomingCall(const std::string &_inAddress, const bool &_transfer, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->acceptIncomingCall(_inAddress, _transfer, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::acceptIncomingCallAsync(const std::string &_inAddress, const bool &_transfer, AcceptIncomingCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->acceptIncomingCallAsync(_inAddress, _transfer, _callback, _info);
}
/**
 * description: End call for passed call ID
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   callId (Int32)          : Call ID of the phone call to be ended
	returns:
 *   errorCode (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::endCall(const std::string &_inAddress, const int8_t &_callId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->endCall(_inAddress, _callId, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::endCallAsync(const std::string &_inAddress, const int8_t &_callId, EndCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->endCallAsync(_inAddress, _callId, _callback, _info);
}
/**
 * description: End currently active call for a particular device
 * param: inAddress (String)      : BD Address of the device to get the
 *   properties
	returns: errorCode (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::endActiveCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->endActiveCall(_inAddress, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::endActiveCallAsync(const std::string &_inAddress, EndActiveCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->endActiveCallAsync(_inAddress, _callback, _info);
}
/**
 * description: Ends all available calls
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::endAllCalls(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->endAllCalls(_inAddress, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::endAllCallsAsync(const std::string &_inAddress, EndAllCallsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->endAllCallsAsync(_inAddress, _callback, _info);
}
/**
 * description: Reject incoming calls
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::rejectIncomingCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->rejectIncomingCall(_inAddress, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::rejectIncomingCallAsync(const std::string &_inAddress, RejectIncomingCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->rejectIncomingCallAsync(_inAddress, _callback, _info);
}
/**
 * description: Put current active call on hold
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::holdActiveCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->holdActiveCall(_inAddress, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::holdActiveCallAsync(const std::string &_inAddress, HoldActiveCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->holdActiveCallAsync(_inAddress, _callback, _info);
}
/**
 * description: Activate the held from head unit
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::resumeHeldCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->resumeHeldCall(_inAddress, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::resumeHeldCallAsync(const std::string &_inAddress, ResumeHeldCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->resumeHeldCallAsync(_inAddress, _callback, _info);
}
/**
 * description: Conference available calls from Head Unit
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::conferenceCall(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->conferenceCall(_inAddress, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::conferenceCallAsync(const std::string &_inAddress, ConferenceCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->conferenceCallAsync(_inAddress, _callback, _info);
}
/**
 * description: Interface is used by HMI to select a particular call in case two phone are
 *   connected each with a phone call.
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   callId (Int32)          : Call ID of the phone call to be selected
	returns:
 *   errorCode (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::selectCall(const std::string &_inAddress, const int8_t &_callId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->selectCall(_inAddress, _callId, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::selectCallAsync(const std::string &_inAddress, const int8_t &_callId, SelectCallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->selectCallAsync(_inAddress, _callId, _callback, _info);
}
/**
 * description: Interface is used by HMI to transfer call audio from Handsfree to Handset and
 *   vise versa
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   hfMode (Boolean)	: Handsfree Mode requested from the HMI
	returns: errorCode
 *   (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::setHfMode(const std::string &_inAddress, const bool &_hfMode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setHfMode(_inAddress, _hfMode, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::setHfModeAsync(const std::string &_inAddress, const bool &_hfMode, SetHfModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setHfModeAsync(_inAddress, _hfMode, _callback, _info);
}
/**
 * description: Interface is used by HMI to active Phone VR mode from Head Unit
 * param: inAddress (String)	: BD Address of the device to get the properties
	      :
 *   mode (Boolean)		: VR Mode requested from the HMI
	returns: errorCode
 *   (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::setVRMode(const std::string &_inAddress, const bool &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setVRMode(_inAddress, _mode, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::setVRModeAsync(const std::string &_inAddress, const bool &_mode, SetVRModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setVRModeAsync(_inAddress, _mode, _callback, _info);
}
/**
 * description: Interface is used by HMI to swap the active call available on Head Unit
 * param: inAddress (String)	: BD Address of the device to get the properties
	returns:
 *   errorCode (eErrorType): API execution output
 */
template <typename ... _AttributeExtensions>
void CallManagerProxy<_AttributeExtensions...>::swapCalls(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->swapCalls(_inAddress, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CallManagerProxy<_AttributeExtensions...>::swapCallsAsync(const std::string &_inAddress, SwapCallsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->swapCallsAsync(_inAddress, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &CallManagerProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool CallManagerProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool CallManagerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& CallManagerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& CallManagerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace btpres
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v1::com::harman::btpres::CallManagerProxy,
    _AttributeExtension> {
    typedef typename ::v1::com::harman::btpres::CallManagerProxy<
            ::v1::com::harman::btpres::CallManagerExtensions::HfFeaturesListAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::btpres::CallManagerExtensions::OperatorInfoListAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::btpres::CallManagerExtensions::RssiChargeInfoListAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::btpres::CallManagerExtensions::CallStateInfoAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::btpres::CallManagerExtensions::HfModeAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::btpres::CallManagerExtensions::CallDurationAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::btpres::CallManagerExtensions::AudioStatusAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::btpres::CallManagerExtensions::VrModeAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_BTPRES_Call_Manager_PROXY_HPP_
