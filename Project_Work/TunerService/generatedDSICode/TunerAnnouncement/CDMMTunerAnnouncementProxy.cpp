 
/**********************************************************************
 *  Project       Harman Car Multimedia System
 *  (c) copyright 2013
 *  Company       Harman/Becker Automotive Systems GmbH
 *                All rights reserved
 **********************************************************************/

/*
 * Generated by DSI Generator version 2.0
 * Date: 6.5.2013
 */


#include "CDMMTunerAnnouncementProxy.hpp"
#include "CTunerRequestResponseHandler.hpp"
#include "CTunerAnnouncementHandler.hpp"
#include "CTunerRespHandler.hpp"
#include "CTunerDataTypes.hpp"
#include <string.h>
#include "TraceMacros.hpp"

TRC_SCOPE_DEF(TunerService, CDMMTunerAnnouncementProxy, componentConnected);
TRC_SCOPE_DEF(TunerService, CDMMTunerAnnouncementProxy, componentDisconnected);
TRC_SCOPE_DEF(TunerService, CDMMTunerAnnouncementProxy, processInternalEvent);
TRC_SCOPE_DEF(TunerService, CDMMTunerAnnouncementProxy, responseStartTune);
TRC_SCOPE_DEF(TunerService, CDMMTunerAnnouncementProxy, informationCurrentAnnouncement);
TRC_SCOPE_DEF(TunerService, CDMMTunerAnnouncementProxy, responseAbort);

static void _responseSetFilter( DMMTunerAnnouncementProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->responseSetFilter( handle, feedback ) ;
}

static void _responseAbort( DMMTunerAnnouncementProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->responseAbort( handle, feedback ) ;
}

static void _responseStartTune( DMMTunerAnnouncementProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->responseStartTune( handle, feedback ) ;
}

static void _informationCurrentAnnouncement( DMMTunerAnnouncementProxy* proxy, const DMMTunerAnnouncement_Announcement* announcement )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->informationCurrentAnnouncement(  *announcement ) ;
}

static void _responseSetFilters( DMMTunerAnnouncementProxy* proxy,  unsigned int handle, const DMMTunerTypes_Feedbacks feedbacks )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->responseSetFilters( handle, feedbacks ) ;
}

static void _processInternalEvent( DMMTunerAnnouncementProxy* proxy, int code, void* data )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->processInternalEvent( code,  data ) ;
}

static void _processUpdateEvent( DMMTunerAnnouncementProxy* proxy, DMMTunerAnnouncement_UpdateIdEnum updateId )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->processUpdateEvent( updateId ) ;
}

static void _componentConnected( DMMTunerAnnouncementProxy* proxy )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->componentConnected( ) ;
}

static void _componentDisconnected( DMMTunerAnnouncementProxy* proxy )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->componentDisconnected( ) ;
}

static void _cleanup( DMMTunerAnnouncementProxy* proxy )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->cleanup( ) ;
}

static void _responseInvalid( DMMTunerAnnouncementProxy* proxy, DMMTunerAnnouncement_UpdateIdEnum id )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->responseInvalid( id );
}

static void _requestSetFilterFailed( DMMTunerAnnouncementProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->requestSetFilterFailed( errType );
}

static void _requestAbortFailed( DMMTunerAnnouncementProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->requestAbortFailed( errType );
}

static void _requestStartTuneFailed( DMMTunerAnnouncementProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->requestStartTuneFailed( errType );
}

static void _requestUnblockStationFailed( DMMTunerAnnouncementProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->requestUnblockStationFailed( errType );
}

static void _requestSetFiltersFailed( DMMTunerAnnouncementProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerAnnouncementProxy*)proxy)->requestSetFiltersFailed( errType );
}


CDMMTunerAnnouncementProxy::CDMMTunerAnnouncementProxy( )
{
   memset( (DMMTunerAnnouncementProxy*)this, 0, sizeof(DMMTunerAnnouncementProxy) );

   fnResponseSetFilter = _responseSetFilter ;
   fnResponseAbort = _responseAbort ;
   fnResponseStartTune = _responseStartTune ;
   fnInformationCurrentAnnouncement = _informationCurrentAnnouncement ;
   fnResponseSetFilters = _responseSetFilters ;

   fnRequestSetFilterFailed = _requestSetFilterFailed ;
   fnRequestAbortFailed = _requestAbortFailed ;
   fnRequestStartTuneFailed = _requestStartTuneFailed ;
   fnRequestUnblockStationFailed = _requestUnblockStationFailed ;
   fnRequestSetFiltersFailed = _requestSetFiltersFailed ;

   fnProcessInternalEvent = _processInternalEvent ;
   fnProcessUpdateEvent = _processUpdateEvent ;
   fnComponentConnected = _componentConnected ;
   fnComponentDisconnected = _componentDisconnected ;
   fnResponseInvalid = _responseInvalid ;
   fnCleanup = _cleanup ;
}

CDMMTunerAnnouncementProxy::~CDMMTunerAnnouncementProxy()
{
}

int CDMMTunerAnnouncementProxy::start( const char* rolename )
{
	return DMMTunerAnnouncementProxy_Start( this, rolename ) ;
}

void CDMMTunerAnnouncementProxy::stop( int exitcode )
{
   DMMTunerAnnouncementProxy_Stop( this, exitcode );
}

int CDMMTunerAnnouncementProxy::postInternalEvent( int code, void* data )
{
	return DSIPostInternalEvent( client.Channel.Master, client.Id, 0, code, data );
}

int CDMMTunerAnnouncementProxy::sendInternalEvent( int code, void* data )
{
   return DSISendInternalEvent( client.Channel.Master, client.Id, 0, code, data );
}

void CDMMTunerAnnouncementProxy::cleanup()
{
}

void CDMMTunerAnnouncementProxy::componentConnected( )
{
	TRC_SCOPE(TunerService, CDMMTunerAnnouncementProxy, componentConnected);
	CTunerRequestResponseHandler* mMain = CTunerRequestResponseHandler::GetInstance();
	bool status = true;
	mMain->setAnnouncementComponentStatus(status);
	DBG_MSG(("CDMMTunerAnnouncementProxy::Component connected called !!!"));
	setNotification(DMMTunerAnnouncement_UPD_ID_informationCurrentAnnouncement);
}
void CDMMTunerAnnouncementProxy::componentDisconnected()
{
	TRC_SCOPE(TunerService, CDMMTunerAnnouncementProxy, componentDisconnected);
	DBG_MSG(("CDMMTunerAnnouncementProxy::Component disconnected called !!!"));
}
void CDMMTunerAnnouncementProxy::processInternalEvent( int code, void* data )
{
	TRC_SCOPE(TunerService, CDMMTunerAnnouncementProxy, processInternalEvent);
	switch(code)
	{
		case DMMTunerAnnouncement_UPD_ID_requestAbort:
		{
			//INT32 frequency = *(INT32*)data;
			proxy info = *(proxy*)data;
			UINT32 handle = info.token;
			DBG_MSG(("[CDMMTunerAnnouncementProxy]:RequestAbort"));
			DMMTunerAnnouncement_StationSelector source;
			source.deviceType = DMMTunerTypes_AMFM;
			source.id = 0;
			requestAbort(source,DMMTunerAnnouncement_ROAD_TRAFFIC,handle );
			break;
		}
		default:
			break;
	}
}
void CDMMTunerAnnouncementProxy::responseStartTune(  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
	TRC_SCOPE(TunerService, CDMMTunerAnnouncementProxy, responseStartTune);
	DBG_MSG(("[CDMMTunerAnnouncementProxy]: responseStartTune"));
}
void CDMMTunerAnnouncementProxy::responseAbort(  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
	TRC_SCOPE(TunerService, CDMMTunerAnnouncementProxy, responseAbort);
	DBG_MSG(("[CDMMTunerAnnouncementProxy]: responseAbort"));
	   int result = 2;
	   switch(feedback)
	   {
	     case 0:
	     result = 0;
	     break;
	     case 1:
	     result = 1;
	     break;
	     case 2:
	     result = 2;
	     break;
	     case 3:
	     result = 1;
	     break;
	     case 4:
	     result = 3;
	     break;
	     case 5:
	     result = 1;
	     break;
	     default:
	     result = 1;
	     break;
	   }
	   std::string signalName = "requestStatus";
	   Json::Value res;
	   res["status"] = result;
	   res["description"] = "Status";
	   res["type"] = "cancelTA";
	   CTunerRequestResponseHandler::handleNotif(signalName,res);
}
void CDMMTunerAnnouncementProxy::informationCurrentAnnouncement(const DMMTunerAnnouncement_Announcement& announcement )
{
	TRC_SCOPE(TunerService, CDMMTunerAnnouncementProxy, informationCurrentAnnouncement);
	CTunerAnnouncementHandler* mAnnouncement = CTunerAnnouncementHandler::getAnnouncementHandler();
	DBG_MSG(("[CDMMTunerAnnouncementProxy]: informationCurrentAnnouncement"));
	DMMTunerAnnouncement_StationSelector src = announcement.source;
	std::string signalName = "trafficAnnouncement";
	Json::Value data;
	std::string types;
	bool states = false;
	DMMTunerAnnouncement_AnnouncementType type = announcement.type;
	DMMTunerAnnouncement_AnnouncementState state = announcement.state;
	if(2 == type)
	{
		types = "TA";
	}
	else if(16 == type)
	{
		//types = "News";
	}
	else
	{
		;
	}
	if(2 == state)
	{
	  if((true == mAnnouncement->getTAMode()) && (types == "TA"))
		{
		  data["trafficAnnouncement"]= false;
		  data["value"] = false;
		  CTunerAnnouncementHandler::mAnnouncementState = false;
		  DBG_MSG(("[CDMMTunerAnnouncementProxy]: Announcement lost,sending TA not available signal to HMI"));
		  CTunerRequestResponseHandler::handleNotif(signalName,data);
		}
		else
		{
          ;
		}
	}
	else if(3 == state)
	{
	  /*if((true == mAnnouncement->getTAMode()) && (types == "TA"))
		{
		  DBG_MSG(("Starting Traffic tuning \n"));
		  requestStartTune(src,false,1);
		  data["trafficAnnouncement"]= false;
		  data["value"] = false;
		  DBG_MSG(("[CDMMTunerAnnouncementProxy]: sending TA not available signal to HMI"));
		  CTunerRequestResponseHandler::handleNotif(signalName,data);
		}
		else
		{
		  ;
		}*/
	  if((true == mAnnouncement->getTAMode()) && (types == "TA"))
		{
		  data["trafficAnnouncement"]= false;
		  data["value"] = false;
		  CTunerAnnouncementHandler::mAnnouncementState = false;
		  DBG_MSG(("[CDMMTunerAnnouncementProxy]: Announcement available,sending no active TA available signal to HMI"));
		  CTunerRequestResponseHandler::handleNotif(signalName,data);
		}
		else
		{
		  ;
		}
	}
	else if(4 == state)
	{
	  if((true == mAnnouncement->getTAMode()) && (types == "TA"))
	  {
		  //DBG_MSG(("Starting Traffic tuning \n"));
		  //requestStartTune(src,true,1);
		  data["trafficAnnouncement"]= false;
		  data["value"] = false;
		  CTunerAnnouncementHandler::mAnnouncementState = false;
		  DBG_MSG(("[CDMMTunerAnnouncementProxy]: sending no active TA available signal to HMI"));
		  CTunerRequestResponseHandler::handleNotif(signalName,data);
	  }
	  else
	  {
		  ;
	  }
		/*states = true;
		data["trafficAnnouncement"]= true;
		data["value"] = true;*/
	}
	else if(5 == state)
	{
	  states = true;
	  data["trafficAnnouncement"]= true;
	  data["value"] = true;
	}

	DBG_MSG(("Traffic frequency is: %d",announcement.source.frequency));
	DBG_MSG(("[CDMMTunerAnnouncementProxy]: type %d",type));
	DBG_MSG(("[CDMMTunerAnnouncementProxy]: state %d",state));

	CTunerAnnouncementHandler::TAfreq = announcement.source.frequency;

	//CTunerAnnouncementHandler* mAnnouncement = CTunerAnnouncementHandler::getAnnouncementHandler();
	DBG_MSG(("the TA mode set currently is %d",mAnnouncement->getTAMode()));
	if((true == mAnnouncement->getTAMode()) && (types == "TA") && (true == states))
	{
		/*CTunerRespHandler* resp = new CTunerRespHandler();
		resp->handleNotif(signalName,data);*/
		DBG_MSG(("[CDMMTunerAnnouncementProxy]: sending TA available signal to HMI"));
		CTunerAnnouncementHandler::mAnnouncementState = true;
		states = false;
		CTunerRequestResponseHandler::handleNotif(signalName,data);
		//requestStartTune(src,false,1);
	}
	else if((false == mAnnouncement->getTAMode()) && (state == 5))
	{
		DBG_MSG(("[CDMMTunerAnnouncementProxy]:RequestAbort called since TA not enabled"));
		DMMTunerAnnouncement_StationSelector source;
	    source.deviceType = DMMTunerTypes_AMFM;
		source.id = 0;
		requestAbort(source,DMMTunerAnnouncement_ROAD_TRAFFIC,1 );

		DBG_MSG(("Inform AM/FM resource manager regarding the source switch to Entertainment source after cancelling of TA"));
	    proxy data;
	    data.token = TOKEN;
   	    data.srcType = DMMTunerAudio_SRC_ANNOUNCEMENT;
   	    data.snkSpeakerStatus = false;
   	    CTunerRequestResponseHandler::mAudioProxy->postInternalEvent(DMMTunerAudio_UPD_ID_requestSetCurrentSinks, (void*)&data);

   	   if(CTunerRequestResponseHandler::mLastSource == "dab")
   	   {
   	 	 data.srcType = (DMMTunerAudio_SourceType)0xFF;
   	 	 CTunerRequestResponseHandler::mAudioProxy->postInternalEvent(DMMTunerAudio_UPD_ID_requestSetCurrentSinks, (void*)&data);
   	 	 DBG_MSG(("Inform AM/FM resource manager regarding the source switch to dab source after TA"));
   	   }
   	   else if(CTunerRequestResponseHandler::mLastSource == "fm")
   	   {
           data.snkSpeakerStatus = true;
           data.srcType = DMMTunerAudio_SRC_ENTERTAINMENT;
           CTunerRequestResponseHandler::mAudioProxy->postInternalEvent(DMMTunerAudio_UPD_ID_requestSetCurrentSinks, (void*)&data);
   	   }
   	   else if(CTunerRequestResponseHandler::mLastSource == "am")
   	   {
           data.snkSpeakerStatus = true;
           data.srcType = DMMTunerAudio_SRC_ENTERTAINMENT;
           CTunerRequestResponseHandler::mAudioProxy->postInternalEvent(DMMTunerAudio_UPD_ID_requestSetCurrentSinks, (void*)&data);
   	   }
	}
}
