#ifndef CDMMTUNERANNOUNCEMENTSTUB_HPP
#define CDMMTUNERANNOUNCEMENTSTUB_HPP
/**********************************************************************
 *  Project       Harman Car Multimedia System
 *  (c) copyright 2013
 *  Company       Harman/Becker Automotive Systems GmbH
 *                All rights reserved
 **********************************************************************/

/*
 * Generated by DSI Generator version 2.0
 * Date: 6.5.2013
 */


#include "DMMTunerAnnouncementStub.h"

/**
 * DSI Stub: DMMTunerAnnouncement
 *
 * Tuner generic and project independent announcement interface. Via this interface announcements are indicated and can be controlled.
 */
class CDMMTunerAnnouncementStub : public DMMTunerAnnouncementStub
{
public:
   /**
    * Constructor.
    */
   CDMMTunerAnnouncementStub( );

   /**
    * Destructor.
    */
   virtual ~CDMMTunerAnnouncementStub();

   /**
    * Start the server
    */
   int start( const char* rolename );

   /**
    * Stop the server
    */
   void stop( int exitcode );

   /**
    * Called right before the stub thread ends
    */
   virtual void cleanup();

   /**
    * Set the filter for one announcement of one tuner device (enable/disable; priority).
    */
   virtual void requestSetFilter( const DMMTunerAnnouncement_Filter& filter,  unsigned int handle ) = 0 ;

   /**
    * Abort an active announcement
    */
   virtual void requestAbort( const DMMTunerAnnouncement_StationSelector& source,  DMMTunerAnnouncement_AnnouncementType type,  unsigned int handle ) = 0 ;

   /**
    * Starts tuning a frequency or selecting a station. 
    * NOTE: Use this method ONLY if YOUR component is in charge to tune to an active announcement, usually this is done by the tuner itself or by the announcement master component.  
    */
   virtual void requestStartTune( const DMMTunerAnnouncement_StationSelector& station,  DSIBool blockStation,  unsigned int handle ) = 0 ;

   /**
    * Device shall unblock new tune requests via DMMTunerStation interface and shall also restore latest requested station.
    * NOTE: Use this method ONLY if YOUR component is in charge to tune to an active announcement, usually this is done by the tuner itself or by the announcement master component.
    */
   virtual void requestUnblockStation( ) = 0 ;

   /**
    * Like setFilter but with the capability to set several filters at once
    */
   virtual void requestSetFilters( const DMMTunerAnnouncement_Filters filters,  unsigned int handle ) = 0 ;

   /**
    * Called when an internal event was sent to the server
    */
   virtual void processInternalEvent( int code, void* data ) {}

   /**
    * Result of filter setting request. This response is only sent if handle of setFilter is not equal to zero (notifcation has to be set explicitly).
    */
   void responseSetFilter(  unsigned int handle,  DMMTunerTypes_Feedback feedback );

   /**
    * Result of abort request. This response is only sent if handle of abort is not equal to zero (notifcation has to be set explicitly).
    */
   void responseAbort(  unsigned int handle,  DMMTunerTypes_Feedback feedback );

   /**
    * Result of startTune() request
    */
   void responseStartTune(  unsigned int handle,  DMMTunerTypes_Feedback feedback );

   /**
    * Current announcement information
    */
   void informationCurrentAnnouncement( const DMMTunerAnnouncement_Announcement& announcement );

   /**
    * Result of filters setting request. This response is only sent if handle of setFilters is not equal to zero (notifcation has to be set explicitly).
    */
   void responseSetFilters(  unsigned int handle, const DMMTunerTypes_Feedbacks feedbacks );


   void sendNotification( DMMTunerAnnouncement_UpdateIdEnum updateId );

   /**
    * Respond with an error message.
    */
   void sendError( DMMTunerAnnouncement_UpdateIdEnum id );

   int postInternalEvent( int code, void* data );
   int sendInternalEvent( int code, void* data );

private:

   /*
    * Duplicating not allowed
    */
   CDMMTunerAnnouncementStub( const CDMMTunerAnnouncementStub& ) {}
   CDMMTunerAnnouncementStub& operator= (const CDMMTunerAnnouncementStub& ) { return *this ; }
};

inline void CDMMTunerAnnouncementStub::sendNotification( DMMTunerAnnouncement_UpdateIdEnum updateId )
{
   DMMTunerAnnouncementStub_SendNotification( this, updateId );
}


inline void CDMMTunerAnnouncementStub::responseSetFilter(  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DMMTunerAnnouncement_ResponseSetFilter( (DMMTunerAnnouncementStub*)this, handle, feedback );
}

inline void CDMMTunerAnnouncementStub::responseAbort(  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DMMTunerAnnouncement_ResponseAbort( (DMMTunerAnnouncementStub*)this, handle, feedback );
}

inline void CDMMTunerAnnouncementStub::responseStartTune(  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DMMTunerAnnouncement_ResponseStartTune( (DMMTunerAnnouncementStub*)this, handle, feedback );
}

inline void CDMMTunerAnnouncementStub::informationCurrentAnnouncement( const DMMTunerAnnouncement_Announcement& announcement )
{
   DMMTunerAnnouncement_InformationCurrentAnnouncement( (DMMTunerAnnouncementStub*)this,  &announcement );
}

inline void CDMMTunerAnnouncementStub::responseSetFilters(  unsigned int handle, const DMMTunerTypes_Feedbacks feedbacks )
{
   DMMTunerAnnouncement_ResponseSetFilters( (DMMTunerAnnouncementStub*)this, handle, feedbacks );
}


#endif // CDMMTUNERANNOUNCEMENTSTUB_HPP


