 
/**********************************************************************
 *  Project       Harman Car Multimedia System
 *  (c) copyright 2014
 *  Company       Harman/Becker Automotive Systems GmbH
 *                All rights reserved
 **********************************************************************/

/*
 * Generated by DSI Generator version 2.0
 * Date: 21.11.2014
 */


#include "CDMMTunerAudioProxy.hpp"
#include <string.h>
#include "TraceMacros.hpp"
#include <iostream.h>
#include "CTunerRequestResponseHandler.hpp"
#include <iostream>
#include<fstream>
#include "TraceMacros.hpp"

TRC_SCOPE_DEF(TunerService, CDMMTunerAudioProxy, ComponentConnected);
TRC_SCOPE_DEF(TunerService, CDMMTunerAudioProxy, componentDisconnected);
static pthread_mutex_t  myMtx;

TRC_SCOPE_DEF(TunerService, CDMMTunerAudioProxy, processInternalEvent);
TRC_SCOPE_DEF(TunerService, CDMMTunerAudioProxy, componentConnected);
TRC_SCOPE_DEF(TunerService, CDMMTunerAudioProxy, responseSetCurrentSinks);
bool CDMMTunerAudioProxy::spkStatus = true;

static void _responseSetSourceActivity( DMMTunerAudioProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerAudioProxy*)proxy)->responseSetSourceActivity( handle, feedback ) ;
}

static void _responseEnableSourceMute( DMMTunerAudioProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerAudioProxy*)proxy)->responseEnableSourceMute( handle, feedback ) ;
}

static void _responseSetCurrentSinks( DMMTunerAudioProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerAudioProxy*)proxy)->responseSetCurrentSinks( handle, feedback ) ;
}

static void _processInternalEvent( DMMTunerAudioProxy* proxy, int code, void* data )
{
   ((CDMMTunerAudioProxy*)proxy)->processInternalEvent( code,  data ) ;
}

static void _processUpdateEvent( DMMTunerAudioProxy* proxy, DMMTunerAudio_UpdateIdEnum updateId )
{
   ((CDMMTunerAudioProxy*)proxy)->processUpdateEvent( updateId ) ;
}

static void _componentConnected( DMMTunerAudioProxy* proxy )
{
   ((CDMMTunerAudioProxy*)proxy)->componentConnected( ) ;
}

static void _componentDisconnected( DMMTunerAudioProxy* proxy )
{
   ((CDMMTunerAudioProxy*)proxy)->componentDisconnected( ) ;
}

static void _cleanup( DMMTunerAudioProxy* proxy )
{
   ((CDMMTunerAudioProxy*)proxy)->cleanup( ) ;
}

static void _responseInvalid( DMMTunerAudioProxy* proxy, DMMTunerAudio_UpdateIdEnum id )
{
   ((CDMMTunerAudioProxy*)proxy)->responseInvalid( id );
}

static void _requestSetSourceActivityFailed( DMMTunerAudioProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerAudioProxy*)proxy)->requestSetSourceActivityFailed( errType );
}

static void _requestEnableSourceMuteFailed( DMMTunerAudioProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerAudioProxy*)proxy)->requestEnableSourceMuteFailed( errType );
}

static void _requestSetCurrentSinksFailed( DMMTunerAudioProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerAudioProxy*)proxy)->requestSetCurrentSinksFailed( errType );
}


CDMMTunerAudioProxy::CDMMTunerAudioProxy( )
{
   memset( (DMMTunerAudioProxy*)this, 0, sizeof(DMMTunerAudioProxy) );

   fnResponseSetSourceActivity = _responseSetSourceActivity ;
   fnResponseEnableSourceMute = _responseEnableSourceMute ;
   fnResponseSetCurrentSinks = _responseSetCurrentSinks ;

   fnRequestSetSourceActivityFailed = _requestSetSourceActivityFailed ;
   fnRequestEnableSourceMuteFailed = _requestEnableSourceMuteFailed ;
   fnRequestSetCurrentSinksFailed = _requestSetCurrentSinksFailed ;

   fnProcessInternalEvent = _processInternalEvent ;
   fnProcessUpdateEvent = _processUpdateEvent ;
   fnComponentConnected = _componentConnected ;
   fnComponentDisconnected = _componentDisconnected ;
   fnResponseInvalid = _responseInvalid ;
   fnCleanup = _cleanup ;
}

CDMMTunerAudioProxy::~CDMMTunerAudioProxy()
{
}

int CDMMTunerAudioProxy::start( const char* rolename )
{
   return DMMTunerAudioProxy_Start( this, rolename ) ;
}

void CDMMTunerAudioProxy::stop( int exitcode )
{
   DMMTunerAudioProxy_Stop( this, exitcode );
}

int CDMMTunerAudioProxy::postInternalEvent( int code, void* data )
{
   return DSIPostInternalEvent( client.Channel.Master, client.Id, 0, code, data );
}

int CDMMTunerAudioProxy::sendInternalEvent( int code, void* data )
{
   return DSISendInternalEvent( client.Channel.Master, client.Id, 0, code, data );
}

void CDMMTunerAudioProxy::cleanup()
{
}



void CDMMTunerAudioProxy::componentConnected( )
{
	TRC_SCOPE(TunerService, CDMMTunerAudioProxy, ComponentConnected);

	DBG_MSG(("In CDMMTunerAudioProxy::Component Connected !!!!!!!!!!!"));
	setNotification(DMMTunerAudio_UPD_ID_responseSetCurrentSinks);
	DBG_MSG(("Dirana control component connected called !!!\n"));
	//printf("Dirana control component connected called\n");
	std::string sig = "diranaFlashStatus";
	Json::Value obj;
	obj[""] = "";
	CTunerRequestResponseHandler::handleNotif(sig,obj);
	//printf("Dirana control marker file to be created\n");
	ofstream f("/tmp/D3_Ready");
	DBG_MSG(("Dirana control marker file to be created !!!\n"));
    f.close();
    CDMMAmFmTunerDiranaControlProxy::D3status = true;

}

void CDMMTunerAudioProxy::processInternalEvent( int code, void* data )
{
	TRC_SCOPE(TunerService, CDMMTunerAudioProxy, processInternalEvent);

	DBG_MSG(("In CDMMTunerAudioProxy::processInternalEvent !!!!!!!!!!!"));

   switch(code)
   {
      case DMMTunerAudio_UPD_ID_requestSetCurrentSinks:
	  {
		  DBG_MSG(("Setting source as Entertainment in CDMMTunerAudioProxy !!!!!!!!!!!"));
          proxy info = *(proxy*)data;
		  pthread_mutex_lock( &myMtx );
		  UINT32 handle = info.token;
		  DMMTunerAudio_SourceType src = info.srcType;
		//  bool status = info.snkSpeakerStatus;
		  bool status = spkStatus;
		  DBG_MSG(("CDMMTunerAudioProxy::Address received is %x and speaker status is %d",(proxy*)data,status));
		  pthread_mutex_unlock(&myMtx);
		  if(src == 0xFF)
		  {
			  DBG_MSG(("Value of source is 0xFF !!!!!!"));
			  DMMTunerAudio_SinkTypes sinkType = 0;
			  //DSIVectorAlloc( sinkType, 1 );//lint !e449
			  //sinkType->data[0] = (DMMTunerAudio_SinkType) -1;
			  DBG_MSG(("Put the AM/FM source activity to OFF - source switch happened !!!"));
			  requestSetCurrentSinks(DMMTunerAudio_SRC_ENTERTAINMENT, sinkType, handle);
		  }
		  else
		  {
			  if(false == status)
			  {
				  DBG_MSG(("Setting sink to empty on completion of TA"));
				  DBG_MSG(("Value of source is %d !!!!!!", src));
				  //proxy datas;
				  //datas.taStatus = true;
				  DMMTunerAudio_SinkTypes sinkType = 0;
				  //DSIVectorAlloc( sinkType, 1 );//lint !e449
				  DBG_MSG(("Sink type set is OFF after TA !!!!!!!!"));
				  requestSetCurrentSinks(src, sinkType , handle);
			  }
			  else
			  {
			   DBG_MSG(("Setting sink to speakers on start of TA/AM/FM"));
			   DBG_MSG(("Value of source is %d !!!!!!", src));

			   DMMTunerAudio_SinkTypes sinkType = 0;
			   DSIVectorAlloc( sinkType, 1 );//lint !e449
			   //DSIVectorPush(sinkType,DMMTunerAudio_SNK_SPEAKERS);
			   sinkType->data[0] = DMMTunerAudio_SNK_SPEAKERS;

			   DBG_MSG(("Sink type set is DMMTunerAudio_SNK_SPEAKERS !!!!!!!!"));
	           requestSetCurrentSinks(src, sinkType , handle);
			  }
		  }
		  break;
	  }
      default:
      {
         break;
      }
   }
}

void CDMMTunerAudioProxy::responseSetCurrentSinks(  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
	TRC_SCOPE(TunerService, CDMMTunerAudioProxy, responseSetCurrentSinks);
	int result = 2;
		switch(feedback)
		{
		case DMMTunerTypes_DONE:
			DBG_MSG(("Request was set successfully ... "));
			result = 0;
			break;
		case DMMTunerTypes_INTERRUPTED:
			DBG_MSG(("Request was interrupted by another request"));
			result = 1;
		    break;
		case DMMTunerTypes_NOT_APPLICABLE:
			DBG_MSG(("Request not supported"));
			result = 2;
		    break;
		case DMMTunerTypes_ALREADY_SET:
			DBG_MSG(("Request had no effect  - not used consequently"));
			result = 1;
			break;
		case DMMTunerTypes_FAILURE:
			DBG_MSG(("Request was not successful because of invalid parameters"));
			result = 3;
			break;
		case DMMTunerTypes_DELAYED:
			DBG_MSG(("Done but result will be delayed - e.g. device currently blocked"));
			result = 1;
			break;
		default:
			DBG_MSG(("ERROR"));
			break;
		}
	   std::string signalName = "requestStatus";
	   Json::Value res;
	   res["status"] = result;
	   res["description"] = "Status";
	   res["type"] = "setCurrentSink";
	   CTunerRequestResponseHandler::handleNotif(signalName,res);
}

