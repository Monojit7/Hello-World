/**********************************************************************
 *  Project       Harman Car Multimedia System
 *  (c) copyright 2015
 *  Company       Harman/Becker Automotive Systems GmbH
 *                All rights reserved
 **********************************************************************/

/*
 * Generated by DSI Generator version 2.0
 * Date: 15.1.2015
 */

struct _DMMTunerAudioStub ;
#define TDSIServer struct _DMMTunerAudioStub

#define DSICONST

#include "DMMTunerAudioStub.h"
#include <string.h>
#include <stdio.h>
#include <malloc.h>
#include <assert.h>

#ifdef _WIN32
#define snprintf _snprintf
#endif

static const char* SERVER_NAME = "DMMTunerAudio" ;
static const int SERVER_MAJOR_VERSION = 1 ;
static const int SERVER_MINOR_VERSION = 1 ;

static int WriteAttribute( DMMTunerAudioStub* stub, DSIStream* stream, unsigned int id, DSIUpdateType type, short position, short count )
{
   int success = 0 ;
   if (stub == 0)
   {
      return success;
   }

   // avoid unused variables
   (void)type;(void)position;(void)count;

   switch( (DMMTunerAudio_UpdateIdEnum)id )
   {
   case DMMTunerAudio_UPD_ID_audioAvailability:
      DSIWrite32( stream, &stub->audioAvailability );
      success = 1 ;
      break;

   case DMMTunerAudio_UPD_ID_implVersion:
      DSIWrite( stream, &stub->implVersion, sizeof(stub->implVersion), 1 );
      success = 1 ;
      break;

   default:
      assert( 0 ) ;  //lint !e506 Constant value Boolean  bad response id
      break;
   }
   return success ;
}




static void ProcessRequest( DMMTunerAudioStub* stub, DSIStream* stream, unsigned int id )
{
   if (stub == 0)
   {
      return;
   }
   switch( (DMMTunerAudio_UpdateIdEnum)id )
   {
   case DMMTunerAudio_UPD_ID_requestSetSourceActivity:
      {
         DMMTunerAudio_SourceActivity activity = 0 ;
         unsigned char sourceNumber = 0 ;
         unsigned int handle = 0 ;
         DSIRead32( stream, &activity ) ;
         DSIRead8( stream, &sourceNumber ) ;
         DSIRead32( stream, &handle ) ;
         if( 0 != stub->fnRequestSetSourceActivity )
         {
            stub->fnRequestSetSourceActivity( stub, activity, sourceNumber, handle );
         }
      }
      break;

   case DMMTunerAudio_UPD_ID_requestEnableSourceMute:
      {
         DSIBool mute = 0 ;
         unsigned int handle = 0 ;
         DSIReadBool( stream, &mute ) ;
         DSIRead32( stream, &handle ) ;
         if( 0 != stub->fnRequestEnableSourceMute )
         {
            stub->fnRequestEnableSourceMute( stub, mute, handle );
         }
      }
      break;

   case DMMTunerAudio_UPD_ID_requestSetCurrentSinks:
      {
         DMMTunerAudio_SourceType sourceType = 0 ;
         DMMTunerAudio_SinkTypes sinkTypes = 0 ;
         unsigned int handle = 0 ;
         DSIRead32( stream, &sourceType ) ;
         DSIReadDMMTunerAudio_SinkTypes( stream, &sinkTypes ) ;
         DSIRead32( stream, &handle ) ;
         if( 0 != stub->fnRequestSetCurrentSinks )
         {
            stub->fnRequestSetCurrentSinks( stub, sourceType, sinkTypes, handle );
         }
         if( 0 != stub->fnRequestSetCurrentSinksEx )
         {
            stub->fnRequestSetCurrentSinksEx( stub, sourceType, DSIVectorData( sinkTypes ), DSIVectorSize( sinkTypes ), handle );
         }
         DMMTunerAudio_SinkTypes_Free( &sinkTypes );
      }
      break;

   default:
      break;
   }
}




void DMMTunerAudio_ResponseSetSourceActivity( DMMTunerAudioStub* stub,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &handle ) ;
   DSIWrite32( &stream, &feedback ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerAudio_UPD_ID_responseSetSourceActivity, &stream );
   DSIClose( &stream );
}

void DMMTunerAudio_ResponseEnableSourceMute( DMMTunerAudioStub* stub,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &handle ) ;
   DSIWrite32( &stream, &feedback ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerAudio_UPD_ID_responseEnableSourceMute, &stream );
   DSIClose( &stream );
}

void DMMTunerAudio_ResponseSetCurrentSinks( DMMTunerAudioStub* stub,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &handle ) ;
   DSIWrite32( &stream, &feedback ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerAudio_UPD_ID_responseSetCurrentSinks, &stream );
   DSIClose( &stream );
}


static void ProcessInternalEvent( DMMTunerAudioStub* stub, int code, void* data )
{
   if( stub && stub->fnProcessInternalEvent )
   {
      stub->fnProcessInternalEvent( stub, code, data );
   }
}

void DMMTunerAudioStub_SendNotification( DMMTunerAudioStub* stub, DMMTunerAudio_UpdateIdEnum id )
{
   DSIServerSendNotification( stub, id );
}

static void Cleanup( DMMTunerAudioStub* stub )
{
   if( stub && stub->fnCleanup )
   {
      stub->fnCleanup( stub );
   }
}

static int GetResponse( DMMTunerAudioStub* stub, int requestId )
{
   DMMTunerAudio_UpdateIdEnum responseId = DMMTunerAudio_UPD_ID_NOP ;


   return (responseId == DMMTunerAudio_UPD_ID_NOP) ? DSI_INVALID_ID : (int)responseId ;
}

int DMMTunerAudioStub_Init( DMMTunerAudioStub* stub, const char* rolename )
{
   DSIInit();
   if (stub)
   {
      memset( stub, 0, sizeof(*stub));
   }
   DSIServerInit( stub, SERVER_NAME, rolename, SERVER_MAJOR_VERSION, SERVER_MINOR_VERSION );
   if (stub)
   {
      stub->server.fnWriteAttribute = WriteAttribute ;
      stub->server.fnProcessRequest = ProcessRequest ;
      stub->server.fnProcessInternalEvent = ProcessInternalEvent ;
      stub->server.fnCleanup = Cleanup ;
      stub->server.fnGetResponse = GetResponse ;
   }
   return 0;
}

void DMMTunerAudioStub_Free( DMMTunerAudioStub* stub  )
{
   if (stub == 0)
   {
      return;
   }
   DSIServerFree( stub );
   memset( stub, 0, sizeof(*stub) );
}

int DMMTunerAudioStub_Start( DMMTunerAudioStub* stub, const char* rolename )
{
   DSIInit();
   if (stub == 0)
   {
      return 0;
   }
   // check if all request function pointers are valid
   assert( 0 != stub->fnRequestSetSourceActivity  );
   assert( 0 != stub->fnRequestEnableSourceMute  );
   assert( 0 != stub->fnRequestSetCurrentSinks || 0 != stub->fnRequestSetCurrentSinksEx );

   DSIServerInit( stub, SERVER_NAME, rolename, SERVER_MAJOR_VERSION, SERVER_MINOR_VERSION );
   stub->server.fnWriteAttribute = WriteAttribute ;
   stub->server.fnProcessRequest = ProcessRequest ;
   stub->server.fnProcessInternalEvent = ProcessInternalEvent ;
   stub->server.fnCleanup = Cleanup ;
   stub->server.fnGetResponse = GetResponse ;
   return DSIServerRun( stub );
}


int DMMTunerAudioStub_Stop( DMMTunerAudioStub* stub, int exitcode )
{
	return DSIServerStop( stub, exitcode );
}


void DMMTunerAudioSendError( DMMTunerAudioStub* stub, DMMTunerAudio_UpdateIdEnum id )
{
   DSIStream stream;
   DSIResultType typ = RESULT_REQUEST_ERROR;

   if ( IS_RESPONSE_ID(id) )
      typ = RESULT_INVALID;
   else if ( IS_ATTRIBUTE_ID(id) )
      typ = RESULT_DATA_INVALID;

   DSIOpen( &stream );
   DSIServerSendResponse( stub, typ, id, &stream );
   DSIClose( &stream );
}


int DMMTunerAudioStub_PostInternalEvent( DMMTunerAudioStub* stub, int code, void* data )
{
   if (stub)
	   return DSIPostInternalEvent( stub->server.Channel.Master, stub->server.Id, 0, code, data );
   else
      return -1;
}


int DMMTunerAudioStub_SendInternalEvent( DMMTunerAudioStub* stub, int code, void* data )
{
   if (stub)
   {
      if (stub->server.SendChid)
      {
          return DSISendInternalEvent( stub->server.SendChid, stub->server.Id, 0, code, data );

      }
      else
      {

   	   return DSISendInternalEvent( stub->server.Channel.Master, stub->server.Id, 0, code, data );
      }
   }
   else
      return -1;
}


