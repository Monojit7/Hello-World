/**********************************************************************
 *  Project       Harman Car Multimedia System
 *  (c) copyright 2014
 *  Company       Harman/Becker Automotive Systems GmbH
 *                All rights reserved
 **********************************************************************/

/*
 * Generated by DSI Generator version 2.0
 * Date: 21.11.2014
 */

struct _DMMAmFmTunerDiranaControlStub ;
#define TDSIServer struct _DMMAmFmTunerDiranaControlStub

#define DSICONST

#include "DMMAmFmTunerDiranaControlStub.h"
#include <string.h>
#include <stdio.h>
#include <malloc.h>
#include <assert.h>

#ifdef _WIN32
#define snprintf _snprintf
#endif

static const char* SERVER_NAME = "DMMAmFmTunerDiranaControl" ;
static const int SERVER_MAJOR_VERSION = 1 ;
static const int SERVER_MINOR_VERSION = 1 ;

static int WriteAttribute( DMMAmFmTunerDiranaControlStub* stub, DSIStream* stream, unsigned int id, DSIUpdateType type, short position, short count )
{
   int success = 0 ;
   if (stub == 0)
   {
      return success;
   }

   // avoid unused variables
   (void)type;(void)position;(void)count;

   return success ;
}




static void ProcessRequest( DMMAmFmTunerDiranaControlStub* stub, DSIStream* stream, unsigned int id )
{
   if (stub == 0)
   {
      return;
   }
   switch( (DMMAmFmTunerDiranaControl_UpdateIdEnum)id )
   {
   case DMMAmFmTunerDiranaControl_UPD_ID_requestSetAudioRouting:
      {
         DMMAmFmTunerDiranaControl_AudioInputs input = 0 ;
         DMMAmFmTunerDiranaControl_AudioOutputs output = 0 ;
         DSIRead32( stream, &input ) ;
         DSIRead32( stream, &output ) ;
         if( 0 != stub->fnRequestSetAudioRouting )
         {
            stub->fnRequestSetAudioRouting( stub, input, output );
         }
      }
      break;

   case DMMAmFmTunerDiranaControl_UPD_ID_requestGetAudioRouting:
      {
         DMMAmFmTunerDiranaControl_AudioOutputs output = 0 ;
         DSIRead32( stream, &output ) ;
         if( 0 != stub->fnRequestGetAudioRouting )
         {
            stub->fnRequestGetAudioRouting( stub, output );
         }
      }
      break;

   case DMMAmFmTunerDiranaControl_UPD_ID_requestWriteXMem:
      {
         unsigned int memAddress = 0 ;
         unsigned int memValueX = 0 ;
         DSIRead32( stream, &memAddress ) ;
         DSIRead32( stream, &memValueX ) ;
         if( 0 != stub->fnRequestWriteXMem )
         {
            stub->fnRequestWriteXMem( stub, memAddress, memValueX );
         }
      }
      break;

   case DMMAmFmTunerDiranaControl_UPD_ID_requestReadXMem:
      {
         unsigned int memAddress = 0 ;
         DSIRead32( stream, &memAddress ) ;
         if( 0 != stub->fnRequestReadXMem )
         {
            stub->fnRequestReadXMem( stub, memAddress );
         }
      }
      break;

   case DMMAmFmTunerDiranaControl_UPD_ID_requestWriteYMem:
      {
         unsigned int memAddress = 0 ;
         unsigned short memValueY = 0 ;
         DSIRead32( stream, &memAddress ) ;
         DSIRead16( stream, &memValueY ) ;
         if( 0 != stub->fnRequestWriteYMem )
         {
            stub->fnRequestWriteYMem( stub, memAddress, memValueY );
         }
      }
      break;

   case DMMAmFmTunerDiranaControl_UPD_ID_requestReadYMem:
      {
         unsigned int memAddress = 0 ;
         DSIRead32( stream, &memAddress ) ;
         if( 0 != stub->fnRequestReadYMem )
         {
            stub->fnRequestReadYMem( stub, memAddress );
         }
      }
      break;

   default:
      break;
   }
}




void DMMAmFmTunerDiranaControl_ResponseSetAudioRouting( DMMAmFmTunerDiranaControlStub* stub,  DMMAmFmTunerDiranaControl_Result result )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &result ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMAmFmTunerDiranaControl_UPD_ID_responseSetAudioRouting, &stream );
   DSIClose( &stream );
}

void DMMAmFmTunerDiranaControl_ResponseGetAudioRouting( DMMAmFmTunerDiranaControlStub* stub,  DMMAmFmTunerDiranaControl_AudioInputs input )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &input ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMAmFmTunerDiranaControl_UPD_ID_responseGetAudioRouting, &stream );
   DSIClose( &stream );
}

void DMMAmFmTunerDiranaControl_ResponseReadXMem( DMMAmFmTunerDiranaControlStub* stub,  DMMAmFmTunerDiranaControl_Result result,  unsigned int memValueX )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &result ) ;
   DSIWrite32( &stream, &memValueX ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMAmFmTunerDiranaControl_UPD_ID_responseReadXMem, &stream );
   DSIClose( &stream );
}

void DMMAmFmTunerDiranaControl_ResponseWriteXMem( DMMAmFmTunerDiranaControlStub* stub,  DMMAmFmTunerDiranaControl_Result result )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &result ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMAmFmTunerDiranaControl_UPD_ID_responseWriteXMem, &stream );
   DSIClose( &stream );
}

void DMMAmFmTunerDiranaControl_ResponseReadYMem( DMMAmFmTunerDiranaControlStub* stub,  DMMAmFmTunerDiranaControl_Result result,  unsigned short memValueY )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &result ) ;
   DSIWrite16( &stream, &memValueY ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMAmFmTunerDiranaControl_UPD_ID_responseReadYMem, &stream );
   DSIClose( &stream );
}

void DMMAmFmTunerDiranaControl_ResponseWriteYMem( DMMAmFmTunerDiranaControlStub* stub,  DMMAmFmTunerDiranaControl_Result result )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &result ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMAmFmTunerDiranaControl_UPD_ID_responseWriteYMem, &stream );
   DSIClose( &stream );
}


static void ProcessInternalEvent( DMMAmFmTunerDiranaControlStub* stub, int code, void* data )
{
   if( stub && stub->fnProcessInternalEvent )
   {
      stub->fnProcessInternalEvent( stub, code, data );
   }
}

void DMMAmFmTunerDiranaControlStub_SendNotification( DMMAmFmTunerDiranaControlStub* stub, DMMAmFmTunerDiranaControl_UpdateIdEnum id )
{
   DSIServerSendNotification( stub, id );
}

static void Cleanup( DMMAmFmTunerDiranaControlStub* stub )
{
   if( stub && stub->fnCleanup )
   {
      stub->fnCleanup( stub );
   }
}

static int GetResponse( DMMAmFmTunerDiranaControlStub* stub, int requestId )
{
   DMMAmFmTunerDiranaControl_UpdateIdEnum responseId = DMMAmFmTunerDiranaControl_UPD_ID_NOP ;


   return (responseId == DMMAmFmTunerDiranaControl_UPD_ID_NOP) ? DSI_INVALID_ID : (int)responseId ;
}

int DMMAmFmTunerDiranaControlStub_Init( DMMAmFmTunerDiranaControlStub* stub, const char* rolename )
{
   DSIInit();
   if (stub)
   {
      memset( stub, 0, sizeof(*stub));
   }
   DSIServerInit( stub, SERVER_NAME, rolename, SERVER_MAJOR_VERSION, SERVER_MINOR_VERSION );
   if (stub)
   {
      stub->server.fnWriteAttribute = WriteAttribute ;
      stub->server.fnProcessRequest = ProcessRequest ;
      stub->server.fnProcessInternalEvent = ProcessInternalEvent ;
      stub->server.fnCleanup = Cleanup ;
      stub->server.fnGetResponse = GetResponse ;
   }
   return 0;
}

void DMMAmFmTunerDiranaControlStub_Free( DMMAmFmTunerDiranaControlStub* stub  )
{
   if (stub == 0)
   {
      return;
   }
   DSIServerFree( stub );
   memset( stub, 0, sizeof(*stub) );
}

int DMMAmFmTunerDiranaControlStub_Start( DMMAmFmTunerDiranaControlStub* stub, const char* rolename )
{
   DSIInit();
   if (stub == 0)
   {
      return 0;
   }
   // check if all request function pointers are valid
   assert( 0 != stub->fnRequestSetAudioRouting  );
   assert( 0 != stub->fnRequestGetAudioRouting  );
   assert( 0 != stub->fnRequestWriteXMem  );
   assert( 0 != stub->fnRequestReadXMem  );
   assert( 0 != stub->fnRequestWriteYMem  );
   assert( 0 != stub->fnRequestReadYMem  );

   DSIServerInit( stub, SERVER_NAME, rolename, SERVER_MAJOR_VERSION, SERVER_MINOR_VERSION );
   stub->server.fnWriteAttribute = WriteAttribute ;
   stub->server.fnProcessRequest = ProcessRequest ;
   stub->server.fnProcessInternalEvent = ProcessInternalEvent ;
   stub->server.fnCleanup = Cleanup ;
   stub->server.fnGetResponse = GetResponse ;
   return DSIServerRun( stub );
}


int DMMAmFmTunerDiranaControlStub_Stop( DMMAmFmTunerDiranaControlStub* stub, int exitcode )
{
	return DSIServerStop( stub, exitcode );
}


void DMMAmFmTunerDiranaControlSendError( DMMAmFmTunerDiranaControlStub* stub, DMMAmFmTunerDiranaControl_UpdateIdEnum id )
{
   DSIStream stream;
   DSIResultType typ = RESULT_REQUEST_ERROR;

   if ( IS_RESPONSE_ID(id) )
      typ = RESULT_INVALID;
   else if ( IS_ATTRIBUTE_ID(id) )
      typ = RESULT_DATA_INVALID;

   DSIOpen( &stream );
   DSIServerSendResponse( stub, typ, id, &stream );
   DSIClose( &stream );
}


int DMMAmFmTunerDiranaControlStub_PostInternalEvent( DMMAmFmTunerDiranaControlStub* stub, int code, void* data )
{
   if (stub)
	   return DSIPostInternalEvent( stub->server.Channel.Master, stub->server.Id, 0, code, data );
   else
      return -1;
}


int DMMAmFmTunerDiranaControlStub_SendInternalEvent( DMMAmFmTunerDiranaControlStub* stub, int code, void* data )
{
   if (stub)
   {
      if (stub->server.SendChid)
      {
          return DSISendInternalEvent( stub->server.SendChid, stub->server.Id, 0, code, data );

      }
      else
      {

   	   return DSISendInternalEvent( stub->server.Channel.Master, stub->server.Id, 0, code, data );
      }
   }
   else
      return -1;
}


