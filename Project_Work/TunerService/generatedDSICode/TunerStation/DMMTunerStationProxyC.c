/**********************************************************************
 *  Project       Harman Car Multimedia System
 *  (c) copyright 2015
 *  Company       Harman/Becker Automotive Systems GmbH
 *                All rights reserved
 **********************************************************************/

/*
 * Generated by DSI Generator version 2.0
 * Date: 20.5.2015
 */


struct _DMMTunerStationProxy ;
#define TDSIClient struct _DMMTunerStationProxy

/*
 * Remove the const from the attributes for this module.
 */
#define DSICONST


#include "DMMTunerStationProxy.h"

static const char* SERVER_NAME = "DMMTunerStation" ;
static const int SERVER_MAJOR_VERSION = 7 ;
static const int SERVER_MINOR_VERSION = 0 ;


static void DMMTunerStationReadErrorEnumerator( DMMTunerStationProxy* proxy, DSIStream* stream )
{
   (void)proxy;
}


static void ProcessResponse( DMMTunerStationProxy* proxy, DSIStream* stream, const EventInfo* event )
{
    if ((event == 0) || (proxy == 0))
      return;
   if( event->responseType == RESULT_INVALID )
   {
      DMMTunerStationReadErrorEnumerator( proxy, stream );

      if( proxy->fnResponseInvalid )
      {
         proxy->fnResponseInvalid( proxy, (DMMTunerStation_UpdateIdEnum)event->requestID );
      }
   }
   else if( event->responseType == RESULT_REQUEST_ERROR
           || event->responseType == RESULT_REQUEST_BUSY
           || event->responseType == RESULT_NOP )   // FIXME remove when MoCCA is fixed
   {
      DMMTunerStationReadErrorEnumerator( proxy, stream );

      switch( event->requestID )
      {
      case DMMTunerStation_UPD_ID_requestStartTune:
         if( proxy->fnRequestStartTuneFailed )
         {
            proxy->fnRequestStartTuneFailed( proxy, (DSIResultType)event->responseType );
         }
         break;

      case DMMTunerStation_UPD_ID_requestControlSeek:
         if( proxy->fnRequestControlSeekFailed )
         {
            proxy->fnRequestControlSeekFailed( proxy, (DSIResultType)event->responseType );
         }
         break;

      case DMMTunerStation_UPD_ID_requestAbortTune:
         if( proxy->fnRequestAbortTuneFailed )
         {
            proxy->fnRequestAbortTuneFailed( proxy, (DSIResultType)event->responseType );
         }
         break;

      case DMMTunerStation_UPD_ID_requestForceUpdate:
         if( proxy->fnRequestForceUpdateFailed )
         {
            proxy->fnRequestForceUpdateFailed( proxy, (DSIResultType)event->responseType );
         }
         break;

      case DMMTunerStation_UPD_ID_requestMakePersistent:
         if( proxy->fnRequestMakePersistentFailed )
         {
            proxy->fnRequestMakePersistentFailed( proxy, (DSIResultType)event->responseType );
         }
         break;

      default:
         assert( 0 ); //lint !e506 Constant value Boolean
         break;
      }
   }
   else
   {
      int bSendEvent = 0 ;
      switch( event->requestID )
      {
      case DMMTunerStation_UPD_ID_informationCurrentStation:
         {
            DMMTunerStation_Station current ;
            unsigned int handle = 0 ;
            memset( &current, 0, sizeof(current) )  ;
            DSIReadDMMTunerStation_Station( stream, &current ) ;
            DSIRead32( stream, &handle ) ;
            if( proxy->fnInformationCurrentStation )
            {
               proxy->fnInformationCurrentStation( proxy,  &current, handle );
            }
            DMMTunerStation_Station_Free( &current );
         }
         break;

      case DMMTunerStation_UPD_ID_informationStationList:
         {
            DMMTunerStation_StationList list ;
            unsigned int handle = 0 ;
            memset( &list, 0, sizeof(list) )  ;
            DSIReadDMMTunerStation_StationList( stream, &list ) ;
            DSIRead32( stream, &handle ) ;
            if( proxy->fnInformationStationList )
            {
               proxy->fnInformationStationList( proxy,  &list, handle );
            }
            DMMTunerStation_StationList_Free( &list );
         }
         break;

      case DMMTunerStation_UPD_ID_informationSeek:
         {
            DMMTunerStation_SeekData seekData ;
            unsigned int handle = 0 ;
            memset( &seekData, 0, sizeof(seekData) )  ;
            DSIReadDMMTunerStation_SeekData( stream, &seekData ) ;
            DSIRead32( stream, &handle ) ;
            if( proxy->fnInformationSeek )
            {
               proxy->fnInformationSeek( proxy,  &seekData, handle );
            }
            DMMTunerStation_SeekData_Free( &seekData );
         }
         break;

      case DMMTunerStation_UPD_ID_responseStartTune:
         {
            unsigned int handle = 0 ;
            DMMTunerTypes_Feedback feedback = 0 ;
            DSIRead32( stream, &handle ) ;
            DSIRead32( stream, &feedback ) ;
            if( proxy->fnResponseStartTune )
            {
               proxy->fnResponseStartTune( proxy, handle, feedback );
            }
         }
         break;

      case DMMTunerStation_UPD_ID_responseAbortTune:
         {
            unsigned int handle = 0 ;
            DMMTunerTypes_Feedback feedback = 0 ;
            DSIRead32( stream, &handle ) ;
            DSIRead32( stream, &feedback ) ;
            if( proxy->fnResponseAbortTune )
            {
               proxy->fnResponseAbortTune( proxy, handle, feedback );
            }
         }
         break;

      case DMMTunerStation_UPD_ID_responseControlSeek:
         {
            unsigned int handle = 0 ;
            DMMTunerTypes_Feedback feedback = 0 ;
            DSIRead32( stream, &handle ) ;
            DSIRead32( stream, &feedback ) ;
            if( proxy->fnResponseControlSeek )
            {
               proxy->fnResponseControlSeek( proxy, handle, feedback );
            }
         }
         break;

      case DMMTunerStation_UPD_ID_responseMakePersistent:
         {
            unsigned int handle = 0 ;
            DMMTunerTypes_Feedback feedback = 0 ;
            DSIRead32( stream, &handle ) ;
            DSIRead32( stream, &feedback ) ;
            if( proxy->fnResponseMakePersistent )
            {
               proxy->fnResponseMakePersistent( proxy, handle, feedback );
            }
         }
         break;

      case DMMTunerStation_UPD_ID_responseForceUpdate:
         {
            unsigned int handle = 0 ;
            DMMTunerTypes_Feedback feedback = 0 ;
            DSIRead32( stream, &handle ) ;
            DSIRead32( stream, &feedback ) ;
            if( proxy->fnResponseForceUpdate )
            {
               proxy->fnResponseForceUpdate( proxy, handle, feedback );
            }
         }
         break;

      default:
         assert( 0 ); //lint !e506 Constant value Boolean unknown update id
         break;
      }

      if( bSendEvent && proxy->fnProcessUpdateEvent )
      {
         // notify the user about the update
         proxy->fnProcessUpdateEvent( proxy, (DMMTunerStation_UpdateIdEnum)event->requestID );
      }
   }
}

int DMMTunerStation_RequestStartTune( DMMTunerStationProxy* proxy, const DMMTunerTypes_StationSelector* station,  unsigned int handle,  DMMTunerStation_SelectionMode selectionMode )
{
   int seqNr = DSICreateId();
   DSIStream stream ;
   DSIOpen( &stream );   
   DSIWriteDMMTunerTypes_StationSelector( &stream, station ) ;      
   DSIWrite32( &stream, &handle ) ;   
   DSIWrite32( &stream, &selectionMode ) ;
   DSIClientSendRequest( proxy, DMMTunerStation_UPD_ID_requestStartTune, seqNr, &stream );
   DSIClose( &stream );
   return seqNr ;
}



int DMMTunerStation_RequestControlSeek( DMMTunerStationProxy* proxy,  DMMTunerTypes_DeviceType device,  DMMTunerStation_SeekMode seekMode,  unsigned int genre,  unsigned int flags,  unsigned int handle )
{
   int seqNr = DSICreateId();
   DSIStream stream ;
   DSIOpen( &stream );   
   DSIWrite32( &stream, &device ) ;   
   DSIWrite32( &stream, &seekMode ) ;   
   DSIWrite32( &stream, &genre ) ;   
   DSIWrite32( &stream, &flags ) ;   
   DSIWrite32( &stream, &handle ) ;
   DSIClientSendRequest( proxy, DMMTunerStation_UPD_ID_requestControlSeek, seqNr, &stream );
   DSIClose( &stream );
   return seqNr ;
}



int DMMTunerStation_RequestAbortTune( DMMTunerStationProxy* proxy,  DMMTunerTypes_DeviceType device,  unsigned int handle )
{
   int seqNr = DSICreateId();
   DSIStream stream ;
   DSIOpen( &stream );   
   DSIWrite32( &stream, &device ) ;   
   DSIWrite32( &stream, &handle ) ;
   DSIClientSendRequest( proxy, DMMTunerStation_UPD_ID_requestAbortTune, seqNr, &stream );
   DSIClose( &stream );
   return seqNr ;
}



int DMMTunerStation_RequestForceUpdate( DMMTunerStationProxy* proxy,  unsigned int updateId,  unsigned int sourceType,  unsigned int stationType,  unsigned int handle )
{
   int seqNr = DSICreateId();
   DSIStream stream ;
   DSIOpen( &stream );   
   DSIWrite32( &stream, &updateId ) ;   
   DSIWrite32( &stream, &sourceType ) ;   
   DSIWrite32( &stream, &stationType ) ;   
   DSIWrite32( &stream, &handle ) ;
   DSIClientSendRequest( proxy, DMMTunerStation_UPD_ID_requestForceUpdate, seqNr, &stream );
   DSIClose( &stream );
   return seqNr ;
}



int DMMTunerStation_RequestMakePersistent( DMMTunerStationProxy* proxy, const DMMTunerTypes_StationSelector* station,  DSIBool persistent,  unsigned int handle )
{
   int seqNr = DSICreateId();
   DSIStream stream ;
   DSIOpen( &stream );   
   DSIWriteDMMTunerTypes_StationSelector( &stream, station ) ;      
   DSIWriteBool( &stream, &persistent ) ;   
   DSIWrite32( &stream, &handle ) ;
   DSIClientSendRequest( proxy, DMMTunerStation_UPD_ID_requestMakePersistent, seqNr, &stream );
   DSIClose( &stream );
   return seqNr ;
}





/*******************************************************************************************/

static void ComponentConnected( DMMTunerStationProxy* proxy )
{
   if( proxy && proxy->fnComponentConnected )
   {
      proxy->fnComponentConnected( proxy );
   }
}

static void ComponentDisconnected( DMMTunerStationProxy* proxy )
{
   if( proxy && proxy->fnComponentDisconnected )
   {
      proxy->fnComponentDisconnected( proxy );
   }
}

static void ProcessInternalEvent( DMMTunerStationProxy* proxy, int code, void* data )
{
   if( proxy && proxy->fnProcessInternalEvent )
   {
      proxy->fnProcessInternalEvent( proxy, code, data );
   }
}

static void Cleanup( DMMTunerStationProxy* proxy )
{
   if( proxy && proxy->fnCleanup )
   {
      proxy->fnCleanup( proxy );
   }
}

/*** notifications *************************************************************************/

void DMMTunerStationProxy_SetNotification( DMMTunerStationProxy* proxy, DMMTunerStation_UpdateIdEnum updateId )
{
   DSIClientSetNotification( proxy, (int)updateId );
}


void DMMTunerStationProxy_ClearNotification( DMMTunerStationProxy* proxy, DMMTunerStation_UpdateIdEnum updateId )
{
   DSIClientClearNotification( proxy, (int)updateId );
}


void DMMTunerStationProxy_ClearAllNotifications( DMMTunerStationProxy* proxy )
{
   DSIClientClearAllNotifications( proxy );
}

/*** (de)initialization ********************************************************************/

int DMMTunerStationProxy_Init( DMMTunerStationProxy* proxy, const char* rolename )
{
   DSIInit();
   if (proxy)
   {
      memset( proxy, 0, sizeof(*proxy) );
   }
   DSIClientInit( proxy, SERVER_NAME, rolename, SERVER_MAJOR_VERSION, SERVER_MINOR_VERSION );
   if (proxy)
   {
	   proxy->client.fnComponentConnected = ComponentConnected ;
	   proxy->client.fnComponentDisconnected = ComponentDisconnected ;
	   proxy->client.fnProcessResponse = ProcessResponse ;
	   proxy->client.fnProcessInternalEvent = ProcessInternalEvent ;
	   proxy->client.fnCleanup = Cleanup ;
   }
   return 0 ;
}

void DMMTunerStationProxy_Free( DMMTunerStationProxy* proxy  )
{
   if (proxy == 0)
      return;

   DSIClientFree( proxy );

   memset( proxy, 0, sizeof(*proxy) );
}

int DMMTunerStationProxy_Start( DMMTunerStationProxy* proxy, const char* rolename )
{
   // do not call the _Init function here since the proxy will be NULL'ed which makes problems with
   // the CPP implementation callbacks already registered...

   DSIInit();
   DSIClientInit( proxy, SERVER_NAME, rolename, SERVER_MAJOR_VERSION, SERVER_MINOR_VERSION );
   if (proxy)
   {
	   proxy->client.fnComponentConnected = ComponentConnected ;
	   proxy->client.fnComponentDisconnected = ComponentDisconnected ;
	   proxy->client.fnProcessResponse = ProcessResponse ;
	   proxy->client.fnProcessInternalEvent = ProcessInternalEvent ;
	   proxy->client.fnCleanup = Cleanup ;
   }
   return DSIClientRun( proxy );
}

int DMMTunerStationProxy_Stop( DMMTunerStationProxy* proxy, int exitcode )
{
   return DSIClientStop( proxy, exitcode );
}

int DMMTunerStationProxy_PostInternalEvent( DMMTunerStationProxy* proxy, int code, void* data )
{
   if (0 == proxy)
      return 0;
   return DSIPostInternalEvent( proxy->client.Channel.Master, proxy->client.Id, 0, code, data );
}

int DMMTunerStationProxy_SendInternalEvent( DMMTunerStationProxy* proxy, int code, void* data )
{
   if (0 != proxy)
   {
      if (proxy->client.SendChid)
      {
          return DSISendInternalEvent( proxy->client.SendChid, proxy->client.Id, 0, code, data );

      }
      else
      {

         return DSISendInternalEvent( proxy->client.Channel.Master, proxy->client.Id, 0, code, data );
      }
   }
   else
   {
      return 0;
   }
}


