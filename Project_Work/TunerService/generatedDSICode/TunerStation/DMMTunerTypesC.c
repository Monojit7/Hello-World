/**********************************************************************
 *  Project       Harman Car Multimedia System
 *  (c) copyright 2014
 *  Company       Harman/Becker Automotive Systems GmbH
 *                All rights reserved
 **********************************************************************/

/*
 * Generated by DSI Generator version 2.0
 * Date: 24.11.2014
 */

#include "DMMTunerTypes.h"
#include <string.h>
#include <malloc.h>

void DMMTunerTypes_UInt32s_Copy( DMMTunerTypes_UInt32s* lhs, const DMMTunerTypes_UInt32s* rhs )
{
   int vecsize = 0;
   if ((lhs == 0) || (rhs == 0))
      return;
   vecsize = DSIVectorSize( *rhs ) ;
   *lhs = 0 ;
   if( vecsize )
   {
      int idx ;
      DSIVectorAlloc( *lhs, DSIVectorSize( *rhs ) );

      for( idx=0; idx<vecsize; idx++ )
      {
         (*lhs)->data[idx] = (*rhs)->data[idx] ;
      }
   }
}

void DMMTunerTypes_CHBStrings_Copy( DMMTunerTypes_CHBStrings* lhs, const DMMTunerTypes_CHBStrings* rhs )
{
   int vecsize = 0;
   if ((lhs == 0) || (rhs == 0))
      return;
   vecsize = DSIVectorSize( *rhs ) ;
   *lhs = 0 ;
   if( vecsize )
   {
      int idx ;
      DSIVectorAlloc( *lhs, DSIVectorSize( *rhs ) );

      for( idx=0; idx<vecsize; idx++ )
      {
         if ((*rhs)->data[idx] != 0)
         {
            (*lhs)->data[idx] = strdup((*rhs)->data[idx]);
         }
      }
   }
}

void DMMTunerTypes_Feedbacks_Copy( DMMTunerTypes_Feedbacks* lhs, const DMMTunerTypes_Feedbacks* rhs )
{
   int vecsize = 0;
   if ((lhs == 0) || (rhs == 0))
      return;
   vecsize = DSIVectorSize( *rhs ) ;
   *lhs = 0 ;
   if( vecsize )
   {
      int idx ;
      DSIVectorAlloc( *lhs, DSIVectorSize( *rhs ) );

      for( idx=0; idx<vecsize; idx++ )
      {
         (*lhs)->data[idx] = (*rhs)->data[idx] ;
      }
   }
}

void DMMTunerTypes_StationSelector_Copy( DMMTunerTypes_StationSelector* lhs, const DMMTunerTypes_StationSelector* rhs )
{
   if ((lhs == 0) || (rhs == 0))
      return;
   lhs->deviceType = rhs->deviceType ;
   lhs->frequency = rhs->frequency ;
   DMMTunerTypes_UInt32s_Copy( &lhs->id, &rhs->id );
}

void DMMTunerTypes_StationSelectors_Copy( DMMTunerTypes_StationSelectors* lhs, const DMMTunerTypes_StationSelectors* rhs )
{
   int vecsize = 0;
   if ((lhs == 0) || (rhs == 0))
      return;
   vecsize = DSIVectorSize( *rhs ) ;
   *lhs = 0 ;
   if( vecsize )
   {
      int idx ;
      DSIVectorAlloc( *lhs, DSIVectorSize( *rhs ) );

      for( idx=0; idx<vecsize; idx++ )
      {
         DMMTunerTypes_StationSelector_Copy( &(*lhs)->data[idx], &(*rhs)->data[idx] );
      }
   }
}



void DSIReadDMMTunerTypes_UInt32s( DSIStream *stream, DMMTunerTypes_UInt32s *p )
{
   if( p && stream)
   {
      int size = 0 ;
      DMMTunerTypes_UInt32s_Free( p );

      DSIRead32( stream, &size );
      if( 0 != size )
      {
         int idx = 0 ;
         DMMTunerTypes_UInt32s vec = 0 ; 
         DSIVectorAlloc( vec, size );//lint !e449
         if (vec)
         { 
            memset( vec->data, 0, sizeof(vec->data[0]) * size );
            while( idx < vec->size )
            {
               DSIRead32( stream, &vec->data[idx] ) ;
               idx++;
            }
         }
         *p = vec ;
      }
   }
}

void DSIWriteDMMTunerTypes_UInt32s( DSIStream *stream, const DMMTunerTypes_UInt32s *p )
{
   if (!stream)
      return;
   if( !p || !(*p) || !(*p)->size )
   {
      static const int size0 = 0 ;
      DSIWrite32( stream, &size0 );
   }
   else
   {
      int idx = 0 ;
      const DMMTunerTypes_UInt32s vec = *p ;
      DSIWrite32( stream, &vec->size );
      while( idx < vec->size )
      {
         DSIWrite32( stream, &vec->data[idx] ) ;
         idx++;
      }
   }
}


void DMMTunerTypes_CHBStrings_Free( DMMTunerTypes_CHBStrings *p )
{
if (p == 0)
   return;
   {
      int idx = DSIVectorSize( (*p) ) ;
      while( --idx >= 0 )
      {
         DSIStringFree( (*p)->data[idx] );
      }
   }
   DSIVectorFree( (*p) );
}

void DSIReadDMMTunerTypes_CHBStrings( DSIStream *stream, DMMTunerTypes_CHBStrings *p )
{
   if( p && stream)
   {
      int size = 0 ;
      DMMTunerTypes_CHBStrings_Free( p );

      DSIRead32( stream, &size );
      if( 0 != size )
      {
         int idx = 0 ;
         DMMTunerTypes_CHBStrings vec = 0 ; 
         DSIVectorAlloc( vec, size );//lint !e449
         if (vec)
         { 
            memset( vec->data, 0, sizeof(vec->data[0]) * size );
            while( idx < vec->size )
            {
               DSIReadString( stream, &vec->data[idx] ) ;
               idx++;
            }
         }
         *p = vec ;
      }
   }
}

void DSIWriteDMMTunerTypes_CHBStrings( DSIStream *stream, const DMMTunerTypes_CHBStrings *p )
{
   if (!stream)
      return;
   if( !p || !(*p) || !(*p)->size )
   {
      static const int size0 = 0 ;
      DSIWrite32( stream, &size0 );
   }
   else
   {
      int idx = 0 ;
      const DMMTunerTypes_CHBStrings vec = *p ;
      DSIWrite32( stream, &vec->size );
      while( idx < vec->size )
      {
         DSIWriteString( stream, &vec->data[idx] ) ;
         idx++;
      }
   }
}



void DSIReadDMMTunerTypes_Feedbacks( DSIStream *stream, DMMTunerTypes_Feedbacks *p )
{
   if( p && stream)
   {
      int size = 0 ;
      DMMTunerTypes_Feedbacks_Free( p );

      DSIRead32( stream, &size );
      if( 0 != size )
      {
         int idx = 0 ;
         DMMTunerTypes_Feedbacks vec = 0 ; 
         DSIVectorAlloc( vec, size );//lint !e449
         if (vec)
         { 
            memset( vec->data, 0, sizeof(vec->data[0]) * size );
            while( idx < vec->size )
            {
               DSIRead32( stream, &vec->data[idx] ) ;
               idx++;
            }
         }
         *p = vec ;
      }
   }
}

void DSIWriteDMMTunerTypes_Feedbacks( DSIStream *stream, const DMMTunerTypes_Feedbacks *p )
{
   if (!stream)
      return;
   if( !p || !(*p) || !(*p)->size )
   {
      static const int size0 = 0 ;
      DSIWrite32( stream, &size0 );
   }
   else
   {
      int idx = 0 ;
      const DMMTunerTypes_Feedbacks vec = *p ;
      DSIWrite32( stream, &vec->size );
      while( idx < vec->size )
      {
         DSIWrite32( stream, &vec->data[idx] ) ;
         idx++;
      }
   }
}


void DMMTunerTypes_StationSelector_Free( DMMTunerTypes_StationSelector *p )
{
   if (p == 0)
      return;
   DMMTunerTypes_UInt32s_Free( &p->id );
   memset( p, 0, sizeof(*p) );
}

void DSIReadDMMTunerTypes_StationSelector( DSIStream *stream, DMMTunerTypes_StationSelector *p )
{
   if ((stream == 0) || (p == 0))
      return;
   DSIRead32( stream, &(p)->deviceType ) ;
   DSIRead32( stream, &(p)->frequency ) ;
   DSIReadDMMTunerTypes_UInt32s( stream, &(p)->id ) ;
}

void DSIWriteDMMTunerTypes_StationSelector( DSIStream *stream, const DMMTunerTypes_StationSelector *p )
{
   if ((stream == 0) || (p == 0))
      return;
   DSIWrite32( stream, &(p)->deviceType ) ;
   DSIWrite32( stream, &(p)->frequency ) ;
   DSIWriteDMMTunerTypes_UInt32s( stream, &(p)->id ) ;
}

void DMMTunerTypes_StationSelectors_Free( DMMTunerTypes_StationSelectors *p )
{
if (p == 0)
   return;
   {
      int idx = DSIVectorSize( (*p) ) ;
      while( --idx >= 0 )
      {
         DMMTunerTypes_StationSelector_Free( &(*p)->data[idx] );
      }
   }
   DSIVectorFree( (*p) );
}

void DSIReadDMMTunerTypes_StationSelectors( DSIStream *stream, DMMTunerTypes_StationSelectors *p )
{
   if( p && stream)
   {
      int size = 0 ;
      DMMTunerTypes_StationSelectors_Free( p );

      DSIRead32( stream, &size );
      if( 0 != size )
      {
         int idx = 0 ;
         DMMTunerTypes_StationSelectors vec = 0 ; 
         DSIVectorAlloc( vec, size );//lint !e449
         if (vec)
         { 
            memset( vec->data, 0, sizeof(vec->data[0]) * size );
            while( idx < vec->size )
            {
               DSIReadDMMTunerTypes_StationSelector( stream, &vec->data[idx] ) ;
               idx++;
            }
         }
         *p = vec ;
      }
   }
}

void DSIWriteDMMTunerTypes_StationSelectors( DSIStream *stream, const DMMTunerTypes_StationSelectors *p )
{
   if (!stream)
      return;
   if( !p || !(*p) || !(*p)->size )
   {
      static const int size0 = 0 ;
      DSIWrite32( stream, &size0 );
   }
   else
   {
      int idx = 0 ;
      const DMMTunerTypes_StationSelectors vec = *p ;
      DSIWrite32( stream, &vec->size );
      while( idx < vec->size )
      {
         DSIWriteDMMTunerTypes_StationSelector( stream, &vec->data[idx] ) ;
         idx++;
      }
   }
}



void DSIReadDMMTunerTypes_ArbitrationElement( DSIStream *stream, DMMTunerTypes_ArbitrationElement *p )
{
   if ((stream == 0) || (p == 0))
      return;
   DSIReadBool( stream, &(p)->actual ) ;
   DSIReadBool( stream, &(p)->desired ) ;
}

void DSIWriteDMMTunerTypes_ArbitrationElement( DSIStream *stream, const DMMTunerTypes_ArbitrationElement *p )
{
   if ((stream == 0) || (p == 0))
      return;
   DSIWriteBool( stream, &(p)->actual ) ;
   DSIWriteBool( stream, &(p)->desired ) ;
}



