/**********************************************************************
 *  Project       Harman Car Multimedia System
 *  (c) copyright 2014
 *  Company       Harman/Becker Automotive Systems GmbH
 *                All rights reserved
 **********************************************************************/

/*
 * Generated by DSI Generator version 2.0
 * Date: 21.11.2014
 */

struct _DMMTunerStationStub ;
#define TDSIServer struct _DMMTunerStationStub

#define DSICONST

#include "DMMTunerStationStub.h"
#include <string.h>
#include <stdio.h>
#include <malloc.h>
#include <assert.h>

#ifdef _WIN32
#define snprintf _snprintf
#endif

static const char* SERVER_NAME = "DMMTunerStation" ;
static const int SERVER_MAJOR_VERSION = 6 ;
static const int SERVER_MINOR_VERSION = 1 ;

static int WriteAttribute( DMMTunerStationStub* stub, DSIStream* stream, unsigned int id, DSIUpdateType type, short position, short count )
{
   int success = 0 ;
   if (stub == 0)
   {
      return success;
   }

   // avoid unused variables
   (void)type;(void)position;(void)count;

   return success ;
}




static void ProcessRequest( DMMTunerStationStub* stub, DSIStream* stream, unsigned int id )
{
   if (stub == 0)
   {
      return;
   }
   switch( (DMMTunerStation_UpdateIdEnum)id )
   {
   case DMMTunerStation_UPD_ID_requestStartTune:
      {
         DMMTunerTypes_StationSelector station ;
         unsigned int handle = 0 ;
         DMMTunerStation_SelectionMode selectionMode = 0 ;
         memset( &station, 0, sizeof(station) )  ;
         DSIReadDMMTunerTypes_StationSelector( stream, &station ) ;
         DSIRead32( stream, &handle ) ;
         DSIRead32( stream, &selectionMode ) ;
         if( 0 != stub->fnRequestStartTune )
         {
            stub->fnRequestStartTune( stub,  &station, handle, selectionMode );
         }
         DMMTunerTypes_StationSelector_Free( &station );
      }
      break;

   case DMMTunerStation_UPD_ID_requestControlSeek:
      {
         DMMTunerTypes_DeviceType device = 0 ;
         DMMTunerStation_SeekMode seekMode = 0 ;
         unsigned char genre = 0 ;
         unsigned int flags = 0 ;
         unsigned int handle = 0 ;
         DSIRead32( stream, &device ) ;
         DSIRead32( stream, &seekMode ) ;
         DSIRead8( stream, &genre ) ;
         DSIRead32( stream, &flags ) ;
         DSIRead32( stream, &handle ) ;
         if( 0 != stub->fnRequestControlSeek )
         {
            stub->fnRequestControlSeek( stub, device, seekMode, genre, flags, handle );
         }
      }
      break;

   case DMMTunerStation_UPD_ID_requestAbortTune:
      {
         DMMTunerTypes_DeviceType device = 0 ;
         unsigned int handle = 0 ;
         DSIRead32( stream, &device ) ;
         DSIRead32( stream, &handle ) ;
         if( 0 != stub->fnRequestAbortTune )
         {
            stub->fnRequestAbortTune( stub, device, handle );
         }
      }
      break;

   case DMMTunerStation_UPD_ID_requestForceUpdate:
      {
         unsigned int updateId = 0 ;
         unsigned int sourceType = 0 ;
         unsigned int stationType = 0 ;
         unsigned int handle = 0 ;
         DSIRead32( stream, &updateId ) ;
         DSIRead32( stream, &sourceType ) ;
         DSIRead32( stream, &stationType ) ;
         DSIRead32( stream, &handle ) ;
         if( 0 != stub->fnRequestForceUpdate )
         {
            stub->fnRequestForceUpdate( stub, updateId, sourceType, stationType, handle );
         }
      }
      break;

   case DMMTunerStation_UPD_ID_requestMakePersistent:
      {
         DMMTunerTypes_StationSelector station ;
         DSIBool persistent = 0 ;
         unsigned int handle = 0 ;
         memset( &station, 0, sizeof(station) )  ;
         DSIReadDMMTunerTypes_StationSelector( stream, &station ) ;
         DSIReadBool( stream, &persistent ) ;
         DSIRead32( stream, &handle ) ;
         if( 0 != stub->fnRequestMakePersistent )
         {
            stub->fnRequestMakePersistent( stub,  &station, persistent, handle );
         }
         DMMTunerTypes_StationSelector_Free( &station );
      }
      break;

   default:
      break;
   }
}




void DMMTunerStation_InformationCurrentStation( DMMTunerStationStub* stub, const DMMTunerStation_Station* current,  unsigned int handle )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWriteDMMTunerStation_Station( &stream, current ) ;
   DSIWrite32( &stream, &handle ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerStation_UPD_ID_informationCurrentStation, &stream );
   DSIClose( &stream );
}

void DMMTunerStation_InformationStationList( DMMTunerStationStub* stub, const DMMTunerStation_StationList* list,  unsigned int handle )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWriteDMMTunerStation_StationList( &stream, list ) ;
   DSIWrite32( &stream, &handle ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerStation_UPD_ID_informationStationList, &stream );
   DSIClose( &stream );
}

void DMMTunerStation_InformationSeek( DMMTunerStationStub* stub, const DMMTunerStation_SeekData* seekData,  unsigned int handle )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWriteDMMTunerStation_SeekData( &stream, seekData ) ;
   DSIWrite32( &stream, &handle ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerStation_UPD_ID_informationSeek, &stream );
   DSIClose( &stream );
}

void DMMTunerStation_ResponseStartTune( DMMTunerStationStub* stub,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &handle ) ;
   DSIWrite32( &stream, &feedback ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerStation_UPD_ID_responseStartTune, &stream );
   DSIClose( &stream );
}

void DMMTunerStation_ResponseAbortTune( DMMTunerStationStub* stub,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &handle ) ;
   DSIWrite32( &stream, &feedback ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerStation_UPD_ID_responseAbortTune, &stream );
   DSIClose( &stream );
}

void DMMTunerStation_ResponseControlSeek( DMMTunerStationStub* stub,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &handle ) ;
   DSIWrite32( &stream, &feedback ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerStation_UPD_ID_responseControlSeek, &stream );
   DSIClose( &stream );
}

void DMMTunerStation_ResponseMakePersistent( DMMTunerStationStub* stub,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &handle ) ;
   DSIWrite32( &stream, &feedback ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerStation_UPD_ID_responseMakePersistent, &stream );
   DSIClose( &stream );
}

void DMMTunerStation_ResponseForceUpdate( DMMTunerStationStub* stub,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   DSIStream stream ;
   DSIOpen( &stream );
   DSIWrite32( &stream, &handle ) ;
   DSIWrite32( &stream, &feedback ) ;
   DSIServerSendResponse( stub, RESULT_OK, DMMTunerStation_UPD_ID_responseForceUpdate, &stream );
   DSIClose( &stream );
}


static void ProcessInternalEvent( DMMTunerStationStub* stub, int code, void* data )
{
   if( stub && stub->fnProcessInternalEvent )
   {
      stub->fnProcessInternalEvent( stub, code, data );
   }
}

void DMMTunerStationStub_SendNotification( DMMTunerStationStub* stub, DMMTunerStation_UpdateIdEnum id )
{
   DSIServerSendNotification( stub, id );
}

static void Cleanup( DMMTunerStationStub* stub )
{
   if( stub && stub->fnCleanup )
   {
      stub->fnCleanup( stub );
   }
}

static int GetResponse( DMMTunerStationStub* stub, int requestId )
{
   DMMTunerStation_UpdateIdEnum responseId = DMMTunerStation_UPD_ID_NOP ;


   return (responseId == DMMTunerStation_UPD_ID_NOP) ? DSI_INVALID_ID : (int)responseId ;
}

int DMMTunerStationStub_Init( DMMTunerStationStub* stub, const char* rolename )
{
   DSIInit();
   if (stub)
   {
      memset( stub, 0, sizeof(*stub));
   }
   DSIServerInit( stub, SERVER_NAME, rolename, SERVER_MAJOR_VERSION, SERVER_MINOR_VERSION );
   if (stub)
   {
      stub->server.fnWriteAttribute = WriteAttribute ;
      stub->server.fnProcessRequest = ProcessRequest ;
      stub->server.fnProcessInternalEvent = ProcessInternalEvent ;
      stub->server.fnCleanup = Cleanup ;
      stub->server.fnGetResponse = GetResponse ;
   }
   return 0;
}

void DMMTunerStationStub_Free( DMMTunerStationStub* stub  )
{
   if (stub == 0)
   {
      return;
   }
   DSIServerFree( stub );
   memset( stub, 0, sizeof(*stub) );
}

int DMMTunerStationStub_Start( DMMTunerStationStub* stub, const char* rolename )
{
   DSIInit();
   if (stub == 0)
   {
      return 0;
   }
   // check if all request function pointers are valid
   assert( 0 != stub->fnRequestStartTune  );
   assert( 0 != stub->fnRequestControlSeek  );
   assert( 0 != stub->fnRequestAbortTune  );
   assert( 0 != stub->fnRequestForceUpdate  );
   assert( 0 != stub->fnRequestMakePersistent  );

   DSIServerInit( stub, SERVER_NAME, rolename, SERVER_MAJOR_VERSION, SERVER_MINOR_VERSION );
   stub->server.fnWriteAttribute = WriteAttribute ;
   stub->server.fnProcessRequest = ProcessRequest ;
   stub->server.fnProcessInternalEvent = ProcessInternalEvent ;
   stub->server.fnCleanup = Cleanup ;
   stub->server.fnGetResponse = GetResponse ;
   return DSIServerRun( stub );
}


int DMMTunerStationStub_Stop( DMMTunerStationStub* stub, int exitcode )
{
	return DSIServerStop( stub, exitcode );
}


void DMMTunerStationSendError( DMMTunerStationStub* stub, DMMTunerStation_UpdateIdEnum id )
{
   DSIStream stream;
   DSIResultType typ = RESULT_REQUEST_ERROR;

   if ( IS_RESPONSE_ID(id) )
      typ = RESULT_INVALID;
   else if ( IS_ATTRIBUTE_ID(id) )
      typ = RESULT_DATA_INVALID;

   DSIOpen( &stream );
   DSIServerSendResponse( stub, typ, id, &stream );
   DSIClose( &stream );
}


int DMMTunerStationStub_PostInternalEvent( DMMTunerStationStub* stub, int code, void* data )
{
   if (stub)
	   return DSIPostInternalEvent( stub->server.Channel.Master, stub->server.Id, 0, code, data );
   else
      return -1;
}


int DMMTunerStationStub_SendInternalEvent( DMMTunerStationStub* stub, int code, void* data )
{
   if (stub)
   {
      if (stub->server.SendChid)
      {
          return DSISendInternalEvent( stub->server.SendChid, stub->server.Id, 0, code, data );

      }
      else
      {

   	   return DSISendInternalEvent( stub->server.Channel.Master, stub->server.Id, 0, code, data );
      }
   }
   else
      return -1;
}


