 
/**********************************************************************
 *  Project       Harman Car Multimedia System
 *  (c) copyright 2013
 *  Company       Harman/Becker Automotive Systems GmbH
 *                All rights reserved
 **********************************************************************/

/*
 * Generated by DSI Generator version 2.0
 * Date: 21.9.2013
 */
#include "pthread.h"
#include "CDMMTunerStationProxy.hpp"
#include <string.h>
#include <algorithm>
#include "CTunerRequestResponseHandler.hpp"
#include "CTunerRespHandler.hpp"
#include "CTunerScanHandler.hpp"
#include "CTunerSeekHandler.hpp"
#include "CTunerPresets.hpp"
#include "DMMTunerStationTypes.h"
#include "DMMTunerStation.h"
#include "DMMTunerTypes.h"
#include "CTunerDataTypes.hpp"
#include "TraceMacros.hpp"
#include "CTunerAnnouncementHandler.hpp"
#include "CTunerCmdInvoker.hpp"
#include "kpi_marker.h"
#include <TunerPersistency.hpp>
static pthread_mutex_t  myMutex;

TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, start);
TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, responseStartTune);
TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, responseControlSeek);
TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, requestStartTuneFailed);
TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, processInternalEvent);
TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, informationCurrentStation);
TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, informationSeek);
TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, informationStationList);
TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, componentConnected);
TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, responseSetSourceActivity);
TRC_SCOPE_DEF(TunerService, CDMMTunerStationProxy, requestControlSeekFailed);

static void _informationStationList( DMMTunerStationProxy* proxy, const DMMTunerStation_StationList* list,  unsigned int handle )
{
   ((CDMMTunerStationProxy*)proxy)->informationStationList(  *list, handle ) ;
}

static void _informationSeek( DMMTunerStationProxy* proxy, const DMMTunerStation_SeekData* seekData,  unsigned int handle )
{
   ((CDMMTunerStationProxy*)proxy)->informationSeek(  *seekData, handle ) ;
}

static void _responseStartTune( DMMTunerStationProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerStationProxy*)proxy)->responseStartTune( handle, feedback ) ;
}

static void _responseAbortTune( DMMTunerStationProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerStationProxy*)proxy)->responseAbortTune( handle, feedback ) ;
}

static void _responseControlSeek( DMMTunerStationProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerStationProxy*)proxy)->responseControlSeek( handle, feedback ) ;
}

static void _responseMakePersistent( DMMTunerStationProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerStationProxy*)proxy)->responseMakePersistent( handle, feedback ) ;
}

static void _responseForceUpdate( DMMTunerStationProxy* proxy,  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   ((CDMMTunerStationProxy*)proxy)->responseForceUpdate( handle, feedback ) ;
}

static void _processInternalEvent( DMMTunerStationProxy* proxy, int code, void* data )
{
   ((CDMMTunerStationProxy*)proxy)->processInternalEvent( code,  data ) ;
}

static void _processUpdateEvent( DMMTunerStationProxy* proxy, DMMTunerStation_UpdateIdEnum updateId )
{
   ((CDMMTunerStationProxy*)proxy)->processUpdateEvent( updateId ) ;
}

static void _componentConnected( DMMTunerStationProxy* proxy )
{
   ((CDMMTunerStationProxy*)proxy)->componentConnected( ) ;
}

static void _componentDisconnected( DMMTunerStationProxy* proxy )
{
   ((CDMMTunerStationProxy*)proxy)->componentDisconnected( ) ;
}

static void _cleanup( DMMTunerStationProxy* proxy )
{
   ((CDMMTunerStationProxy*)proxy)->cleanup( ) ;
}

static void _responseInvalid( DMMTunerStationProxy* proxy, DMMTunerStation_UpdateIdEnum id )
{
   ((CDMMTunerStationProxy*)proxy)->responseInvalid( id );
}

static void _requestStartTuneFailed( DMMTunerStationProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerStationProxy*)proxy)->requestStartTuneFailed( errType );
}

static void _requestControlSeekFailed( DMMTunerStationProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerStationProxy*)proxy)->requestControlSeekFailed( errType );
}

static void _requestAbortTuneFailed( DMMTunerStationProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerStationProxy*)proxy)->requestAbortTuneFailed( errType );
}

static void _requestForceUpdateFailed( DMMTunerStationProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerStationProxy*)proxy)->requestForceUpdateFailed( errType );
}

static void _requestMakePersistentFailed( DMMTunerStationProxy* proxy, DSIResultType errType )
{
   ((CDMMTunerStationProxy*)proxy)->requestMakePersistentFailed( errType );
}


static void _informationCurrentStation( DMMTunerStationProxy* proxy, const DMMTunerStation_Station* current,  unsigned int handle )
{
   ((CDMMTunerStationProxy*)proxy)->informationCurrentStation(  *current, handle ) ;
}


inline bool comp(const stationInformation& pva1, stationInformation& pva2) { return pva1.freq > pva2.freq; }


CDMMTunerStationProxy::CDMMTunerStationProxy( )
{
   memset( (DMMTunerStationProxy*)this, 0, sizeof(DMMTunerStationProxy) );

   fnInformationCurrentStation = _informationCurrentStation ;
   fnInformationStationList = _informationStationList ;
   fnInformationSeek = _informationSeek ;
   fnResponseStartTune = _responseStartTune ;
   fnResponseAbortTune = _responseAbortTune ;
   fnResponseControlSeek = _responseControlSeek ;
   fnResponseMakePersistent = _responseMakePersistent ;
   fnResponseForceUpdate = _responseForceUpdate ;

   fnRequestStartTuneFailed = _requestStartTuneFailed ;
   fnRequestControlSeekFailed = _requestControlSeekFailed ;
   fnRequestAbortTuneFailed = _requestAbortTuneFailed ;
   fnRequestForceUpdateFailed = _requestForceUpdateFailed ;
   fnRequestMakePersistentFailed = _requestMakePersistentFailed ;

   fnProcessInternalEvent = _processInternalEvent ;
   fnProcessUpdateEvent = _processUpdateEvent ;
   fnComponentConnected = _componentConnected ;
   fnComponentDisconnected = _componentDisconnected ;
   fnResponseInvalid = _responseInvalid ;
   fnCleanup = _cleanup ;
}

CDMMTunerStationProxy::~CDMMTunerStationProxy()
{
}

int CDMMTunerStationProxy::start( const char* rolename )
{
   TRC_SCOPE(TunerService, CDMMTunerStationProxy, start);
   DBG_MSG(("In start function, rolename : %s\n",rolename));
   return DMMTunerStationProxy_Start( this, rolename ) ;
}

void CDMMTunerStationProxy::stop( int exitcode )
{
   DMMTunerStationProxy_Stop( this, exitcode );
}

int CDMMTunerStationProxy::postInternalEvent( int code, void* data )
{
   return DSIPostInternalEvent( client.Channel.Master, client.Id, 0, code, data );
}

int CDMMTunerStationProxy::sendInternalEvent( int code, void* data )
{
   return DSISendInternalEvent( client.Channel.Master, client.Id, 0, code, data );
}

void CDMMTunerStationProxy::cleanup()
{
}
void CDMMTunerStationProxy::componentConnected( )
{
   TRC_SCOPE(TunerService, CDMMTunerStationProxy, componentConnected);
   //CTunerRequestResponseHandler* mMain = CTunerRequestResponseHandler::GetInstance();
   bool status = true;
   CTunerRequestResponseHandler::GetInstance()->setStationComponentStatus(status);
   DBG_MSG(("KPI_MARKER:TUNERSERVICE_STATION_CONNECTED"));
   KPIMARKER(11, "KPI_MARKER:TUNERSERVICE_STATION_CONNECTED");
   setNotification(DMMTunerStation_UPD_ID_requestStartTune);
   setNotification(DMMTunerStation_UPD_ID_informationCurrentStation);
   setNotification(DMMTunerStation_UPD_ID_informationSeek);
   setNotification(DMMTunerStation_UPD_ID_responseStartTune);
   setNotification(DMMTunerStation_UPD_ID_responseControlSeek);
   setNotification(DMMTunerStation_UPD_ID_informationStationList);
   pthread_mutex_lock(&CHBTunerPersistency::getInstance()->mAvailBandMSignalmutex);
   if(CHBTunerPersistency::meInitProgressStatus == ePERSISTENCY_COMPLETION)
   {
  // CHBTunerPersistency::meInitProgressStatus = CHBTunerPersistency::eSTATION_INTERFACE_CONNECTED;
   DBG_MSG(("CDMMTunerStationProxy::Component connected called !!!\n"));
   Json::Value availableBands (Json::arrayValue);
   Json::Value waveBand;
   unsigned int j = 0;
   availableBands[j] = "fm";
   j++;
   availableBands[j] = "am";
   j++;
   availableBands[j] = "wb";
   waveBand["value"] = availableBands;
   DBG_MSG(("[CDMMTunerStationProxy]::GetProperties: sending available Band inside Persistency read completion"));
   CTunerRequestResponseHandler::handleNotif("availableBands",waveBand);
   DBG_MSG(("Setting the persistency flag with true value"));
   CTunerCmdInvoker::GetInstance()->setPersistencyFlag(true);
   }
   else
   {
	   DBG_MSG(("setting CDMMTunerStationProxy::eSTATION_INTERFACE_CONNECTED !!!\n"));
	   CHBTunerPersistency::meInitProgressStatus = eSTATION_INTERFACE_CONNECTED;
   }
   pthread_mutex_unlock(&CHBTunerPersistency::getInstance()->mAvailBandMSignalmutex);
}

void CDMMTunerStationProxy::responseStartTune(  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   TRC_SCOPE(TunerService, CDMMTunerStationProxy, responseStartTune);
   DBG_MSG(("CDMMTunerStationProxy::responseStartTune %d",feedback));
   int result = -1;
   switch(feedback)
   {
     case 0:
     result = 0;
     break;
     case 1:
     result = 1;
     break;
     case 2:
     result = 2;
     break;
     case 3:
     result = 1;
     break;
     case 4:
     result = 3;
     break;
     case 5:
     result = 1;
     break;
     default:
     result = 1;
     break;
   }
   std::string signalName = "requestStatus";
   Json::Value res;
   res["status"] = result;
   res["description"] = "Status";
   res["type"] = "directTune";
   Json::Value data;
   if(result == 0)
   {
	   if(CTunerSeekHandler::getCurrBand() == Tuner_Band_FM)
	   {
		 data["waveband"] = "fm";
	   }
	   else if(CTunerSeekHandler::getCurrBand() == Tuner_Band_AM)
	   {
		 data["waveband"] = "am";
	   }
	   else if(CTunerSeekHandler::getCurrBand() == Tuner_Band_WB)
	   {
		 data["waveband"] = "wb";
	   }
	   else
	   {
		   ;
	   }
	   CTunerRequestResponseHandler::handleNotif("waveband",data);
   }
   CTunerRequestResponseHandler::handleNotif(signalName,res);
}
void CDMMTunerStationProxy::responseControlSeek(  unsigned int handle,  DMMTunerTypes_Feedback feedback )
{
   TRC_SCOPE(TunerService, CDMMTunerStationProxy, responseControlSeek);
   DBG_MSG(("CDMMTunerStationProxy::responseControlSeek \n"));
   int result = 2;
   switch(feedback)
   {
     case 0:
     result = 0;
     break;
     case 1:
     result = 1;
     break;
     case 2:
     result = 2;
     break;
     case 3:
     result = 1;
     break;
     case 4:
     result = 3;
     break;
     case 5:
     result = 1;
     break;
     default:
     result = 1;
     break;
   }
   std::string signalName = "requestStatus";
   Json::Value res;
   res["status"] = result;
   res["description"] = "Status";
   res["type"] = "seek";
   CTunerRequestResponseHandler::handleNotif(signalName,res);
}
void CDMMTunerStationProxy::requestStartTuneFailed( DSIResultType errType )
{
   TRC_SCOPE(TunerService, CDMMTunerStationProxy, requestStartTuneFailed);
   DBG_MSG(("Error in start tune"));
}
void CDMMTunerStationProxy::requestControlSeekFailed( DSIResultType errType )
{
   TRC_SCOPE(TunerService, CDMMTunerStationProxy, requestControlSeekFailed);
   DBG_MSG(("Error in Control Seek"));
}
void CDMMTunerStationProxy::processInternalEvent( int code, void* data )
{
   TRC_SCOPE(TunerService, CDMMTunerStationProxy, processInternalEvent);
   switch(code)
   {
   case DMMTunerStation_UPD_ID_requestStartTune:
   {
     proxy info = *(proxy*)data;
     UINT32 frequency = info.frequency;
     UINT32 handle = info.token;
     UINT32 piCode = info.piCode;
     UINT32 selType = info.selectionType;
     DMMTunerStation_SelectionMode mode;

     //Map the selection type received to the corresponding request type
     switch(selType)
     {
     case 0:
  	   mode = DMMTunerStation_SELECT_DIRECT;
  	   break;
     case 1:
  	   mode = DMMTunerStation_SELECT_LIST;
  	   break;
     case 2:
  	   mode = DMMTunerStation_SELECT_PRESET;
  	   break;
     default:
  	   mode = DMMTunerStation_SELECT_DIRECT;
  	   break;
     }


     DMMTunerTypes_StationSelector station;
     DSIVectorInit(station.id);
     DSIVectorAlloc(station.id, 3);
     DBG_MSG(("Calling request Start Tune allocating memory"));
     if(((frequency >= CTunerSeekHandler::mFMMinFrequency) && (frequency <= CTunerSeekHandler::mFMMaxFrequency)) || ((frequency >= CTunerSeekHandler::mAMMinFrequency) && (frequency <= CTunerSeekHandler::mAMMaxFrequency)) || ((frequency >= CTunerSeekHandler::mWBMinFrequency) && (frequency <= CTunerSeekHandler::mWBMaxFrequency)) )
     {
  	   DBG_MSG(("Calling request Start Tune with Valid Frequency"));
  	   DBG_MSG(("Calling request Start Tune with PI code as %d",piCode));
  	   station.id->data[DMMTunerStationTypes_AMFM_PI] = piCode;
  	   station.frequency = frequency;
     }
     else
     {
  	   DBG_MSG(("Calling request Start Tune with Last Tuned Frequency,since Invalid Frequency received"));
  	   if(CTunerSeekHandler::mCurrentTunerBand == Tuner_Band_AM)
  	   {
  		   station.frequency = CTunerSeekHandler::mLastTunedAMFrequency;
  		   DBG_MSG(("Calling request Start Tune for last tuned frequency - %d ",station.frequency));
  	   }
  	   else if(CTunerSeekHandler::mCurrentTunerBand == Tuner_Band_FM)
  	   {
  		   station.frequency = CTunerSeekHandler::mLastTunedFMFrequency;
  		   station.id->data[DMMTunerStationTypes_AMFM_PI] = CTunerSeekHandler::mPIcode;
  		   DBG_MSG(("Calling request Start Tune for last tuned frequency - %d ",station.frequency));
  	   }
  	   else if(CTunerSeekHandler::mCurrentTunerBand == Tuner_Band_WB)
  	   {
  		   station.frequency = CTunerSeekHandler::mLastTunedWBFrequency;
  		   station.id->data[DMMTunerStationTypes_AMFM_PI] = CTunerSeekHandler::mPIcode;
  		   DBG_MSG(("Calling request Start Tune for last tuned frequency - %d ",station.frequency));
  	   }
  	   else
  	   {
  		   ;
  	   }
  	 }
     station.id->data[1] = 0;
     station.deviceType = DMMTunerTypes_AMFM;
     requestStartTune(station, handle, mode);
     break;
   }
     case DMMTunerStation_UPD_ID_requestControlSeek:
     {
       proxy info = *(proxy*)data;
       UINT32 handle = info.token;
       DMMTunerStation_SeekMode type = info.mode;
       DBG_MSG(("The handle is %d \n",handle));
       DBG_MSG(("The mode is %d \n", type));
       requestControlSeek(DMMTunerTypes_AMFM,type,0,0,handle);
       break;
     }
     default:
     break;

   }
}
void CDMMTunerStationProxy::informationCurrentStation( const DMMTunerStation_Station& current,  unsigned int handle)
{
   TRC_SCOPE(TunerService, CDMMTunerStationProxy, informationCurrentStation);

   DBG_MSG(("CDMMTunerStationProxy::informationCurrentStation received - Frequency is %d \n", current.sel.frequency));
   DBG_MSG(("Current tuner band is %d",current.sel.deviceType));
   if(handle != 0)
   {

   /*if(true == mInst->getScanStatus())
   {
     mInst->startTimer();
     //mInst->setTuningFreq(current.sel.frequency);
   }
   else
   {
       mInst->setCurrentFreq(current.sel.frequency);
   }*/
   std::string psN = "";
   if(NULL !=(current.name->data[DMMTunerStationTypes_AMFM_PS]))
   {
	 psN = (current.name->data[DMMTunerStationTypes_AMFM_PS]);
     DBG_MSG(("[ informationCurrentStation ] Station Name and frequency is %s and %d",psN.c_str(), current.sel.frequency));
   }

   else
   {
     ;
   }

  // printf("Current Band is %d\n", CTunerSeekHandler::getCurrBand());

   //Extracting the current service number for HD
   Json::Value data;
   Json::Value info;

      //Check validity of pi
      if(0x00010000 == (DMMTunerStationTypes_AMFM_PI_INVALID & (current.sel.id->data[DMMTunerStationTypes_AMFM_PI])))
      {
        DBG_MSG(("The value of PI not received"));
        data["pi"] = (current.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
        CTunerSeekHandler::mPIcode = (current.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
      }
      else if(0x00020000 == (DMMTunerStationTypes_AMFM_PI_INVALID & (current.sel.id->data[DMMTunerStationTypes_AMFM_PI])))
      {
        DBG_MSG(("The value of PI received for first time"));
        data["pi"] = (current.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
        CTunerSeekHandler::mPIcode = (current.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
      }
      else if(0x00040000 == (DMMTunerStationTypes_AMFM_PI_INVALID & (current.sel.id->data[DMMTunerStationTypes_AMFM_PI])))
      {
        DBG_MSG(("PI timed out"));
        data["pi"] = (current.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
        CTunerSeekHandler::mPIcode = (current.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
      }
      else if(!(DMMTunerStationTypes_AMFM_PI_INVALID & (current.sel.id->data[DMMTunerStationTypes_AMFM_PI])))
      {
        DBG_MSG(("PI valid"));
        data["pi"] = (current.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
        CTunerSeekHandler::mPIcode = (current.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
      }


   CTunerSeekHandler* seek = new CTunerSeekHandler();

   if(current.sel.deviceType == (DMMTunerTypes_AMFM_MW ))
   {
	   info["waveband"] = "am";
	  if((current.sel.frequency >= CTunerSeekHandler::mAMMinFrequency) && (current.sel.frequency <= CTunerSeekHandler::mAMMaxFrequency))
	  {
		pthread_mutex_lock( &myMutex );
		seek->setAMLastTunedFreq(current.sel.frequency);
	    CTunerSeekHandler::mCurrentTunerBand = Tuner_Band_AM;
	    pthread_mutex_unlock(&myMutex);
	    DBG_MSG(("Frequency stored into current AM frequency %d ",current.sel.frequency));
	  }
	  else
	  {
		 DBG_MSG(("Invalid frequency, hence not stored into current AM frequency"));
	  }
	  CTunerPresetAM::updatePresetNoAM(current.sel.frequency,-1);
   }

   else if(current.sel.deviceType == (DMMTunerTypes_AMFM_FM))
   {
	   info["waveband"] = "fm";
	if(CTunerAnnouncementHandler::mAnnouncementState == false)
	{
		 if((current.sel.frequency >= CTunerSeekHandler::mFMMinFrequency) && (current.sel.frequency <= CTunerSeekHandler::mFMMaxFrequency))
		 {
		   if((CTunerAnnouncementHandler::TAfreq == current.sel.frequency))
		   {
			  DBG_MSG(("Frequency not stored into current FM frequency since it is TA frequency : %d ",current.sel.frequency));
		   }
		   else if(DMMTunerStation_CTRL_FOLLOWING == (current.stationType & DMMTunerStation_CTRL_FOLLOWING))
		   {
			  DBG_MSG(("Frequency not stored into current FM frequency since it is linked frequency : %d ",current.sel.frequency));
		   }
		   else if(DMMTunerStation_CTRL_INACTIVE == (current.stationType & DMMTunerStation_CTRL_INACTIVE))
		   {
			  DBG_MSG(("Frequency not stored into current FM frequency since it is linked frequency : %d ",current.sel.frequency));
		   }
		   else if(DMMTunerStation_CTRL_ANNOUNCE == (current.stationType & DMMTunerStation_CTRL_ANNOUNCE))
		   {
			  DBG_MSG(("Frequency not stored into current FM frequency since it is TA frequency : %d ",current.sel.frequency));
		   }
		   else
		   {
			   CTunerAnnouncementHandler::TAfreq = 0;
			   pthread_mutex_lock( &myMutex );
			   seek->setFMLastTunedFreq(current.sel.frequency);
			   CTunerSeekHandler::mCurrentTunerBand = Tuner_Band_FM;
			   pthread_mutex_unlock(&myMutex);
			   DBG_MSG(("Frequency stored into current FM frequency %d ",current.sel.frequency));
		   }
		 }
		 else
		 {
			DBG_MSG(("Invalid frequency, hence not stored into current FM frequency"));
		 }
		 CTunerPresetFM::updatePresetNoFM(current.sel.frequency,-1,CTunerSeekHandler::mPIcode);
	}
   }
   else if(current.sel.deviceType == (DMMTunerTypes_AMFM_WB))
   {
	   info["waveband"] = "wb";

		 if((current.sel.frequency >= CTunerSeekHandler::mWBMinFrequency) && (current.sel.frequency <= CTunerSeekHandler::mWBMaxFrequency))
		 {


			   CTunerAnnouncementHandler::TAfreq = 0;
			   pthread_mutex_lock( &myMutex );
			   seek->setWBLastTunedFreq(current.sel.frequency);
			   CTunerSeekHandler::mCurrentTunerBand = Tuner_Band_WB;
			   pthread_mutex_unlock(&myMutex);
			   DBG_MSG(("Frequency stored into current WB frequency %d ",current.sel.frequency));

		 }
		 else
		 {
			DBG_MSG(("Invalid frequency, hence not stored into current FM frequency"));
		 }
		 CTunerPresetWB::updatePresetNoWB(current.sel.frequency,-1);

   }


   std::string signalName = "infoCurrentStation";
   std::string sigName = "frequency";
   //std::string signal = "infoBallgameModeStatus";

   Json::Value status;

   //Store the signal quality of the currently tuned station
   CTunerSeekHandler::setCurrentstationQuality(current.quality->data[DMMTunerStationTypes_AMFM_FS]);
   DBG_MSG(("Current Station :: Frequency: %d ", (current.sel.frequency)));
//   DBG_MSG(("Current Station :: Program Service Name: %s", (char*)(current.name->data[])));
  // monojit DBG_MSG(("Current Station :: Program Service Name: %s", (char*)(current.name->data[DMMTunerStationTypes_AMFM_PS])));
  // DBG_MSG(("Current Station :: Program Service Name: %s",current.name->data[DMMTunerStationTypes_AMFM_PS]));
  // printf("%s",current.name->data[DMMTunerStationTypes_AMFM_PS]);
   DBG_MSG(("Current Station :: FieldStrength: %d", current.quality->data[DMMTunerStationTypes_AMFM_FS]));
   DBG_MSG(("Current Station :: PTY: %d", current.genre->data[DMMTunerStationTypes_AMFM_PTY]));
   //info["fieldStrength"] = current.quality->data[DMMTunerStationTypes_AMFM_FS];
   info["frequency"] = (current.sel.frequency);
   data["frequency"] = (current.sel.frequency);
   data["psName"] = psN;
   data["pty"] = current.genre->data[DMMTunerStationTypes_AMFM_PTY];
   data["fieldStrength"] = current.quality->data[DMMTunerStationTypes_AMFM_FS];


   //Extract available HD services
   DBG_MSG(("[CDMMTunerStationProxy]:informationCurrentStation HD services is %d",current.sel.id->data[DMMTunerStationTypes_AMFM_SERVICES]));
   DBG_MSG(("[CDMMTunerStationProxy]:informationCurrentStation current HD services is %d",current.sel.id->data[DMMTunerStationTypes_AMFM_SERVICE]));

   Json::Value obj;


   if((current.name->data[DMMTunerStationTypes_AMFM_RT])!= NULL)
   {
     data["radioText"] = (current.name->data[DMMTunerStationTypes_AMFM_RT]);
     (CTunerSeekHandler::stnInfo).radioText = (current.name->data[DMMTunerStationTypes_AMFM_RT]);
   }
   else
   {
     data["radioText"] = "";
     (CTunerSeekHandler::stnInfo).radioText = "";
   }

   //pthread_mutex_unlock(&myMutex);


   delete seek;

   DBG_MSG(("[CDMMTunerStationProxy]:informationCurrentStation Waveband is %d",CTunerSeekHandler::getCurrBand()));
   DBG_MSG(("[CDMMTunerStationProxy]:informationCurrentStation CTunerSeekHandler::mFMMinFrequency is %d",CTunerSeekHandler::mFMMinFrequency));
   DBG_MSG(("[CDMMTunerStationProxy]:informationCurrentStation CTunerSeekHandler::mFMMaxFrequency is %d",CTunerSeekHandler::mFMMaxFrequency));
  // CTunerAnnouncementHandler* mAnn = CTunerAnnouncementHandler::getAnnouncementHandler();

   if(((current.sel.deviceType == (DMMTunerTypes_AMFM_FM)) && ((current.sel.frequency >= CTunerSeekHandler::mFMMinFrequency) && (current.sel.frequency <= CTunerSeekHandler::mFMMaxFrequency))) ||
	  ((current.sel.deviceType == (DMMTunerTypes_AMFM_MW)) && ((current.sel.frequency >= CTunerSeekHandler::mAMMinFrequency) && (current.sel.frequency <= CTunerSeekHandler::mAMMaxFrequency))) ||
	  ((current.sel.deviceType == (DMMTunerTypes_AMFM_WB)) && ((current.sel.frequency >= CTunerSeekHandler::mWBMinFrequency) && (current.sel.frequency <= CTunerSeekHandler::mWBMaxFrequency))))
   {

		CTunerRequestResponseHandler::handleNotif(signalName,data);
		CTunerRequestResponseHandler::handleNotif(sigName,info);


   }
   else if(((current.sel.deviceType == 65) && ((current.sel.frequency >= CTunerSeekHandler::mFMMinFrequency) && (current.sel.frequency <= CTunerSeekHandler::mFMMaxFrequency))) ||
   	  ((current.sel.deviceType == 66) && ((current.sel.frequency >= CTunerSeekHandler::mAMMinFrequency) && (current.sel.frequency <= CTunerSeekHandler::mAMMaxFrequency))))
   {
   	   CTunerRequestResponseHandler::handleNotif(signalName,data);
   	   CTunerRequestResponseHandler::handleNotif(sigName,info);
   }
   else
   {
	   DBG_WARNING(("Invalid frequency Received ... "));
   }
   }
   else
   {
	   DBG_WARNING(("Ignored frequency : %d",current.sel.frequency));
   }
}
void CDMMTunerStationProxy::informationSeek(const DMMTunerStation_SeekData& seekData,  unsigned int handle )
{
   TRC_SCOPE(TunerService, CDMMTunerStationProxy, informationSeek);
   DBG_MSG(("CDMMTunerStationProxy::informationSeek received"));
   CTunerScanHandler* mInst = CTunerScanHandler::getScanHandler();
   mInst->setTuningFreq(seekData.frequency);
   //Call function to send response to response handler class
   std::string signalName = "frequency";
   std::string sigName = "seekStatus";
   Json::Value data;
   Json::Value info;
   int mode = seekData.mode;
   switch(mode)
   {
     case 0:
        info["status"] = 0;
        break;
     case 1:

        break;
     case 2:

        break;
     case 3:
    	info["status"] = 1;
        break;
     case 4:
    	info["status"] = 2;
        break;
     case 5:

        break;
     default:
    	 info["status"] = -1;
        break;
   }
   DBG_MSG(("CDMMTunerStationProxy::informationSeek mode received is %d",seekData.mode));
   data["frequency"] = (seekData.frequency);
   if(((CTunerSeekHandler::getCurrBand() == Tuner_Band_FM) && ((seekData.frequency >= CTunerSeekHandler::mFMMinFrequency) && (seekData.frequency <= CTunerSeekHandler::mFMMaxFrequency))) ||
   	  ((CTunerSeekHandler::getCurrBand() == Tuner_Band_AM) && ((seekData.frequency >= CTunerSeekHandler::mAMMinFrequency) && (seekData.frequency <= CTunerSeekHandler::mAMMaxFrequency))) ||
   	((CTunerSeekHandler::getCurrBand() == Tuner_Band_WB) && ((seekData.frequency >= CTunerSeekHandler::mWBMinFrequency) && (seekData.frequency <= CTunerSeekHandler::mWBMaxFrequency))))
      {
	    CTunerRequestResponseHandler::handleNotif(signalName,data);
      }
      else
      {
   	    DBG_WARNING(("Invalid frequency Received in informationSeek... "));
      }
   CTunerRequestResponseHandler::handleNotif(sigName,info);
}

void CDMMTunerStationProxy::informationStationList( const DMMTunerStation_StationList& list,  unsigned int handle  )
{
  	TRC_SCOPE(TunerService, CDMMTunerStationProxy, informationStationList);
	DBG_MSG(("[CDMMTunerStationProxy]: informationStationList \n"));

   DMMTunerStation_Station s;
   std::vector<struct stationInformation> vAutoStoreList;
   UINT32 index;
   UINT32 numStations = 0;
   STRING psN = "";

   if(list.stations!= NULL)
   {
	 DBG_MSG(("Device Type received in station list is %d",list.deviceType));
     if(list.deviceType == DMMTunerTypes_AMFM_FM)
     {
    	 DBG_MSG(("Device Type received FM"));
      	if(list.stations->size > 0)
        {
    	  if(list.stations->size > MAX_TUNER_STATIONS_LIST)
          {
            numStations = MAX_TUNER_STATIONS_LIST;
          }
          else
          {
        	numStations = list.stations->size;
        	DBG_MSG(("Stations received and list size is %d",numStations));
          }

   	   CTunerSeekHandler::stnSize=numStations;
       pthread_mutex_lock( &myMutex );
   	   memset(CTunerSeekHandler::stndata,0,numStations);
       for(index = 0; index < numStations; index++)
       {
           s = list.stations->data[index];
           DBG_MSG(("Stations received and frequency is %d",s.sel.frequency));
           DBG_MSG(("Stations received and pty is %d",s.genre->data[DMMTunerStationTypes_AMFM_PTY]));
           CTunerSeekHandler::stndata[index].freq = s.sel.frequency;
           CTunerSeekHandler::stndata[index].pty =(s.genre->data[DMMTunerStationTypes_AMFM_PTY]);

           //Extract the name for the station if available
           if((s.name->size) > 0)
           {
             if((s.name->data != NULL) && (s.name->data[0] != NULL))
             {
               psN = s.name->data[0];
               strcpy((CTunerSeekHandler::stndata[index].name), psN);
             }
             else
             {
               psN = (char*)"";
               strcpy((CTunerSeekHandler::stndata[index].name), psN);
             }
           }
           DBG_MSG(("Stations received and psName is %s",psN));
           DBG_MSG(("Stations received and pICode is %d",s.sel.id->data[DMMTunerStationTypes_AMFM_PI]));
           //Extract the PI code for the station if available
           if((s.sel.id)!= NULL)
           {
        	   if(0x00010000 == (DMMTunerStationTypes_AMFM_PI_INVALID & (s.sel.id->data[DMMTunerStationTypes_AMFM_PI])))
        	   {

        		   DBG_MSG(("The value of PI not received"));
        	      CTunerSeekHandler::stndata[index].picode = (s.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
        	   }
        	   else if(0x00020000 == (DMMTunerStationTypes_AMFM_PI_INVALID & (s.sel.id->data[DMMTunerStationTypes_AMFM_PI])))
        	   {
        		   DBG_MSG(("The value of PI received for first time"));
        	      CTunerSeekHandler::stndata[index].picode = (s.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
        	   }
        	   else if(0x00040000 == (DMMTunerStationTypes_AMFM_PI_INVALID & (s.sel.id->data[DMMTunerStationTypes_AMFM_PI])))
        	   {
        		   DBG_MSG(("PI timed out"));
        		  CTunerSeekHandler::stndata[index].picode = (s.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
        	   }
        	   else if(!(DMMTunerStationTypes_AMFM_PI_INVALID & (s.sel.id->data[DMMTunerStationTypes_AMFM_PI])))
        	   {
        		   DBG_MSG(("PI valid"));
            	  CTunerSeekHandler::stndata[index].picode = (s.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
        	   }
        	   else
        	   {
        		   ;
        	   }
           }
           else
           {
             ;
           }
         }
	   }
       else
       {
    	   DBG_MSG(("The size received is 0, hence empty station list received"));
    	   CTunerSeekHandler::stnSize = 0;
    	   memset(CTunerSeekHandler::stndata,0,CTunerSeekHandler::stnSize);
       }
       pthread_mutex_unlock(&myMutex);
	 }
     else if(list.deviceType == DMMTunerTypes_AMFM_MW)  // Auto Store Implementation
     {
    	 DBG_MSG(("Device Type is AM"));
    	 DBG_MSG(("Station List size is %d", list.stations->size));

       	if(list.stations->size > 0)
         {
       		if(CTunerCmdInvoker::eListType == 1)
       		{
       			DBG_MSG(("AM Auto Store Preset List"));
      	  if(list.stations->size > MAX_AUTO_STORE_AM_PRESET_LIST)
            {
              numStations = MAX_AUTO_STORE_AM_PRESET_LIST;
            }
            else
            {
          	numStations = list.stations->size;
          	DBG_MSG(("Stations received and list size is %d",numStations));
            }
       		}
       		else if (CTunerCmdInvoker::eListType == 0)
       		{
       			DBG_MSG(("AM Auto Store Station List"));
            	  if(list.stations->size > MAX_AUTO_STORE_AM_STATION_LIST)
                  {
                    numStations = MAX_AUTO_STORE_AM_STATION_LIST;
                  }
                  else
                  {
                	numStations = list.stations->size;
                	DBG_MSG(("Stations received and list size is %d",numStations));
                  }
       		}
       		//CTunerSeekHandler::stnSize=numStations;

            pthread_mutex_lock( &myMutex );
            memset(CTunerSeekHandler::stndataAutoStore,0,numStations);
            Json::Value presetsArray(Json::arrayValue);
            Json::Value StationListArray(Json::arrayValue);
            Json::Value data(Json::objectValue);
            Json::Value objAutoStore(Json::objectValue);
            std::string signalName = "AutoStoreList";
            if(list.stationType & (static_cast<unsigned int>(DMMTunerStation_AUTOSTORED)))
            {
            for(index = 0; index < numStations; index++)
            {
            	s = list.stations->data[index];
            	DBG_MSG(("StationType is %d",s.stationType));
            		DBG_MSG(("AUto Stored Station and Frequency is %d",s.sel.frequency));
            		CTunerSeekHandler::stndataAutoStore[index].freq = s.sel.frequency;
            		CTunerSeekHandler::stndataAutoStore[index].picode = (s.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
            		CTunerSeekHandler::stndataAutoStore[index].pty = (s.genre->data[DMMTunerStationTypes_AMFM_PTY]);
                    if((s.name->size) > 0)
                    {
                      if((s.name->data != NULL) && (s.name->data[0] != NULL))
                      {
                        psN = s.name->data[0];
                        strcpy((CTunerSeekHandler::stndataAutoStore[index].name), psN);
                      }
                      else
                      {
                        psN = (char*)"";
                        strcpy((CTunerSeekHandler::stndataAutoStore[index].name), psN);
                      }
            	   }

                    vAutoStoreList.push_back(CTunerSeekHandler::stndataAutoStore[index]);
            }

            	sort(vAutoStoreList.begin(), vAutoStoreList.end(), comp);
                vector<struct stationInformation>::iterator vItAutoStore;
                int PresetNum = 0;
                CTunerPresetAM* mInst;
                mInst = new CTunerPresetAM();
                if(CTunerCmdInvoker::eListType == 1)
                {
                DBG_MSG(("CTunerCmdInvoker::AM::Clearing the presetList"));
                CTunerPresetAM::presetListAM.clear();
                }
                for(vItAutoStore = vAutoStoreList.begin(); vItAutoStore != vAutoStoreList.end(); vItAutoStore++)
                {
                DBG_MSG(("%d Preset contains %d frequency",PresetNum, (unsigned int)vItAutoStore->freq));
                (*mInst).frequency = vItAutoStore->freq;
                (*mInst).presetNo = PresetNum;
                (*mInst).piCode = vItAutoStore->picode;
                (*mInst).pty = vItAutoStore->pty;
                (*mInst).psName = vItAutoStore->name;
            	DBG_MSG(("mInst->frequency is %d",CTunerPresetAM::value.picode));
            	DBG_MSG(("mInst->presetNo  is %d",PresetNum));
            	data["frequency"] = vItAutoStore->freq;
                data["presetNo"] = PresetNum;
                data["bandtype"] = "am";
                data["psName"]	= vItAutoStore->name;
                data["piCode"] = vItAutoStore->picode;
                data["pty"] = vItAutoStore->pty;
                DBG_MSG(("2"));
                if(CTunerCmdInvoker::eListType == 1)
                {
                	DBG_MSG(("CTunerCmdInvoker::AM::Pushing to the PresetList"));
                    CTunerPresetAM::presetListAM.push_back(*mInst);
                }
                else if(CTunerCmdInvoker::eListType == 0)
                {
                	DBG_MSG(("CTunerCmdInvoker::eListType is StationList"));
                }
                presetsArray[PresetNum] = data;
                StationListArray[PresetNum] = data;
                ++PresetNum;

                }
                if(vAutoStoreList.size() < 6)
                {
                	for(int index = 0; index < ( MAX_AUTO_STORE_AM_PRESET_LIST - vAutoStoreList.size()); index++)
                	{
                		DBG_MSG(("%d Preset contains 530 frequency",PresetNum));
                    	data["frequency"] = 530;
                        data["presetNo"] = PresetNum;
                        data["bandtype"] = "am";
                        data["psName"]	= "";
                        data["piCode"] = 65537;
                        data["pty"] = 0;
                        (*mInst).frequency = 530;
                        (*mInst).presetNo = PresetNum;
                        (*mInst).piCode = 65537;
                        (*mInst).pty = 0;
                        (*mInst).psName = "";
                        if(CTunerCmdInvoker::eListType == 1)
                        {
                        DBG_MSG(("CTunerCmdInvoker::StationList size is less than 6 and eListType: %d",CTunerCmdInvoker::eListType));
                        CTunerPresetAM::presetListAM.push_back(*mInst);
                        }
                        presetsArray[PresetNum] = data;
                        ++PresetNum;
                	}
                }


            }
            if((numStations > 0) && (list.stationType & (static_cast<unsigned int>(DMMTunerStation_AUTOSTORED))))
            {
            DBG_MSG(("Sending AutoStorePreset NumOfStations %d",numStations));
            if(CTunerCmdInvoker::eListType == 1)
                           {
            	CTunerCmdInvoker::eListType = -1;
            	DBG_MSG(("CTunerCmdInvoker::eListType is AutoStoreList"));
            objAutoStore["AutoStorePreset"] = presetsArray;
                           }
            if(CTunerCmdInvoker::eListType == 0)
            {
            	DBG_MSG(("CTunerCmdInvoker::eListType is StationList"));
            	CTunerCmdInvoker::eListType = -1;
            	objAutoStore["AutoStorePreset"] = StationListArray;
            }
            CTunerRequestResponseHandler::handleNotif(signalName,objAutoStore);
            }

            pthread_mutex_unlock(&myMutex);
         }

     }
     else if(list.deviceType == DMMTunerTypes_AMFM_WB)  // Auto Store Implementation
     {
    	 DBG_MSG(("Device Type is WB"));
       	if(list.stations->size > 0)
         {
      	  if(list.stations->size > MAX_AUTO_STORE_AM_STATION_LIST)
            {
              numStations = MAX_AUTO_STORE_AM_STATION_LIST;
            }
            else
            {
          	numStations = list.stations->size;
          	DBG_MSG(("Stations received and list size is %d",numStations));
            }
       		//CTunerSeekHandler::stnSize=numStations;

            pthread_mutex_lock( &myMutex );
            memset(CTunerSeekHandler::stndataAutoStore,0,numStations);
            Json::Value presetsArray(Json::arrayValue);
            Json::Value StationListArray(Json::arrayValue);
            Json::Value data;
            Json::Value objAutoStore(Json::objectValue);
            std::string signalName = "AutoStoreList";
            if(list.stationType & (static_cast<unsigned int>(DMMTunerStation_AUTOSTORED)))
            {
            for(index = 0; index < numStations; index++)
            {
            	s = list.stations->data[index];
            	DBG_MSG(("[ WB ] StationType is %d",s.stationType));
            		DBG_MSG((" [ WB ] Auto Stored Station and Frequency is %d",s.sel.frequency));
            		CTunerSeekHandler::stndataAutoStore[index].freq = s.sel.frequency;
            		CTunerSeekHandler::stndataAutoStore[index].picode = (s.sel.id->data[DMMTunerStationTypes_AMFM_PI]);
            		CTunerSeekHandler::stndataAutoStore[index].pty = (s.genre->data[DMMTunerStationTypes_AMFM_PTY]);;
                    if((s.name->size) > 0)
                    {
                      if((s.name->data != NULL) && (s.name->data[0] != NULL))
                      {
                        psN = s.name->data[0];
                        strcpy((CTunerSeekHandler::stndataAutoStore[index].name), psN);
                      }
                      else
                      {
                        psN = (char*)"";
                        strcpy((CTunerSeekHandler::stndataAutoStore[index].name), psN);
                      }
            	   }

                    vAutoStoreList.push_back(CTunerSeekHandler::stndataAutoStore[index]);
            }
            	//vAutoStoreList.push_back(CTunerSeekHandler::stndataAutoStore[index]);

            	sort(vAutoStoreList.begin(), vAutoStoreList.end(), comp);
                vector<struct stationInformation>::iterator vItAutoStore;
                int PresetNum = 0;
                CTunerPresetWB* mInst;
                mInst = new CTunerPresetWB();
                if(CTunerCmdInvoker::eListType == 1)
                {
                DBG_MSG(("CTunerCmdInvoker::AM::Clearing the presetList"));
                CTunerPresetWB::presetListWB.clear();
                }


                for(vItAutoStore = vAutoStoreList.begin(); vItAutoStore != vAutoStoreList.end(); vItAutoStore++)
                {
                DBG_MSG(("[ WB ] %d Preset contains %d frequency",PresetNum, (unsigned int)vItAutoStore->freq));
                (*mInst).frequency = vItAutoStore->freq;
                (*mInst).presetNo = PresetNum;
                (*mInst).piCode = vItAutoStore->picode;
                (*mInst).pty = vItAutoStore->pty;
                (*mInst).psName = vItAutoStore->name;
            	DBG_MSG(("mInst->frequency is %d",CTunerPresetAM::value.picode));
            	DBG_MSG(("mInst->presetNo  is %d",PresetNum));
            	data["frequency"] = vItAutoStore->freq;
                data["presetNo"] = PresetNum;
                data["bandtype"] = "wb";
                data["psName"]	= vItAutoStore->name;
                data["piCode"] = vItAutoStore->picode;
                data["pty"] = vItAutoStore->pty;
                DBG_MSG(("2"));
                if(CTunerCmdInvoker::eListType == 1)
                {
                	DBG_MSG(("CTunerCmdInvoker::WB::Pushing to the PresetList"));
                CTunerPresetWB::presetListWB.push_back(*mInst);
                }
                else if(CTunerCmdInvoker::eListType == 0)
                {
                	DBG_MSG(("CTunerCmdInvoker::WB::eListType is StationList"));
                }
                presetsArray[PresetNum] = data;
                StationListArray[PresetNum] = data;

                ++PresetNum;

                }
                //delete mInst;
            }
            if((numStations > 0) && (list.stationType & (static_cast<unsigned int>(DMMTunerStation_AUTOSTORED))))
            {
            DBG_MSG(("Sending AutoStorePreset NumOfStations %d",numStations));
            if(CTunerCmdInvoker::eListType == 1)
                           {
            	CTunerCmdInvoker::eListType = -1;
            objAutoStore["AutoStorePreset"] = presetsArray;
                           }
            if(CTunerCmdInvoker::eListType == 0)
            {
            	DBG_MSG(("CTunerCmdInvoker::eListType is StationList"));
            	CTunerCmdInvoker::eListType = -1;
            	objAutoStore["AutoStorePreset"] = StationListArray;
            }
            CTunerRequestResponseHandler::handleNotif(signalName,objAutoStore);
            }

            pthread_mutex_unlock(&myMutex);
         }

     }
     else
     {
    	 DBG_MSG(("Device Type not FM"));
     }
	
	}
   else if((list.stations == NULL) && (DMMTunerTypes_AMFM_FM == list.deviceType))
   {
	   DBG_MSG(("The list received is NULL for FM, hence empty station list received"));
	   pthread_mutex_lock( &myMutex );
	   CTunerSeekHandler::stnSize = 0;
	   memset(CTunerSeekHandler::stndata,0,CTunerSeekHandler::stnSize);
	   pthread_mutex_unlock(&myMutex);
   }
}



