/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: "Control" interface of the NodeStateManager.
		This interface contains
 *   functions, which have direct influence on the system state and therefore have
 *   to be handled with care. The interface can only be used by certain clients,
 *   which need to be configured in the D-Bus configuration.
 */
#include <v2/org/genivi/NodeStateManager/LifecycleControlDBusProxy.hpp>

namespace v2 {
namespace org {
namespace genivi {
namespace NodeStateManager {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createLifecycleControlDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<LifecycleControlDBusProxy>(_address, _connection);
}

INITIALIZER(registerLifecycleControlDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		LifecycleControl::getInterface(),
		&createLifecycleControlDBusProxy);
}

LifecycleControlDBusProxy::LifecycleControlDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
{
}


    
    /**
     * description: RequestNodeRestart:
        	RestartReason: The passed value will be based upon the
     *   enum NsmRestartReason_e.
        	RestartType:   This is the type of restart that
     *   is required, i.e. during Coding process it is normal for a fast shutdown to
     *   be	requested whereas other Diagnosis restart requests would be normal.
     *   Possible values are NSM_SHUTDOWNTYPE_FAST and NSM_SHUTDOWNTYPE_NORMAL.
       
     *   	ErrorCode:     Return value passed to the caller, based upon
     *   NsmErrorStatus_e.
    
        	The method is used by other applications to request a
     *   restart of the node.
     * author: Giridhar
     */
    void LifecycleControlDBusProxy::RequestNodeRestart(const ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmRestartReason &_RestartReason, const uint32_t &_RestartType, CommonAPI::CallStatus &_internalCallStatus, ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus &_ErrorCode, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmRestartReason, CommonAPI::EmptyDeployment> deploy_RestartReason(_RestartReason, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_RestartType(_RestartType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> deploy_ErrorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmRestartReason, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "RequestNodeRestart",
        "iu",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_RestartReason, deploy_RestartType,
_internalCallStatus,
deploy_ErrorCode);
_ErrorCode = deploy_ErrorCode.getValue();
}
    std::future<CommonAPI::CallStatus> LifecycleControlDBusProxy::RequestNodeRestartAsync(const ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmRestartReason &_RestartReason, const uint32_t &_RestartType, RequestNodeRestartAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmRestartReason, CommonAPI::EmptyDeployment> deploy_RestartReason(_RestartReason, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_RestartType(_RestartType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> deploy_ErrorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmRestartReason, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "RequestNodeRestart",
        "iu",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_RestartReason, deploy_RestartType,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> _ErrorCode) {
        	if (_callback)
        		_callback(_internalCallStatus, _ErrorCode.getValue());
        },
        std::make_tuple(deploy_ErrorCode));
    }
    /**
     * description: SetApplicationMode:
        	ApplicationModeId: This parameter will be based upon
     *   the NsmNodeApplicationMode_e.
        	ErrorCode:         Return value passed to
     *   the caller, based upon NsmErrorStatus_e.
        	The method is used by other
     *   applications to request a restart of the node.
     * author: Giridhar
     */
    void LifecycleControlDBusProxy::SetApplicationMode(const ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmApplicationMode &_ApplicationModeId, CommonAPI::CallStatus &_internalCallStatus, ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus &_ErrorCode, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmApplicationMode, CommonAPI::EmptyDeployment> deploy_ApplicationModeId(_ApplicationModeId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> deploy_ErrorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmApplicationMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetApplicationMode",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_ApplicationModeId,
_internalCallStatus,
deploy_ErrorCode);
_ErrorCode = deploy_ErrorCode.getValue();
}
    std::future<CommonAPI::CallStatus> LifecycleControlDBusProxy::SetApplicationModeAsync(const ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmApplicationMode &_ApplicationModeId, SetApplicationModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmApplicationMode, CommonAPI::EmptyDeployment> deploy_ApplicationModeId(_ApplicationModeId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> deploy_ErrorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmApplicationMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetApplicationMode",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_ApplicationModeId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> _ErrorCode) {
        	if (_callback)
        		_callback(_internalCallStatus, _ErrorCode.getValue());
        },
        std::make_tuple(deploy_ErrorCode));
    }
    /**
     * description: SetNodeState:
        	NodeStateId: The passed value will be based upon the enum
     *   NsmNodeState_e.
        	ErrorCode:   Return value passed to the caller, based
     *   upon NsmErrorStatus_e.
        
        	The method is used by other applications to
     *   set the NodeState. When this method is called to change the current NodeState
     *   a signal will be sent to notify registered consumers of the new state.
     * author: Giridhar
     */
    void LifecycleControlDBusProxy::SetNodeState(const ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmNodeState &_NodeStateId, CommonAPI::CallStatus &_internalCallStatus, ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus &_ErrorCode, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmNodeState, CommonAPI::EmptyDeployment> deploy_NodeStateId(_NodeStateId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> deploy_ErrorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmNodeState, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetNodeState",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_NodeStateId,
_internalCallStatus,
deploy_ErrorCode);
_ErrorCode = deploy_ErrorCode.getValue();
}
    std::future<CommonAPI::CallStatus> LifecycleControlDBusProxy::SetNodeStateAsync(const ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmNodeState &_NodeStateId, SetNodeStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmNodeState, CommonAPI::EmptyDeployment> deploy_NodeStateId(_NodeStateId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> deploy_ErrorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmNodeState, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetNodeState",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_NodeStateId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> _ErrorCode) {
        	if (_callback)
        		_callback(_internalCallStatus, _ErrorCode.getValue());
        },
        std::make_tuple(deploy_ErrorCode));
    }
    /**
     * description: SetBootMode:
        	BootMode:   New BootMode to be set. The values will be
     *   defined by a third party header, which has not been delivered yet. The
     *   description needs to be updated as soon as the header is available.
       
     *   	ErrorCode:  Return value passed to the caller, based upon NsmErrorStatus_e.
     
     *     
        	The method has been introduced, because the property "BootMode" can
     *   only be read by other applications. Nevertheless there are some exceptions
     *   where the property should be set by a restricted set of applications which
     *   will be handled within this method.
     * author: Giridhar
     */
    void LifecycleControlDBusProxy::SetBootMode(const int32_t &_BootMode, CommonAPI::CallStatus &_internalCallStatus, ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus &_ErrorCode, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_BootMode(_BootMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> deploy_ErrorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetBootMode",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_BootMode,
_internalCallStatus,
deploy_ErrorCode);
_ErrorCode = deploy_ErrorCode.getValue();
}
    std::future<CommonAPI::CallStatus> LifecycleControlDBusProxy::SetBootModeAsync(const int32_t &_BootMode, SetBootModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_BootMode(_BootMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> deploy_ErrorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetBootMode",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_BootMode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> _ErrorCode) {
        	if (_callback)
        		_callback(_internalCallStatus, _ErrorCode.getValue());
        },
        std::make_tuple(deploy_ErrorCode));
    }
    /**
     * description: SetAppHealthStatus:
        	AppName:    This parameter can be used to give the
     *   name of the application that has failed (this must be the applications systemd
     *   unit name).
        	AppRunning: The AppState will be FALSE for failed and TRUE
     *   for running.
        	ErrorCode:  Return value passed to the caller, based upon
     *   NsmErrorStatus_e.
        
        	This method will be used by the Node Health
     *   Monitor to report to the NSM if an application has failed and if it is running
     *   again. Internally the NSM will use this information to keep a count of the
     *   number of failed applications within the current lifecycle. Additionally it
     *   will unset any sessions that the failing application may have had active. It
     *   will also be possible for the product node state machine to make a decision on
     *   what to do with this information, i.e. even reset the node or reset the node
     *   if too many applications have failed.
       		The method is used by other
     *   applications to request a restart of the node.
     * author: Giridhar
     */
    void LifecycleControlDBusProxy::SetAppHealthStatus(const std::string &_AppName, const bool &_AppRunning, CommonAPI::CallStatus &_internalCallStatus, ::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus &_ErrorCode, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_AppName(_AppName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_AppRunning(_AppRunning, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> deploy_ErrorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetAppHealthStatus",
        "sb",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_AppName, deploy_AppRunning,
_internalCallStatus,
deploy_ErrorCode);
_ErrorCode = deploy_ErrorCode.getValue();
}
    std::future<CommonAPI::CallStatus> LifecycleControlDBusProxy::SetAppHealthStatusAsync(const std::string &_AppName, const bool &_AppRunning, SetAppHealthStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_AppName(_AppName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_AppRunning(_AppRunning, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> deploy_ErrorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetAppHealthStatus",
        "sb",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_AppName, deploy_AppRunning,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v2::org::genivi::NodeStateManager::NodeStateTypes::NsmErrorStatus, CommonAPI::EmptyDeployment> _ErrorCode) {
        	if (_callback)
        		_callback(_internalCallStatus, _ErrorCode.getValue());
        },
        std::make_tuple(deploy_ErrorCode));
    }
    /**
     * description: CheckLucRequired:
        	LucWanted: This will be a simple TRUE or FALSE to define
     *   whether the LUC is wanted in the current Lifecycle.
       
        	This method will
     *   be called exclusivley by the Boot Manager to find out whether the LUC
     *   Applications should be started in the current Lifecycle. This is required
     *   whilst in certain Node Application Modes (i.e. Transport, Factory) we do not
     *   want the LUC Applications started.
     * author: Giridhar
     */
    void LifecycleControlDBusProxy::CheckLucRequired(CommonAPI::CallStatus &_internalCallStatus, bool &_LucWanted, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_LucWanted(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "CheckLucRequired",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_LucWanted);
_LucWanted = deploy_LucWanted.getValue();
}
    std::future<CommonAPI::CallStatus> LifecycleControlDBusProxy::CheckLucRequiredAsync(CheckLucRequiredAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_LucWanted(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "CheckLucRequired",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> _LucWanted) {
        	if (_callback)
        		_callback(_internalCallStatus, _LucWanted.getValue());
        },
        std::make_tuple(deploy_LucWanted));
    }


void LifecycleControlDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 2;
          ownVersionMinor = 0;
      }

      } // namespace NodeStateManager
      } // namespace genivi
      } // namespace org
      } // namespace v2
