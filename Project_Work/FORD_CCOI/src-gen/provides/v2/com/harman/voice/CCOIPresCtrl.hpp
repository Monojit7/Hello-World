/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V2_COM_HARMAN_VOICE_CCOI_PRES_CTRL_HPP_
#define V2_COM_HARMAN_VOICE_CCOI_PRES_CTRL_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v2 {
namespace com {
namespace harman {
namespace voice {

class CCOIPresCtrl {
public:
    virtual ~CCOIPresCtrl() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct ToggleSts : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            TOGGLE_OFF = 0,
            TOGGLE_ON = 1
        };
        
        ToggleSts() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::TOGGLE_OFF)) {}
        ToggleSts(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::TOGGLE_OFF):
                case static_cast<int32_t>(Literal::TOGGLE_ON):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ToggleSts &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ToggleSts &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ToggleSts &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ToggleSts &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ToggleSts &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ToggleSts &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct LocDataShareIconValues : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            LD_INVALID = -1,
            LD_LOC_ONLY = 0,
            LD_DATA_ONLY = 1,
            LD_DATA_LOC = 2
        };
        
        LocDataShareIconValues() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::LD_INVALID)) {}
        LocDataShareIconValues(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::LD_INVALID):
                case static_cast<int32_t>(Literal::LD_LOC_ONLY):
                case static_cast<int32_t>(Literal::LD_DATA_ONLY):
                case static_cast<int32_t>(Literal::LD_DATA_LOC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocDataShareIconValues &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocDataShareIconValues &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocDataShareIconValues &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocDataShareIconValues &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocDataShareIconValues &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocDataShareIconValues &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct entityDetails : CommonAPI::Struct<std::string, std::string, std::string, std::string, ToggleSts, std::string, std::string, bool, LocDataShareIconValues, bool, bool> {
    	
    	entityDetails() {
    		std::get<7>(values_) = false;
    		std::get<9>(values_) = false;
    		std::get<10>(values_) = false;
    	}
    	entityDetails(const std::string &_unique_id, const std::string &_entity_type, const std::string &_entity_id, const std::string &_name, const ToggleSts &_toggle_val, const std::string &_info_text, const std::string &_icon_file, const bool &_grey_out, const LocDataShareIconValues &_loc_data_icon_val, const bool &_toggleVisible, const bool &_infoVisible)
    	{
    		std::get<0>(values_) = _unique_id;
    		std::get<1>(values_) = _entity_type;
    		std::get<2>(values_) = _entity_id;
    		std::get<3>(values_) = _name;
    		std::get<4>(values_) = _toggle_val;
    		std::get<5>(values_) = _info_text;
    		std::get<6>(values_) = _icon_file;
    		std::get<7>(values_) = _grey_out;
    		std::get<8>(values_) = _loc_data_icon_val;
    		std::get<9>(values_) = _toggleVisible;
    		std::get<10>(values_) = _infoVisible;
    	}
    	/**
    	 * description: This id is used to determine the entity in the settings menu.
    	 */
    	inline const std::string &getUnique_id() const { return std::get<0>(values_); }
    	inline void setUnique_id(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: entity type info received from TCU.
    	 */
    	inline const std::string &getEntity_type() const { return std::get<1>(values_); }
    	inline void setEntity_type(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: entity id received from TCU.
    	 */
    	inline const std::string &getEntity_id() const { return std::get<2>(values_); }
    	inline void setEntity_id(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: contains the name of the entity that need to be displayed in the settings menu.
    	 */
    	inline const std::string &getName() const { return std::get<3>(values_); }
    	inline void setName(const std::string &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: ON/OFF toggle status in the settings menu. based on user changes, this will be
    	 *   updated by HMI
    	 */
    	inline const ToggleSts &getToggle_val() const { return std::get<4>(values_); }
    	inline void setToggle_val(const ToggleSts &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: contains the text that need to be shown when the user presses the info button.
    	 */
    	inline const std::string &getInfo_text() const { return std::get<5>(values_); }
    	inline void setInfo_text(const std::string &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: if a specific icon image has to be displayed, the image file name will be
    	 *   available in this field.
    	 */
    	inline const std::string &getIcon_file() const { return std::get<6>(values_); }
    	inline void setIcon_file(const std::string &_value) { std::get<6>(values_) = _value; }
    	/**
    	 * description: contains the info for displaying the entity as greyed or not in settings menu. 
    	 *   greyed item are not user selectable in settings menu
    	 */
    	inline const bool &getGrey_out() const { return std::get<7>(values_); }
    	inline void setGrey_out(const bool _value) { std::get<7>(values_) = _value; }
    	/**
    	 * description: Refer the description in the enumerator LocDataShareIconValues
    	 */
    	inline const LocDataShareIconValues &getLoc_data_icon_val() const { return std::get<8>(values_); }
    	inline void setLoc_data_icon_val(const LocDataShareIconValues &_value) { std::get<8>(values_) = _value; }
    	/**
    	 * description: contains the info whether to display toggle button for this entity or not.
    	 */
    	inline const bool &getToggleVisible() const { return std::get<9>(values_); }
    	inline void setToggleVisible(const bool _value) { std::get<9>(values_) = _value; }
    	/**
    	 * description: contains the visibility of info button whether it shall be displayed or not
    	 *   besides the menu entity item
    	 */
    	inline const bool &getInfoVisible() const { return std::get<10>(values_); }
    	inline void setInfoVisible(const bool _value) { std::get<10>(values_) = _value; }
    	inline bool operator==(const entityDetails& _other) const {
                return (getUnique_id() == _other.getUnique_id() && getEntity_type() == _other.getEntity_type() && getEntity_id() == _other.getEntity_id() && getName() == _other.getName() && getToggle_val() == _other.getToggle_val() && getInfo_text() == _other.getInfo_text() && getIcon_file() == _other.getIcon_file() && getGrey_out() == _other.getGrey_out() && getLoc_data_icon_val() == _other.getLoc_data_icon_val() && getToggleVisible() == _other.getToggleVisible() && getInfoVisible() == _other.getInfoVisible());
        }
    	inline bool operator!=(const entityDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<CCOIPresCtrl::entityDetails> entity;
    
    struct SyncStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SYNC_NOT_SUPPORTED = -1,
            SYNC_IN_PROGRESS = 0,
            SYNC_DONE = 1,
            SYNC_ERROR = 2,
            SYNC_TIMED_ERROR = 3,
            SYNC_SM_INCONSISTENT = 4,
            SYNC_DATA_SAVE_ERROR = 5,
            SYNC_SOFTWARE_UPDATE = 6
        };
        
        SyncStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SYNC_NOT_SUPPORTED)) {}
        SyncStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SYNC_NOT_SUPPORTED):
                case static_cast<int32_t>(Literal::SYNC_IN_PROGRESS):
                case static_cast<int32_t>(Literal::SYNC_DONE):
                case static_cast<int32_t>(Literal::SYNC_ERROR):
                case static_cast<int32_t>(Literal::SYNC_TIMED_ERROR):
                case static_cast<int32_t>(Literal::SYNC_SM_INCONSISTENT):
                case static_cast<int32_t>(Literal::SYNC_DATA_SAVE_ERROR):
                case static_cast<int32_t>(Literal::SYNC_SOFTWARE_UPDATE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SyncStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SyncStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SyncStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SyncStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SyncStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SyncStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: sync popups along with Ids, as per latest PTE & UFM received the message
     *   displayed in the pop-up is dynamic and shall retrieved from PTE, UFM
     */
    struct syncPopupMessage : CommonAPI::Struct<SyncStatus, std::string> {
    	
    	syncPopupMessage() {
    	}
    	syncPopupMessage(const SyncStatus &_id, const std::string &_message)
    	{
    		std::get<0>(values_) = _id;
    		std::get<1>(values_) = _message;
    	}
    	inline const SyncStatus &getId() const { return std::get<0>(values_); }
    	inline void setId(const SyncStatus &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getMessage() const { return std::get<1>(values_); }
    	inline void setMessage(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const syncPopupMessage& _other) const {
                return (getId() == _other.getId() && getMessage() == _other.getMessage());
        }
    	inline bool operator!=(const syncPopupMessage &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: contains the status of the location entity obtained from PTE, syncSettings in
     *   CCOI, clients like appLink need to know location status.
     */
    struct Location : CommonAPI::Struct<bool, bool> {
    	
    	Location() {
    		std::get<0>(values_) = false;
    		std::get<1>(values_) = false;
    	}
    	Location(const bool &_status, const bool &_subscribed)
    	{
    		std::get<0>(values_) = _status;
    		std::get<1>(values_) = _subscribed;
    	}
    	/**
    	 * description: status which has the value true for Location ON & false for Location OFF.
    	 */
    	inline const bool &getStatus() const { return std::get<0>(values_); }
    	inline void setStatus(const bool _value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: whether location entity is subscribed by enduser or not.
    	 */
    	inline const bool &getSubscribed() const { return std::get<1>(values_); }
    	inline void setSubscribed(const bool _value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const Location& _other) const {
                return (getStatus() == _other.getStatus() && getSubscribed() == _other.getSubscribed());
        }
    	inline bool operator!=(const Location &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: contains the value of the app & brand Names used to replace the varibale texts
     *   in the display texts in various contexts, will be picked from PTE
    		          
     *          clients will call this to known the appNames & replace their UI with
     *   this text ex: wifiPresCtrl has a dependency on this.
     */
    struct AppBrandNames : CommonAPI::Struct<std::string, std::string> {
    	
    	AppBrandNames() {
    	}
    	AppBrandNames(const std::string &_appName, const std::string &_brandName)
    	{
    		std::get<0>(values_) = _appName;
    		std::get<1>(values_) = _brandName;
    	}
    	/**
    	 * description: contains the value of th eapp Name used to replace in various contexts, will be
    	 *   picked from PTE.
    	 */
    	inline const std::string &getAppName() const { return std::get<0>(values_); }
    	inline void setAppName(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: whether location entity is subscribed by enduser or not.
    	 */
    	inline const std::string &getBrandName() const { return std::get<1>(values_); }
    	inline void setBrandName(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const AppBrandNames& _other) const {
                return (getAppName() == _other.getAppName() && getBrandName() == _other.getBrandName());
        }
    	inline bool operator!=(const AppBrandNames &_other) const {
    		return !((*this) == _other);
    	}
    
    };
};

const char* CCOIPresCtrl::getInterface() {
    return ("com.harman.voice.CCOIPresCtrl");
}

CommonAPI::Version CCOIPresCtrl::getInterfaceVersion() {
    return CommonAPI::Version(2, 0);
}

/**
 * description: sync popups along with Ids, as per latest PTE & UFM received the message
 *   displayed in the pop-up is dynamic and shall retrieved from PTE, UFM
 */
/**
 * description: contains the status of the location entity obtained from PTE, syncSettings in
 *   CCOI, clients like appLink need to know location status.
 */
/**
 * description: contains the value of the app & brand Names used to replace the varibale texts
 *   in the display texts in various contexts, will be picked from PTE
		          
 *          clients will call this to known the appNames & replace their UI with
 *   this text ex: wifiPresCtrl has a dependency on this.
 */

} // namespace voice
} // namespace harman
} // namespace com
} // namespace v2

namespace CommonAPI {
}


// Compatibility
namespace v2_0 = v2;

#endif // V2_COM_HARMAN_VOICE_CCOI_PRES_CTRL_HPP_
