/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V1_COM_HARMAN_VEHICLE_Vehicle_Type_HPP_
#define V1_COM_HARMAN_VEHICLE_Vehicle_Type_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace vehicle {

struct VehicleType {
    
    struct eBezelBeeps : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INACTIVE = 0,
            ENABLED = 1,
            DISABLED = 2
        };
        
        eBezelBeeps() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INACTIVE)) {}
        eBezelBeeps(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INACTIVE):
                case static_cast<int32_t>(Literal::ENABLED):
                case static_cast<int32_t>(Literal::DISABLED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eBezelBeeps &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eBezelBeeps &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eBezelBeeps &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eBezelBeeps &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eBezelBeeps &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eBezelBeeps &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eDisplayLang : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            Invalid = 0,
            Unknown = 1,
            UK_English = 2,
            NA_English = 3,
            German = 4,
            Italian = 5,
            EU_French = 6,
            Cana_French = 7,
            EU_Spanish = 8,
            Mex_Spanish = 9,
            Turkish = 10,
            Russian = 11,
            Dutch = 12,
            Flemish = 13,
            Polish = 14,
            Czech = 15,
            Greek = 16,
            Hungarian = 17,
            Swedish = 18,
            Danish = 19,
            Norwegian = 20,
            Finish = 21,
            EU_Portuguese = 22,
            Braz_Portuguese = 23,
            Japanese = 24,
            AU_English = 25,
            Korean = 26,
            Mandarin_Chinese = 27,
            Taiwanese = 28,
            Arabic = 29,
            Slovak = 30,
            Thai = 31,
            Indian_English = 32
        };
        
        eDisplayLang() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::Invalid)) {}
        eDisplayLang(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::Invalid):
                case static_cast<int32_t>(Literal::Unknown):
                case static_cast<int32_t>(Literal::UK_English):
                case static_cast<int32_t>(Literal::NA_English):
                case static_cast<int32_t>(Literal::German):
                case static_cast<int32_t>(Literal::Italian):
                case static_cast<int32_t>(Literal::EU_French):
                case static_cast<int32_t>(Literal::Cana_French):
                case static_cast<int32_t>(Literal::EU_Spanish):
                case static_cast<int32_t>(Literal::Mex_Spanish):
                case static_cast<int32_t>(Literal::Turkish):
                case static_cast<int32_t>(Literal::Russian):
                case static_cast<int32_t>(Literal::Dutch):
                case static_cast<int32_t>(Literal::Flemish):
                case static_cast<int32_t>(Literal::Polish):
                case static_cast<int32_t>(Literal::Czech):
                case static_cast<int32_t>(Literal::Greek):
                case static_cast<int32_t>(Literal::Hungarian):
                case static_cast<int32_t>(Literal::Swedish):
                case static_cast<int32_t>(Literal::Danish):
                case static_cast<int32_t>(Literal::Norwegian):
                case static_cast<int32_t>(Literal::Finish):
                case static_cast<int32_t>(Literal::EU_Portuguese):
                case static_cast<int32_t>(Literal::Braz_Portuguese):
                case static_cast<int32_t>(Literal::Japanese):
                case static_cast<int32_t>(Literal::AU_English):
                case static_cast<int32_t>(Literal::Korean):
                case static_cast<int32_t>(Literal::Mandarin_Chinese):
                case static_cast<int32_t>(Literal::Taiwanese):
                case static_cast<int32_t>(Literal::Arabic):
                case static_cast<int32_t>(Literal::Slovak):
                case static_cast<int32_t>(Literal::Thai):
                case static_cast<int32_t>(Literal::Indian_English):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eDisplayLang &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eDisplayLang &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eDisplayLang &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eDisplayLang &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eDisplayLang &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eDisplayLang &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eDisplayLangResponse : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INACTIVE = 0,
            LANGUAGEUPDATED = 1,
            LANGUAGENOTSUPPORTED = 2
        };
        
        eDisplayLangResponse() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INACTIVE)) {}
        eDisplayLangResponse(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INACTIVE):
                case static_cast<int32_t>(Literal::LANGUAGEUPDATED):
                case static_cast<int32_t>(Literal::LANGUAGENOTSUPPORTED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eDisplayLangResponse &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eDisplayLangResponse &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eDisplayLangResponse &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eDisplayLangResponse &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eDisplayLangResponse &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eDisplayLangResponse &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eDistanceUnits : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            METRIC = 0,
            IMPERIAL = 1,
            INACTIVE = 2
        };
        
        eDistanceUnits() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::METRIC)) {}
        eDistanceUnits(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::METRIC):
                case static_cast<int32_t>(Literal::IMPERIAL):
                case static_cast<int32_t>(Literal::INACTIVE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eDistanceUnits &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eDistanceUnits &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eDistanceUnits &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eDistanceUnits &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eDistanceUnits &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eDistanceUnits &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eTempreatureUnits : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            CELSIUS = 0,
            FAHRENHEIT = 1,
            INACTIVE = 2
        };
        
        eTempreatureUnits() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::CELSIUS)) {}
        eTempreatureUnits(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::CELSIUS):
                case static_cast<int32_t>(Literal::FAHRENHEIT):
                case static_cast<int32_t>(Literal::INACTIVE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eTempreatureUnits &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eTempreatureUnits &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eTempreatureUnits &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eTempreatureUnits &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eTempreatureUnits &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eTempreatureUnits &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eTimeFormat : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INACTIVE = 0,
            H12_MODE = 1,
            H24_MODE = 2
        };
        
        eTimeFormat() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INACTIVE)) {}
        eTimeFormat(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INACTIVE):
                case static_cast<int32_t>(Literal::H12_MODE):
                case static_cast<int32_t>(Literal::H24_MODE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eTimeFormat &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eTimeFormat &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eTimeFormat &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eTimeFormat &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eTimeFormat &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eTimeFormat &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eAmbientLightingColor : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            LightAmbColor_Invalid = 0,
            LightAmbColor_1 = 1,
            LightAmbColor_2 = 2,
            LightAmbColor_3 = 3,
            LightAmbColor_4 = 4,
            LightAmbColor_5 = 5,
            LightAmbColor_6 = 6,
            LightAmbColor_7 = 7,
            LightAmbColor_8 = 8,
            LightAmbColor_9 = 9,
            LightAmbColor_10 = 10,
            LightAmbColor_11 = 11,
            LightAmbColor_12 = 12,
            LightAmbColor_13 = 13,
            LightAmbColor_14 = 14,
            LightAmbColor_15 = 15,
            LightAmbColor_16 = 16
        };
        
        eAmbientLightingColor() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::LightAmbColor_Invalid)) {}
        eAmbientLightingColor(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::LightAmbColor_Invalid):
                case static_cast<int32_t>(Literal::LightAmbColor_1):
                case static_cast<int32_t>(Literal::LightAmbColor_2):
                case static_cast<int32_t>(Literal::LightAmbColor_3):
                case static_cast<int32_t>(Literal::LightAmbColor_4):
                case static_cast<int32_t>(Literal::LightAmbColor_5):
                case static_cast<int32_t>(Literal::LightAmbColor_6):
                case static_cast<int32_t>(Literal::LightAmbColor_7):
                case static_cast<int32_t>(Literal::LightAmbColor_8):
                case static_cast<int32_t>(Literal::LightAmbColor_9):
                case static_cast<int32_t>(Literal::LightAmbColor_10):
                case static_cast<int32_t>(Literal::LightAmbColor_11):
                case static_cast<int32_t>(Literal::LightAmbColor_12):
                case static_cast<int32_t>(Literal::LightAmbColor_13):
                case static_cast<int32_t>(Literal::LightAmbColor_14):
                case static_cast<int32_t>(Literal::LightAmbColor_15):
                case static_cast<int32_t>(Literal::LightAmbColor_16):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eAmbientLightingColor &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eAmbientLightingColor &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eAmbientLightingColor &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eAmbientLightingColor &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eAmbientLightingColor &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eAmbientLightingColor &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Structure containing colour id and intensity
     */
    struct AmbientLightSetting : CommonAPI::Struct<eAmbientLightingColor, int16_t> {
    	
    	AmbientLightSetting() {
    	}
    	AmbientLightSetting(const eAmbientLightingColor &_Color, const int16_t &_Intensity)
    	{
    		std::get<0>(values_) = _Color;
    		std::get<1>(values_) = _Intensity;
    	}
    	inline const eAmbientLightingColor &getColor() const { return std::get<0>(values_); }
    	inline void setColor(const eAmbientLightingColor &_value) { std::get<0>(values_) = _value; }
    	inline const int16_t &getIntensity() const { return std::get<1>(values_); }
    	inline void setIntensity(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const AmbientLightSetting& _other) const {
                return (getColor() == _other.getColor() && getIntensity() == _other.getIntensity());
        }
    	inline bool operator!=(const AmbientLightSetting &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::vector<VehicleType::AmbientLightSetting> ListAmbLightSettings;
    
    struct eWirelessChargingStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            Null = 0,
            Charging_NotIn_Progress = 1,
            Charging_In_Progress = 2,
            Charging_Complete = 3,
            Metal_Object_Detected = 4,
            Overheat = 5,
            Misalignment = 6,
            Reserved = 7
        };
        
        eWirelessChargingStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::Null)) {}
        eWirelessChargingStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::Null):
                case static_cast<int32_t>(Literal::Charging_NotIn_Progress):
                case static_cast<int32_t>(Literal::Charging_In_Progress):
                case static_cast<int32_t>(Literal::Charging_Complete):
                case static_cast<int32_t>(Literal::Metal_Object_Detected):
                case static_cast<int32_t>(Literal::Overheat):
                case static_cast<int32_t>(Literal::Misalignment):
                case static_cast<int32_t>(Literal::Reserved):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eWirelessChargingStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eWirelessChargingStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eWirelessChargingStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eWirelessChargingStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eWirelessChargingStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eWirelessChargingStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct EGenericVehResp : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            e_Failure = 0,
            e_Success = 1
        };
        
        EGenericVehResp() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::e_Failure)) {}
        EGenericVehResp(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::e_Failure):
                case static_cast<int32_t>(Literal::e_Success):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const EGenericVehResp &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const EGenericVehResp &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const EGenericVehResp &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const EGenericVehResp &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const EGenericVehResp &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const EGenericVehResp &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eCountryRegion : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            REGION_INVALID = 0,
            REGION_NORTH_AMERICA = 1,
            REGION_EUROPE = 2,
            REGION_US = 3
        };
        
        eCountryRegion() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::REGION_INVALID)) {}
        eCountryRegion(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::REGION_INVALID):
                case static_cast<int32_t>(Literal::REGION_NORTH_AMERICA):
                case static_cast<int32_t>(Literal::REGION_EUROPE):
                case static_cast<int32_t>(Literal::REGION_US):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eCountryRegion &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eCountryRegion &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eCountryRegion &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eCountryRegion &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eCountryRegion &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eCountryRegion &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: SWVersion: Software Version, Revision: Revision Number, ESN: ESN, ESN_TCU: TCU
     *   ESN, PartNo: Part Number, VIN: VIN
     */
    struct VersionInfoList : CommonAPI::Struct<std::string, std::string, std::string, std::string, std::string, std::string> {
    	
    	VersionInfoList() {
    	}
    	VersionInfoList(const std::string &_SWVersion, const std::string &_Revision, const std::string &_ESN, const std::string &_ESN_TCU, const std::string &_PartNo, const std::string &_VIN)
    	{
    		std::get<0>(values_) = _SWVersion;
    		std::get<1>(values_) = _Revision;
    		std::get<2>(values_) = _ESN;
    		std::get<3>(values_) = _ESN_TCU;
    		std::get<4>(values_) = _PartNo;
    		std::get<5>(values_) = _VIN;
    	}
    	inline const std::string &getSWVersion() const { return std::get<0>(values_); }
    	inline void setSWVersion(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getRevision() const { return std::get<1>(values_); }
    	inline void setRevision(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline const std::string &getESN() const { return std::get<2>(values_); }
    	inline void setESN(const std::string &_value) { std::get<2>(values_) = _value; }
    	inline const std::string &getESN_TCU() const { return std::get<3>(values_); }
    	inline void setESN_TCU(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline const std::string &getPartNo() const { return std::get<4>(values_); }
    	inline void setPartNo(const std::string &_value) { std::get<4>(values_) = _value; }
    	inline const std::string &getVIN() const { return std::get<5>(values_); }
    	inline void setVIN(const std::string &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const VersionInfoList& _other) const {
                return (getSWVersion() == _other.getSWVersion() && getRevision() == _other.getRevision() && getESN() == _other.getESN() && getESN_TCU() == _other.getESN_TCU() && getPartNo() == _other.getPartNo() && getVIN() == _other.getVIN());
        }
    	inline bool operator!=(const VersionInfoList &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.vehicle.VehicleType";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 1);
}

}; // struct VehicleType

} // namespace vehicle
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
}


namespace std {
    //Hash for eBezelBeeps
    template<>
    struct hash<::v1::com::harman::vehicle::VehicleType::eBezelBeeps> {
        inline size_t operator()(const ::v1::com::harman::vehicle::VehicleType::eBezelBeeps& eBezelBeeps) const {
            return static_cast<int32_t>(eBezelBeeps);
        }
    };
    //Hash for eDisplayLang
    template<>
    struct hash<::v1::com::harman::vehicle::VehicleType::eDisplayLang> {
        inline size_t operator()(const ::v1::com::harman::vehicle::VehicleType::eDisplayLang& eDisplayLang) const {
            return static_cast<int32_t>(eDisplayLang);
        }
    };
    //Hash for eDisplayLangResponse
    template<>
    struct hash<::v1::com::harman::vehicle::VehicleType::eDisplayLangResponse> {
        inline size_t operator()(const ::v1::com::harman::vehicle::VehicleType::eDisplayLangResponse& eDisplayLangResponse) const {
            return static_cast<int32_t>(eDisplayLangResponse);
        }
    };
    //Hash for eDistanceUnits
    template<>
    struct hash<::v1::com::harman::vehicle::VehicleType::eDistanceUnits> {
        inline size_t operator()(const ::v1::com::harman::vehicle::VehicleType::eDistanceUnits& eDistanceUnits) const {
            return static_cast<int32_t>(eDistanceUnits);
        }
    };
    //Hash for eTempreatureUnits
    template<>
    struct hash<::v1::com::harman::vehicle::VehicleType::eTempreatureUnits> {
        inline size_t operator()(const ::v1::com::harman::vehicle::VehicleType::eTempreatureUnits& eTempreatureUnits) const {
            return static_cast<int32_t>(eTempreatureUnits);
        }
    };
    //Hash for eTimeFormat
    template<>
    struct hash<::v1::com::harman::vehicle::VehicleType::eTimeFormat> {
        inline size_t operator()(const ::v1::com::harman::vehicle::VehicleType::eTimeFormat& eTimeFormat) const {
            return static_cast<int32_t>(eTimeFormat);
        }
    };
    //Hash for eAmbientLightingColor
    template<>
    struct hash<::v1::com::harman::vehicle::VehicleType::eAmbientLightingColor> {
        inline size_t operator()(const ::v1::com::harman::vehicle::VehicleType::eAmbientLightingColor& eAmbientLightingColor) const {
            return static_cast<int32_t>(eAmbientLightingColor);
        }
    };
    //Hash for eWirelessChargingStatus
    template<>
    struct hash<::v1::com::harman::vehicle::VehicleType::eWirelessChargingStatus> {
        inline size_t operator()(const ::v1::com::harman::vehicle::VehicleType::eWirelessChargingStatus& eWirelessChargingStatus) const {
            return static_cast<int32_t>(eWirelessChargingStatus);
        }
    };
    //Hash for EGenericVehResp
    template<>
    struct hash<::v1::com::harman::vehicle::VehicleType::EGenericVehResp> {
        inline size_t operator()(const ::v1::com::harman::vehicle::VehicleType::EGenericVehResp& eGenericVehResp) const {
            return static_cast<int32_t>(eGenericVehResp);
        }
    };
    //Hash for eCountryRegion
    template<>
    struct hash<::v1::com::harman::vehicle::VehicleType::eCountryRegion> {
        inline size_t operator()(const ::v1::com::harman::vehicle::VehicleType::eCountryRegion& eCountryRegion) const {
            return static_cast<int32_t>(eCountryRegion);
        }
    };
}


// Compatibility
namespace v1_1 = v1;

#endif // V1_COM_HARMAN_VEHICLE_Vehicle_Type_HPP_
