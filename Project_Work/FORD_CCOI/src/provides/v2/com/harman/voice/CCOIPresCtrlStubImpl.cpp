/**
 * generated by Voice CodeGen Version: R1_v1.3.0
 * generated on: Mon Feb 27 15:02:49 IST 2017
 */

#include "v2/com/harman/voice/CCOIPresCtrlStubImpl.hpp"

namespace v2 {
    namespace com {
        namespace harman {
            namespace voice {

// global instances required to interact with HMI.. 
CCOIPresCtrl::entity                    gMenu ;             // HMI
string                                  gMenuInfo ;         // HMI
CCOIPresCtrl::Location                  gLocation ;         // HMI
vector < uint8_t >                      gTcu_snList ;       // HMI
CCOIPresCtrl::LocDataShareIconValues    gLocDataShareIcon ; // HMI

// static members definition
CCOIPresCtrl::syncPopupMessage CCOIPresCtrlStubImpl::syncStatus_ ;

// container to map the status values of CCOI component to HMI understanding status values.
// these are the only states we are interested in, as the sync popups are defined only for these states, the rest of the states are ignored.
unordered_map < int, CCOIPresCtrl::SyncStatus >  CCOIPresCtrlStubImpl::statusCCOItoHMIMap_ = {

    { CCOI_INVALID,                                             CCOIPresCtrl::SyncStatus::Literal::SYNC_NOT_SUPPORTED   },
    { CCOI_WAITING,                                             CCOIPresCtrl::SyncStatus::Literal::SYNC_NOT_SUPPORTED   },
    { CCOI_ONBOARD_UPDATE_PENDING,                              CCOIPresCtrl::SyncStatus::Literal::SYNC_IN_PROGRESS     },
    { CCOI_SYNC_NEEDED,                                         CCOIPresCtrl::SyncStatus::Literal::SYNC_IN_PROGRESS     },
    { CCOI_SYNCHRONIZING,                                       CCOIPresCtrl::SyncStatus::Literal::SYNC_IN_PROGRESS     },
    { CCOI_SYNC_FAILED,                                         CCOIPresCtrl::SyncStatus::Literal::SYNC_IN_PROGRESS     },
    { CCOI_ONBOARD_DISTRIBUTED_STATE_MACHINE_INCONSISTENT,      CCOIPresCtrl::SyncStatus::Literal::SYNC_IN_PROGRESS     },
    { CCOI_SYNCHRONIZED,                                        CCOIPresCtrl::SyncStatus::Literal::SYNC_DONE            },
    { CCOI_DATA_STORAGE_ERROR,                                  CCOIPresCtrl::SyncStatus::Literal::SYNC_DATA_SAVE_ERROR },
    { CCOI_UNRECOVERABLE_SYNC_ERROR,                            CCOIPresCtrl::SyncStatus::Literal::SYNC_ERROR           }
};

// entityName, entityType, entityID in respective order
unordered_map < string, pair < string, string > > CCOIPresCtrlStubImpl::entityNamesMap_ = 
{
    { "VehicleConnectivity",       { "0",  "1" }    },
    { "UserAuthorizationPending",  { "0",  "2" }    },
    { "TcuAuthorized",             { "0",  "3" }    },
    { "Location",                  { "0",  "4" }    },
    { "VehicleData",               { "0",  "5" }    },
    { "Traffic",                   { "1",  "1" }    },
    { "Fleet",                     { "1",  "2" }    }
} ;

/* first entry corresponds to bit map of triplet < bUAllowOnOff, bPAllowOnOff, bFPOnOff > */
unordered_map < int, int > CCOIPresCtrlStubImpl::flagsSummaryBitMap_ =
{
    { 0, 0 },
    { 4, 0 },
    { 2, 0 },
    { 6, 1 },
    { 1, 0 },
    { 5, 0 },
    { 3, 1 },
    { 7, 1 }
} ;

/* first entry corresponds to bit map of triplet < bPAllowOnOff, bFPOnOff, bSAllowOnOff >, set contains triplet of flags < visible, enable, value > */
unordered_map < int, int > CCOIPresCtrlStubImpl::flagsVESBitMap_ =
{
    { 2, 0 },
    { 3, 0 },
    { 6, 4 },
    { 7, 5 },
    { 0, 0 },
    { 1, 0 },
    { 4, 4 },
    { 5, 7 }
} ;

CCOIPresCtrlStubImpl::CCOIPresCtrlStubImpl()
{
    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, " CCOIPresCtrlStubImpl::CCOIPresCtrlStubImpl created\n" ) ;

}

bool CCOIPresCtrlStubImpl::loadEntities ( )
{
    // clear old entries
    entities_. clear () ;

    ifstream entitiesStream ( ENTITIES_DATA_PATH ) ;
    if ( entitiesStream. is_open () )
    {
        string entityID ;
        string entityType ;
        
        bool success = true ;
        while ( success )
        {
            success = success && getline ( entitiesStream, entityID ) ;
            success = success && getline ( entitiesStream, entityType ) ;

            vector < string > flags ;
            for ( int i = 0; i < NUM_ENTITY_FLAGS; i++)
            {
                string temp ;
                success = success && getline ( entitiesStream, temp ) ;
                
                if ( ! temp. empty () )   flags. push_back ( temp ) ;
            }
            
            if ( success )    entities_. push_back ( make_shared < EntityElement > ( entityID, entityType, flags ) ) ;
        }
        // sets the icon used by HMI for display based on current data of entities 
        CCOIMessagesUtil msgUtil ;
        msgUtil. populateEntries ( "iconRules", getEntities () ) ;
        updateLocationStatus () ;
    }
    else    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, " SettingsEntries file not yet persisted, so no data to load upon init" ) ;
    
    CCOIMessagesUtil msgUtil ;
    gMenuInfo = msgUtil. getMessage ( "infoText", "11", "menu", true ) ; // menu infoText comes in messageCode 11 as per latest UFM, keep track of it and change as per UFM

    setInfoMessageAttribute ( gMenuInfo ) ;

    return ( entities_. size () > 0 ) ;
}

bool CCOIPresCtrlStubImpl::loadHMIData ()
{
    // first sort the menu entries as per the display sequence
    sort ( getButtons (). begin (), getButtons (). end (), bind ( &CCOIPresCtrlStubImpl::compareMenu, this, std::placeholders::_1, std::placeholders::_2 ) ) ;

    CCOIMessagesUtil msgUtil ;
    // populates the grey status of the entities based on current data 
    bool success = msgUtil. populateEntries ( "controllingEntities", getEntities () ) ;

    populateHMIData ( gMenu ) ;
    setResponseAttribute ( gMenu ) ;

    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d success %d", __FUNCTION__, __LINE__, success ) ;

    return success ;
}

/**
@description : HMI can query the below method to get complete set of entries that need to be populated in the settings screen
@returns: response (entities) : if not NULL, then it has array of valid settings to populate the settings screen
**/
const CCOIPresCtrl::entity& CCOIPresCtrlStubImpl::getResponseAttribute()
{
    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "getResponseAttribute response sent to HMI\n" ) ;
    return gMenu ;
}

void CCOIPresCtrlStubImpl::SettingsEntriesUpdate(const std::shared_ptr<CommonAPI::ClientId> _client, CCOIPresCtrl::entityDetails _request, SettingsEntriesUpdateReply_t _reply)
{
    settingsMenuEntry button ;
    getMenuButton ( _request. getName (), button ) ;

    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, " menu entry %s toggle val %d \n", _request.getName ().c_str (), _request.getToggle_val () ) ;
    // get & update the user choice and send it to Ccoimgr to send to TCU
    if ( !button.first->getName(). empty () )
    {
        vector < CCOIMenuButtonPtr > buttons ;
        buttons.push_back ( button.first ) ;

        // get the text of the menu button consent prompt based on or off, as both has different texts from UFM messages to be shown to user
        if ( _request. getToggle_val () != button.first-> getOnOffStatus () )
        {
            string value = ( _request.getToggle_val () == CCOIPresCtrl::ToggleSts::TOGGLE_ON ) ? button.first-> getOnValue () : button.first-> getOffValue () ;
            button.first-> setValue ( value ) ;

            button.first-> setOnOffStatus ( _request.getToggle_val () ) ; // revert the change based on user choice in user prompt.
            if ( button.first-> isPopupSupported () )
            {
                // inform to ccoimgr to update the state and communciate the same to TCU
                pccoi-> onUserSettingsResponseReceived ( SELECTED, buttons ) ;

                // this menu button supports popup i.e. user consent is required go ahead with display of user prompt with corresponding details.
                string requestToken = button.first->getName () ;    // name itself is sufficient to handle as uniqueToken.
               
                CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, " requestToken %s\n", requestToken.c_str () ) ;
                CCOIUserPromptScreenData userPrompt ( requestToken, button.first, bind ( &CCOIPresCtrlStubImpl::userConsentResponse, this, std::placeholders::_1, std::placeholders::_2 )  ) ;

                userPrompt.sendDataToHMI () ;
            }
            // no popup i.e., user consent not required for this menu button toggle status change, just update and send the updated status to TCU
            else    pccoi-> onUserSettingsResponseReceived ( CONFIRMED, buttons ) ;
        }
    }
    else    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_ERROR, " Invalid menu entry update sent by HMI %d %s %d\n", _request.getUnique_id (), _request.getName (), _request.getToggle_val () ) ;
}

const CCOIPresCtrl::syncPopupMessage& CCOIPresCtrlStubImpl::getSyncMessageAttribute()
{
    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d", __FUNCTION__, __LINE__ ) ;
    
    return syncStatus_ ;
}

// CCoimgr or the state machine component would call this whenever the state with TCU changes.
void CCOIPresCtrlStubImpl::setSyncStatus ( int ccoiStsValue )
{
    const auto status = statusCCOItoHMIMap_.find (ccoiStsValue) ;
    // react only for the HMI interested sync status states
    if ( status != statusCCOItoHMIMap_.end() )
    {
        syncStatus_. setId ( status-> second ) ;
        
        string message = getSyncPopupMessage ( status-> second ) ;
        syncStatus_. setMessage ( message ) ;

        // HMI interested sync status state, so broadcast now - below stub should send Attributechanged to the listener - HMI.
        setSyncMessageAttribute ( syncStatus_ ) ;
        CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, " setSyncMessageAttribute done with status %d %s", status-> second, message ) ;
    }
    else    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, " HMI uninterested sync status changed, so ignored\n", ccoiStsValue ) ;
}

void CCOIPresCtrlStubImpl::addButton ( CCOIMenuButton &menu, CCOIButton &info )
{
    // button has come for addition for display now update the other flags before adding based on the syncSettings data for this entity
    Entity entity ;
    if ( getEntity ( menu. getEntityId (), menu. getEntityType (), entity ) )
    {
        CCOIButtonPtr     infoptr = make_shared < CCOIButton >     ( info ) ;
        CCOIMenuButtonPtr menuptr = make_shared < CCOIMenuButton > ( menu ) ;
    
        bool bUAllowOnOff = false ;
        uint8_t VES = computeVESFlag ( entity, bUAllowOnOff ) ;     // VES = visible, enable, status of toggle in the same order

        menuptr-> setVisible ( ( VES >> 2 ) & 0x1 ) ;
        menuptr-> setEnabled ( ( VES >> 1 ) & 0x1 ) ;
        menuptr-> setOnOffStatus ( ( VES & 0x1 ) & bUAllowOnOff ) ;    // status from flag says follow bUAllowOnOff

        // if visible make & push the pair of menu & info buttons (this together forms one menu setting entry in the screen) into the list.
        if ( menuptr-> isVisible () )    settingMenuEntries_. push_back ( { menuptr, infoptr } ) ;

        CcoiLog.write (CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d menu %s button%sadded", __FUNCTION__, __LINE__, menuptr-> getName (). c_str (), menuptr-> isVisible () ? " " : " not ") ;
    }
    else    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_ERROR, "%s:%d Entity in showInMenu but not there in the syncEntities data so this menu button not added", __FUNCTION__, __LINE__ ) ;
}

/** This function converts the populate CCOIStructData into HMI data structure content and sends it to HMI for display purpose.
*/
void CCOIPresCtrlStubImpl::populateHMIData ( CCOIPresCtrl::entity &menu)
{
    // clear the old contents 
    menu. clear () ;
    //fill up the buttons in the menu
    for ( auto const &btn : getButtons () )
    {
        CCOIPresCtrl::ToggleSts OnOff = ( btn.first->getOnOffStatus () )? CCOIPresCtrl::ToggleSts::TOGGLE_ON : CCOIPresCtrl::ToggleSts::TOGGLE_OFF ; 
        CCOIPresCtrl::LocDataShareIconValues iconType ;

        // Name is sent as ID, should suffice for exchange of informaiton with HMI, as menu name will always be unique.
        CCOIPresCtrl::entityDetails button ( btn.first->getName (), btn.first->getEntityId (), btn.first->getEntityType (), btn.first->getName (), OnOff,
                                             btn.second->getValue (), "", !btn.first->getEnabled (), iconType, btn.first-> getOnOffVisible (), btn.second-> isVisible () ) ; 
                                   
        CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "HMI values: s: %s s: %s s: %s s: %s i: %d i: %d s: %s i: %d i: %d b: %d b: %d", btn.first->getName ().c_str (), 
                        btn.first->getEntityId ().c_str (), btn.first->getEntityType ().c_str (), btn.first->getName ().c_str (), btn.first->getOnOffStatus(), btn.second->getValue ().c_str (), 
                        "", !btn.first->getEnabled (), iconType, btn.first-> getOnOffVisible (), btn.second-> isVisible () ) ;
        
        menu.push_back ( button ) ;    
    }
}

// Gives the instance of the button from the list of buttons (of settingsMenuEntry list) corresponding to the ButtonID
bool CCOIPresCtrlStubImpl::getMenuButton ( const string &name, settingsMenuEntry &button )
{
    bool success = false ;
    // build the popup dialogue if this button supports popup upon click & send to HMI for display.
    for ( auto &btn : getButtons () )
    {
        CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_ERROR, "%s:%d name %s btn. first 0x%x btn.getName %s ", __FUNCTION__, __LINE__, name. c_str (), btn. first, btn. first-> getName (). c_str () ) ;
        if ( name == btn.first->getName () )
        {
            button = btn ;

            success = true ;
			break ;
        }
    }

    return success ;
}

// Gives the instance of the button from the list of buttons (of settingsMenuEntry list) corresponding to the ButtonID
void CCOIPresCtrlStubImpl::updateMenuButton ( const string &id, const string &type, int visible, int enable, int value )
{
	settingsMenuEntry button ;
	
    // first get the button with the entityId, entityType
    for ( auto &btn : getButtons () )
    {
        if ( ( id == btn.first-> getEntityId () ) && ( type == btn.first-> getEntityType () ) )
        {
			// Now, update the values
            if ( visible != NO_UPDATE )    btn. first->  setVisible    ( visible ) ;

			if ( enable != NO_UPDATE )     btn. first-> setEnabled 	   ( enable  ) ;
			
			if ( value != NO_UPDATE )      btn. first-> setOnOffStatus ( value   ) ;
            
            break ;
        }
    }
}

void CCOIPresCtrlStubImpl::userConsentResponse ( int response, const string &name )
{
    // rest of the responses we do not bother about it now
    bool valid = ( response == CONTINUE_BUTTON || response == CANCEL_BUTTON ) ;
    if ( valid )
    {
        CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_ERROR, "%s:%d name %s namelen %d", __FUNCTION__, __LINE__, name. c_str (), name. length () ) ;
        settingsMenuEntry button ;
        if ( getMenuButton ( name, button ) )
        {
            vector < CCOIMenuButtonPtr > buttons ;
            if ( response == CONTINUE_BUTTON )
            {
                // call to send the data to TCU and persist the user selected data.
                buttons.push_back ( button. first ) ;

                pccoi-> onUserSettingsResponseReceived ( CONFIRMED, buttons ) ;
            }
            else if ( response == CANCEL_BUTTON )
            {
                // user has cancelled his choice, so revert the updated status upon HMI call earlier.

                CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_ERROR, "%s:%d btn. first 0x%x", __FUNCTION__, __LINE__, button. first ) ;
                button. first-> setOnOffStatus ( ! button. first-> getOnOffStatus () ) ;

                pccoi-> onUserSettingsResponseReceived ( CANCELLED, buttons ) ;
                CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, " User cancelled the menu toggle choice" ) ;
            }
        }
    }
}

void  CCOIPresCtrlStubImpl::updateLocDataShareIcon ( string icon, string iconPopup )
{
    CCOIPresCtrl::LocDataShareIconValues value = static_cast < CCOIPresCtrl::LocDataShareIconValues::Literal > ( getIconType ( icon ) ) ;

    if ( gLocDataShareIcon != value )
    {
        CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d icon changed from %d to %d so show the icon popup now", __FUNCTION__, __LINE__, gLocDataShareIcon, value) ;
        gLocDataShareIcon  = value ;

        // just throw the popup to display through HMI, and we don't care about what happened to the button interaction here
        CCOIButtonPtr button = make_shared < CCOIButton > ( ICON_BUTTON, "icon", iconPopup ) ;
        CCOIUserPromptScreenData userPrompt ( icon, button, bind ( &CCOIPresCtrlStubImpl::userConsentResponse, this, std::placeholders::_1, std::placeholders::_2 ) ) ;

        userPrompt.sendDataToHMI () ;
    }

    setLoc_data_icon_valAttribute( gLocDataShareIcon ) ;
    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d setLoc_data_icon_valAttribute called with _value %d", __FUNCTION__, __LINE__, value) ;

}

// returns the icon type based on the icon JPG file name sent as parameter
int CCOIPresCtrlStubImpl::getIconType ( const string &name )
{
    int icon = CCOIPresCtrl::LocDataShareIconValues::LD_INVALID ;

    if ( !name.empty() )
    {
        if ( name == "icon_sharing_data.png" )                     icon = CCOIPresCtrl::LocDataShareIconValues::LD_DATA_ONLY ;
        else if ( name == "icon_sharing_location.png" )            icon = CCOIPresCtrl::LocDataShareIconValues::LD_LOC_ONLY ;
        else if ( name == "icon_sharing_data_and_location.png")    icon = CCOIPresCtrl::LocDataShareIconValues::LD_DATA_LOC ;  
    }
    
    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "iconFile %s icon %d\n", name, icon ) ;
    return icon ;
}

bool CCOIPresCtrlStubImpl::getEntity ( const string &entityId, const string &entityType, Entity &element )
{
    bool found = false ;

    for ( auto &entity : entities_ )
    {
        if ( ( entity-> entityType_ == entityType ) && ( entity-> entityID_ == entityId ) )
        {
            element = entity ;
            found = true ;
        }
    }
    
    return found ;    
}

bool CCOIPresCtrlStubImpl::getEntityValue ( string name, bool &bSAllowOnOff )
{
    bool retVal = false ;

    auto entityIDTypePair = entityNamesMap_. find ( name ) ;
    if ( entityIDTypePair != entityNamesMap_. end () )
    {
        if ( entities_. size () > 0 )
        {
            for ( auto &entity : entities_ )
            {
                if ( ( entity-> entityType_ == entityIDTypePair-> second. first ) && ( entity-> entityID_ == entityIDTypePair-> second. second ) )    retVal = computeAllowOnOFF ( entity, bSAllowOnOff ) ;
            }
        }
    }
    
    else    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_ERROR, "%s:%d No entity exists with name %s", __FUNCTION__, __LINE__, name ) ;

    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_ERROR, "%s:%d retVal %d", __FUNCTION__, __LINE__, retVal ) ;
    return retVal ;
}

int CCOIPresCtrlStubImpl::computeVESFlag ( Entity &entity, bool &bUAllowOnOff )
{
    int flags = 0 ;

    for ( auto &value : entity-> values_ )
    {
        if ( value. find ( "bSAllow"  ) != string::npos )   flags |= ( ( value == "bSAllowOnOff_True"   ) ? 1 : 0 ) ;

        if ( value. find ( "bFPOnOff" ) != string::npos )   flags |= ( ( ( value == "bFPOnOff_True"     ) ? 1 : 0 ) << 1 ) ;
        
        if ( value. find ( "bPAllow"  ) != string::npos )   flags |= ( ( ( value == "bPAllowOnOff_True" ) ? 1 : 0 ) << 2 ) ;

        if ( value. find ( "bUAllow"  ) != string::npos )   bUAllowOnOff = ( ( value == "bUAllowOnOff_True" ) ? 1 : 0 ) ;

    }

    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d flags %d retval %d", __FUNCTION__, __LINE__, flags, flagsVESBitMap_ [ flags ] ) ;

    return flagsVESBitMap_ [ flags ] ; 
}

bool CCOIPresCtrlStubImpl::computeAllowOnOFF ( Entity &entity, bool &bSAllowOnOff )
{
    int flags = 0;

    for ( auto &value : entity-> values_ )
    {
        if ( value. find ( "bFPOnOff" ) != string::npos )   flags |= ( ( value == "bFPOnOff_True" ) ? 1 : 0 ) ;
        
        if ( value. find ( "bPAllow"  ) != string::npos )   flags |= ( ( ( value == "bPAllowOnOff_True" ) ? 1 : 0 ) << 1 ) ;

        if ( value. find ( "bUAllow"  ) != string::npos )   flags |= ( ( ( value == "bUAllowOnOff_True" ) ? 1 : 0 ) << 2 ) ;

        if ( value. find ( "bSAllow"  ) != string::npos )   bSAllowOnOff = ( ( value == "bSAllowOnOff_True" ) ? 1 : 0 ) ;
    }

    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d flags %d retval %d", __FUNCTION__, __LINE__, flags, flagsSummaryBitMap_ [ flags ] ) ;

    return flagsSummaryBitMap_ [ flags ] ; 
}

void CCOIPresCtrlStubImpl::updateLocationStatus ( )
{
    bool bSAllow = false ;
    bool bAllow = getEntityValue ( "Location", bSAllow ) ;
    gLocation. setStatus ( bAllow ) ;
    gLocation. setSubscribed ( bSAllow ) ;

    setLocationstsAttribute ( gLocation ) ;
    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d loc %d bSAllow %d", __FUNCTION__, __LINE__, bAllow, bSAllow ) ;
}

string CCOIPresCtrlStubImpl::getSyncPopupMessage ( CCOIPresCtrl::SyncStatus status )
{  
    // update the menu infoText comes in messageCode 11 as per latest UFM, keep track of it and change whenever UFM agreed codes are changed by TCU
    string messageCode ;
    
    switch ( status )
    {
        // all below errors points to same error message
        case CCOIPresCtrl::SyncStatus::Literal::SYNC_ERROR :
        case CCOIPresCtrl::SyncStatus::Literal::SYNC_TIMED_ERROR :
        case CCOIPresCtrl::SyncStatus::Literal::SYNC_DATA_SAVE_ERROR :
            messageCode = "9" ;       
            break ;

        case CCOIPresCtrl::SyncStatus::Literal::SYNC_NOT_SUPPORTED :
            messageCode = "10" ;       
            break ;

        case CCOIPresCtrl::SyncStatus::Literal::SYNC_SOFTWARE_UPDATE :
            messageCode = "12" ;
            break ;
    }

    CCOIMessagesUtil msgUtil ;
    return msgUtil. getMessage ( "textBody", messageCode, "error", true ) ;
}

const CCOIPresCtrl::Location& CCOIPresCtrlStubImpl::getLocationstsAttribute ( )
{
    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d", __FUNCTION__, __LINE__ ) ;

    return gLocation ;
}

const std::vector<uint8_t>& CCOIPresCtrlStubImpl::getTcu_snAttribute ( )
{
    // we write version to the version manager, not sure if this is required

    return gTcu_snList ;
}

const CCOIPresCtrl::LocDataShareIconValues&  CCOIPresCtrlStubImpl::getLoc_data_icon_valAttribute (const shared_ptr < CommonAPI::ClientId > _client)
{
    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d retval %d", __FUNCTION__, __LINE__, gLocDataShareIcon ) ;

    return gLocDataShareIcon ;
}

const string& CCOIPresCtrlStubImpl::getInfoMessageAttribute(const std::shared_ptr<CommonAPI::ClientId> _client)
{
    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d retval %s", __FUNCTION__, __LINE__, gMenuInfo. c_str () ) ;

    return gMenuInfo ;
}

// destructor
CCOIPresCtrlStubImpl::~CCOIPresCtrlStubImpl()
{
    CcoiLog.write ( CCOILog::eLogCCOIPresCtrlStubImpl, CCOILog::LOG_INFO, "%s:%d", __FUNCTION__, __LINE__ ) ;
}

            } // namespace voice
        } // namespace harman
    } // namespace com
} // namespace v2

