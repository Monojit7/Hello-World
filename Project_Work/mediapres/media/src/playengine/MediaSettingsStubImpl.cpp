/**
 * generated by Voice CodeGen Version: R1_v1.3.0
 * generated on: Mon Feb 06 15:58:49 IST 2017
 */

#include <playengine/MediaSettingsStubImpl.hpp>
#include <playengine/RemoteCDplaybackengine.h>

namespace v1 {
namespace com {
namespace harman {
namespace mmpres {

MediaSettingsStubImpl::MediaSettingsStubImpl()
      : isFullScreenLocal(false)
{
    LOG_INFO(LOG_CONTEXT_MEDIA, "MediaSettingsStubImpl::MediaSettingsStubImpl");
    
    LOG_INFO(LOG_CONTEXT_MEDIA, "MediaSettingsStubImpl::MediaSettingsStubImpl:: Calling RemoteCDPluginEvent ");
    FacadeHelper<RemoteCDPlaybackEngine> mRemoteCDPlayBackEngine;
    mRemoteCDPlayBackEngine->initPluginEvent();
	registerMediaSettingsCallback();
    mDetect->initAppleAuthenticationCheck();
}

void MediaSettingsStubImpl::registerMediaSettingsCallback()
{
	LOG_INFO(LOG_CONTEXT_MEDIA, "MediaSettingsStubImpl::registerMediaSettingsCallback");
	mPlayEngine->setSubtitleStatusStubCallBack(std::bind(&MediaSettingsStubImpl::setSubtitleStatusAttribute, this, _1));
	mPlayEngine->setUpScaleStatusStubCallBack (std::bind(&MediaSettingsStubImpl::setIsFullScreenAttribute, this, _1));
	mPlayEngine->setAudioChannelStatusStubCallBack(std::bind(&MediaSettingsStubImpl::setAudioChannelAttribute, this, _1));
    mDetect->setAppleChipAuthenticationCallBack(std::bind(&MediaSettingsStubDefault::setAppleAuthenticationChipstatusAttribute,this,_1));
}

void MediaSettingsStubImpl::unRegisterMediaSettingsCallback()
{
   LOG_INFO(LOG_CONTEXT_MEDIA, "MediaSettingsStubImpl::unRegisterMediaSettingsCallback");
   mPlayEngine->setSubtitleStatusStubCallBack(nullptr);
   mPlayEngine->setUpScaleStatusStubCallBack(nullptr);
   mPlayEngine->setAudioChannelStatusStubCallBack(nullptr);
   mDetect->setAppleChipAuthenticationCallBack(nullptr);
}

MediaSettingsStubImpl::~MediaSettingsStubImpl()
{
	unRegisterMediaSettingsCallback();
}

void MediaSettingsStubImpl::masterMediaReset(const std::shared_ptr<CommonAPI::ClientId> _client, masterMediaResetReply_t reply)
{
	// TODO: Implement me	
	DeviceBase* pDevice = mDetect->getActiveDevice();
	if(nullptr != pDevice)
	{
		LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::masterMediaReset");
		pDevice->setMasterMediaReset(true);
		reply(MMPresTypes::eCallResult::CALLRESULT_OK);
	}
	else
	{
		LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::masterMediaReset not success");
		reply(MMPresTypes::eCallResult::CALLRESULT_BAD_PARAMETER);
	}

}

void MediaSettingsStubImpl::resetMediaIndex(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t slotId, resetMediaIndexReply_t reply)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::resetMediaIndex-slotId = %d",slotId);

	uint64_t mediumID = mDetect->getDevice(slotId);
	DeviceBase* pDevice = mDetect->getDevice(mediumID);
	if(nullptr != pDevice)
	{
		LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::resetMediaIndex-slotId = %d, mediumID = %llu",slotId, mediumID);

         pDevice->setResetMediaIndex(true);
         reply(MMPresTypes::eCallResult::CALLRESULT_OK);
	}
	else
	{
		LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::resetMediaIndex-mediumID=%llu not found", mediumID);
		reply(MMPresTypes::eCallResult::CALLRESULT_FAILED_MEDIUM_REMOVED);
	}
}

void MediaSettingsStubImpl::updateIndex(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t slotId, updateIndexReply_t reply)
{
	/* get deviceID using Slot id */
	uint64_t mediumID = mDetect->getDevice(slotId);

	LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::updateIndex-slotId = %d, mediumID = %llu",slotId, mediumID);

	/* call reIndexing of CoC through MediaBrowseEngine */
	mBrowseEngine->reIndexing((uint32_t) mediumID, std::bind(&MediaSettingsStubImpl::updateIndexCallBack, this, _1, _2));

	reply(MMPresTypes::eMediaError::MEDIAERROR_NO_ERROR);
}

void MediaSettingsStubImpl::setSubtitle(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::com::harman::mmpres::MMPresTypes::eSubtitleStatus dispSubtitle, setSubtitleReply_t reply)
{
	 LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::setSubtitle-dispSubtitle = %d",(int)dispSubtitle);

	 PlayerTypes::SubtitleStatus subtileStatus = PlayerTypes::SubtitleStatus::ON;
	 MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	 bool subtileSupported = true;

	 switch(dispSubtitle)
	 {
	 case MMPresTypes::eSubtitleStatus::ON:
		 // Hence the default value of subtileStatus is set as ON , Its not required to set it explicitly again.
		 break;
	 case MMPresTypes::eSubtitleStatus::OFF:
		 subtileStatus = PlayerTypes::SubtitleStatus::OFF;
		 break;
	 default:
		 subtileSupported = false;
		 break;
	 }

	 if(subtileSupported)
	 {
        mPlayEngine->setSubtitle(mPlayEngine.mClientID, subtileStatus, std::bind(&MediaSettingsStubImpl::setSubtitleCallback, this, _1, _2));
	 }
	 else
	 {
		 LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::setSubtitle-error: dispSubtitle = %d", (int)dispSubtitle);
		 reply(MMPresTypes::eCallResult::CALLRESULT_BAD_PARAMETER);
	 }

     reply(result);
}

void MediaSettingsStubImpl::setAudioChannel(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::com::harman::mmpres::MMPresTypes::eAudioChannelStatus audioChannel, setAudioChannelReply_t reply)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::setAudioChannel-audioChannel = %d", (int)audioChannel);

	PlayerTypes::AudioChannelStatus audiochannelStatus = PlayerTypes::AudioChannelStatus::STEREO;
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	
	switch (audioChannel)
	{
	case MMPresTypes::eAudioChannelStatus::STEREO:
		// Hence the default value set as STEREO for "audiochannelStatus", Its not required to set it explicitly again.
		break;

	case MMPresTypes::eAudioChannelStatus::LEFT:
		audiochannelStatus = PlayerTypes::AudioChannelStatus::LEFT;
		break;

	case MMPresTypes::eAudioChannelStatus::RIGHT:
		audiochannelStatus = PlayerTypes::AudioChannelStatus::RIGHT;
		break;
	default:
		break;
	}

	mPlayEngine->setAudioChannel(mPlayEngine.mClientID, audiochannelStatus, std::bind(&MediaSettingsStubImpl::setAudioChannelCallback, this, _1, _2));

	reply(result);
}

void MediaSettingsStubImpl::setDisplayWindow(const std::shared_ptr<CommonAPI::ClientId> _client, bool isFullscreen, ::v3::com::harman::mmpres::MMPresTypes::tScreen screeenDimension, setDisplayWindowReply_t reply)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::setDisplayWindow");
    LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::setDisplayWindow-isFullscreen = %d", (int)isFullscreen);
	LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaSettingsStubImpl::setDisplayWindow- left = %d, top = %d, right = %d, bottom = %d ", screeenDimension.getLeft(), screeenDimension.getTop(), screeenDimension.getRight(), screeenDimension.getBottom());

	isFullScreenLocal = isFullscreen;
	mPlayEngine->setDisplayWindow(mPlayEngine.mClientID, isFullscreen, screeenDimension, std::bind(&MediaSettingsStubImpl::setUpScaleCallback, this, _1, _2));

	reply(MMPresTypes::eMediaError::MEDIAERROR_NO_ERROR);
}

void MediaSettingsStubImpl::updateIndexCallBack(const CommonAPI::CallStatus& status, const Indexer::IndexerError& error)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::updateIndexCallBack: status=%d,error=%d", (int)(status), (int)error);
}

void MediaSettingsStubImpl::setSubtitleCallback(const CommonAPI::CallStatus& status, const PlayerTypes::SubtitleStatus& subtitle)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::setSubtitleCallback : CallStatus : %d SubtitleStatus %d", (int)status, (int)subtitle);
}

void MediaSettingsStubImpl::setAudioChannelCallback(const CommonAPI::CallStatus& status, const PlayerTypes::AudioChannelStatus& AudioChannel)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::setAudioChannelCallback : CallStatus : %d AudioChannel %d", (int)status, (int)AudioChannel);
}

void MediaSettingsStubImpl::setUpScaleCallback(const CommonAPI::CallStatus& status, const PlayerTypes::AspectModeStatus& aspectModeStatus)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::setUpScaleCallback : CallStatus : %d aspectModeStatus %d", (int)status, (int)aspectModeStatus);
}

void MediaSettingsStubImpl::setDisplayWindowCallback(const CommonAPI::CallStatus& status, const PlayerTypes::PlayerError& error)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::setDisplayWindowCallback: status=%d,error=%d", (int)(status), (int)error);

	/* if there is no error from CoC media then fire "isFullScreen" attribute to HMI
	 * Send stored value of isFullscreen from HMI back for this attribute
	 */
	if(PlayerTypes::PlayerError::NO_ERROR == error)
	{
		LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::setDisplayWindowCallback - Firing isFullScreen attribute with value = %d", isFullScreenLocal);
        MediaSettingsStubImpl::setIsFullScreenAttribute(isFullScreenLocal);
	}
}

/* over-riding default functionality of Common-API for AudioChannel attribute for HMI. */
const ::v3::com::harman::mmpres::MMPresTypes::eAudioChannelStatus& MediaSettingsStubImpl::getAudioChannelAttribute()
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::getAudioChannelAttribute: AudioChannelStatus=%d",mAudioChannelAttribute );

    return mAudioChannelAttribute;
}

void MediaSettingsStubImpl::setAudioChannelAttribute(::v3::com::harman::mmpres::MMPresTypes::eAudioChannelStatus _value)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::setAudioChannelAttribute: AudioChannelStatus=%d",_value );

	auto stubAdapter = CommonAPI::Stub<MediaSettingsStubAdapter, MediaSettingsStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->fireAudioChannelAttributeChanged(_value);

	mAudioChannelAttribute = _value;
}

/* over-riding default functionality of Common-API for IsFullScreen attribute for HMI. */
const bool& MediaSettingsStubImpl::getIsFullScreenAttribute()
{
	
    LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::getIsFullScreenAttribute: IsFullScreen=%d",(int)isFullScreenLocal );
    
    if ( isFullScreenLocal )
    {
        isFullScreenLocal = true; 
        
    }
    else
    {
        isFullScreenLocal = false ;
        
    }
    
    return isFullScreenLocal;
 
}

void MediaSettingsStubImpl::setIsFullScreenAttribute(bool _value)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::setIsFullScreenAttribute: IsFullScreen=%d",(int)_value );

	auto stubAdapter = CommonAPI::Stub<MediaSettingsStubAdapter, MediaSettingsStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->fireIsFullScreenAttributeChanged(_value);
    
    isFullScreenLocal = _value ;
}

/* over-riding default functionality of Common-API for SubtitleStatus attribute for HMI. */
const ::v3::com::harman::mmpres::MMPresTypes::eSubtitleStatus& MediaSettingsStubImpl::getSubtitleStatusAttribute()
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::getSubtitleStatusAttribute: subtitleStatus=%d",mSubtitleStatusAttribute );

    return mSubtitleStatusAttribute;
}

void MediaSettingsStubImpl::setSubtitleStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::eSubtitleStatus _value)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaSettingsStubImpl::setSubtitleStatusAttribute: subtitleStatus=%d",_value );

	auto stubAdapter = CommonAPI::Stub<MediaSettingsStubAdapter, MediaSettingsStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->fireSubtitleStatusAttributeChanged(_value);

	mSubtitleStatusAttribute = _value;
}

} // namespace mmpres
} // namespace harman
} // namespace com
} // namespace v1

