/**
 * generated by Voice CodeGen Version: R1_v1.3.0
 * generated on: Wed Jun 22 09:34:32 IST 2016
 */
#include <spot/harman_kpimarker.h>
#include <playengine/MediaPlayerStubImpl.hpp>
#include<device/DeviceBase.h>

namespace v1 {
namespace com {
namespace harman {
namespace mmpres {

MediaPlayerStubImpl::MediaPlayerStubImpl()
{
    LOG_INFO(LOG_CONTEXT_MEDIA, "MediaPlayerStubImpl::MediaPlayerStubImpl");
	registerPlayerCallback();
}

void MediaPlayerStubImpl::registerPlayerCallback()
{
	mPlayEngine->setTracklistSupportStubCallBack(std::bind(&MediaPlayerStubImpl::setTrackListSupportAttribute,this,_1));
   mPlayEngine->setPromoteStatusStubCallBack(std::bind(&MediaPlayerStubImpl::setPromoteStatusAttribute, this, _1));
   mPlayEngine->setDemoteStatusStubCallBack(std::bind(&MediaPlayerStubImpl::setDemoteStatusAttribute, this, _1));
   mPlayEngine->setAddToWishListStatusStubCallBack(std::bind(&MediaPlayerStubImpl::setAddToWishListStatusAttribute, this, _1));
	mPlayEngine->setPlaystateStubCallBack(std::bind(&MediaPlayerStubImpl::setPlayStateAttribute,this,_1));
	mPlayEngine->setCurrentPlayTimeStubCallBack(std::bind(&MediaPlayerStubImpl::setCurrentPlayTimeAttribute,this,_1));
	mPlayEngine->setTotalPlayDurationStubCallBack(std::bind(&MediaPlayerStubImpl::setTotalPlayDurationAttribute,this,_1));
   mPlayEngine->setRemotePlayerChangedStubCallBack(std::bind(&MediaPlayerStubImpl::setRemotePlayerChangedAttribute, this, _1));
	mPlayEngine->setTrackStateStubCallBack(std::bind(&MediaPlayerStubImpl::setTrackStateAttribute, this, _1));
	mPlayEngine->setNowPlayingDataStubCallBack(std::bind(&MediaPlayerStubImpl::setNowPlayingDataAttribute, this, _1));
	mPlayEngine->setRepeatModeStubCallBack(std::bind(&MediaPlayerStubImpl::setRepeatModeAttribute, this, _1));
	mPlayEngine->setShuffleModeStubCallBack(std::bind(&MediaPlayerStubImpl::setShuffleModeAttribute, this, _1));
	mPlayEngine->setTrackSeekSpeedStubCallBack(std::bind(&MediaPlayerStubImpl::setSpeedAttribute, this, _1));
	mPlayEngine->setArtworkStatusStubCallback(std::bind(&MediaPlayerStubImpl::setNowPlayingArtworkStatusAttribute, this, _1));
	mPlayEngine->setRemotePlayerCapabilityStubCallback(std::bind(&MediaPlayerStubImpl::setRemotePlayerCapabilityAttribute,this,_1));
	mPlayEngine->setSyncStatusStubCallback(std::bind(&MediaPlayerStubDefault::setSyncStatusAttribute,this, _1));
    mPlayEngine->setMediaErrorStubCallback(std::bind(&MediaPlayerStubImpl::setMediaErrorAttribute, this, _1));
    /*MediaError: changing attribute to broadcost for better handeling of error condition*/
    //mPlayEngine->setMediaErrorStubCallback(std::bind(&MediaPlayerStubDefault::fireMediaErrorEvent, this, _1));
    mPlayEngine->setVideoPlayStatusCallBack(std::bind(&MediaPlayerStubDefault::setVideoPlayStatusAttribute,this,_1));
    mRemoteCDPlayEngine->setCDStatusEvent(std::bind(&MediaPlayerStubImpl::setMRemoteCDDiscStatusAttribute,this,_1));
    mRemoteCDPlayEngine->setCDErrorEvent(std::bind(&MediaPlayerStubImpl::setMRemoteCDErrorStatusAttribute,this,_1));
    mRemoteCDPlayEngine->setEOLStatusEvent(std::bind(&MediaPlayerStubImpl::setMCDEOLStatusAttribute,this,_1));
    mRemoteCDPlayEngine->setCDEjectChimesWarningEvent(std::bind(&MediaPlayerStubImpl::setMRemoteCDEjectChimesWarningAttribute,this,_1));
    
    mPlayEngine->setSpeedInfoStubCallback(std::bind(&MediaPlayerStubImpl::setPlaybackSpeedAttribute,this,_1));
    mPlayEngine->setActiveDeviceBTLinkLossCallBack(std::bind(&MediaPlayerStubImpl::setActiveDeviceBTLinkLossAttribute, this, _1));
    
   
}

void MediaPlayerStubImpl::unRegisterPlayerCallback()
{
   mPlayEngine->setTracklistSupportStubCallBack(nullptr);
   mPlayEngine->setPromoteStatusStubCallBack(nullptr);
   mPlayEngine->setDemoteStatusStubCallBack(nullptr);
   mPlayEngine->setAddToWishListStatusStubCallBack(nullptr);
	mPlayEngine->setPlaystateStubCallBack(nullptr);
   mPlayEngine->setSpeedInfoStubCallback(nullptr);
	mPlayEngine->setCurrentPlayTimeStubCallBack(nullptr);
	mPlayEngine->setTotalPlayDurationStubCallBack(nullptr);
	mPlayEngine->setRemotePlayerChangedStubCallBack(nullptr);
	mPlayEngine->setNowPlayingDataStubCallBack(nullptr);
	mPlayEngine->setRepeatModeStubCallBack(nullptr);
	mPlayEngine->setShuffleModeStubCallBack(nullptr);
	mPlayEngine->setTrackSeekSpeedStubCallBack(nullptr);
	mPlayEngine->setArtworkStatusStubCallback(nullptr);
	mPlayEngine->setRemotePlayerCapabilityStubCallback(nullptr);
	mPlayEngine->setSyncStatusStubCallback(nullptr);
	mPlayEngine->setMediaErrorStubCallback(nullptr);
	mPlayEngine->setVideoPlayStatusCallBack(nullptr);
   mPlayEngine->setActiveDeviceBTLinkLossCallBack(nullptr);
}

MediaPlayerStubImpl::~MediaPlayerStubImpl()
{
   unRegisterPlayerCallback();
}

void MediaPlayerStubImpl::playAll(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _slotId, ::v3::com::harman::mmpres::MMPresTypes::eMetadataType _objectType, playAllReply_t _reply)
{
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;

	LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaPlayerStubImpl::playAll- slotId = %d, objectType= %ld", _slotId, _objectType);
    DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
    mSourceSwitch->SetretainPauseStateForDevice(false);
    switch (_objectType)
    {
    case MMPresTypes::eMetadataType::METADATATYPE_FOLDER:
       /* To-Do for folderPath */
       break;

    case MMPresTypes::eMetadataType::METADATATYPE_TITLE:
    case MMPresTypes::eMetadataType::METADATATYPE_VIDEO:
    {
       if (pDevice != nullptr)
       {
          pDevice->playDevice(_objectType);
       }
       else
       {
          LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaPlayerStubImpl::playAll- Error as ActiveDevice is not found");
          result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
       }
    }
     break;
	  default:
		/* this is considered as devicePath */
		/* device path is accessible through DeviceBase using playDevice method which in turn calls openUriAsync of CoC media with devicePath */
		/* For MediaPlayback always activeDevice is used as per current earlier design */
		if(pDevice != nullptr)
		{
			LOG_INFO(LOG_CONTEXT_MEDIA, ">>> DeviceBase::playDevice");
            pDevice->playDevice(_objectType);
		}
		else
		{
			LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaPlayerStubImpl::playAll- Error as ActiveDevice is not found");
			result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
		}
		break;
	}

	_reply(result);
}

void MediaPlayerStubImpl::next(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t step, nextReply_t reply)
{
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
    KPIMARKER(306, "AV_Request_Next");
    LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::next %llu",step);
	if (pDevice != nullptr)
	{
		pDevice->next(step);
	}
	else
	{
		result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
	}
	reply(result);
}

void MediaPlayerStubImpl::previous(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t step, previousReply_t reply)
{
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
    KPIMARKER(306, "AV_Request_Previous");

	if (pDevice != nullptr)
	{
		pDevice->previous(step);
	}
	else
	{
		result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
	}
	reply(result);
}

void MediaPlayerStubImpl::pause(const std::shared_ptr<CommonAPI::ClientId> _client, pauseReply_t reply)
{
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
    KPIMARKER(306, "AV_Request_Pause");
	if (pDevice != nullptr)
	{
		pDevice->pause();
        mSourceSwitch->SetretainPauseStateForDevice(true);
	}
	else
	{
		result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
	}
	reply(result);
}

void MediaPlayerStubImpl::resume(const std::shared_ptr<CommonAPI::ClientId> _client, resumeReply_t reply)
{
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	DeviceBase* pDevice=mDetectionEngine->getActiveDevice();
    KPIMARKER(306, "AV_Request_Resume");
	if (pDevice != nullptr)
	{
        mSourceSwitch->SetretainPauseStateForDevice(false);
		pDevice->resume();
	}
	else
	{
		result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
	}
	reply(result);
}

void MediaPlayerStubImpl::seekToTime(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t timePosition, seekToTimeReply_t reply)
{
	// TODO: Implement me
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
    KPIMARKER(306, "AV_Request_SeekToTime");
	if (pDevice != nullptr)
	{
		if (timePosition <= pDevice->getTotalDuration()) /*timePosition>=0 && */ //Removed as unit64_t will never be -ve
		{
			pDevice->seekToTime(timePosition);
		}
		else
		{
			result = MMPresTypes::eCallResult::CALLRESULT_BAD_PARAMETER;
		}
	}
	else
	{
		result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
	}
	reply(result);
}


void MediaPlayerStubImpl::fastForward(const std::shared_ptr<CommonAPI::ClientId> _client, fastForwardReply_t reply)
{
	// TODO: Implement me
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
    KPIMARKER(306, "AV_Request_FastForword");
	if (pDevice != nullptr)
	{
		result = pDevice->fastForward();
	}
	else
	{
		result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
	}
	reply(result);
}

void MediaPlayerStubImpl::fastReverse(const std::shared_ptr<CommonAPI::ClientId> _client, fastReverseReply_t reply)
{
	// TODO: Implement me
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
    KPIMARKER(306, "AV_Request_FastReverse");
	if (pDevice != nullptr)
	{
		result = pDevice->fastReverse();
	}
	else
	{
		result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
	}
	reply(result);
}
void MediaPlayerStubImpl::setRepeat(const std::shared_ptr<CommonAPI::ClientId> _client, MMPresTypes::eRepeatMode mode, setRepeatReply_t reply)
{
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
	if (pDevice != nullptr)
	{
		if (mode.validate())
		{
			pDevice->setRepeat(mode);
		}
		else
		{
			result = MMPresTypes::eCallResult::CALLRESULT_BAD_PARAMETER;
		}
	}
	else
	{
		result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
	}
	reply(result);
}

void MediaPlayerStubImpl::setShuffle(const std::shared_ptr<CommonAPI::ClientId> _client, MMPresTypes::eShuffleMode mode, setShuffleReply_t reply)
{
	// TODO: Implement me
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
	if (pDevice != nullptr)
	{
		if (mode.validate())
		{
			pDevice->setShuffle(mode);
		}
		else
		{
			result = MMPresTypes::eCallResult::CALLRESULT_BAD_PARAMETER;
		}
	}
	else
	{
		result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
	}
	reply(result);
}

void MediaPlayerStubImpl::getNowPlayingAlbumArtInformation(const std::shared_ptr<CommonAPI::ClientId> _client, getNowPlayingAlbumArtInformationReply_t reply)
{
	// TODO: Implement me
}

void MediaPlayerStubImpl::getNowPlayingAlbumArtPath(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t imageNumber, getNowPlayingAlbumArtPathReply_t reply)
{
	MMPresTypes::eCallResult result = MMPresTypes::eCallResult::CALLRESULT_OK;
	DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
	std::string path = "";
	if (pDevice != nullptr)
	{
	path=pDevice->getNowPlayingAlbumArtPath(imageNumber);
	}
	else
	{
		result = MMPresTypes::eCallResult::CALLRESULT_FAILED_INTERNALERROR;
	}
	reply(path);
}

void MediaPlayerStubImpl::getNowPlayingAlbumArtData(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t imageNumber, getNowPlayingAlbumArtDataReply_t reply)
{
	// TODO: Implement me
}

void MediaPlayerStubImpl::getAlbumArtInformationForTrack(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t trackId, getAlbumArtInformationForTrackReply_t reply)
{
	// TODO: Implement me
}

void MediaPlayerStubImpl::getAlbumArtPathForTrack(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t trackId, uint8_t imageNumber, getAlbumArtPathForTrackReply_t reply)
{
	// TODO: Implement me
}

void MediaPlayerStubImpl::getAlbumArtDataForTrack(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t trackId, uint8_t imageNumber, getAlbumArtDataForTrackReply_t reply)
{
	// TODO: Implement me
}

void MediaPlayerStubImpl::promote(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t fileid, promoteReply_t _reply)
{
   DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
   if (nullptr != pDevice)
   {
      pDevice->promote(fileid);
   }
}
void MediaPlayerStubImpl::demote(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t fileid, demoteReply_t _reply)
{
   DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
   if (nullptr != pDevice)
   {
      pDevice->demote(fileid);
   }
}
void MediaPlayerStubImpl::addToWishList(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t fileid, addToWishListReply_t _reply)
{
   DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
   if (nullptr != pDevice)
   {
      pDevice->addToWishList(fileid);
   }
}

void MediaPlayerStubImpl::sendIAP2KeyEvent(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::com::harman::mmpres::MMPresTypes::IAP2ButtonType buttonType, bool pressed, sendIAP2KeyEventReply_t _reply)
{
   DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
   if (nullptr != pDevice)
   {
      pDevice->sendIAP2KeyEvent(buttonType, pressed);
   }
}


void MediaPlayerStubImpl::setTotalPlayDurationAttribute(uint64_t _value) 
{
	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
	{
		stubAdapter->fireTotalPlayDurationAttributeChanged(_value);
	}
	mTotalPlayDurationAttributeValue = _value;
}

const uint64_t& MediaPlayerStubImpl::getTotalPlayDurationAttribute()
{
   return mTotalPlayDurationAttributeValue;
}

void MediaPlayerStubImpl::setRemotePlayerChangedAttribute(uint32_t _value)
{
   auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
   if (stubAdapter)
   {
      stubAdapter->fireRemotePlayerChangedAttributeChanged(_value);
   }
   mRemotePlayerChangedAttributeValue = _value;
}

const uint32_t& MediaPlayerStubImpl::getRemotePlayerChangedAttribute()
{
   return mRemotePlayerChangedAttributeValue;
}

const ::v3::com::harman::mmpres::MMPresTypes::eArtWorkAvailabilityStatus& MediaPlayerStubImpl::getNowPlayingArtworkStatusAttribute()
{
	return mArtworkStatus;
}

void MediaPlayerStubImpl::setNowPlayingArtworkStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::eArtWorkAvailabilityStatus _value)
{
	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->fireNowPlayingArtworkStatusAttributeChanged(_value);
	mArtworkStatus = _value;
}

void MediaPlayerStubImpl::setSpeed(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t slotId, ::v3::com::harman::mmpres::MMPresTypes::eMetadataType type, ::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed speed, setSpeedReply_t reply)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setSpeed");
	// We are currently supporting set speed only for audiobooks /podcasts for audiobook and podcasts.Also we support it for all devices. 
	// so we are not doing any slot and device check

    DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
    if(pDevice != nullptr)
    {
     pDevice ->setSlotForAudiobookPodcast(slotId);
     pDevice ->setMetadatType(type);
    }

	if (PlayHelper::isPlaybackSpeedSupported(type))
	{
		BaseType::tAudioObjectType audioType;
		bool ret = false;
		ret = PlayHelper::getMetadataType(type, audioType);
		if (ret)
		{
			mPlayEngine->setPlaybackSpeed(mPlayEngine.mClientID, audioType, PlayHelper::getPlaybackSpeed(speed),std::bind(&MediaPlayerStubImpl::setSpeedCallback,this,_1,_2));
            //mPlayEngine->setRate(mPlayEngine.mClientID,PlayHelper::getPlaybackSpeed(speed),std::bind(&MediaPlayerStubImpl::setRateCallback, this, _1, _2));
			reply(MMPresTypes::eCallResult::CALLRESULT_OK);
		}
		else
		{
			reply(MMPresTypes::eCallResult::CALLRESULT_BAD_PARAMETER);
		}
	}
	else
	{
		reply(MMPresTypes::eCallResult::CALLRESULT_BAD_PARAMETER);
	}
}

void MediaPlayerStubImpl::getSpeed(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t slotId, ::v3::com::harman::mmpres::MMPresTypes::eMetadataType type, getSpeedReply_t reply)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getSpeed");
	// We are currently supporting get speed only for audiobooks /podcasts for audiobook and podcasts.Also we support it for all devices. 
	// so we are not doing any slot and device check
	if (PlayHelper::isPlaybackSpeedSupported(type))
	{
		BaseType::tAudioObjectType audioType;
		bool ret = false;
		ret = PlayHelper::getMetadataType(type, audioType);
		if (ret)
		{
            LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getSpeed rate");
			//mPlayEngine->getPlaybackSpeed(mPlayEngine.mClientID, audioType, std::bind(&MediaPlayerStubImpl::getSpeedCallback, this,std::move(reply), _1, _2, _3));
	    }
		else
	    {
		 reply(MMPresTypes::ePlaybackSpeed::NORMAL);
	    }
	 }
	else
	{
		reply(MMPresTypes::ePlaybackSpeed::NORMAL);
	}	
}

void MediaPlayerStubImpl::getSpeedCallback(const CommonAPI::CallStatus& status, const double& speed, const ::v1::com::harman::media::BaseType::tBaseError& error)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getSpeedCallback: status=%d,speed=%f,error=%d",(int)(status),speed,(int)error);
	MMPresTypes::ePlaybackSpeed playSpeed = MMPresTypes::ePlaybackSpeed::NORMAL;
    DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
  if(pDevice != nullptr)
  {
    MMPresTypes::eMetadataType  lMetadataType  = pDevice->getMetadataType();
    int8_t slot = pDevice->getSlotForAudiobookPodcast();
    MMPresTypes::tPlaybackSpeed mSpeedInfo = pDevice->getSpeedInfoObj();
   
	if (error == BaseType::tBaseError::S_OK)
	{
		/*if (speed < 1)
		{
			playSpeed = MMPresTypes::ePlaybackSpeed::SLOWER;
		}
		else if (speed>1)
		{
			playSpeed = MMPresTypes::ePlaybackSpeed::FASTER;
		}*/
   //Changes for setSpeed for Audiobook/Podcast

    switch (lMetadataType)
	{
	case MMPresTypes::eMetadataType::METADTATATYPE_AUDIOBOOK:
	case MMPresTypes::eMetadataType::METADTATATYPE_CHAPTER:
	case MMPresTypes::eMetadataType::METADTATATYPE_PODCAST:
	case MMPresTypes::eMetadataType::METADTATATYPE_EPISODE:
		{
          LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getSpeedCallback - Podcast/Audiobook");
		  if(PAUSED_SPEED < speed)//speed is positive
		  {
			if (FFWD_RATE_THRESHOLD_AP > speed)//within playing range - 0.5 to 1.5
			{
			 if(speed > PLAYING_SPEED)
			  {
				playSpeed = MMPresTypes::ePlaybackSpeed::FASTER;
			  }
			  else if(speed < PLAYING_SPEED)
			  {
				playSpeed = MMPresTypes::ePlaybackSpeed::SLOWER;
			  }
			}
		  }
		}
		break;
	default:
		{
		}
		break;
	}
      mSpeedInfo.setSlotId(slot);
	  mSpeedInfo.setType(lMetadataType);
	  mSpeedInfo.setPlaybackSpeed(playSpeed);

    std::function<void(const MMPresTypes::tPlaybackSpeed&)> speedInfoCallback = mPlayEngine->getSpeedInfoStubCallback();
	/** For PLAYSTATE_PLAYING only we will be sending speedInfoCallback */
	if(speedInfoCallback != nullptr)
	{
		speedInfoCallback(mSpeedInfo);
	}
	else
	{
		LOG_INFO(LOG_CONTEXT_MEDIA,"MediaPlayerStubImpl::getSpeedCallback - speedInfoCallback is null");
	}
		}
	}
}

void MediaPlayerStubImpl::setSpeedCallback(const CommonAPI::CallStatus& status, const ::v1::com::harman::media::BaseType::tBaseError& error)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setSpeedCallback: status=%d,error=%d", (int)(status),(int)error);
    BaseType::tAudioObjectType audioType;
     MMPresTypes::eMetadataType type;
    DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
    if(pDevice != nullptr)
    {
       type = pDevice->getMetadataType();
    }

	bool ret = false;
	ret = PlayHelper::getMetadataType(type, audioType);
    if(ret)
    {
      // mPlayEngine->getPlaybackSpeed(mPlayEngine.mClientID, audioType, std::bind(&MediaPlayerStubImpl::getSpeedCallback, this,std::move(reply), _1, _2, _3));
     mPlayEngine->getPlaybackSpeed(mPlayEngine.mClientID, audioType, std::bind(&MediaPlayerStubImpl::getSpeedCallback, this, _1, _2, _3));
    }
}

void MediaPlayerStubImpl::setRateCallback(const CommonAPI::CallStatus& status, const double& rate)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, "<<< MediaPlayerStubImpl::setRateCallback: CallStatus : %d rate: %f", (int)status, rate);
}

const ::v3::com::harman::mmpres::MMPresTypes::tNowPlayingInfo& MediaPlayerStubImpl::getNowPlayingDataAttribute()
{
	return mNowPlayingInfo;
	//TBD
}

void MediaPlayerStubImpl::setNowPlayingDataAttribute(::v3::com::harman::mmpres::MMPresTypes::tNowPlayingInfo _value)
{
	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
	{
		stubAdapter->fireNowPlayingDataAttributeChanged(_value);
	}
	mNowPlayingInfo = _value;
}

const ::v3::com::harman::mmpres::MMPresTypes::eRemoteCDDiscStatus& MediaPlayerStubImpl::getMRemoteCDDiscStatusAttribute()
{
    return mDiscStatus;
}

void MediaPlayerStubImpl::setMRemoteCDDiscStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::eRemoteCDDiscStatus _value)
{
    	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
	{
		stubAdapter->fireMRemoteCDDiscStatusAttributeChanged(_value);
	}
	mDiscStatus = _value;
}

const ::v3::com::harman::mmpres::MMPresTypes::RemoteCDErrorStatus& MediaPlayerStubImpl::getMRemoteCDErrorStatusAttribute()
{
    return mErrorStatus;
}

void MediaPlayerStubImpl::setMRemoteCDErrorStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::RemoteCDErrorStatus _value)
{
    	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
	{
		stubAdapter->fireMRemoteCDErrorStatusAttributeChanged(_value);
	}
	mErrorStatus = _value;
}

const bool& MediaPlayerStubImpl::getMRemoteCDEjectChimesWarningAttribute()
{
	return mbEjectChaimWarningStatus;
}

void MediaPlayerStubImpl::setMRemoteCDEjectChimesWarningAttribute(const bool _value)
{
    auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
	{
		stubAdapter->fireMRemoteCDEjectChimesWarningAttributeChanged(_value);
	}
	mbEjectChaimWarningStatus = _value;
}

const ::v3::com::harman::mmpres::MMPresTypes::MediaErrorMap& MediaPlayerStubImpl::getMediaErrorAttribute()
{
    return mMediaErrorMap;
}

void MediaPlayerStubImpl::setMediaErrorAttribute(::v3::com::harman::mmpres::MMPresTypes::MediaErrorMap _value)
{
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireMediaErrorAttributeChanged(_value);
        
        mMediaErrorMap = _value ;
}


const ::v3::com::harman::mmpres::MMPresTypes::tRemotePlayerCapability& MediaPlayerStubImpl::getRemotePlayerCapabilityAttribute()
{
    return mRemotePlayerCapability ;
}

void MediaPlayerStubImpl::setRemotePlayerCapabilityAttribute(::v3::com::harman::mmpres::MMPresTypes::tRemotePlayerCapability _value)
{
    LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setRemotePlayerCapabilityAttribute SlotId = %d ,Capability = %d",_value.getSlotId(), _value.getCapability());
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireRemotePlayerCapabilityAttributeChanged(_value);
        
        mRemotePlayerCapability = _value ;
}

/* over-riding default functionality of Common-API for trackState attribute.
 * This is because during source-switch from USB to AM/FM and coming back to USB again, HMI is clearing out all metadata.
 * As trackState is not changing after source-switch, Common-API suppresses trackState. Hence below over-riding is done
 */

const ::v3::com::harman::mmpres::MMPresTypes::tTrackState& MediaPlayerStubImpl::getTrackStateAttribute()
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getTrackStateAttribute- currentTrack =%llu, totalTracks =%llu",mTrackStateAttribute.getCurrentTrack(), mTrackStateAttribute.getTotalTracks());
    return mTrackStateAttribute;
}

void MediaPlayerStubImpl::setTrackStateAttribute(::v3::com::harman::mmpres::MMPresTypes::tTrackState _value)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setTrackStateAttribute- currentTrack =%llu, totalTracks =%llu",_value.getCurrentTrack(), _value.getTotalTracks());

	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->fireTrackStateAttributeChanged(_value);

	mTrackStateAttribute = _value;
}

/* over-riding default functionality of Common-API for repateMode attribute.
 * This is because during source-switch from USB to AM/FM and coming back to USB again, HMI is clearing out all metadata.
 * As repateMode is not changing after source-switch, Common-API suppresses repateMode. Hence below over-riding is done
 */
const ::v3::com::harman::mmpres::MMPresTypes::eRepeatMode& MediaPlayerStubImpl::getRepeatModeAttribute()
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getRepeatModeAttribute- repeatMode =%d",mRepeatModeAttribute);
    return mRepeatModeAttribute;
}

void MediaPlayerStubImpl::setRepeatModeAttribute(::v3::com::harman::mmpres::MMPresTypes::eRepeatMode _value)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setRepeatModeAttribute- repeatMode =%d",_value);

	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->fireRepeatModeAttributeChanged(_value);

	mRepeatModeAttribute = _value;
}

/* over-riding default functionality of Common-API for shuffleMode attribute.
 * This is because during source-switch from USB to AM/FM and coming back to USB again, HMI is clearing out all metadata.
 * As shuffleMode is not changing after source-switch, Common-API suppresses shuffleMode. Hence below over-riding is done
 */
const ::v3::com::harman::mmpres::MMPresTypes::eShuffleMode& MediaPlayerStubImpl::getShuffleModeAttribute()
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getShuffleModeAttribute- shuffleMode =%d",mShuffleModeAttribute);
    return mShuffleModeAttribute;
}

void MediaPlayerStubImpl::setShuffleModeAttribute(::v3::com::harman::mmpres::MMPresTypes::eShuffleMode _value)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setShuffleModeAttribute- shuffleMode =%d",_value);

	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->fireShuffleModeAttributeChanged(_value);

	mShuffleModeAttribute = _value;
}

/* over-riding default functionality of Common-API for currentPlay Time attribute.
 * This is because during source-switch from USB to AM/FM and coming back to USB again, HMI is clearing out all metadata.
 * As currentPlay Time is not changing after source-switch, Common-API suppresses currentPlay Time. Hence below over-riding is done
 */
const uint64_t& MediaPlayerStubImpl::getCurrentPlayTimeAttribute()
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getCurrentPlayTimeAttribute- currentPlayTime =%llu",mCurrentPlayTimeAttribute);
    return mCurrentPlayTimeAttribute;
}

void MediaPlayerStubImpl::setCurrentPlayTimeAttribute(uint64_t _value)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setCurrentPlayTimeAttribute- currentPlayTime =%llu",_value);

	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->fireCurrentPlayTimeAttributeChanged(_value);

	mCurrentPlayTimeAttribute = _value;
}

/* over-riding default functionality of Common-API for playbackSpeed attribute for HMI. */
const ::v3::com::harman::mmpres::MMPresTypes::tPlaybackSpeed& MediaPlayerStubImpl::getPlaybackSpeedAttribute()
{
    
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getPlaybackSpeedAttribute- slotId =%d, metadataType=%llu, playbackSpeed=%d",mPlaybackSpeedAttribute.getSlotId(), mPlaybackSpeedAttribute.getType(), mPlaybackSpeedAttribute.getPlaybackSpeed());
    return mPlaybackSpeedAttribute;
    
}

void MediaPlayerStubImpl::setPlaybackSpeedAttribute(::v3::com::harman::mmpres::MMPresTypes::tPlaybackSpeed _value)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setPlaybackSpeedAttribute- slotId =%d, metadataType=%llu, playbackSpeed=%d",_value.getSlotId(), _value.getType(), _value.getPlaybackSpeed());

	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->firePlaybackSpeedAttributeChanged(_value);

	mPlaybackSpeedAttribute = _value;
}

/* over-riding default functionality of Common-API for ActiveDeviceBTLinkLoss attribute for HMI. */
const bool& MediaPlayerStubImpl::getActiveDeviceBTLinkLossAttribute()
{
     LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getActiveDeviceBTLinkLossAttribute- activeDeviceBTLinkLoss status =%d",(int)mActiveDeviceBTLinkLossAttribute);
    
    if ( mActiveDeviceBTLinkLossAttribute )
    {
        mActiveDeviceBTLinkLossAttribute = true;
        
    }
    else
    {
        mActiveDeviceBTLinkLossAttribute = false;
    }
    
    return mActiveDeviceBTLinkLossAttribute;
    
}

void MediaPlayerStubImpl::setActiveDeviceBTLinkLossAttribute(bool _value)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setActiveDeviceBTLinkLossAttribute- activeDeviceBTLinkLoss status =%d",(int)_value);

	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->fireActiveDeviceBTLinkLossAttributeChanged(_value);

	mActiveDeviceBTLinkLossAttribute = _value;
}

/* over-riding default functionality of Common-API for TrackListSupport attribute for HMI. */
const ::v3::com::harman::mmpres::MMPresTypes::tTrackListSupport& MediaPlayerStubImpl::getTrackListSupportAttribute()
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getTrackListSupportAttribute-  slotId =%d, IsTrackListSupported=%d",mTrackListSupportAttribute.getSlotId(), (int)mTrackListSupportAttribute.getIsTrackListSupported());

    return mTrackListSupportAttribute;
}

void MediaPlayerStubImpl::setTrackListSupportAttribute(::v3::com::harman::mmpres::MMPresTypes::tTrackListSupport _value)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setTrackListSupportAttribute-  slotId =%d, IsTrackListSupported=%d",_value.getSlotId(), (int)_value.getIsTrackListSupported());

	auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
	if (stubAdapter)
		stubAdapter->fireTrackListSupportAttributeChanged(_value);

	mTrackListSupportAttribute = std::move(_value);
}

/* over-riding default functionality of Common-API for Promote Status attribute for HMI. */
const bool& MediaPlayerStubImpl::getPromoteStatusAttribute()
{
   DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
   if (pDevice != nullptr)
   {
      mbPromoteStatus = pDevice->getPromoteStatus();
   }
   LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getPromoteStatusAttribute- PromoteStatus=%d", (int)mbPromoteStatus);

   return mbPromoteStatus;
}

void MediaPlayerStubImpl::setPromoteStatusAttribute(bool _value)
{
   LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setPromoteStatusAttribute- PromoteStatus=%d", (int)_value);
   DeviceBase* pDevice = mDetectionEngine->getActiveDevice();

   auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
   if (stubAdapter)
      stubAdapter->firePromoteStatusAttributeChanged(_value);

   if (pDevice != nullptr)
   {
      mbPromoteStatus = std::move(_value);
      //pDevice->setPromoteStatus(mbPromoteStatus);
   }
}


const bool& MediaPlayerStubImpl::getDemoteStatusAttribute()
{
   DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
   if (pDevice != nullptr)
   {
      mbDemoteStatus = pDevice->getDemoteStatus();
   }
   LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getDemoteStatusAttribute- DemoteStatus=%d", (int)mbDemoteStatus);

   return mbDemoteStatus;
}

void MediaPlayerStubImpl::setDemoteStatusAttribute(bool _value)
{
   LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setDemoteStatusAttribute- DemoteStatus=%d", (int)_value);
   DeviceBase* pDevice = mDetectionEngine->getActiveDevice();

   auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
   if (stubAdapter)
      stubAdapter->fireDemoteStatusAttributeChanged(_value);

   if (pDevice != nullptr)
   {
      mbDemoteStatus = std::move(_value);
      //pDevice->setDemoteStatus(mbDemoteStatus);
   }
}

const bool& MediaPlayerStubImpl::getAddToWishListStatusAttribute()
{
   DeviceBase* pDevice = mDetectionEngine->getActiveDevice();
   if (pDevice != nullptr)
   {
      mbAddToWishListStatus = pDevice->getAddToWishListStatus();
   }
   LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::getAddToWishListStatusAttribute- AddToWishListStatus=%d",(int) mbAddToWishListStatus);

   return mbAddToWishListStatus;
}

void MediaPlayerStubImpl::setAddToWishListStatusAttribute(bool _value)
{
   LOG_INFO(LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setAddToWishListStatusAttribute- AddToWishListStatus=%d", (int)_value);
   DeviceBase* pDevice = mDetectionEngine->getActiveDevice();

   auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
   if (stubAdapter)
      stubAdapter->fireAddToWishListStatusAttributeChanged(_value);

   if (pDevice != nullptr)
   {
      mbAddToWishListStatus = std::move(_value);
      //pDevice->setAddToWishListStatus(mbAddToWishListStatus);
   }
}

const ::v3::com::harman::mmpres::MMPresTypes::eCDEOLStatus& MediaPlayerStubImpl::getMCDEOLStatusAttribute()
{
    return mEOLStatus;
}

void MediaPlayerStubImpl::setMCDEOLStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::eCDEOLStatus _value) 
{
   LOG_INFO( LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::setMCDEOLStatusAttribute " );
   auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
   if (stubAdapter)
   {
      LOG_INFO( LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::stubAdapter true " );
      stubAdapter->fireMCDEOLStatusAttributeChanged( _value );
   }
   else
   {
      LOG_INFO( LOG_CONTEXT_MEDIA, ">>> MediaPlayerStubImpl::stubAdapter false " ); 
   }
   mEOLStatus = std::move ( _value );
}

} // namespace mmpres
} // namespace harman
} // namespace com
} // namespace v1

