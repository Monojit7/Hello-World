/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1/org/genivi/mediamanager/PlayerDBusProxy.hpp>

namespace v1 {
namespace org {
namespace genivi {
namespace mediamanager {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createPlayerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<PlayerDBusProxy>(_address, _connection);
}

INITIALIZER(registerPlayerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		Player::getInterface(),
		&createPlayerDBusProxy);
}

PlayerDBusProxy::PlayerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		mute_(*this, "onMuteAttributeChanged", "setMuteAttribute", "i", "getMuteAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		shuffle_(*this, "onShuffleAttributeChanged", "setShuffleAttribute", "i", "getShuffleAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		repeat_(*this, "onRepeatAttributeChanged", "setRepeatAttribute", "i", "getRepeatAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		scan_(*this, "onScanAttributeChanged", "setScanAttribute", "i", "getScanAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		rate_(*this, "onRateAttributeChanged", "setRateAttribute", "d", "getRateAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		volume_(*this, "onVolumeAttributeChanged", "setVolumeAttribute", "d", "getVolumeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canGetPlayQueue_(*this, "onCanGetPlayQueueAttributeChanged", "b", "getCanGetPlayQueueAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canGoNext_(*this, "onCanGoNextAttributeChanged", "b", "getCanGoNextAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canGoPrevious_(*this, "onCanGoPreviousAttributeChanged", "b", "getCanGoPreviousAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canPause_(*this, "onCanPauseAttributeChanged", "b", "getCanPauseAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canPlay_(*this, "onCanPlayAttributeChanged", "b", "getCanPlayAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		canSeek_(*this, "onCanSeekAttributeChanged", "b", "getCanSeekAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		currentTrack_(*this, "onCurrentTrackAttributeChanged", "t", "getCurrentTrackAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		totalTracks_(*this, "onTotalTracksAttributeChanged", "t", "getTotalTracksAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		playbackStatus_(*this, "onPlaybackStatusAttributeChanged", "i", "getPlaybackStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		position_(*this, "onPositionAttributeChanged", "t", "getPositionAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		duration_(*this, "onDurationAttributeChanged", "t", "getDurationAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		videoPlayStatus_(*this, "onVideoPlayStatusAttributeChanged", "b", "getVideoPlayStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		sessionEnd_(*this, "onSessionEndAttributeChanged", "b", "getSessionEndAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		currAudioLanguage_(*this, "onCurrAudioLanguageAttributeChanged", "s", "getCurrAudioLanguageAttribute", static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
		totalAudioLanguage_(*this, "onTotalAudioLanguageAttributeChanged", "u", "getTotalAudioLanguageAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		audioChannel_(*this, "onAudioChannelAttributeChanged", "setAudioChannelAttribute", "i", "getAudioChannelAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		subtitle_(*this, "onSubtitleAttributeChanged", "setSubtitleAttribute", "i", "getSubtitleAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		aspectMode_(*this, "onAspectModeAttributeChanged", "setAspectModeAttribute", "i", "getAspectModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		restrictedMode_(*this, "onRestrictedModeAttributeChanged", "setRestrictedModeAttribute", "i", "getRestrictedModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		playerType_(*this, "onPlayerTypeAttributeChanged", "setPlayerTypeAttribute", "i", "getPlayerTypeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		metadata_(*this, "onMetadataAttributeChanged", "a{s(yv)}", "getMetadataAttribute", static_cast<::v1::org::genivi::mediamanager::MediaTypes_::ResultMapDeployment_t*>(nullptr)),
		currentMediumId_(*this, "onCurrentMediumIdAttributeChanged", "u", "getCurrentMediumIdAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr))
,		playQueueChanged_(*this, "playQueueChanged", "", std::make_tuple()),
		playError_(*this, "playError", "ui", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		devicePlayStatusChange_(*this, "devicePlayStatusChange", "uis", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)))
{
}

      PlayerDBusProxy::MuteAttribute& PlayerDBusProxy::getMuteAttribute() {
          return mute_;
      }
      PlayerDBusProxy::ShuffleAttribute& PlayerDBusProxy::getShuffleAttribute() {
          return shuffle_;
      }
      PlayerDBusProxy::RepeatAttribute& PlayerDBusProxy::getRepeatAttribute() {
          return repeat_;
      }
      PlayerDBusProxy::ScanAttribute& PlayerDBusProxy::getScanAttribute() {
          return scan_;
      }
      PlayerDBusProxy::RateAttribute& PlayerDBusProxy::getRateAttribute() {
          return rate_;
      }
      PlayerDBusProxy::VolumeAttribute& PlayerDBusProxy::getVolumeAttribute() {
          return volume_;
      }
      PlayerDBusProxy::CanGetPlayQueueAttribute& PlayerDBusProxy::getCanGetPlayQueueAttribute() {
          return canGetPlayQueue_;
      }
      PlayerDBusProxy::CanGoNextAttribute& PlayerDBusProxy::getCanGoNextAttribute() {
          return canGoNext_;
      }
      PlayerDBusProxy::CanGoPreviousAttribute& PlayerDBusProxy::getCanGoPreviousAttribute() {
          return canGoPrevious_;
      }
      PlayerDBusProxy::CanPauseAttribute& PlayerDBusProxy::getCanPauseAttribute() {
          return canPause_;
      }
      PlayerDBusProxy::CanPlayAttribute& PlayerDBusProxy::getCanPlayAttribute() {
          return canPlay_;
      }
      PlayerDBusProxy::CanSeekAttribute& PlayerDBusProxy::getCanSeekAttribute() {
          return canSeek_;
      }
      PlayerDBusProxy::CurrentTrackAttribute& PlayerDBusProxy::getCurrentTrackAttribute() {
          return currentTrack_;
      }
      PlayerDBusProxy::TotalTracksAttribute& PlayerDBusProxy::getTotalTracksAttribute() {
          return totalTracks_;
      }
      PlayerDBusProxy::PlaybackStatusAttribute& PlayerDBusProxy::getPlaybackStatusAttribute() {
          return playbackStatus_;
      }
      PlayerDBusProxy::PositionAttribute& PlayerDBusProxy::getPositionAttribute() {
          return position_;
      }
      PlayerDBusProxy::DurationAttribute& PlayerDBusProxy::getDurationAttribute() {
          return duration_;
      }
      PlayerDBusProxy::VideoPlayStatusAttribute& PlayerDBusProxy::getVideoPlayStatusAttribute() {
          return videoPlayStatus_;
      }
      PlayerDBusProxy::SessionEndAttribute& PlayerDBusProxy::getSessionEndAttribute() {
          return sessionEnd_;
      }
      PlayerDBusProxy::CurrAudioLanguageAttribute& PlayerDBusProxy::getCurrAudioLanguageAttribute() {
          return currAudioLanguage_;
      }
      PlayerDBusProxy::TotalAudioLanguageAttribute& PlayerDBusProxy::getTotalAudioLanguageAttribute() {
          return totalAudioLanguage_;
      }
      PlayerDBusProxy::AudioChannelAttribute& PlayerDBusProxy::getAudioChannelAttribute() {
          return audioChannel_;
      }
      PlayerDBusProxy::SubtitleAttribute& PlayerDBusProxy::getSubtitleAttribute() {
          return subtitle_;
      }
      PlayerDBusProxy::AspectModeAttribute& PlayerDBusProxy::getAspectModeAttribute() {
          return aspectMode_;
      }
      PlayerDBusProxy::RestrictedModeAttribute& PlayerDBusProxy::getRestrictedModeAttribute() {
          return restrictedMode_;
      }
      PlayerDBusProxy::PlayerTypeAttribute& PlayerDBusProxy::getPlayerTypeAttribute() {
          return playerType_;
      }
      PlayerDBusProxy::MetadataAttribute& PlayerDBusProxy::getMetadataAttribute() {
          return metadata_;
      }
      PlayerDBusProxy::CurrentMediumIdAttribute& PlayerDBusProxy::getCurrentMediumIdAttribute() {
          return currentMediumId_;
      }

PlayerDBusProxy::PlayQueueChangedEvent& PlayerDBusProxy::getPlayQueueChangedEvent() {
    return playQueueChanged_;
}
PlayerDBusProxy::PlayErrorEvent& PlayerDBusProxy::getPlayErrorEvent() {
    return playError_;
}
PlayerDBusProxy::DevicePlayStatusChangeEvent& PlayerDBusProxy::getDevicePlayStatusChangeEvent() {
    return devicePlayStatusChange_;
}
    
    /**
     * description: Skip to the next track in the play queue. If there is no                       
     *   next track, playback is stopped. If playback is paused or                     
     *     stopped, this function will set the next plack to be                       
     *   played once playback is activated
     */
    void PlayerDBusProxy::next(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "next",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::nextAsync(NextAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "next",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Skip to the next chapter if current playback audio is podcast                  
     *        or audiobook.
     */
    void PlayerDBusProxy::nextChapter(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "nextChapter",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::nextChapterAsync(NextChapterAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "nextChapter",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: USB device Next folder selection                        1. On next folder
     *   selection, the folder which comes next in alphabetical                        
     *     order shall be selected for play. System shall play first track of          
     *                   next folder on next folder selection.                       
     *   2. If the current song is in pause state and user presses next folder         
     *                    button, then system shall come out of pause state and play
     *   the next                          folder.                        3. Next
     *   folder operation should not be performed by the system when no                
     *             folder/tracks are present in the USB device.                       
     *   4. The system shall support next folder selection in Random and Repeat modes.
     */
    void PlayerDBusProxy::nextFolder(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "nextFolder",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::nextFolderAsync(NextFolderAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "nextFolder",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Open the supplied Uri for playback in the playback engine.          returns:
     *   INVALID_URI When an invalid URI is supplied                               
     *   (decided by playback engine)                    NO_ERROR    On success
     * param: uri URI of media to play, uri format is decided by backend
     */
    void PlayerDBusProxy::openUri(const std::string &_uri, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "openUri",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_uri,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::openUriAsync(const std::string &_uri, OpenUriAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "openUri",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_uri,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Enqueue the supplied Uri for playback in the playback engine.          returns:
     *   INVALID_URI When an invalid URI is supplied                               
     *   (decided by playback engine)                   NO_ERROR    On success
     * param: uri URI of media to enqueue, uri format is decided by backend
     */
    void PlayerDBusProxy::enqueueUri(const std::string &_uri, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "enqueueUri",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_uri,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::enqueueUriAsync(const std::string &_uri, EnqueueUriAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "enqueueUri",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_uri,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Dequeue the item with the supplied index in the playback                      
     *   engine.
     * param: pos index of media to dequeue
     */
    void PlayerDBusProxy::dequeueIndex(const uint64_t &_pos, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "dequeueIndex",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_pos,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::dequeueIndexAsync(const uint64_t &_pos, DequeueIndexAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "dequeueIndex",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_pos,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Retrieve the current play queue. The format of the result                      
     *   object is described in MediaTypes.fidl          returns: Current play queue
     */
    void PlayerDBusProxy::getCurrentPlayQueue(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::MediaTypes::ResultMapList &_playQueue, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> deploy_playQueue(static_cast<::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList,::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t>,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getCurrentPlayQueue",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_playQueue, deploy_e);
_playQueue = deploy_playQueue.getValue();
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::getCurrentPlayQueueAsync(GetCurrentPlayQueueAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> deploy_playQueue(static_cast<::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList,::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t>,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getCurrentPlayQueue",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> _playQueue, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _playQueue.getValue(), _e.getValue());
        },
        std::make_tuple(deploy_playQueue, deploy_e));
    }
    /**
     * description: Retrieve the current play queue with offset and count.     				  The format of
     *   the result object is described in MediaTypes.fidl          returns: Current
     *   play queue
     */
    void PlayerDBusProxy::getCurrentPlayQueueEx(const uint64_t &_offset, const uint64_t &_count, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::MediaTypes::ResultMapList &_playQueue, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_offset(_offset, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_count(_count, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> deploy_playQueue(static_cast<::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList,::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t>,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getCurrentPlayQueueEx",
        "tt",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_offset, deploy_count,
_internalCallStatus,
deploy_playQueue, deploy_e);
_playQueue = deploy_playQueue.getValue();
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::getCurrentPlayQueueExAsync(const uint64_t &_offset, const uint64_t &_count, GetCurrentPlayQueueExAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_offset(_offset, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_count(_count, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> deploy_playQueue(static_cast<::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList,::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t>,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getCurrentPlayQueueEx",
        "tt",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_offset, deploy_count,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> _playQueue, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _playQueue.getValue(), _e.getValue());
        },
        std::make_tuple(deploy_playQueue, deploy_e));
    }
    /**
     * description: Dequeue all elements, emptying the play queue
     */
    void PlayerDBusProxy::dequeueAll(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "dequeueAll",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::dequeueAllAsync(DequeueAllAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "dequeueAll",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Use the supplied playlist as the current play queue. If                      
     *   the play queue is invalid, the old play queue is                      
     *   untouched.          returns: BAD_PLAYLIST If playlist can not be loaded       
     *               NO_ERROR     On success
     */
    void PlayerDBusProxy::openPlaylist(const std::string &_uri, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "openPlaylist",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_uri,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::openPlaylistAsync(const std::string &_uri, OpenPlaylistAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "openPlaylist",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_uri,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Pause playback in the playback engine.                        If already
     *   paused, this has no effect                        Note: If CanPause is false,
     *   this has no effect
     */
    void PlayerDBusProxy::pause(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "pause",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::pauseAsync(PauseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "pause",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Start or resume playback in the playback engine.                        If
     *   playback is already commencing, this has not effect.                        If
     *   paused, playback resumes from the current position.                        If
     *   there is no track to play, calling this has no effect                       
     *   Note: If CanPlay is false, this has no effect
     */
    void PlayerDBusProxy::play(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "play",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::playAsync(PlayAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "play",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Stop playback in the playback engine.                        If playback is
     *   already stopped, this has not effect.
     */
    void PlayerDBusProxy::stop(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "stop",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::stopAsync(StopAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "stop",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Starts playback (see Play) if paused                       Pauses playback (see
     *   Pause) is playing
     * see: Play
     * see: Pause
     */
    void PlayerDBusProxy::playPause(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "playPause",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::playPauseAsync(PlayPauseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "playPause",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Loads previous track in play queue or start at the      				  beginning of
     *   current track, time can be configured.                       If there is no
     *   previous track, playback is stopped                       If playback is
     *   stopped or paused, it remains this way,                       but the next
     *   track to be played will the set                       by this function        
     *                 Note: If CanGoPrevious is false, this has no effect
     */
    void PlayerDBusProxy::previous(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "previous",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::previousAsync(PreviousAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "previous",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Skip to the next chapter if current playback audio is podcast                  
     *        or audiobook.
     */
    void PlayerDBusProxy::previousChapter(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "previousChapter",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::previousChapterAsync(PreviousChapterAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "previousChapter",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: USB device Previous folder selection                        1. On previous
     *   folder selection, the folder which comes previous in alphabetical             
     *                order shall be selected for play. System shall play first track
     *   of previous                           folder on previous folder selection.    
     *                      2. If the current song is in pause state and user presses
     *   previous folder                           button, then system shall come out
     *   of pause state and play the previous folder.                        3.
     *   previous folder operation should not be performed by the system when no       
     *                      folder/tracks are present in the USB device.               
     *           4. The system shall support previous folder selection in Random and
     *   Repeat modes.
     */
    void PlayerDBusProxy::previousFolder(const ::v1::org::genivi::mediamanager::PlayerTypes::StartIndexOption &_startIndexOpt, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::StartIndexOption, CommonAPI::EmptyDeployment> deploy_startIndexOpt(_startIndexOpt, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::StartIndexOption, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "previousFolder",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_startIndexOpt,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::previousFolderAsync(const ::v1::org::genivi::mediamanager::PlayerTypes::StartIndexOption &_startIndexOpt, PreviousFolderAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::StartIndexOption, CommonAPI::EmptyDeployment> deploy_startIndexOpt(_startIndexOpt, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::StartIndexOption, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "previousFolder",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_startIndexOpt,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Seek relatively in the current track                       If a negative seek
     *   leads to a play position less than 0,                       the play position
     *   will be set to 0.                       If a positive seek leads outside the
     *   length of the current                       track, this is treated like a call
     *   to Next()                       Note: If CanSeek is false, this has no effect
     * param: pos Relative seek amount in microseconds
     * see: Next
     */
    void PlayerDBusProxy::seek(const int64_t &_pos, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "seek",
        "x",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_pos,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::seekAsync(const int64_t &_pos, SeekAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "seek",
        "x",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_pos,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Jump to the specified position in the current                        If the
     *   position is not within range of the current track,                        do
     *   nothing          Note: If CanSeek is false, this has no effect
     * param: pos Absolute position in microseconds
     */
    void PlayerDBusProxy::setPosition(const uint64_t &_pos, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setPosition",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_pos,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::setPositionAsync(const uint64_t &_pos, SetPositionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_pos(_pos, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setPosition",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_pos,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: list all audio languages for current track
     * param: list The string list of all audio languages
     */
    void PlayerDBusProxy::listAudioLanguages(CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::MediaTypes::StringList &_list, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::StringList, ::v1::org::genivi::mediamanager::MediaTypes_::StringListDeployment_t> deploy_list(static_cast<::v1::org::genivi::mediamanager::MediaTypes_::StringListDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::StringList,::v1::org::genivi::mediamanager::MediaTypes_::StringListDeployment_t>,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "listAudioLanguages",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_list, deploy_e);
_list = deploy_list.getValue();
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::listAudioLanguagesAsync(ListAudioLanguagesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::StringList, ::v1::org::genivi::mediamanager::MediaTypes_::StringListDeployment_t> deploy_list(static_cast<::v1::org::genivi::mediamanager::MediaTypes_::StringListDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::StringList,::v1::org::genivi::mediamanager::MediaTypes_::StringListDeployment_t>,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "listAudioLanguages",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::StringList, ::v1::org::genivi::mediamanager::MediaTypes_::StringListDeployment_t> _list, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _list.getValue(), _e.getValue());
        },
        std::make_tuple(deploy_list, deploy_e));
    }
    /**
     * description: select a audio languages for current track
     * param: lang audio languages code, eg. en/zh/jp
     */
    void PlayerDBusProxy::selectAudioLanguage(const std::string &_lang, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_lang(_lang, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "selectAudioLanguage",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_lang,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::selectAudioLanguageAsync(const std::string &_lang, SelectAudioLanguageAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_lang(_lang, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "selectAudioLanguage",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_lang,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: list all (internal or external) subtitles in specified path
     * param: path The folder path name to list                      "." stand for current
     *   directory                      ".."  stand for the parent directory.          
     *          ResultMap usage:                 ----------------                 For
     *   Folders and Subtitles:                   - DisplayName(String): The name of
     *   Folder/Subtitle                   - Type(String): The type will be "folder" or
     *   "subtitle"                  For Folders only:                   -
     *   Path(String): The path name to list                  For Subtitles only:      
     *               - ID(Int64): The indentifier of Subtitle.                   -
     *   Language(String): The language code of current subtitle.                   -
     *   Active(Boolean): The subtitle is selected will be true, otherwise false.
     */
    void PlayerDBusProxy::listSubtitles(const std::string &_path, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::MediaTypes::ResultMapList &_list, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(_path, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> deploy_list(static_cast<::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList,::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t>,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "listSubtitles",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_path,
_internalCallStatus,
deploy_list, deploy_e);
_list = deploy_list.getValue();
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::listSubtitlesAsync(const std::string &_path, ListSubtitlesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(_path, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> deploy_list(static_cast<::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList,::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t>,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "listSubtitles",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_path,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::MediaTypes::ResultMapList, ::v1::org::genivi::mediamanager::MediaTypes_::ResultMapListDeployment_t> _list, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _list.getValue(), _e.getValue());
        },
        std::make_tuple(deploy_list, deploy_e));
    }
    /**
     * description: select a subtitle for current playing video track
     * param: id The id of selected subtitle, the id from the ResultMap of listSubtitles
     */
    void PlayerDBusProxy::selectSubtitle(const int64_t &_id, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment> deploy_id(_id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "selectSubtitle",
        "x",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_id,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::selectSubtitleAsync(const int64_t &_id, SelectSubtitleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment> deploy_id(_id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "selectSubtitle",
        "x",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_id,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Adjust the current subtitle timeline for syncing with audio track playback
     * param: ms Adjustment in microseconds
     */
    void PlayerDBusProxy::syncSubtitle(const int32_t &_ms, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_ms(_ms, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "syncSubtitle",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_ms,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::syncSubtitleAsync(const int32_t &_ms, SyncSubtitleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_ms(_ms, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "syncSubtitle",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_ms,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Set the display window coordinates of video playback
     * param: fullscreen ture is enable fullscreen, false is disable fullscreen and manually
     *   assigned by rectangle                 rect rectangle coordinates
     */
    void PlayerDBusProxy::setDisplayWindow(const bool &_fullscreen, const ::v1::org::genivi::mediamanager::PlayerTypes::tRectangle &_rect, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_fullscreen(_fullscreen, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::tRectangle, ::v1::org::genivi::mediamanager::PlayerTypes_::tRectangleDeployment_t> deploy_rect(_rect, static_cast<::v1::org::genivi::mediamanager::PlayerTypes_::tRectangleDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::tRectangle, ::v1::org::genivi::mediamanager::PlayerTypes_::tRectangleDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setDisplayWindow",
        "b(uuuu)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_fullscreen, deploy_rect,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::setDisplayWindowAsync(const bool &_fullscreen, const ::v1::org::genivi::mediamanager::PlayerTypes::tRectangle &_rect, SetDisplayWindowAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_fullscreen(_fullscreen, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::tRectangle, ::v1::org::genivi::mediamanager::PlayerTypes_::tRectangleDeployment_t> deploy_rect(_rect, static_cast<::v1::org::genivi::mediamanager::PlayerTypes_::tRectangleDeployment_t*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::tRectangle, ::v1::org::genivi::mediamanager::PlayerTypes_::tRectangleDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setDisplayWindow",
        "b(uuuu)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_fullscreen, deploy_rect,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: promote the track
     * param: uri is the track uri, empty uri can be used for current playing track.
     */
    void PlayerDBusProxy::promote(const std::string &_uri, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "promote",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_uri,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::promoteAsync(const std::string &_uri, PromoteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "promote",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_uri,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: demote the track
     * param: uri is the track uri, empty uri can be used for current playing track.
     */
    void PlayerDBusProxy::demote(const std::string &_uri, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "demote",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_uri,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::demoteAsync(const std::string &_uri, DemoteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "demote",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_uri,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: add iTunes station to a WishList
     * param: uri is the track uri, empty uri can be used for current playing track.
     */
    void PlayerDBusProxy::addToWishList(const std::string &_uri, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "addToWishList",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_uri,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::addToWishListAsync(const std::string &_uri, AddToWishListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_uri(_uri, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "addToWishList",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_uri,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: create and now playing list by Ids
     * param: mediumId - the unique device id: 0 means current player                 titleId
     *   - title of the media/audiobook/podcast                 albumId - id of the
     *   album                 artistId - id of the artist                 genreId - id
     *   of the genre                 playlistId - id of the playlist                
     *   audiobookId - id of the audiobook                 podcastId - id of the
     *   podcast          For the Ids, set the value to 0 for default
     */
    void PlayerDBusProxy::playByIds(const uint32_t &_mediumId, const int32_t &_titleId, const int32_t &_albumId, const int32_t &_artistId, const int32_t &_genreId, const int32_t &_playlistId, const int32_t &_audiobookId, const int32_t &_podcastId, CommonAPI::CallStatus &_internalCallStatus, ::v1::org::genivi::mediamanager::PlayerTypes::PlayerError &_e, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_mediumId(_mediumId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_titleId(_titleId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_albumId(_albumId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_artistId(_artistId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_genreId(_genreId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_playlistId(_playlistId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_audiobookId(_audiobookId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_podcastId(_podcastId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "playByIds",
        "uiiiiiii",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mediumId, deploy_titleId, deploy_albumId, deploy_artistId, deploy_genreId, deploy_playlistId, deploy_audiobookId, deploy_podcastId,
_internalCallStatus,
deploy_e);
_e = deploy_e.getValue();
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::playByIdsAsync(const uint32_t &_mediumId, const int32_t &_titleId, const int32_t &_albumId, const int32_t &_artistId, const int32_t &_genreId, const int32_t &_playlistId, const int32_t &_audiobookId, const int32_t &_podcastId, PlayByIdsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_mediumId(_mediumId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_titleId(_titleId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_albumId(_albumId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_artistId(_artistId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_genreId(_genreId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_playlistId(_playlistId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_audiobookId(_audiobookId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_podcastId(_podcastId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> deploy_e(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "playByIds",
        "uiiiiiii",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mediumId, deploy_titleId, deploy_albumId, deploy_artistId, deploy_genreId, deploy_playlistId, deploy_audiobookId, deploy_podcastId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::PlayerError, CommonAPI::EmptyDeployment> _e) {
        	if (_callback)
        		_callback(_internalCallStatus, _e.getValue());
        },
        std::make_tuple(deploy_e));
    }
    /**
     * description: Method to send the button events received from HMI
     */
    void PlayerDBusProxy::sendIAP2KeyEvent(const ::v1::org::genivi::mediamanager::PlayerTypes::IAP2ButtonType &_buttonType, const bool &_pressed, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::IAP2ButtonType, CommonAPI::EmptyDeployment> deploy_buttonType(_buttonType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_pressed(_pressed, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::IAP2ButtonType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "sendIAP2KeyEvent",
        "ib",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_buttonType, deploy_pressed,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> PlayerDBusProxy::sendIAP2KeyEventAsync(const ::v1::org::genivi::mediamanager::PlayerTypes::IAP2ButtonType &_buttonType, const bool &_pressed, SendIAP2KeyEventAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::IAP2ButtonType, CommonAPI::EmptyDeployment> deploy_buttonType(_buttonType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_pressed(_pressed, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::org::genivi::mediamanager::PlayerTypes::IAP2ButtonType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "sendIAP2KeyEvent",
        "ib",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_buttonType, deploy_pressed,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }


void PlayerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 4;
      }

      } // namespace mediamanager
      } // namespace genivi
      } // namespace org
      } // namespace v1
