/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: This class implements Bluetooth debugging related operations     WARNING -
 *   proper care is to be taken  from the consumer of this interface mainly because
 *   of  security concerns attached. 	Proper handling/restrictions is to be done so
 *   that the proxy uses the interface only to debug .  	And the interface
 *   consumption should not be entertained or well controlled in SOP deliveries.
 * author: Poornima Hiremath
 */
#include <v1/com/harman/connectivity/BtServiceDebugOnlyDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace connectivity {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createBtServiceDebugOnlyDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<BtServiceDebugOnlyDBusProxy>(_address, _connection);
}

INITIALIZER(registerBtServiceDebugOnlyDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		BtServiceDebugOnly::getInterface(),
		&createBtServiceDebugOnlyDBusProxy);
}

BtServiceDebugOnlyDBusProxy::BtServiceDebugOnlyDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
{
}


    
    /**
     * description: The method used to retrieve the Link Key of a paired device . 	WARNING - 
     *   proper care is to be taken from the caller as this method has security
     *   concerns attached. 	Proper handling is to be done so that the method is called
     *   only to debug and SHOULD NOT be called in SOP deliveries.
     * author: Poornima Hiremath
     */
    void BtServiceDebugOnlyDBusProxy::getLinkKey(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, std::string &_outAddress, std::string &_linkKey, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_inAddress(_inAddress, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_outAddress(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_linkKey(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_errorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
            CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getLinkKey",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_inAddress,
_internalCallStatus,
deploy_outAddress, deploy_linkKey, deploy_errorCode);
_outAddress = deploy_outAddress.getValue();
_linkKey = deploy_linkKey.getValue();
_errorCode = deploy_errorCode.getValue();
}
    std::future<CommonAPI::CallStatus> BtServiceDebugOnlyDBusProxy::getLinkKeyAsync(const std::string &_inAddress, GetLinkKeyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_inAddress(_inAddress, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_outAddress(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_linkKey(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_errorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
            CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getLinkKey",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_inAddress,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _outAddress, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _linkKey, CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> _errorCode) {
        	if (_callback)
        		_callback(_internalCallStatus, _outAddress.getValue(), _linkKey.getValue(), _errorCode.getValue());
        },
        std::make_tuple(deploy_outAddress, deploy_linkKey, deploy_errorCode));
    }
    /**
     * description: The method used to enable or disable HCI Debug mode.
     * author: Poornima Hiremath
     */
    void BtServiceDebugOnlyDBusProxy::setHCIDebugMode(const bool &_debugMode, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_debugMode(_debugMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_errorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setHCIDebugMode",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_debugMode,
_internalCallStatus,
deploy_errorCode);
_errorCode = deploy_errorCode.getValue();
}
    std::future<CommonAPI::CallStatus> BtServiceDebugOnlyDBusProxy::setHCIDebugModeAsync(const bool &_debugMode, SetHCIDebugModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_debugMode(_debugMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_errorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setHCIDebugMode",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_debugMode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> _errorCode) {
        	if (_callback)
        		_callback(_internalCallStatus, _errorCode.getValue());
        },
        std::make_tuple(deploy_errorCode));
    }
    /**
     * description: The method is used to enable or disable Secure Simple Pairing debug mode.
     *   	WARNING -  proper care is to be taken from the caller as this method has
     *   security concerns attached. 	Proper handling is to be done so that the method
     *   is called only to debug and SHOULD NOT be called in SOP deliveries.
     * author: Poornima Hiremath
     */
    void BtServiceDebugOnlyDBusProxy::setSSPDebugMode(const bool &_debugMode, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_debugMode(_debugMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_errorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setSSPDebugMode",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_debugMode,
_internalCallStatus,
deploy_errorCode);
_errorCode = deploy_errorCode.getValue();
}
    std::future<CommonAPI::CallStatus> BtServiceDebugOnlyDBusProxy::setSSPDebugModeAsync(const bool &_debugMode, SetSSPDebugModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_debugMode(_debugMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_errorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setSSPDebugMode",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_debugMode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> _errorCode) {
        	if (_callback)
        		_callback(_internalCallStatus, _errorCode.getValue());
        },
        std::make_tuple(deploy_errorCode));
    }
    /**
     * description: The method is used to enable HFP audio loop back testing. 	WARNING -  proper
     *   care is to be taken from the caller as this method has security concerns
     *   attached. 	Proper handling is to be done so that the method is called only to
     *   debug and SHOULD NOT be called in SOP deliveries.
     * author: Poornima Hiremath
     */
    void BtServiceDebugOnlyDBusProxy::hfpAudioLoopBackTest(const bool &_loopback_mode, const ::com::harman::connectivity::btTypedefs::eHfpAudioCodec &_loopback_AudioCodec, CommonAPI::CallStatus &_internalCallStatus, int32_t &_errorCode, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_loopback_mode(_loopback_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::com::harman::connectivity::btTypedefs::eHfpAudioCodec, CommonAPI::EmptyDeployment> deploy_loopback_AudioCodec(_loopback_AudioCodec, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_errorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::com::harman::connectivity::btTypedefs::eHfpAudioCodec, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "hfpAudioLoopBackTest",
        "bi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_loopback_mode, deploy_loopback_AudioCodec,
_internalCallStatus,
deploy_errorCode);
_errorCode = deploy_errorCode.getValue();
}
    std::future<CommonAPI::CallStatus> BtServiceDebugOnlyDBusProxy::hfpAudioLoopBackTestAsync(const bool &_loopback_mode, const ::com::harman::connectivity::btTypedefs::eHfpAudioCodec &_loopback_AudioCodec, HfpAudioLoopBackTestAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_loopback_mode(_loopback_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::com::harman::connectivity::btTypedefs::eHfpAudioCodec, CommonAPI::EmptyDeployment> deploy_loopback_AudioCodec(_loopback_AudioCodec, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_errorCode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::com::harman::connectivity::btTypedefs::eHfpAudioCodec, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "hfpAudioLoopBackTest",
        "bi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_loopback_mode, deploy_loopback_AudioCodec,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> _errorCode) {
        	if (_callback)
        		_callback(_internalCallStatus, _errorCode.getValue());
        },
        std::make_tuple(deploy_errorCode));
    }


void BtServiceDebugOnlyDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 1;
      }

      } // namespace connectivity
      } // namespace harman
      } // namespace com
      } // namespace v1
