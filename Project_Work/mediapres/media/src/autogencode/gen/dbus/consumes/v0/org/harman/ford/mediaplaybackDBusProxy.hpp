/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V0_ORG_HARMAN_FORD_mediaplayback_DBUS_PROXY_HPP_
#define V0_ORG_HARMAN_FORD_mediaplayback_DBUS_PROXY_HPP_

#include <v0/org/harman/ford/mediaplaybackProxyBase.hpp>
#include "v0/org/harman/ford/mediaplaybackDBusDeployment.hpp"

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/DBus/DBusAddress.hpp>
#include <CommonAPI/DBus/DBusFactory.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/DBus/DBusAttribute.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

#include <string>

namespace v0 {
namespace org {
namespace harman {
namespace ford {

class mediaplaybackDBusProxy
    : virtual public mediaplaybackProxyBase, 
      virtual public CommonAPI::DBus::DBusProxy {
public:
    mediaplaybackDBusProxy(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection);

    virtual ~mediaplaybackDBusProxy() { }

    virtual APIM_ActiveTrackNum_StAttribute& getAPIM_ActiveTrackNum_StAttribute();
    virtual APIM_NumberofTracks_StAttribute& getAPIM_NumberofTracks_StAttribute();
    virtual ACU_CurrTUBand_St_enumAttribute& getACU_CurrTUBand_St_enumAttribute();
    virtual ACU_RadioSeekMode2_St_enumAttribute& getACU_RadioSeekMode2_St_enumAttribute();
    virtual ACU_CurrentFreq_StAttribute& getACU_CurrentFreq_StAttribute();
    virtual ACU_CompLogic_St_enumAttribute& getACU_CompLogic_St_enumAttribute();
    virtual CD_Send_SignalsAttribute& getCD_Send_SignalsAttribute();
    virtual CD_Request_SignalsAttribute& getCD_Request_SignalsAttribute();
    virtual Dsp_CutItem_Rq_enumAttribute& getDsp_CutItem_Rq_enumAttribute();
    virtual Dsp_ItemNameLength_RqAttribute& getDsp_ItemNameLength_RqAttribute();
    virtual Dsp_FolderNumber_RqAttribute& getDsp_FolderNumber_RqAttribute();
    virtual Dsp_SourceSetTrack_RqAttribute& getDsp_SourceSetTrack_RqAttribute();
    virtual Dsp_FolderNumber3_RqAttribute& getDsp_FolderNumber3_RqAttribute();
    virtual Dsp_ItemIndex_RqAttribute& getDsp_ItemIndex_RqAttribute();
    virtual Dsp_PlayFrstTrInFldr_RqAttribute& getDsp_PlayFrstTrInFldr_RqAttribute();
    virtual NAV_LoadEjectDisc_Rq_enumAttribute& getNAV_LoadEjectDisc_Rq_enumAttribute();
    virtual NAV_SetOperationMode_Rq_enumAttribute& getNAV_SetOperationMode_Rq_enumAttribute();
    virtual NAV_CDSetIntroScan_Rq_enumAttribute& getNAV_CDSetIntroScan_Rq_enumAttribute();
    virtual ACU_Send_Signals_6Attribute& getACU_Send_Signals_6Attribute();
    virtual ACU_Send_Signals_5Attribute& getACU_Send_Signals_5Attribute();
    virtual ACU_SendSignals_9Attribute& getACU_SendSignals_9Attribute();
    virtual Dsp_ItemNameLength2_RqAttribute& getDsp_ItemNameLength2_RqAttribute();
    virtual Dsp_FolderContent_Rq_enumAttribute& getDsp_FolderContent_Rq_enumAttribute();
    virtual Dsp_CutItem2_Rq_enumAttribute& getDsp_CutItem2_Rq_enumAttribute();
    virtual Dsp_NbrOfItems2_RqAttribute& getDsp_NbrOfItems2_RqAttribute();
    virtual Dsp_FolderNumber2_RqAttribute& getDsp_FolderNumber2_RqAttribute();
    virtual Dsp_StartItemIndexRqAttribute& getDsp_StartItemIndexRqAttribute();
    virtual HMI_SetCompression_Rq_enumAttribute& getHMI_SetCompression_Rq_enumAttribute();


    /**
     * description: No Information Available
     */
    virtual void ACU_CurrPreset2_St_method(const uint8_t &_ACU_CurrPreset2_St, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void ACU_CurrentPSName_St_method(const uint64_t &_ACU_CurrentPSName_St, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void ACU_CurrTUDABBlock_St_method(const uint16_t &_ACU_CurrTUDABBlock_St, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void ACU_ActServiceLink_St_method(const ::v0::org::harman::ford::mediaplayback_types::ACU_ActServiceLink_St_enum &_aCU_ActServiceLink_St_enum, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void ACU_CurrTUDRService2_St_method(const ::v0::org::harman::ford::mediaplayback_types::ACU_CurrTUDRService2_St_enum &_aCU_CurrTUDRService2_St_enum, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void Dsp_GetCDTOCDData_Rq_method(const ::v0::org::harman::ford::mediaplayback_types::Dsp_GetCDTOCDData_Rq_enum &_dsp_GetCDTOCDData_Rq_enum, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void Dsp_AudioSourceSel_Rq_method(const ::v0::org::harman::ford::mediaplayback_types::Dsp_AudioSourceSel_Rq_enum &_dsp_AudioSourceSel_Rq_enum, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void Dsp_AudioSourceSel3_Rq_method(const ::v0::org::harman::ford::mediaplayback_types::Dsp_AudioSourceSel3_Rq_enum &_dsp_AudioSourceSel3_Rq_enum, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void NAV_LoadEjectMode_Rq_method(const ::v0::org::harman::ford::mediaplayback_types::NAV_LoadEjectMode_Rq_enum &_nAV_LoadEjectMode_Rq_enum, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void NAV_CDSetShuffle_Rq_method(const ::v0::org::harman::ford::mediaplayback_types::NAV_CDSetShuffle_Rq_enum &_nAV_CDSetShuffle_Rq_enum, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void NAV_CDSetRepeat_Rq_method(const ::v0::org::harman::ford::mediaplayback_types::NAV_CDSetRepeat_Rq_enum &_nAV_CDSetRepeat_Rq_enum, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void DISP_SetVolume_Rq_method(const uint8_t &_DISP_SetVolume_Rq, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void Dsp_AudioSourceSel2_Rq_method(const ::v0::org::harman::ford::mediaplayback_types::Dsp_AudioSourceSel2_Rq_enum &_dsp_AudioSourceSel2_Rq_enum, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: No Information Available
     */
    virtual void HMI_SkipTrack_Rq_method(const ::v0::org::harman::ford::mediaplayback_types::HMI_SkipTrack_Rq_enum &_hMI_SkipTrack_Rq_enum, CommonAPI::CallStatus &_internalCallStatus);


    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;

private:
   
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<APIM_ActiveTrackNum_StAttribute>> aPIM_ActiveTrackNum_St_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<APIM_NumberofTracks_StAttribute>> aPIM_NumberofTracks_St_;
    class DBusaCU_CurrTUBand_St_enum_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_CurrTUBand_St_enumAttribute>> {
    public:
    template <typename... _A>
    	DBusaCU_CurrTUBand_St_enum_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_CurrTUBand_St_enumAttribute>>(
    			_proxy, arguments...) {}
    void setValue(const ::v0::org::harman::ford::mediaplayback_types::ACU_CurrTUBand_St_enum& requestValue,
    	CommonAPI::CallStatus& callStatus,
    	::v0::org::harman::ford::mediaplayback_types::ACU_CurrTUBand_St_enum& responseValue,
    	const CommonAPI::CallInfo *_info = nullptr) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			callStatus = CommonAPI::CallStatus::INVALID_VALUE;
    			return;
    		}
    		// call parent function if ok
    		CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_CurrTUBand_St_enumAttribute>>::setValue(requestValue, callStatus, responseValue, _info);
    	}
    std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::org::harman::ford::mediaplayback_types::ACU_CurrTUBand_St_enum& requestValue,
    	std::function<void(const CommonAPI::CallStatus &, ::v0::org::harman::ford::mediaplayback_types::ACU_CurrTUBand_St_enum)> _callback,
    	const CommonAPI::CallInfo *_info) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			::v0::org::harman::ford::mediaplayback_types::ACU_CurrTUBand_St_enum _returnvalue;
    			_callback(CommonAPI::CallStatus::INVALID_VALUE, _returnvalue);
    			std::promise<CommonAPI::CallStatus> promise;
    			promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
    			return promise.get_future();            				
    		}
    		// call parent function if ok
    		return CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_CurrTUBand_St_enumAttribute>>::setValueAsync(requestValue, _callback, _info);
    	}
    };
    DBusaCU_CurrTUBand_St_enum_Attribute aCU_CurrTUBand_St_enum_;
    class DBusaCU_RadioSeekMode2_St_enum_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_RadioSeekMode2_St_enumAttribute>> {
    public:
    template <typename... _A>
    	DBusaCU_RadioSeekMode2_St_enum_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_RadioSeekMode2_St_enumAttribute>>(
    			_proxy, arguments...) {}
    void setValue(const ::v0::org::harman::ford::mediaplayback_types::ACU_RadioSeekMode2_St_enum& requestValue,
    	CommonAPI::CallStatus& callStatus,
    	::v0::org::harman::ford::mediaplayback_types::ACU_RadioSeekMode2_St_enum& responseValue,
    	const CommonAPI::CallInfo *_info = nullptr) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			callStatus = CommonAPI::CallStatus::INVALID_VALUE;
    			return;
    		}
    		// call parent function if ok
    		CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_RadioSeekMode2_St_enumAttribute>>::setValue(requestValue, callStatus, responseValue, _info);
    	}
    std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::org::harman::ford::mediaplayback_types::ACU_RadioSeekMode2_St_enum& requestValue,
    	std::function<void(const CommonAPI::CallStatus &, ::v0::org::harman::ford::mediaplayback_types::ACU_RadioSeekMode2_St_enum)> _callback,
    	const CommonAPI::CallInfo *_info) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			::v0::org::harman::ford::mediaplayback_types::ACU_RadioSeekMode2_St_enum _returnvalue;
    			_callback(CommonAPI::CallStatus::INVALID_VALUE, _returnvalue);
    			std::promise<CommonAPI::CallStatus> promise;
    			promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
    			return promise.get_future();            				
    		}
    		// call parent function if ok
    		return CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_RadioSeekMode2_St_enumAttribute>>::setValueAsync(requestValue, _callback, _info);
    	}
    };
    DBusaCU_RadioSeekMode2_St_enum_Attribute aCU_RadioSeekMode2_St_enum_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_CurrentFreq_StAttribute>> aCU_CurrentFreq_St_;
    class DBusaCU_CompLogic_St_enum_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_CompLogic_St_enumAttribute>> {
    public:
    template <typename... _A>
    	DBusaCU_CompLogic_St_enum_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_CompLogic_St_enumAttribute>>(
    			_proxy, arguments...) {}
    void setValue(const ::v0::org::harman::ford::mediaplayback_types::ACU_CompLogic_St_enum& requestValue,
    	CommonAPI::CallStatus& callStatus,
    	::v0::org::harman::ford::mediaplayback_types::ACU_CompLogic_St_enum& responseValue,
    	const CommonAPI::CallInfo *_info = nullptr) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			callStatus = CommonAPI::CallStatus::INVALID_VALUE;
    			return;
    		}
    		// call parent function if ok
    		CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_CompLogic_St_enumAttribute>>::setValue(requestValue, callStatus, responseValue, _info);
    	}
    std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::org::harman::ford::mediaplayback_types::ACU_CompLogic_St_enum& requestValue,
    	std::function<void(const CommonAPI::CallStatus &, ::v0::org::harman::ford::mediaplayback_types::ACU_CompLogic_St_enum)> _callback,
    	const CommonAPI::CallInfo *_info) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			::v0::org::harman::ford::mediaplayback_types::ACU_CompLogic_St_enum _returnvalue;
    			_callback(CommonAPI::CallStatus::INVALID_VALUE, _returnvalue);
    			std::promise<CommonAPI::CallStatus> promise;
    			promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
    			return promise.get_future();            				
    		}
    		// call parent function if ok
    		return CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<ACU_CompLogic_St_enumAttribute>>::setValueAsync(requestValue, _callback, _info);
    	}
    };
    DBusaCU_CompLogic_St_enum_Attribute aCU_CompLogic_St_enum_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<CD_Send_SignalsAttribute, ::v0::org::harman::ford::mediaplayback_types_::CD_Send_Signals_structDeployment_t>> cD_Send_Signals_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<CD_Request_SignalsAttribute, ::v0::org::harman::ford::mediaplayback_types_::CD_Request_Signals_structDeployment_t>> cD_Request_Signals_;
    class DBusdsp_CutItem_Rq_enum_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_CutItem_Rq_enumAttribute>> {
    public:
    template <typename... _A>
    	DBusdsp_CutItem_Rq_enum_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_CutItem_Rq_enumAttribute>>(
    			_proxy, arguments...) {}
    void setValue(const ::v0::org::harman::ford::mediaplayback_types::Dsp_CutItem_Rq_enum& requestValue,
    	CommonAPI::CallStatus& callStatus,
    	::v0::org::harman::ford::mediaplayback_types::Dsp_CutItem_Rq_enum& responseValue,
    	const CommonAPI::CallInfo *_info = nullptr) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			callStatus = CommonAPI::CallStatus::INVALID_VALUE;
    			return;
    		}
    		// call parent function if ok
    		CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_CutItem_Rq_enumAttribute>>::setValue(requestValue, callStatus, responseValue, _info);
    	}
    std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::org::harman::ford::mediaplayback_types::Dsp_CutItem_Rq_enum& requestValue,
    	std::function<void(const CommonAPI::CallStatus &, ::v0::org::harman::ford::mediaplayback_types::Dsp_CutItem_Rq_enum)> _callback,
    	const CommonAPI::CallInfo *_info) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			::v0::org::harman::ford::mediaplayback_types::Dsp_CutItem_Rq_enum _returnvalue;
    			_callback(CommonAPI::CallStatus::INVALID_VALUE, _returnvalue);
    			std::promise<CommonAPI::CallStatus> promise;
    			promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
    			return promise.get_future();            				
    		}
    		// call parent function if ok
    		return CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_CutItem_Rq_enumAttribute>>::setValueAsync(requestValue, _callback, _info);
    	}
    };
    DBusdsp_CutItem_Rq_enum_Attribute dsp_CutItem_Rq_enum_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_ItemNameLength_RqAttribute>> dsp_ItemNameLength_Rq_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_FolderNumber_RqAttribute>> dsp_FolderNumber_Rq_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_SourceSetTrack_RqAttribute>> dsp_SourceSetTrack_Rq_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_FolderNumber3_RqAttribute>> dsp_FolderNumber3_Rq_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_ItemIndex_RqAttribute>> dsp_ItemIndex_Rq_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_PlayFrstTrInFldr_RqAttribute>> dsp_PlayFrstTrInFldr_Rq_;
    class DBusnAV_LoadEjectDisc_Rq_enum_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_LoadEjectDisc_Rq_enumAttribute>> {
    public:
    template <typename... _A>
    	DBusnAV_LoadEjectDisc_Rq_enum_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_LoadEjectDisc_Rq_enumAttribute>>(
    			_proxy, arguments...) {}
    void setValue(const ::v0::org::harman::ford::mediaplayback_types::NAV_LoadEjectDisc_Rq_enum& requestValue,
    	CommonAPI::CallStatus& callStatus,
    	::v0::org::harman::ford::mediaplayback_types::NAV_LoadEjectDisc_Rq_enum& responseValue,
    	const CommonAPI::CallInfo *_info = nullptr) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			callStatus = CommonAPI::CallStatus::INVALID_VALUE;
    			return;
    		}
    		// call parent function if ok
    		CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_LoadEjectDisc_Rq_enumAttribute>>::setValue(requestValue, callStatus, responseValue, _info);
    	}
    std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::org::harman::ford::mediaplayback_types::NAV_LoadEjectDisc_Rq_enum& requestValue,
    	std::function<void(const CommonAPI::CallStatus &, ::v0::org::harman::ford::mediaplayback_types::NAV_LoadEjectDisc_Rq_enum)> _callback,
    	const CommonAPI::CallInfo *_info) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			::v0::org::harman::ford::mediaplayback_types::NAV_LoadEjectDisc_Rq_enum _returnvalue;
    			_callback(CommonAPI::CallStatus::INVALID_VALUE, _returnvalue);
    			std::promise<CommonAPI::CallStatus> promise;
    			promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
    			return promise.get_future();            				
    		}
    		// call parent function if ok
    		return CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_LoadEjectDisc_Rq_enumAttribute>>::setValueAsync(requestValue, _callback, _info);
    	}
    };
    DBusnAV_LoadEjectDisc_Rq_enum_Attribute nAV_LoadEjectDisc_Rq_enum_;
    class DBusnAV_SetOperationMode_Rq_enum_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_SetOperationMode_Rq_enumAttribute>> {
    public:
    template <typename... _A>
    	DBusnAV_SetOperationMode_Rq_enum_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_SetOperationMode_Rq_enumAttribute>>(
    			_proxy, arguments...) {}
    void setValue(const ::v0::org::harman::ford::mediaplayback_types::NAV_SetOperationMode_Rq_enum& requestValue,
    	CommonAPI::CallStatus& callStatus,
    	::v0::org::harman::ford::mediaplayback_types::NAV_SetOperationMode_Rq_enum& responseValue,
    	const CommonAPI::CallInfo *_info = nullptr) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			callStatus = CommonAPI::CallStatus::INVALID_VALUE;
    			return;
    		}
    		// call parent function if ok
    		CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_SetOperationMode_Rq_enumAttribute>>::setValue(requestValue, callStatus, responseValue, _info);
    	}
    std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::org::harman::ford::mediaplayback_types::NAV_SetOperationMode_Rq_enum& requestValue,
    	std::function<void(const CommonAPI::CallStatus &, ::v0::org::harman::ford::mediaplayback_types::NAV_SetOperationMode_Rq_enum)> _callback,
    	const CommonAPI::CallInfo *_info) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			::v0::org::harman::ford::mediaplayback_types::NAV_SetOperationMode_Rq_enum _returnvalue;
    			_callback(CommonAPI::CallStatus::INVALID_VALUE, _returnvalue);
    			std::promise<CommonAPI::CallStatus> promise;
    			promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
    			return promise.get_future();            				
    		}
    		// call parent function if ok
    		return CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_SetOperationMode_Rq_enumAttribute>>::setValueAsync(requestValue, _callback, _info);
    	}
    };
    DBusnAV_SetOperationMode_Rq_enum_Attribute nAV_SetOperationMode_Rq_enum_;
    class DBusnAV_CDSetIntroScan_Rq_enum_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_CDSetIntroScan_Rq_enumAttribute>> {
    public:
    template <typename... _A>
    	DBusnAV_CDSetIntroScan_Rq_enum_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_CDSetIntroScan_Rq_enumAttribute>>(
    			_proxy, arguments...) {}
    void setValue(const ::v0::org::harman::ford::mediaplayback_types::NAV_CDSetIntroScan_Rq_enum& requestValue,
    	CommonAPI::CallStatus& callStatus,
    	::v0::org::harman::ford::mediaplayback_types::NAV_CDSetIntroScan_Rq_enum& responseValue,
    	const CommonAPI::CallInfo *_info = nullptr) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			callStatus = CommonAPI::CallStatus::INVALID_VALUE;
    			return;
    		}
    		// call parent function if ok
    		CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_CDSetIntroScan_Rq_enumAttribute>>::setValue(requestValue, callStatus, responseValue, _info);
    	}
    std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::org::harman::ford::mediaplayback_types::NAV_CDSetIntroScan_Rq_enum& requestValue,
    	std::function<void(const CommonAPI::CallStatus &, ::v0::org::harman::ford::mediaplayback_types::NAV_CDSetIntroScan_Rq_enum)> _callback,
    	const CommonAPI::CallInfo *_info) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			::v0::org::harman::ford::mediaplayback_types::NAV_CDSetIntroScan_Rq_enum _returnvalue;
    			_callback(CommonAPI::CallStatus::INVALID_VALUE, _returnvalue);
    			std::promise<CommonAPI::CallStatus> promise;
    			promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
    			return promise.get_future();            				
    		}
    		// call parent function if ok
    		return CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<NAV_CDSetIntroScan_Rq_enumAttribute>>::setValueAsync(requestValue, _callback, _info);
    	}
    };
    DBusnAV_CDSetIntroScan_Rq_enum_Attribute nAV_CDSetIntroScan_Rq_enum_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<ACU_Send_Signals_6Attribute, ::v0::org::harman::ford::mediaplayback_types_::ACU_Send_Signals_6_structDeployment_t>> aCU_Send_Signals_6_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<ACU_Send_Signals_5Attribute, ::v0::org::harman::ford::mediaplayback_types_::ACU_Send_Signals_5_structDeployment_t>> aCU_Send_Signals_5_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<ACU_SendSignals_9Attribute, ::v0::org::harman::ford::mediaplayback_types_::ACU_SendSignals_9_structDeployment_t>> aCU_SendSignals_9_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_ItemNameLength2_RqAttribute>> dsp_ItemNameLength2_Rq_;
    class DBusdsp_FolderContent_Rq_enum_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_FolderContent_Rq_enumAttribute>> {
    public:
    template <typename... _A>
    	DBusdsp_FolderContent_Rq_enum_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_FolderContent_Rq_enumAttribute>>(
    			_proxy, arguments...) {}
    void setValue(const ::v0::org::harman::ford::mediaplayback_types::Dsp_FolderContent_Rq_enum& requestValue,
    	CommonAPI::CallStatus& callStatus,
    	::v0::org::harman::ford::mediaplayback_types::Dsp_FolderContent_Rq_enum& responseValue,
    	const CommonAPI::CallInfo *_info = nullptr) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			callStatus = CommonAPI::CallStatus::INVALID_VALUE;
    			return;
    		}
    		// call parent function if ok
    		CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_FolderContent_Rq_enumAttribute>>::setValue(requestValue, callStatus, responseValue, _info);
    	}
    std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::org::harman::ford::mediaplayback_types::Dsp_FolderContent_Rq_enum& requestValue,
    	std::function<void(const CommonAPI::CallStatus &, ::v0::org::harman::ford::mediaplayback_types::Dsp_FolderContent_Rq_enum)> _callback,
    	const CommonAPI::CallInfo *_info) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			::v0::org::harman::ford::mediaplayback_types::Dsp_FolderContent_Rq_enum _returnvalue;
    			_callback(CommonAPI::CallStatus::INVALID_VALUE, _returnvalue);
    			std::promise<CommonAPI::CallStatus> promise;
    			promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
    			return promise.get_future();            				
    		}
    		// call parent function if ok
    		return CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_FolderContent_Rq_enumAttribute>>::setValueAsync(requestValue, _callback, _info);
    	}
    };
    DBusdsp_FolderContent_Rq_enum_Attribute dsp_FolderContent_Rq_enum_;
    class DBusdsp_CutItem2_Rq_enum_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_CutItem2_Rq_enumAttribute>> {
    public:
    template <typename... _A>
    	DBusdsp_CutItem2_Rq_enum_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_CutItem2_Rq_enumAttribute>>(
    			_proxy, arguments...) {}
    void setValue(const ::v0::org::harman::ford::mediaplayback_types::Dsp_CutItem2_Rq_enum& requestValue,
    	CommonAPI::CallStatus& callStatus,
    	::v0::org::harman::ford::mediaplayback_types::Dsp_CutItem2_Rq_enum& responseValue,
    	const CommonAPI::CallInfo *_info = nullptr) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			callStatus = CommonAPI::CallStatus::INVALID_VALUE;
    			return;
    		}
    		// call parent function if ok
    		CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_CutItem2_Rq_enumAttribute>>::setValue(requestValue, callStatus, responseValue, _info);
    	}
    std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::org::harman::ford::mediaplayback_types::Dsp_CutItem2_Rq_enum& requestValue,
    	std::function<void(const CommonAPI::CallStatus &, ::v0::org::harman::ford::mediaplayback_types::Dsp_CutItem2_Rq_enum)> _callback,
    	const CommonAPI::CallInfo *_info) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			::v0::org::harman::ford::mediaplayback_types::Dsp_CutItem2_Rq_enum _returnvalue;
    			_callback(CommonAPI::CallStatus::INVALID_VALUE, _returnvalue);
    			std::promise<CommonAPI::CallStatus> promise;
    			promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
    			return promise.get_future();            				
    		}
    		// call parent function if ok
    		return CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_CutItem2_Rq_enumAttribute>>::setValueAsync(requestValue, _callback, _info);
    	}
    };
    DBusdsp_CutItem2_Rq_enum_Attribute dsp_CutItem2_Rq_enum_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_NbrOfItems2_RqAttribute>> dsp_NbrOfItems2_Rq_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_FolderNumber2_RqAttribute>> dsp_FolderNumber2_Rq_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<Dsp_StartItemIndexRqAttribute>> dsp_StartItemIndexRq_;
    class DBushMI_SetCompression_Rq_enum_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<HMI_SetCompression_Rq_enumAttribute>> {
    public:
    template <typename... _A>
    	DBushMI_SetCompression_Rq_enum_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<HMI_SetCompression_Rq_enumAttribute>>(
    			_proxy, arguments...) {}
    void setValue(const ::v0::org::harman::ford::mediaplayback_types::HMI_SetCompression_Rq_enum& requestValue,
    	CommonAPI::CallStatus& callStatus,
    	::v0::org::harman::ford::mediaplayback_types::HMI_SetCompression_Rq_enum& responseValue,
    	const CommonAPI::CallInfo *_info = nullptr) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			callStatus = CommonAPI::CallStatus::INVALID_VALUE;
    			return;
    		}
    		// call parent function if ok
    		CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<HMI_SetCompression_Rq_enumAttribute>>::setValue(requestValue, callStatus, responseValue, _info);
    	}
    std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::org::harman::ford::mediaplayback_types::HMI_SetCompression_Rq_enum& requestValue,
    	std::function<void(const CommonAPI::CallStatus &, ::v0::org::harman::ford::mediaplayback_types::HMI_SetCompression_Rq_enum)> _callback,
    	const CommonAPI::CallInfo *_info) {
    		// validate input parameters
    		if (!requestValue.validate()) {
    			::v0::org::harman::ford::mediaplayback_types::HMI_SetCompression_Rq_enum _returnvalue;
    			_callback(CommonAPI::CallStatus::INVALID_VALUE, _returnvalue);
    			std::promise<CommonAPI::CallStatus> promise;
    			promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
    			return promise.get_future();            				
    		}
    		// call parent function if ok
    		return CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<HMI_SetCompression_Rq_enumAttribute>>::setValueAsync(requestValue, _callback, _info);
    	}
    };
    DBushMI_SetCompression_Rq_enum_Attribute hMI_SetCompression_Rq_enum_;


};

} // namespace ford
} // namespace harman
} // namespace org
} // namespace v0

#endif // V0_ORG_HARMAN_FORD_mediaplayback_DBUS_PROXY_HPP_

