/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1/org/genivi/am/routinginterface/RoutingControl.hpp>
#include <v1/org/genivi/am/routinginterface/RoutingControlDBusStubAdapter.hpp>

namespace v1 {
namespace org {
namespace genivi {
namespace am {
namespace routinginterface {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createRoutingControlDBusStubAdapter(
                   const CommonAPI::DBus::DBusAddress &_address,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
                   const std::shared_ptr<CommonAPI::StubBase> &_stub) {
    return std::make_shared<RoutingControlDBusStubAdapter>(_address, _connection, _stub);
}

INITIALIZER(registerRoutingControlDBusStubAdapter) {
    CommonAPI::DBus::Factory::get()->registerStubAdapterCreateMethod(
    	RoutingControl::getInterface(), &createRoutingControlDBusStubAdapter);
}

RoutingControlDBusStubAdapterInternal::~RoutingControlDBusStubAdapterInternal() {
    deactivateManagedInstances();
    RoutingControlDBusStubAdapterHelper::deinit();
}

void RoutingControlDBusStubAdapterInternal::deactivateManagedInstances() {

}

const char* RoutingControlDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        /**
         * description: Acknowledges for asyncSetSourceState.
         */
        "<signal name=\"ackSetSourceState\">\n"
            "<arg name=\"handle\" type=\"(iq)\" />\n"
            "<arg name=\"amError\" type=\"i\" />\n"
        "</signal>\n"
        /**
         * description: This function is used to set the source state of a particular source.
         *   (at)return E_OK on success, E_UNKNOWN on error
         */
        "<method name=\"asyncSetSourceState\">\n"
            "<arg name=\"_handle\" type=\"(iq)\" direction=\"in\" />\n"
            "<arg name=\"_sourceID\" type=\"q\" direction=\"in\" />\n"
            "<arg name=\"_state\" type=\"i\" direction=\"in\" />\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}

CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v1::org::genivi::am::routinginterface::RoutingControlStub,
        CommonAPI::Version
        > RoutingControlDBusStubAdapterInternal::getRoutingControlInterfaceVersionStubDispatcher(&RoutingControlStub::getInterfaceVersion, "uu");




/**
 * description: This function is used to set the source state of a particular source.
 *   (at)return E_OK on success, E_UNKNOWN on error
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v1::org::genivi::am::routinginterface::RoutingControlStub,
    std::tuple<::v3::org::genivi::am_t::am_Handle_s, ::v3::org::genivi::am_t::am_sourceID_t, ::v3::org::genivi::am_t::am_SourceState_e>,
    std::tuple<>,
    std::tuple<::v3::org::genivi::am_t_::am_Handle_sDeployment_t, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<>
    
    > RoutingControlDBusStubAdapterInternal::asyncSetSourceStateStubDispatcher(
    &RoutingControlStub::asyncSetSourceState, "",
					std::make_tuple(static_cast<::v3::org::genivi::am_t_::am_Handle_sDeployment_t*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple());



/**
 * description: Acknowledges for asyncSetSourceState.
 */
CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::org::genivi::am::routinginterface::RoutingControlStub,
    RoutingControlStubAdapter,
    std::tuple<>,
    std::tuple<bool>
    > RoutingControlDBusStubAdapterInternal::subscribeAckSetSourceStateSelectiveStubDispatcher(&RoutingControlStubAdapter::subscribeForackSetSourceStateSelective, "b");

CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v1::org::genivi::am::routinginterface::RoutingControlStub,
    RoutingControlStubAdapter,
    std::tuple<>,
    std::tuple<>
    > RoutingControlDBusStubAdapterInternal::unsubscribeAckSetSourceStateSelectiveStubDispatcher(&RoutingControlStubAdapter::unsubscribeFromackSetSourceStateSelective, "");

void RoutingControlDBusStubAdapterInternal::fireAckSetSourceStateSelective(const std::shared_ptr<CommonAPI::ClientId> _client, const ::v3::org::genivi::am_t::am_Handle_s &_handle, const ::v3::org::genivi::am_t::am_Error_e &_amError) {
    std::shared_ptr<CommonAPI::DBus::DBusClientId> dbusClient = std::dynamic_pointer_cast<CommonAPI::DBus::DBusClientId, CommonAPI::ClientId>(_client);

    if(dbusClient)
    {
        CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Handle_s, ::v3::org::genivi::am_t_::am_Handle_sDeployment_t>,
        ::v3::org::genivi::am_t::am_Error_e
        >>::sendSignal(
                dbusClient->getDBusId(),
                *this,
                "ackSetSourceState",
                "(iq)i",
        CommonAPI::Deployable<::v3::org::genivi::am_t::am_Handle_s, ::v3::org::genivi::am_t_::am_Handle_sDeployment_t>(_handle, static_cast<::v3::org::genivi::am_t_::am_Handle_sDeployment_t*>(nullptr)),
        _amError
        );
    }
}

void RoutingControlDBusStubAdapterInternal::sendAckSetSourceStateSelective(const ::v3::org::genivi::am_t::am_Handle_s &_handle, const ::v3::org::genivi::am_t::am_Error_e &_amError, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    std::shared_ptr<CommonAPI::ClientIdList> actualReceiverList = _receivers;

    if (!_receivers)
        actualReceiverList = subscribersForAckSetSourceStateSelective_;

    for (auto clientIdIterator = actualReceiverList->cbegin(); clientIdIterator != actualReceiverList->cend(); clientIdIterator++) {
        if (!_receivers || subscribersForAckSetSourceStateSelective_->find(*clientIdIterator) != subscribersForAckSetSourceStateSelective_->end()) {
            fireAckSetSourceStateSelective(*clientIdIterator, _handle, _amError);
        }
    }
}

void RoutingControlDBusStubAdapterInternal::subscribeForackSetSourceStateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId, bool& success) {
    bool ok = RoutingControlDBusStubAdapterHelper::stub_->onAckSetSourceStateSelectiveSubscriptionRequested(clientId);
    if (ok) {
        subscribersForAckSetSourceStateSelective_->insert(clientId);
        RoutingControlDBusStubAdapterHelper::stub_->onAckSetSourceStateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::SUBSCRIBED);
        success = true;
    } else {
        success = false;
    }
}

void RoutingControlDBusStubAdapterInternal::unsubscribeFromackSetSourceStateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId) {
    subscribersForAckSetSourceStateSelective_->erase(clientId);
    RoutingControlDBusStubAdapterHelper::stub_->onAckSetSourceStateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::UNSUBSCRIBED);
}

std::shared_ptr<CommonAPI::ClientIdList> const RoutingControlDBusStubAdapterInternal::getSubscribersForAckSetSourceStateSelective() {
    return subscribersForAckSetSourceStateSelective_;
}


const RoutingControlDBusStubAdapterHelper::StubDispatcherTable& RoutingControlDBusStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}

const CommonAPI::DBus::StubAttributeTable& RoutingControlDBusStubAdapterInternal::getStubAttributeTable() {
    return stubAttributeTable_;
}

RoutingControlDBusStubAdapterInternal::RoutingControlDBusStubAdapterInternal(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
        const std::shared_ptr<CommonAPI::StubBase> &_stub)
	: CommonAPI::DBus::DBusStubAdapter(_address, _connection,false),
      RoutingControlDBusStubAdapterHelper(_address, _connection, std::dynamic_pointer_cast<RoutingControlStub>(_stub), false),
      stubDispatcherTable_({
            /**
             * description: This function is used to set the source state of a particular source.
             *   (at)return E_OK on success, E_UNKNOWN on error
             */
            { { "asyncSetSourceState", "(iq)qi" }, &org::genivi::am::routinginterface::RoutingControlDBusStubAdapterInternal::asyncSetSourceStateStubDispatcher }
            ,
            { { "subscribeForackSetSourceStateSelective", "" }, &org::genivi::am::routinginterface::RoutingControlDBusStubAdapterInternal::subscribeAckSetSourceStateSelectiveStubDispatcher }
            ,
            { { "unsubscribeFromackSetSourceStateSelective", "" }, &org::genivi::am::routinginterface::RoutingControlDBusStubAdapterInternal::unsubscribeAckSetSourceStateSelectiveStubDispatcher }
            }),
        stubAttributeTable_() {
    subscribersForAckSetSourceStateSelective_ = std::make_shared<CommonAPI::ClientIdList>();

    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &org::genivi::am::routinginterface::RoutingControlDBusStubAdapterInternal::getRoutingControlInterfaceVersionStubDispatcher });
}

bool RoutingControlDBusStubAdapterInternal::hasFreedesktopProperties() {
    return false;
}

} // namespace routinginterface
} // namespace am
} // namespace genivi
} // namespace org
} // namespace v1
