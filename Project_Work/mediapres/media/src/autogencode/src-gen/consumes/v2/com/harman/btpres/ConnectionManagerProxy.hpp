/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V2_COM_HARMAN_BTPRES_Connection_Manager_PROXY_HPP_
#define V2_COM_HARMAN_BTPRES_Connection_Manager_PROXY_HPP_

#include <v2/com/harman/btpres/ConnectionManagerProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v2 {
namespace com {
namespace harman {
namespace btpres {

template <typename ... _AttributeExtensions>
class ConnectionManagerProxy
    : virtual public ConnectionManager, 
      virtual public ConnectionManagerProxyBase,
      virtual public _AttributeExtensions... {
public:
    ConnectionManagerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~ConnectionManagerProxy();

    typedef ConnectionManager InterfaceType;


    /**
     * description: It will reflect the current bluetooth status to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute btState.
     */
    virtual BtStateAttribute& getBtStateAttribute() {
        return delegate_->getBtStateAttribute();
    }
    /**
     * description: It will reflect local device address to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute localDevAddr.
     */
    virtual LocalDevAddrAttribute& getLocalDevAddrAttribute() {
        return delegate_->getLocalDevAddrAttribute();
    }
    /**
     * description: It will reflect local device name to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute localDevName.
     */
    virtual LocalDevNameAttribute& getLocalDevNameAttribute() {
        return delegate_->getLocalDevNameAttribute();
    }
    /**
     * description: It will broadcast stored pass key to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute passKeyPin.
     */
    virtual PassKeyPinAttribute& getPassKeyPinAttribute() {
        return delegate_->getPassKeyPinAttribute();
    }
    /**
     * description: It will broadcast device search status to registered client
     */
    /**
     * Returns the wrapper class that provides access to the attribute deviceSearchStatus.
     */
    virtual DeviceSearchStatusAttribute& getDeviceSearchStatusAttribute() {
        return delegate_->getDeviceSearchStatusAttribute();
    }
    /**
     * description: It will broadcast discoverability status to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute discoverableStatus.
     */
    virtual DiscoverableStatusAttribute& getDiscoverableStatusAttribute() {
        return delegate_->getDiscoverableStatusAttribute();
    }
    /**
     * description: It will broadcast discoverability timeout to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute discoveryTimeout.
     */
    virtual DiscoveryTimeoutAttribute& getDiscoveryTimeoutAttribute() {
        return delegate_->getDiscoveryTimeoutAttribute();
    }
    /**
     * description: It will broadcast device search results to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute devSearchResults.
     */
    virtual DevSearchResultsAttribute& getDevSearchResultsAttribute() {
        return delegate_->getDevSearchResultsAttribute();
    }
    /**
     * description: It will broadcast bonded device list to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute devList.
     */
    virtual DevListAttribute& getDevListAttribute() {
        return delegate_->getDevListAttribute();
    }
    /**
     * description: It will broadcast connected device list to registered clients.     This is a
     *   subset of bonded device list
     */
    /**
     * Returns the wrapper class that provides access to the attribute connectedDevList.
     */
    virtual ConnectedDevListAttribute& getConnectedDevListAttribute() {
        return delegate_->getConnectedDevListAttribute();
    }
    /**
     * description: It will broadcast network status to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute netIfStatus.
     */
    virtual NetIfStatusAttribute& getNetIfStatusAttribute() {
        return delegate_->getNetIfStatusAttribute();
    }
    /**
     * description: It will broadcast unstable device info to registered clients
     */
    /**
     * Returns the wrapper class that provides access to the attribute unstableDevs.
     */
    virtual UnstableDevsAttribute& getUnstableDevsAttribute() {
        return delegate_->getUnstableDevsAttribute();
    }
    /**
     * description: It will broadcast primary device address
     */
    /**
     * Returns the wrapper class that provides access to the attribute primaryDevice.
     */
    virtual PrimaryDeviceAttribute& getPrimaryDeviceAttribute() {
        return delegate_->getPrimaryDeviceAttribute();
    }
    /**
     * description: It will broadcast dont disturb status of the device           This will be
     *   deprecated once all clients move to extendedDnd attribute
     */
    /**
     * Returns the wrapper class that provides access to the attribute DnDStatus.
     */
    virtual DnDStatusAttribute& getDnDStatusAttribute() {
        return delegate_->getDnDStatusAttribute();
    }
    /**
     * description: This attribute will be used to enable emergencyAssistance Mode in BtPres.    
     *   If BT is OFF and emargencyAssistance set to true , BT will be automatically
     *   turned ON.     Autoconnect will not be triggered     If this is set to true
     *   all ongoing call will be cancelled. Only newly initiated call from the HU will
     *   be allowed
     */
    /**
     * Returns the wrapper class that provides access to the attribute emargencyAssistance.
     */
    virtual EmargencyAssistanceAttribute& getEmargencyAssistanceAttribute() {
        return delegate_->getEmargencyAssistanceAttribute();
    }
    /**
     * description: This attribute will be used to get different type of DND         It can be used
     *   for HU specific DND/ Phone Specific DND / Disabling audio handling of BTPRES
     */
    /**
     * Returns the wrapper class that provides access to the attribute dndInfo.
     */
    virtual DndInfoAttribute& getDndInfoAttribute() {
        return delegate_->getDndInfoAttribute();
    }

    /**
     * description: It will broadcast standard bonding Request to registered clients
     * param: outAddress (string)     : Bt address of phone
     * param: deviceName (string)     : Device name
     * param: type (eBondingType)     : Bonding type
     * param: pin (string) : pass key pin
     */
    /**
     * Returns the wrapper class that provides access to the broadcast bondingRequest.
     */
    virtual BondingRequestEvent& getBondingRequestEvent() {
        return delegate_->getBondingRequestEvent();
    }
    /**
     * description: It will broadcast service connection request to registered clients
     * param: outAddress (string)         : Bt address of phone
     * param: name (string)               : Device name
     * param: service (eSupportedProfile) : supported profile list
     */
    /**
     * Returns the wrapper class that provides access to the broadcast serviceConnectionRequest.
     */
    virtual ServiceConnectionRequestEvent& getServiceConnectionRequestEvent() {
        return delegate_->getServiceConnectionRequestEvent();
    }
    /**
     * description: It will broadcast service connection status signal to registered clients
     * param: outAddress (string)         : Bt address of phone
     * param: name (string)               : Device name
     * param: service (eSupportedProfile) : supported profile list
     * param: status (eConnectionStatus)  : Connected or disconnected status
     * param: reason (eServiceConnectDisconnectReason) : reason for connection or
     *   disconnection
     */
    /**
     * Returns the wrapper class that provides access to the broadcast serviceConnectionStatus.
     */
    virtual ServiceConnectionStatusEvent& getServiceConnectionStatusEvent() {
        return delegate_->getServiceConnectionStatusEvent();
    }
    /**
     * description: This signal is sent when device has been deleted from Head Unit to registered
     *   clients
     * param: outAddress (string)     : Bt address of phone
     * param: deviceName (string )    : device name
     * param: deviceDeleted (eDeviceDeletedReason): Reason for device deletion i.e. deletion
     *   due to missing key OR deletion due to USER action.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast deviceDeleted.
     */
    virtual DeviceDeletedEvent& getDeviceDeletedEvent() {
        return delegate_->getDeviceDeletedEvent();
    }
    /**
     * description: This signal is sent when device has been deleted from Head Unit to registered
     *   clients
     * param: device : detail of the device for which reconnection failed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast reconnectionFailed.
     */
    virtual ReconnectionFailedEvent& getReconnectionFailedEvent() {
        return delegate_->getReconnectionFailedEvent();
    }
    /**
     * description: This signal is used to update the pairing status to registered clients
     * param: outAddress (string)         : Bt address of phone
     * param: deviceName (string)         : device name
     * param: pairStatus (ePairingStatus) : Pairing status i.e. successful Or failure
     */
    /**
     * Returns the wrapper class that provides access to the broadcast bondingStatus.
     */
    virtual BondingStatusEvent& getBondingStatusEvent() {
        return delegate_->getBondingStatusEvent();
    }
    /**
     * description: This signal is used to update the play state of Alert or Ringtone
     * param: uToneID (union)         : Alert OR Ringtone ID which
     * param: playState (boolean)     : True for playing state and false for idle state
     */
    /**
     * Returns the wrapper class that provides access to the broadcast tonePlayState.
     */
    virtual TonePlayStateEvent& getTonePlayStateEvent() {
        return delegate_->getTonePlayStateEvent();
    }

    /**
     * description: Used to start device search on head unit
     * param: maxDevice (UInt32)       : max limit for found devices
     * param: timeout (UInt32)         : time limit for device search operation         
     *   returns: errorCode (eErrorType) : error code
     * Calls startDeviceSearch with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startDeviceSearch(const uint32_t &_maxDevice, const uint32_t &_timeout, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startDeviceSearch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startDeviceSearchAsync(const uint32_t &_maxDevice, const uint32_t &_timeout, StartDeviceSearchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to stop device search on head unit
     * param: none          returns: error code (eErrorType) : error code
     * Calls stopDeviceSearch with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stopDeviceSearch(CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stopDeviceSearch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stopDeviceSearchAsync(StopDeviceSearchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to send secure Bonding reply
     * param: inAddress (string)       : phone BT address
     * param: accept (boolean)         : accepting authentication request
     * param: trusted (boolean)        : making device trusted means service won't send
     *   connection request for each connect attempt
     * param: type (eBondingType)      : Bonding type, standard or secure bonding         
     *   returns: errorCode (eErrorType) : error code
     * Calls bondingReply with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void bondingReply(const std::string &_inAddress, const bool &_accept, const bool &_trusted, const ::v4::com::harman::btpres::BTPresTypes::eBondingType &_type, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls bondingReply with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> bondingReplyAsync(const std::string &_inAddress, const bool &_accept, const bool &_trusted, const ::v4::com::harman::btpres::BTPresTypes::eBondingType &_type, BondingReplyAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to delete device from paired device list
     * param: inAddress (string)      : phone BT address          returns: errorCode
     *   (eErrorType): error code
     * Calls deleteDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteDevice(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deleteDeviceAsync(const std::string &_inAddress, DeleteDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to delete all device in paired device list
     * param: none          returns: errorCode (eErrorType) : error code
     * Calls deleteAllDevices with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteAllDevices(CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteAllDevices with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deleteAllDevicesAsync(DeleteAllDevicesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to initate profile connection with device         version 1.0
     * param: inAddress (string)       : phone BT address
     * param: service (eSupportedProfile) : profile name
     * param: instanceName (string)    : containing the phone instance
     * param: replaceAddr (string)     : containing the replacement address for which the
     *   connection will be replaced          returns: errorCode (eErrorType) : error
     *   code
     * Calls startServiceConnection with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startServiceConnection(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const std::string &_instanceName, const std::string &_replaceAddr, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startServiceConnection with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startServiceConnectionAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const std::string &_instanceName, const std::string &_replaceAddr, StartServiceConnectionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to initate multiple profile connection with device         version 2.0
     * param: inAddress (string)                       : phone BT address
     * param: ProfileList (arSupportedProfile)         : profile name list
     * param: replaceAddr (string)                     : containing the replacement address
     *   for which the connection will be replaced          returns: errorCode
     *   (eErrorType) : error code
     * Calls startServiceConnection with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startServiceConnection(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::arSupportedProfile &_ProfileList, const std::string &_replaceAddr, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startServiceConnection with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startServiceConnectionAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::arSupportedProfile &_ProfileList, const std::string &_replaceAddr, StartServiceConnectionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to allows the existance of the service connection to this device and
     *   service.
     * param: inAddress (string)           : phone BT address
     * param: service (eSupportedProfile)  : profile name
     * param: allow (Boolean)              : containing the value true for allow, or false
     *   for reject          returns: errorCode (eErrorType)      : error code
     * Calls allowServiceConnection with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void allowServiceConnection(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const bool &_allow, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls allowServiceConnection with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> allowServiceConnectionAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const bool &_allow, AllowServiceConnectionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to initate the disconnection with connected service i.e. HFP and A2DP
     * param: inAddress (string)                  : phone BT address
     * param: service (eSupportedProfile)         : profile name          returns: errorCode
     *   error code (eErrorType)  : error code
     * Calls startServiceDisconnection with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startServiceDisconnection(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startServiceDisconnection with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startServiceDisconnectionAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, StartServiceDisconnectionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to initate the disconnection with connected service i.e. HFP and A2DP
     * param: inAddress (string)                  : phone BT address
     * param: ProfileList (arSupportedProfile)         : profile name list          returns:
     *   errorCode error code (eErrorType)  : error code
     * Calls startServiceDisconnection with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startServiceDisconnection(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::arSupportedProfile &_ProfileList, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startServiceDisconnection with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startServiceDisconnectionAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::arSupportedProfile &_ProfileList, StartServiceDisconnectionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method should be called by clients in order to reply to the incoming
     *   service                         connection request from a remote device as
     *   indicated by the signal 'serviceConnectionRequest'.                        
     *   The reply can be to accept or reject incoming service connection request.
     * param: inAddress (string)              : phone BT address
     * param: service (eSupportedProfile)     : profile name
     * param: accept (boolean)                : containing the value true for allow, or false
     *   for reject
     * param: instanceName (string)           : containing the instance name of the device   
     *         returns: errorCode (eErrorType)         : error code
     * Calls serviceConnectionReply with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void serviceConnectionReply(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const bool &_accept, const std::string &_instanceName, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls serviceConnectionReply with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> serviceConnectionReplyAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const bool &_accept, const std::string &_instanceName, ServiceConnectionReplyAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to initiate the reconnection to previously connected device
     * param: None          returns: errorCode error code (eErrorType) : error code
     * Calls startReconnect with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startReconnect(CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startReconnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startReconnectAsync(StartReconnectAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method should be called to get oldest connected device
     * param: None          returns: oldestDevInfo (oldestDevInfo)     : Oldest device name
     *   and address         returns: errorCode error code (eErrorType) : error code
     * Calls getOldestConnectedDev with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getOldestConnectedDev(CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v4::com::harman::btpres::BTPresTypes::deviceInfo &_oldestDevInfo, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getOldestConnectedDev with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getOldestConnectedDevAsync(GetOldestConnectedDevAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method used to change name of bonded device.
     * param: inAddress  (string)     : contains the BD address.
     * param: name (string)           : Device name          returns: errorCode(eErrorType) 
     *   : error code
     * Calls renameBondedDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void renameBondedDevice(const std::string &_inAddress, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls renameBondedDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> renameBondedDeviceAsync(const std::string &_inAddress, const std::string &_name, RenameBondedDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method used to change local name of head unit.
     * param: name (string)           : Device name          returns: errorCode(eErrorType) 
     *   : error code
     * Calls renameLocalDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void renameLocalDevice(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls renameLocalDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> renameLocalDeviceAsync(const std::string &_name, RenameLocalDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to set bluetooth on or off
     * param: status (boolean)       : set true or false          returns: error
     *   code(eErrorType) : error code
     * Calls setBluetoothStatus with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setBluetoothStatus(const bool &_status, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setBluetoothStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setBluetoothStatusAsync(const bool &_status, SetBluetoothStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Used to enable or disable discoverable mode
     * param: enabled (boolean)       : set true or false          returns: errorCode
     *   (eErrorType) : error code
     * Calls setDiscoverableMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setDiscoverableMode(const bool &_enabled, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setDiscoverableMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setDiscoverableModeAsync(const bool &_enabled, SetDiscoverableModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method used to pin information for head unit.
     * param: passkey (string)          : set the default pin for legacy devices         
     *   returns:  error code (eErrorType) : error code
     * Calls setPin with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setPin(const std::string &_passkey, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setPin with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setPinAsync(const std::string &_passkey, SetPinAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: It will set a device as primary
     * param: inAddress  (string)     : contains the BD address.          returns:  error
     *   code (eErrorType) : error code
     * Calls setPrimaryDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setPrimaryDevice(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setPrimaryDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setPrimaryDeviceAsync(const std::string &_inAddress, SetPrimaryDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API is used for set and get phone specific properties like PhoneBook    
     *   Auto Download is enabled or disables, set specific ringtone, call volume etc.
     *   These property values     will to set for all the paired phones.
     * param: inAddress  (string)     : contains the BD address.
     * param: type (eSettingsOperation) : Operations like GET or SET
     * param: setProperty (eSettingsProperty) : Property like PhoneBook AutoDowload, sorting
     *   order etc
     * param: setValue (settingsValues) : value of the selected property          returns: 
     *   error code (eErrorType) : error code         returns: outAddress  (string)    
     *   : contains the BD address.         returns: getProperty (eSettingsProperty) :
     *   Property like PhoneBook AutoDowload, sorting order etc         returns:
     *   getValue (settingsValues) : value of the selected property
     * Calls PhoneSettings with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void PhoneSettings(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSettingsOperation &_type, const ::v4::com::harman::btpres::BTPresTypes::eSettingsProperty &_setProperty, const ::v4::com::harman::btpres::BTPresTypes::settingsValues &_setValue, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, std::string &_outAddress, ::v4::com::harman::btpres::BTPresTypes::eSettingsProperty &_getProperty, ::v4::com::harman::btpres::BTPresTypes::settingsValues &_getValue, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls PhoneSettings with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> PhoneSettingsAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSettingsOperation &_type, const ::v4::com::harman::btpres::BTPresTypes::eSettingsProperty &_setProperty, const ::v4::com::harman::btpres::BTPresTypes::settingsValues &_setValue, PhoneSettingsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API is used to enable or disable Do Not Disturb for a specific device.    
     *   When this is enabled incoming call to that device will be rejected and also
     *   SMS notification     alerts will be disabled.
     * param: device  (dontDisturbDeviceInfo) : contains the BD address and DnD status to be
     *   set.          returns:  error code (eErrorType)       : error code            
     *        This API will be deprecated once all client move to DontDisturbExtended
     *   API
     * Calls DontDisturb with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void DontDisturb(const ::v4::com::harman::btpres::BTPresTypes::dontDisturbDeviceInfo &_device, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls DontDisturb with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> DontDisturbAsync(const ::v4::com::harman::btpres::BTPresTypes::dontDisturbDeviceInfo &_device, DontDisturbAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API is used to enable or disable Do Not Disturb.      This method should
     *   be called with eDndType , which contains different type of dnd .      when
     *   clients wants to enable phone specific dnd then dnd type should be DND_PHONE  
     *      Whne clents wants to enable dnd for somplete HU then dnd type should be
     *   DND_HU      Whne clents wants to disable audio handling for the BTPRES then
     *   dnd type should be DND_DISABLE_AUDIO.
     * param: device  (extendedDnd) : different type of DND mode       returns:  error code
     *   (eErrorType)       : error code
     * Calls DontDisturbExtended with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void DontDisturbExtended(const ::v4::com::harman::btpres::BTPresTypes::extendedDnd &_dndMode, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls DontDisturbExtended with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> DontDisturbExtendedAsync(const ::v4::com::harman::btpres::BTPresTypes::extendedDnd &_dndMode, DontDisturbExtendedAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This will update the position of the device in devList(Bonded Device List)
     *   attribute.For example     device with index 1 will be at top of the devList.
     * param: address  (string)   : Address of the device
     * param: index  (UInt16)     : New index(position) for the device          returns: 
     *   error code (eErrorType) : error code
     * Calls SetFavoriteDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetFavoriteDevice(const std::string &_address, const uint16_t &_index, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetFavoriteDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetFavoriteDeviceAsync(const std::string &_address, const uint16_t &_index, SetFavoriteDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This will be used to play the HU ringtone
     * param: toneID    : Tone ID which HMI want to play          returns:  error code
     *   (eErrorType) : error code
     * Calls play with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void play(const ::v4::com::harman::btpres::BTPresTypes::uToneID &_toneID, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls play with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> playAsync(const ::v4::com::harman::btpres::BTPresTypes::uToneID &_toneID, PlayAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This will be used to stop the HU ringtone playback started by previous method
     * param: toneID    : Tone ID which is currently playing          returns:  error code
     *   (eErrorType) : error code
     * Calls stop with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stop(const ::v4::com::harman::btpres::BTPresTypes::uToneID &_ringID, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stop with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stopAsync(const ::v4::com::harman::btpres::BTPresTypes::uToneID &_ringID, StopAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This can be used by the clients to get bonded device details like manufacturer,
     *   model,                       software version, profileinfo etc.
     * param: address  (string)   : Address of the device          returns:  error code
     *   (eErrorType) : error code         returns:  device (deviceDetails) : This
     *   contains details like BD Address, Name,                   manufacturer, model,
     *   software version, profileinfo etc.
     * Calls getBondedDeviceDetails with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getBondedDeviceDetails(const std::string &_address, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v4::com::harman::btpres::BTPresTypes::deviceDetails &_device, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBondedDeviceDetails with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getBondedDeviceDetailsAsync(const std::string &_address, GetBondedDeviceDetailsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This will be used to reset profile / profiles to default value.
     * param: type (factroyResetType)	: Type of reset can be user or system level            
     *                                 USER: Should set current user settings to
     *   default value                                           SYSTEM: Should set all
     *   profiles settings to default value          returns:  error code (eErrorType)
     *   : error code
     * Calls factoryReset with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void factoryReset(const ::v4::com::harman::btpres::BTPresTypes::factroyResetType &_type, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls factoryReset with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> factoryResetAsync(const ::v4::com::harman::btpres::BTPresTypes::factroyResetType &_type, FactoryResetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This will be used to get the radio strength of Bluetooth device connected to HU.
     * Calls getRadioStrength with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getRadioStrength(CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::radioStrengthInfoList &_radioStrengthList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRadioStrength with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getRadioStrengthAsync(GetRadioStrengthAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<ConnectionManagerProxyBase> delegate_;
};

typedef ConnectionManagerProxy<> ConnectionManagerProxyDefault;

namespace ConnectionManagerExtensions {
    /**
     * description: It will reflect the current bluetooth status to registered clients
     */
    template <template <typename > class _ExtensionType>
    class BtStateAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::BtStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::BtStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BtStateAttributeExtension() {}
    #endif
    
        BtStateAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getBtStateAttribute()) {
        }
    
        inline extension_type& getBtStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will reflect local device address to registered clients
     */
    template <template <typename > class _ExtensionType>
    class LocalDevAddrAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::LocalDevAddrAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::LocalDevAddrAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        LocalDevAddrAttributeExtension() {}
    #endif
    
        LocalDevAddrAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getLocalDevAddrAttribute()) {
        }
    
        inline extension_type& getLocalDevAddrAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will reflect local device name to registered clients
     */
    template <template <typename > class _ExtensionType>
    class LocalDevNameAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::LocalDevNameAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::LocalDevNameAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        LocalDevNameAttributeExtension() {}
    #endif
    
        LocalDevNameAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getLocalDevNameAttribute()) {
        }
    
        inline extension_type& getLocalDevNameAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast stored pass key to registered clients
     */
    template <template <typename > class _ExtensionType>
    class PassKeyPinAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::PassKeyPinAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::PassKeyPinAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        PassKeyPinAttributeExtension() {}
    #endif
    
        PassKeyPinAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getPassKeyPinAttribute()) {
        }
    
        inline extension_type& getPassKeyPinAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast device search status to registered client
     */
    template <template <typename > class _ExtensionType>
    class DeviceSearchStatusAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::DeviceSearchStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::DeviceSearchStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DeviceSearchStatusAttributeExtension() {}
    #endif
    
        DeviceSearchStatusAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getDeviceSearchStatusAttribute()) {
        }
    
        inline extension_type& getDeviceSearchStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast discoverability status to registered clients
     */
    template <template <typename > class _ExtensionType>
    class DiscoverableStatusAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::DiscoverableStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::DiscoverableStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DiscoverableStatusAttributeExtension() {}
    #endif
    
        DiscoverableStatusAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getDiscoverableStatusAttribute()) {
        }
    
        inline extension_type& getDiscoverableStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast discoverability timeout to registered clients
     */
    template <template <typename > class _ExtensionType>
    class DiscoveryTimeoutAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::DiscoveryTimeoutAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::DiscoveryTimeoutAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DiscoveryTimeoutAttributeExtension() {}
    #endif
    
        DiscoveryTimeoutAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getDiscoveryTimeoutAttribute()) {
        }
    
        inline extension_type& getDiscoveryTimeoutAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast device search results to registered clients
     */
    template <template <typename > class _ExtensionType>
    class DevSearchResultsAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::DevSearchResultsAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::DevSearchResultsAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DevSearchResultsAttributeExtension() {}
    #endif
    
        DevSearchResultsAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getDevSearchResultsAttribute()) {
        }
    
        inline extension_type& getDevSearchResultsAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast bonded device list to registered clients
     */
    template <template <typename > class _ExtensionType>
    class DevListAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::DevListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::DevListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DevListAttributeExtension() {}
    #endif
    
        DevListAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getDevListAttribute()) {
        }
    
        inline extension_type& getDevListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast connected device list to registered clients.     This is a
     *   subset of bonded device list
     */
    template <template <typename > class _ExtensionType>
    class ConnectedDevListAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::ConnectedDevListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::ConnectedDevListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ConnectedDevListAttributeExtension() {}
    #endif
    
        ConnectedDevListAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getConnectedDevListAttribute()) {
        }
    
        inline extension_type& getConnectedDevListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast network status to registered clients
     */
    template <template <typename > class _ExtensionType>
    class NetIfStatusAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::NetIfStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::NetIfStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        NetIfStatusAttributeExtension() {}
    #endif
    
        NetIfStatusAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getNetIfStatusAttribute()) {
        }
    
        inline extension_type& getNetIfStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast unstable device info to registered clients
     */
    template <template <typename > class _ExtensionType>
    class UnstableDevsAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::UnstableDevsAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::UnstableDevsAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        UnstableDevsAttributeExtension() {}
    #endif
    
        UnstableDevsAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getUnstableDevsAttribute()) {
        }
    
        inline extension_type& getUnstableDevsAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast primary device address
     */
    template <template <typename > class _ExtensionType>
    class PrimaryDeviceAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::PrimaryDeviceAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::PrimaryDeviceAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        PrimaryDeviceAttributeExtension() {}
    #endif
    
        PrimaryDeviceAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getPrimaryDeviceAttribute()) {
        }
    
        inline extension_type& getPrimaryDeviceAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: It will broadcast dont disturb status of the device           This will be
     *   deprecated once all clients move to extendedDnd attribute
     */
    template <template <typename > class _ExtensionType>
    class DnDStatusAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::DnDStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::DnDStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DnDStatusAttributeExtension() {}
    #endif
    
        DnDStatusAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getDnDStatusAttribute()) {
        }
    
        inline extension_type& getDnDStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: This attribute will be used to enable emergencyAssistance Mode in BtPres.    
     *   If BT is OFF and emargencyAssistance set to true , BT will be automatically
     *   turned ON.     Autoconnect will not be triggered     If this is set to true
     *   all ongoing call will be cancelled. Only newly initiated call from the HU will
     *   be allowed
     */
    template <template <typename > class _ExtensionType>
    class EmargencyAssistanceAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::EmargencyAssistanceAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::EmargencyAssistanceAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EmargencyAssistanceAttributeExtension() {}
    #endif
    
        EmargencyAssistanceAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getEmargencyAssistanceAttribute()) {
        }
    
        inline extension_type& getEmargencyAssistanceAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: This attribute will be used to get different type of DND         It can be used
     *   for HU specific DND/ Phone Specific DND / Disabling audio handling of BTPRES
     */
    template <template <typename > class _ExtensionType>
    class DndInfoAttributeExtension {
     public:
        typedef _ExtensionType<ConnectionManagerProxyBase::DndInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<ConnectionManagerProxyBase::DndInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DndInfoAttributeExtension() {}
    #endif
    
        DndInfoAttributeExtension(ConnectionManagerProxyBase& proxy): attributeExtension_(proxy.getDndInfoAttribute()) {
        }
    
        inline extension_type& getDndInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace ConnectionManagerExtensions

//
// ConnectionManagerProxy Implementation
//
template <typename ... _AttributeExtensions>
ConnectionManagerProxy<_AttributeExtensions...>::ConnectionManagerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<ConnectionManagerProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<ConnectionManagerProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
ConnectionManagerProxy<_AttributeExtensions...>::~ConnectionManagerProxy() {
}

/**
 * description: Used to start device search on head unit
 * param: maxDevice (UInt32)       : max limit for found devices
 * param: timeout (UInt32)         : time limit for device search operation         
 *   returns: errorCode (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::startDeviceSearch(const uint32_t &_maxDevice, const uint32_t &_timeout, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->startDeviceSearch(_maxDevice, _timeout, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::startDeviceSearchAsync(const uint32_t &_maxDevice, const uint32_t &_timeout, StartDeviceSearchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startDeviceSearchAsync(_maxDevice, _timeout, _callback, _info);
}
/**
 * description: Used to stop device search on head unit
 * param: none          returns: error code (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::stopDeviceSearch(CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->stopDeviceSearch(_internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::stopDeviceSearchAsync(StopDeviceSearchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stopDeviceSearchAsync(_callback, _info);
}
/**
 * description: Used to send secure Bonding reply
 * param: inAddress (string)       : phone BT address
 * param: accept (boolean)         : accepting authentication request
 * param: trusted (boolean)        : making device trusted means service won't send
 *   connection request for each connect attempt
 * param: type (eBondingType)      : Bonding type, standard or secure bonding         
 *   returns: errorCode (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::bondingReply(const std::string &_inAddress, const bool &_accept, const bool &_trusted, const ::v4::com::harman::btpres::BTPresTypes::eBondingType &_type, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    if (!_type.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->bondingReply(_inAddress, _accept, _trusted, _type, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::bondingReplyAsync(const std::string &_inAddress, const bool &_accept, const bool &_trusted, const ::v4::com::harman::btpres::BTPresTypes::eBondingType &_type, BondingReplyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_type.validate()) {
        ::v4::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v4::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->bondingReplyAsync(_inAddress, _accept, _trusted, _type, _callback, _info);
}
/**
 * description: Used to delete device from paired device list
 * param: inAddress (string)      : phone BT address          returns: errorCode
 *   (eErrorType): error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::deleteDevice(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->deleteDevice(_inAddress, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::deleteDeviceAsync(const std::string &_inAddress, DeleteDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deleteDeviceAsync(_inAddress, _callback, _info);
}
/**
 * description: Used to delete all device in paired device list
 * param: none          returns: errorCode (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::deleteAllDevices(CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->deleteAllDevices(_internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::deleteAllDevicesAsync(DeleteAllDevicesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deleteAllDevicesAsync(_callback, _info);
}
/**
 * description: Used to initate profile connection with device         version 1.0
 * param: inAddress (string)       : phone BT address
 * param: service (eSupportedProfile) : profile name
 * param: instanceName (string)    : containing the phone instance
 * param: replaceAddr (string)     : containing the replacement address for which the
 *   connection will be replaced          returns: errorCode (eErrorType) : error
 *   code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::startServiceConnection(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const std::string &_instanceName, const std::string &_replaceAddr, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    if (!_service.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->startServiceConnection(_inAddress, _service, _instanceName, _replaceAddr, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::startServiceConnectionAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const std::string &_instanceName, const std::string &_replaceAddr, StartServiceConnectionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_service.validate()) {
        ::v4::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v4::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->startServiceConnectionAsync(_inAddress, _service, _instanceName, _replaceAddr, _callback, _info);
}
/**
 * description: Used to initate multiple profile connection with device         version 2.0
 * param: inAddress (string)                       : phone BT address
 * param: ProfileList (arSupportedProfile)         : profile name list
 * param: replaceAddr (string)                     : containing the replacement address
 *   for which the connection will be replaced          returns: errorCode
 *   (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::startServiceConnection(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::arSupportedProfile &_ProfileList, const std::string &_replaceAddr, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->startServiceConnection(_inAddress, _ProfileList, _replaceAddr, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::startServiceConnectionAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::arSupportedProfile &_ProfileList, const std::string &_replaceAddr, StartServiceConnectionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startServiceConnectionAsync(_inAddress, _ProfileList, _replaceAddr, _callback, _info);
}
/**
 * description: Used to allows the existance of the service connection to this device and
 *   service.
 * param: inAddress (string)           : phone BT address
 * param: service (eSupportedProfile)  : profile name
 * param: allow (Boolean)              : containing the value true for allow, or false
 *   for reject          returns: errorCode (eErrorType)      : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::allowServiceConnection(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const bool &_allow, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    if (!_service.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->allowServiceConnection(_inAddress, _service, _allow, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::allowServiceConnectionAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const bool &_allow, AllowServiceConnectionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_service.validate()) {
        ::v4::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v4::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->allowServiceConnectionAsync(_inAddress, _service, _allow, _callback, _info);
}
/**
 * description: Used to initate the disconnection with connected service i.e. HFP and A2DP
 * param: inAddress (string)                  : phone BT address
 * param: service (eSupportedProfile)         : profile name          returns: errorCode
 *   error code (eErrorType)  : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::startServiceDisconnection(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    if (!_service.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->startServiceDisconnection(_inAddress, _service, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::startServiceDisconnectionAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, StartServiceDisconnectionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_service.validate()) {
        ::v4::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v4::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->startServiceDisconnectionAsync(_inAddress, _service, _callback, _info);
}
/**
 * description: Used to initate the disconnection with connected service i.e. HFP and A2DP
 * param: inAddress (string)                  : phone BT address
 * param: ProfileList (arSupportedProfile)         : profile name list          returns:
 *   errorCode error code (eErrorType)  : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::startServiceDisconnection(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::arSupportedProfile &_ProfileList, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->startServiceDisconnection(_inAddress, _ProfileList, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::startServiceDisconnectionAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::arSupportedProfile &_ProfileList, StartServiceDisconnectionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startServiceDisconnectionAsync(_inAddress, _ProfileList, _callback, _info);
}
/**
 * description: This method should be called by clients in order to reply to the incoming
 *   service                         connection request from a remote device as
 *   indicated by the signal 'serviceConnectionRequest'.                        
 *   The reply can be to accept or reject incoming service connection request.
 * param: inAddress (string)              : phone BT address
 * param: service (eSupportedProfile)     : profile name
 * param: accept (boolean)                : containing the value true for allow, or false
 *   for reject
 * param: instanceName (string)           : containing the instance name of the device   
 *         returns: errorCode (eErrorType)         : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::serviceConnectionReply(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const bool &_accept, const std::string &_instanceName, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    if (!_service.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->serviceConnectionReply(_inAddress, _service, _accept, _instanceName, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::serviceConnectionReplyAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSupportedProfile &_service, const bool &_accept, const std::string &_instanceName, ServiceConnectionReplyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_service.validate()) {
        ::v4::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v4::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->serviceConnectionReplyAsync(_inAddress, _service, _accept, _instanceName, _callback, _info);
}
/**
 * description: Used to initiate the reconnection to previously connected device
 * param: None          returns: errorCode error code (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::startReconnect(CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->startReconnect(_internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::startReconnectAsync(StartReconnectAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startReconnectAsync(_callback, _info);
}
/**
 * description: This method should be called to get oldest connected device
 * param: None          returns: oldestDevInfo (oldestDevInfo)     : Oldest device name
 *   and address         returns: errorCode error code (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::getOldestConnectedDev(CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v4::com::harman::btpres::BTPresTypes::deviceInfo &_oldestDevInfo, const CommonAPI::CallInfo *_info) {
    delegate_->getOldestConnectedDev(_internalCallStatus, _errorCode, _oldestDevInfo, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::getOldestConnectedDevAsync(GetOldestConnectedDevAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getOldestConnectedDevAsync(_callback, _info);
}
/**
 * description: This method used to change name of bonded device.
 * param: inAddress  (string)     : contains the BD address.
 * param: name (string)           : Device name          returns: errorCode(eErrorType) 
 *   : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::renameBondedDevice(const std::string &_inAddress, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->renameBondedDevice(_inAddress, _name, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::renameBondedDeviceAsync(const std::string &_inAddress, const std::string &_name, RenameBondedDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->renameBondedDeviceAsync(_inAddress, _name, _callback, _info);
}
/**
 * description: This method used to change local name of head unit.
 * param: name (string)           : Device name          returns: errorCode(eErrorType) 
 *   : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::renameLocalDevice(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->renameLocalDevice(_name, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::renameLocalDeviceAsync(const std::string &_name, RenameLocalDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->renameLocalDeviceAsync(_name, _callback, _info);
}
/**
 * description: Used to set bluetooth on or off
 * param: status (boolean)       : set true or false          returns: error
 *   code(eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::setBluetoothStatus(const bool &_status, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setBluetoothStatus(_status, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::setBluetoothStatusAsync(const bool &_status, SetBluetoothStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setBluetoothStatusAsync(_status, _callback, _info);
}
/**
 * description: Used to enable or disable discoverable mode
 * param: enabled (boolean)       : set true or false          returns: errorCode
 *   (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::setDiscoverableMode(const bool &_enabled, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setDiscoverableMode(_enabled, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::setDiscoverableModeAsync(const bool &_enabled, SetDiscoverableModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setDiscoverableModeAsync(_enabled, _callback, _info);
}
/**
 * description: This method used to pin information for head unit.
 * param: passkey (string)          : set the default pin for legacy devices         
 *   returns:  error code (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::setPin(const std::string &_passkey, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setPin(_passkey, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::setPinAsync(const std::string &_passkey, SetPinAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setPinAsync(_passkey, _callback, _info);
}
/**
 * description: It will set a device as primary
 * param: inAddress  (string)     : contains the BD address.          returns:  error
 *   code (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::setPrimaryDevice(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setPrimaryDevice(_inAddress, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::setPrimaryDeviceAsync(const std::string &_inAddress, SetPrimaryDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setPrimaryDeviceAsync(_inAddress, _callback, _info);
}
/**
 * description: This API is used for set and get phone specific properties like PhoneBook    
 *   Auto Download is enabled or disables, set specific ringtone, call volume etc.
 *   These property values     will to set for all the paired phones.
 * param: inAddress  (string)     : contains the BD address.
 * param: type (eSettingsOperation) : Operations like GET or SET
 * param: setProperty (eSettingsProperty) : Property like PhoneBook AutoDowload, sorting
 *   order etc
 * param: setValue (settingsValues) : value of the selected property          returns: 
 *   error code (eErrorType) : error code         returns: outAddress  (string)    
 *   : contains the BD address.         returns: getProperty (eSettingsProperty) :
 *   Property like PhoneBook AutoDowload, sorting order etc         returns:
 *   getValue (settingsValues) : value of the selected property
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::PhoneSettings(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSettingsOperation &_type, const ::v4::com::harman::btpres::BTPresTypes::eSettingsProperty &_setProperty, const ::v4::com::harman::btpres::BTPresTypes::settingsValues &_setValue, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, std::string &_outAddress, ::v4::com::harman::btpres::BTPresTypes::eSettingsProperty &_getProperty, ::v4::com::harman::btpres::BTPresTypes::settingsValues &_getValue, const CommonAPI::CallInfo *_info) {
    if (!_type.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_setProperty.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->PhoneSettings(_inAddress, _type, _setProperty, _setValue, _internalCallStatus, _errorCode, _outAddress, _getProperty, _getValue, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::PhoneSettingsAsync(const std::string &_inAddress, const ::v4::com::harman::btpres::BTPresTypes::eSettingsOperation &_type, const ::v4::com::harman::btpres::BTPresTypes::eSettingsProperty &_setProperty, const ::v4::com::harman::btpres::BTPresTypes::settingsValues &_setValue, PhoneSettingsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_type.validate()) {
        ::v4::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v4::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        std::string outAddress = "";
        ::v4::com::harman::btpres::BTPresTypes::eSettingsProperty getProperty = ::v4::com::harman::btpres::BTPresTypes::eSettingsProperty::PROP_AUTO_PB_DOWNLOAD;
        ::v4::com::harman::btpres::BTPresTypes::settingsValues getValue = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode, outAddress, getProperty, getValue);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_setProperty.validate()) {
        ::v4::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v4::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        std::string outAddress = "";
        ::v4::com::harman::btpres::BTPresTypes::eSettingsProperty getProperty = ::v4::com::harman::btpres::BTPresTypes::eSettingsProperty::PROP_AUTO_PB_DOWNLOAD;
        ::v4::com::harman::btpres::BTPresTypes::settingsValues getValue = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode, outAddress, getProperty, getValue);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->PhoneSettingsAsync(_inAddress, _type, _setProperty, _setValue, _callback, _info);
}
/**
 * description: This API is used to enable or disable Do Not Disturb for a specific device.    
 *   When this is enabled incoming call to that device will be rejected and also
 *   SMS notification     alerts will be disabled.
 * param: device  (dontDisturbDeviceInfo) : contains the BD address and DnD status to be
 *   set.          returns:  error code (eErrorType)       : error code            
 *        This API will be deprecated once all client move to DontDisturbExtended
 *   API
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::DontDisturb(const ::v4::com::harman::btpres::BTPresTypes::dontDisturbDeviceInfo &_device, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->DontDisturb(_device, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::DontDisturbAsync(const ::v4::com::harman::btpres::BTPresTypes::dontDisturbDeviceInfo &_device, DontDisturbAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->DontDisturbAsync(_device, _callback, _info);
}
/**
 * description: This API is used to enable or disable Do Not Disturb.      This method should
 *   be called with eDndType , which contains different type of dnd .      when
 *   clients wants to enable phone specific dnd then dnd type should be DND_PHONE  
 *      Whne clents wants to enable dnd for somplete HU then dnd type should be
 *   DND_HU      Whne clents wants to disable audio handling for the BTPRES then
 *   dnd type should be DND_DISABLE_AUDIO.
 * param: device  (extendedDnd) : different type of DND mode       returns:  error code
 *   (eErrorType)       : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::DontDisturbExtended(const ::v4::com::harman::btpres::BTPresTypes::extendedDnd &_dndMode, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->DontDisturbExtended(_dndMode, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::DontDisturbExtendedAsync(const ::v4::com::harman::btpres::BTPresTypes::extendedDnd &_dndMode, DontDisturbExtendedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->DontDisturbExtendedAsync(_dndMode, _callback, _info);
}
/**
 * description: This will update the position of the device in devList(Bonded Device List)
 *   attribute.For example     device with index 1 will be at top of the devList.
 * param: address  (string)   : Address of the device
 * param: index  (UInt16)     : New index(position) for the device          returns: 
 *   error code (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::SetFavoriteDevice(const std::string &_address, const uint16_t &_index, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->SetFavoriteDevice(_address, _index, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::SetFavoriteDeviceAsync(const std::string &_address, const uint16_t &_index, SetFavoriteDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetFavoriteDeviceAsync(_address, _index, _callback, _info);
}
/**
 * description: This will be used to play the HU ringtone
 * param: toneID    : Tone ID which HMI want to play          returns:  error code
 *   (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::play(const ::v4::com::harman::btpres::BTPresTypes::uToneID &_toneID, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->play(_toneID, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::playAsync(const ::v4::com::harman::btpres::BTPresTypes::uToneID &_toneID, PlayAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->playAsync(_toneID, _callback, _info);
}
/**
 * description: This will be used to stop the HU ringtone playback started by previous method
 * param: toneID    : Tone ID which is currently playing          returns:  error code
 *   (eErrorType) : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::stop(const ::v4::com::harman::btpres::BTPresTypes::uToneID &_ringID, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->stop(_ringID, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::stopAsync(const ::v4::com::harman::btpres::BTPresTypes::uToneID &_ringID, StopAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stopAsync(_ringID, _callback, _info);
}
/**
 * description: This can be used by the clients to get bonded device details like manufacturer,
 *   model,                       software version, profileinfo etc.
 * param: address  (string)   : Address of the device          returns:  error code
 *   (eErrorType) : error code         returns:  device (deviceDetails) : This
 *   contains details like BD Address, Name,                   manufacturer, model,
 *   software version, profileinfo etc.
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::getBondedDeviceDetails(const std::string &_address, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v4::com::harman::btpres::BTPresTypes::deviceDetails &_device, const CommonAPI::CallInfo *_info) {
    delegate_->getBondedDeviceDetails(_address, _internalCallStatus, _errorCode, _device, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::getBondedDeviceDetailsAsync(const std::string &_address, GetBondedDeviceDetailsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getBondedDeviceDetailsAsync(_address, _callback, _info);
}
/**
 * description: This will be used to reset profile / profiles to default value.
 * param: type (factroyResetType)	: Type of reset can be user or system level            
 *                                 USER: Should set current user settings to
 *   default value                                           SYSTEM: Should set all
 *   profiles settings to default value          returns:  error code (eErrorType)
 *   : error code
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::factoryReset(const ::v4::com::harman::btpres::BTPresTypes::factroyResetType &_type, CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    if (!_type.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->factoryReset(_type, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::factoryResetAsync(const ::v4::com::harman::btpres::BTPresTypes::factroyResetType &_type, FactoryResetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_type.validate()) {
        ::v4::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v4::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->factoryResetAsync(_type, _callback, _info);
}
/**
 * description: This will be used to get the radio strength of Bluetooth device connected to HU.
 */
template <typename ... _AttributeExtensions>
void ConnectionManagerProxy<_AttributeExtensions...>::getRadioStrength(CommonAPI::CallStatus &_internalCallStatus, ::v4::com::harman::btpres::BTPresTypes::radioStrengthInfoList &_radioStrengthList, const CommonAPI::CallInfo *_info) {
    delegate_->getRadioStrength(_internalCallStatus, _radioStrengthList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ConnectionManagerProxy<_AttributeExtensions...>::getRadioStrengthAsync(GetRadioStrengthAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getRadioStrengthAsync(_callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &ConnectionManagerProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool ConnectionManagerProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool ConnectionManagerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& ConnectionManagerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& ConnectionManagerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace btpres
} // namespace harman
} // namespace com
} // namespace v2

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v2::com::harman::btpres::ConnectionManagerProxy,
    _AttributeExtension> {
    typedef typename ::v2::com::harman::btpres::ConnectionManagerProxy<
            ::v2::com::harman::btpres::ConnectionManagerExtensions::BtStateAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::LocalDevAddrAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::LocalDevNameAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::PassKeyPinAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::DeviceSearchStatusAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::DiscoverableStatusAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::DiscoveryTimeoutAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::DevSearchResultsAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::DevListAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::ConnectedDevListAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::NetIfStatusAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::UnstableDevsAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::PrimaryDeviceAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::DnDStatusAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::EmargencyAssistanceAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::btpres::ConnectionManagerExtensions::DndInfoAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v2_0 = v2;

#endif // V2_COM_HARMAN_BTPRES_Connection_Manager_PROXY_HPP_
