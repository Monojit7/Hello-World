/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: This is a Common API DBUS control interface of audio presentation controller
 *   for Orinoco 2.0
 * author: AYatheesh
 */
#ifndef V2_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_PROXY_HPP_
#define V2_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_PROXY_HPP_

#include <v2/com/harman/audio/audioPresCtrl/audioPresCtrlControlsProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v2 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

template <typename ... _AttributeExtensions>
class audioPresCtrlControlsProxy
    : virtual public audioPresCtrlControls, 
      virtual public audioPresCtrlControlsProxyBase,
      virtual public _AttributeExtensions... {
public:
    audioPresCtrlControlsProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~audioPresCtrlControlsProxy();

    typedef audioPresCtrlControls InterfaceType;


    /**
     * description: Attribute holding list of active sourceIds 		This is a list because we could
     *   have multiple sources activated at the same time.  		Example: 1. Phone call
     *   active with Entertainment Audio in suspended state 2. Navigation and Touch
     *   beep mixed with Entertainment source.
     */
    /**
     * Returns the wrapper class that provides access to the attribute ActiveAudioSources.
     */
    virtual ActiveAudioSourcesAttribute& getActiveAudioSourcesAttribute() {
        return delegate_->getActiveAudioSourcesAttribute();
    }
    /**
     * description: Attribute holding current ative entertainment source 		This will be updated on
     *   every audiosource change
     */
    /**
     * Returns the wrapper class that provides access to the attribute ActiveEntSource.
     */
    virtual ActiveEntSourceAttribute& getActiveEntSourceAttribute() {
        return delegate_->getActiveEntSourceAttribute();
    }
    /**
     * description: Attribute holding list of entertainment sources and related information 		This
     *   will be updated on a status change(available/unavailable/insert/unknown) of
     *   any entertainment source
     */
    /**
     * Returns the wrapper class that provides access to the attribute EntSourceList.
     */
    virtual EntSourceListAttribute& getEntSourceListAttribute() {
        return delegate_->getEntSourceListAttribute();
    }
    /**
     * description: Attribute holding active alert  		This will be updated whenever any alert is
     *   activated on the system.
     */
    /**
     * Returns the wrapper class that provides access to the attribute ActiveAlert.
     */
    virtual ActiveAlertAttribute& getActiveAlertAttribute() {
        return delegate_->getActiveAlertAttribute();
    }

    /**
     * description: Notification change in status of an entertainment device 	Ex : Availibility
     *   change such as A_AVAILABLE/A_UNAVAILABLE/A_INSERTED 	This will be helpful in
     *   cases where a client has to display a dev info / icon and not the list itself
     */
    /**
     * Returns the wrapper class that provides access to the broadcast EntertainmentSrcStatus.
     */
    virtual EntertainmentSrcStatusEvent& getEntertainmentSrcStatusEvent() {
        return delegate_->getEntertainmentSrcStatusEvent();
    }

    /**
     * description: This method is used to set audio entertainment sources 	(at)attribute update
     *   activeAudioSource and activeEntSrc
     * Calls SetEntertainmentSrc with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetEntertainmentSrc(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetEntertainmentSrc with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetEntertainmentSrcAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, SetEntertainmentSrcAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to switch Audio Context to the source in the given group
     *   	Group needs to be first mentioned in the audiopres.cfg 	Project may choose
     *   any naming strategy as long as it doesnt conflict with another json key in the
     *   cfg 	(at)attribute update activeAudioSource and activeEntSrc if a source
     *   switch has happened 	(at)return eAudioPresErrors
     * Calls SetSourceGroup with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetSourceGroup(const std::string &_sourceGroupName, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetSourceGroup with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetSourceGroupAsync(const std::string &_sourceGroupName, SetSourceGroupAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to toggle source in the source group 	SetSourceGroup needs
     *   to be invoked in order to select an active group 	(at)attribute update
     *   activeAudioSource and activeEntSrc if a source switch has happened 	(at)return
     *   eAudioPresErrors
     * Calls ToggleInSourceGroup with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ToggleInSourceGroup(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls ToggleInSourceGroup with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ToggleInSourceGroupAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleInSourceGroupAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to toggle source in the order specified in
     *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
     *   toggleNextPreviousStrategy with value is defined , method return an error
     *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
     *   entertainment sources in a project 	(at)attribute update activeAudioSource and
     *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
     * Calls ToggleSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ToggleSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls ToggleSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ToggleSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: to activate interrupt source with given SourceID 	Only touchbeep and keytouch
     *   srcs will be supported through requestinformationsource interface 	as these
     *   are the only sources that will be requested by HMIs 	Other sources will be
     *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
     *   for alt audio sources etc) 	Other sources are kept just so that HMI can track
     *   the active source through attribute activeAudioSource     	(at)return
     *   eAudioPresErrors
     * Calls RequestInformationSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void RequestInformationSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls RequestInformationSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> RequestInformationSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, RequestInformationSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: to deactivate interrupt source with given SourceID 	(at)return eAudioPresErrors
     * Calls ReleaseInformationSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ReleaseInformationSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls ReleaseInformationSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ReleaseInformationSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, ReleaseInformationSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: to deactivate entertainment source from HMI with given SourceID for example
     *   AudioOff 	(at)return eAudioPresErrors
     * Calls ReleaseEntertainmentSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ReleaseEntertainmentSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls ReleaseEntertainmentSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ReleaseEntertainmentSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceID, ReleaseEntertainmentSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: To activate/deactive alerts like "Wear Seat Belt"  	(at)return eAudioPresErrors
     * Calls ActivateSystemAlert with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ActivateSystemAlert(const std::string &_systemAlert, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls ActivateSystemAlert with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ActivateSystemAlertAsync(const std::string &_systemAlert, ActivateSystemAlertAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<audioPresCtrlControlsProxyBase> delegate_;
};

typedef audioPresCtrlControlsProxy<> audioPresCtrlControlsProxyDefault;

namespace audioPresCtrlControlsExtensions {
    /**
     * description: Attribute holding list of active sourceIds 		This is a list because we could
     *   have multiple sources activated at the same time.  		Example: 1. Phone call
     *   active with Entertainment Audio in suspended state 2. Navigation and Touch
     *   beep mixed with Entertainment source.
     */
    template <template <typename > class _ExtensionType>
    class ActiveAudioSourcesAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlControlsProxyBase::ActiveAudioSourcesAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlControlsProxyBase::ActiveAudioSourcesAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ActiveAudioSourcesAttributeExtension() {}
    #endif
    
        ActiveAudioSourcesAttributeExtension(audioPresCtrlControlsProxyBase& proxy): attributeExtension_(proxy.getActiveAudioSourcesAttribute()) {
        }
    
        inline extension_type& getActiveAudioSourcesAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding current ative entertainment source 		This will be updated on
     *   every audiosource change
     */
    template <template <typename > class _ExtensionType>
    class ActiveEntSourceAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlControlsProxyBase::ActiveEntSourceAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlControlsProxyBase::ActiveEntSourceAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ActiveEntSourceAttributeExtension() {}
    #endif
    
        ActiveEntSourceAttributeExtension(audioPresCtrlControlsProxyBase& proxy): attributeExtension_(proxy.getActiveEntSourceAttribute()) {
        }
    
        inline extension_type& getActiveEntSourceAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding list of entertainment sources and related information 		This
     *   will be updated on a status change(available/unavailable/insert/unknown) of
     *   any entertainment source
     */
    template <template <typename > class _ExtensionType>
    class EntSourceListAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlControlsProxyBase::EntSourceListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlControlsProxyBase::EntSourceListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EntSourceListAttributeExtension() {}
    #endif
    
        EntSourceListAttributeExtension(audioPresCtrlControlsProxyBase& proxy): attributeExtension_(proxy.getEntSourceListAttribute()) {
        }
    
        inline extension_type& getEntSourceListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding active alert  		This will be updated whenever any alert is
     *   activated on the system.
     */
    template <template <typename > class _ExtensionType>
    class ActiveAlertAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlControlsProxyBase::ActiveAlertAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlControlsProxyBase::ActiveAlertAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ActiveAlertAttributeExtension() {}
    #endif
    
        ActiveAlertAttributeExtension(audioPresCtrlControlsProxyBase& proxy): attributeExtension_(proxy.getActiveAlertAttribute()) {
        }
    
        inline extension_type& getActiveAlertAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace audioPresCtrlControlsExtensions

//
// audioPresCtrlControlsProxy Implementation
//
template <typename ... _AttributeExtensions>
audioPresCtrlControlsProxy<_AttributeExtensions...>::audioPresCtrlControlsProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<audioPresCtrlControlsProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<audioPresCtrlControlsProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
audioPresCtrlControlsProxy<_AttributeExtensions...>::~audioPresCtrlControlsProxy() {
}

/**
 * description: This method is used to set audio entertainment sources 	(at)attribute update
 *   activeAudioSource and activeEntSrc
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::SetEntertainmentSrc(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_sourceId.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->SetEntertainmentSrc(_sourceId, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::SetEntertainmentSrcAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, SetEntertainmentSrcAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_sourceId.validate()) {
        ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->SetEntertainmentSrcAsync(_sourceId, _callback, _info);
}
/**
 * description: This method is used to switch Audio Context to the source in the given group
 *   	Group needs to be first mentioned in the audiopres.cfg 	Project may choose
 *   any naming strategy as long as it doesnt conflict with another json key in the
 *   cfg 	(at)attribute update activeAudioSource and activeEntSrc if a source
 *   switch has happened 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::SetSourceGroup(const std::string &_sourceGroupName, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SetSourceGroup(_sourceGroupName, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::SetSourceGroupAsync(const std::string &_sourceGroupName, SetSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetSourceGroupAsync(_sourceGroupName, _callback, _info);
}
/**
 * description: This method is used to toggle source in the source group 	SetSourceGroup needs
 *   to be invoked in order to select an active group 	(at)attribute update
 *   activeAudioSource and activeEntSrc if a source switch has happened 	(at)return
 *   eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::ToggleInSourceGroup(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_direction.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->ToggleInSourceGroup(_direction, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::ToggleInSourceGroupAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleInSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_direction.validate()) {
        ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->ToggleInSourceGroupAsync(_direction, _callback, _info);
}
/**
 * description: This method is used to toggle source in the order specified in
 *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
 *   toggleNextPreviousStrategy with value is defined , method return an error
 *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
 *   entertainment sources in a project 	(at)attribute update activeAudioSource and
 *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::ToggleSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_direction.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->ToggleSource(_direction, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::ToggleSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_direction.validate()) {
        ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->ToggleSourceAsync(_direction, _callback, _info);
}
/**
 * description: to activate interrupt source with given SourceID 	Only touchbeep and keytouch
 *   srcs will be supported through requestinformationsource interface 	as these
 *   are the only sources that will be requested by HMIs 	Other sources will be
 *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
 *   for alt audio sources etc) 	Other sources are kept just so that HMI can track
 *   the active source through attribute activeAudioSource     	(at)return
 *   eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::RequestInformationSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_sourceID.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->RequestInformationSource(_sourceID, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::RequestInformationSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, RequestInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_sourceID.validate()) {
        ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->RequestInformationSourceAsync(_sourceID, _callback, _info);
}
/**
 * description: to deactivate interrupt source with given SourceID 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::ReleaseInformationSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_sourceID.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->ReleaseInformationSource(_sourceID, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::ReleaseInformationSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, ReleaseInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_sourceID.validate()) {
        ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->ReleaseInformationSourceAsync(_sourceID, _callback, _info);
}
/**
 * description: to deactivate entertainment source from HMI with given SourceID for example
 *   AudioOff 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::ReleaseEntertainmentSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_sourceID.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->ReleaseEntertainmentSource(_sourceID, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::ReleaseEntertainmentSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceID, ReleaseEntertainmentSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_sourceID.validate()) {
        ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->ReleaseEntertainmentSourceAsync(_sourceID, _callback, _info);
}
/**
 * description: To activate/deactive alerts like "Wear Seat Belt"  	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlControlsProxy<_AttributeExtensions...>::ActivateSystemAlert(const std::string &_systemAlert, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->ActivateSystemAlert(_systemAlert, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlControlsProxy<_AttributeExtensions...>::ActivateSystemAlertAsync(const std::string &_systemAlert, ActivateSystemAlertAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->ActivateSystemAlertAsync(_systemAlert, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &audioPresCtrlControlsProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool audioPresCtrlControlsProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool audioPresCtrlControlsProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& audioPresCtrlControlsProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& audioPresCtrlControlsProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace audioPresCtrl
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v2

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v2::com::harman::audio::audioPresCtrl::audioPresCtrlControlsProxy,
    _AttributeExtension> {
    typedef typename ::v2::com::harman::audio::audioPresCtrl::audioPresCtrlControlsProxy<
            ::v2::com::harman::audio::audioPresCtrl::audioPresCtrlControlsExtensions::ActiveAudioSourcesAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::audio::audioPresCtrl::audioPresCtrlControlsExtensions::ActiveEntSourceAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::audio::audioPresCtrl::audioPresCtrlControlsExtensions::EntSourceListAttributeExtension<_AttributeExtension>, 
            ::v2::com::harman::audio::audioPresCtrl::audioPresCtrlControlsExtensions::ActiveAlertAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v2_2 = v2;

#endif // V2_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_PROXY_HPP_
