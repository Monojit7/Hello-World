/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: This is a Common API DBUS control interface of audio presentation controller
 *   for Orinoco 2.0
 * author: AYatheesh
 */
#ifndef V2_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_PROXY_BASE_HPP_
#define V2_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_PROXY_BASE_HPP_

#include <v2/com/harman/audio/audioPresCtrl/audioPresCtrlControls.hpp>


#include <v3/com/harman/audio/audioPresCtrl/audioPresCtrlTypes.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

#include <CommonAPI/Attribute.hpp>
#include <CommonAPI/Event.hpp>
#include <CommonAPI/Proxy.hpp>
#include <functional>
#include <future>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v2 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

class audioPresCtrlControlsProxyBase
    : virtual public CommonAPI::Proxy {
public:
    typedef CommonAPI::ObservableReadonlyAttribute<std::vector<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId>> ActiveAudioSourcesAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceInfo> ActiveEntSourceAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::mEntSrcsInfo> EntSourceListAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<std::string> ActiveAlertAttribute;
    typedef CommonAPI::Event<
        ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceInfo
    > EntertainmentSrcStatusEvent;

    typedef std::function<void(const CommonAPI::CallStatus&, const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors&)> SetEntertainmentSrcAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors&)> SetSourceGroupAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors&)> ToggleInSourceGroupAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors&)> ToggleSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors&)> RequestInformationSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors&)> ReleaseInformationSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors&)> ReleaseEntertainmentSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors&)> ActivateSystemAlertAsyncCallback;

    /**
     * description: Attribute holding list of active sourceIds 		This is a list because we could
     *   have multiple sources activated at the same time.  		Example: 1. Phone call
     *   active with Entertainment Audio in suspended state 2. Navigation and Touch
     *   beep mixed with Entertainment source.
     */
    virtual ActiveAudioSourcesAttribute& getActiveAudioSourcesAttribute() = 0;
    /**
     * description: Attribute holding current ative entertainment source 		This will be updated on
     *   every audiosource change
     */
    virtual ActiveEntSourceAttribute& getActiveEntSourceAttribute() = 0;
    /**
     * description: Attribute holding list of entertainment sources and related information 		This
     *   will be updated on a status change(available/unavailable/insert/unknown) of
     *   any entertainment source
     */
    virtual EntSourceListAttribute& getEntSourceListAttribute() = 0;
    /**
     * description: Attribute holding active alert  		This will be updated whenever any alert is
     *   activated on the system.
     */
    virtual ActiveAlertAttribute& getActiveAlertAttribute() = 0;

    /**
     * description: Notification change in status of an entertainment device 	Ex : Availibility
     *   change such as A_AVAILABLE/A_UNAVAILABLE/A_INSERTED 	This will be helpful in
     *   cases where a client has to display a dev info / icon and not the list itself
     */
    virtual EntertainmentSrcStatusEvent& getEntertainmentSrcStatusEvent() = 0;

    /**
     * description: This method is used to set audio entertainment sources 	(at)attribute update
     *   activeAudioSource and activeEntSrc
     */
    virtual void SetEntertainmentSrc(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> SetEntertainmentSrcAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, SetEntertainmentSrcAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: This method is used to switch Audio Context to the source in the given group
     *   	Group needs to be first mentioned in the audiopres.cfg 	Project may choose
     *   any naming strategy as long as it doesnt conflict with another json key in the
     *   cfg 	(at)attribute update activeAudioSource and activeEntSrc if a source
     *   switch has happened 	(at)return eAudioPresErrors
     */
    virtual void SetSourceGroup(const std::string &_sourceGroupName, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> SetSourceGroupAsync(const std::string &_sourceGroupName, SetSourceGroupAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: This method is used to toggle source in the source group 	SetSourceGroup needs
     *   to be invoked in order to select an active group 	(at)attribute update
     *   activeAudioSource and activeEntSrc if a source switch has happened 	(at)return
     *   eAudioPresErrors
     */
    virtual void ToggleInSourceGroup(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> ToggleInSourceGroupAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleInSourceGroupAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: This method is used to toggle source in the order specified in
     *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
     *   toggleNextPreviousStrategy with value is defined , method return an error
     *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
     *   entertainment sources in a project 	(at)attribute update activeAudioSource and
     *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
     */
    virtual void ToggleSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> ToggleSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: to activate interrupt source with given SourceID 	Only touchbeep and keytouch
     *   srcs will be supported through requestinformationsource interface 	as these
     *   are the only sources that will be requested by HMIs 	Other sources will be
     *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
     *   for alt audio sources etc) 	Other sources are kept just so that HMI can track
     *   the active source through attribute activeAudioSource     	(at)return
     *   eAudioPresErrors
     */
    virtual void RequestInformationSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> RequestInformationSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, RequestInformationSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: to deactivate interrupt source with given SourceID 	(at)return eAudioPresErrors
     */
    virtual void ReleaseInformationSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> ReleaseInformationSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, ReleaseInformationSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: to deactivate entertainment source from HMI with given SourceID for example
     *   AudioOff 	(at)return eAudioPresErrors
     */
    virtual void ReleaseEntertainmentSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> ReleaseEntertainmentSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceID, ReleaseEntertainmentSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: To activate/deactive alerts like "Wear Seat Belt"  	(at)return eAudioPresErrors
     */
    virtual void ActivateSystemAlert(const std::string &_systemAlert, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> ActivateSystemAlertAsync(const std::string &_systemAlert, ActivateSystemAlertAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
};

} // namespace audioPresCtrl
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v2


// Compatibility
namespace v2_2 = v2;

#endif // V2_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_PROXY_BASE_HPP_
