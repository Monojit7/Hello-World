/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: Routing Receive sendInterface description.
 * author: lian zhang
 */
#ifndef V3_ORG_GENIVI_AM_ROUTINGINTERFACE_Routing_Control_Observer_PROXY_HPP_
#define V3_ORG_GENIVI_AM_ROUTINGINTERFACE_Routing_Control_Observer_PROXY_HPP_

#include <v3/org/genivi/am/routinginterface/RoutingControlObserverProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v3 {
namespace org {
namespace genivi {
namespace am {
namespace routinginterface {

template <typename ... _AttributeExtensions>
class RoutingControlObserverProxy
    : virtual public RoutingControlObserver, 
      virtual public RoutingControlObserverProxyBase,
      virtual public _AttributeExtensions... {
public:
    RoutingControlObserverProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~RoutingControlObserverProxy();

    typedef RoutingControlObserver InterfaceType;


    /**
     * description: This attribute signals the current routing state to the clients. A client
     *   should notify himself to this attribute in order to know the current state and
     *   act accordingly.
     */
    /**
     * Returns the wrapper class that provides access to the attribute routingReady.
     */
    virtual RoutingReadyAttribute& getRoutingReadyAttribute() {
        return delegate_->getRoutingReadyAttribute();
    }


    /**
     * description: Registers a domain. (at)return E_OK on success, E_ALREADY_EXISTENT if already
     *   registered E_UNKNOWN on error
     * Calls registerDomain with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void registerDomain(const ::v3::org::genivi::am_t::am_Domain_s &_domainData, const std::string &_returnBusname, const std::string &_returnInterface, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_domainID_t &_domainID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls registerDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerDomainAsync(const ::v3::org::genivi::am_t::am_Domain_s &_domainData, const std::string &_returnBusname, const std::string &_returnInterface, RegisterDomainAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Deregisters a domain. All sources, sinks, gateways and crossfaders from that
     *   domain will be removed as well. (at)return E_OK on success, E_NON_EXISTENT if
     *   not found E_UNKNOWN on error
     * Calls deregisterDomain with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deregisterDomain(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deregisterDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterDomainAsync(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, DeregisterDomainAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function returns the ID to the given domain name. If already a domain is
     *   registered with this name, it will return the corresponding ID, if not it will
     *   reserve an ID but not register the domain. The other parameters of the domain
     *   will be overwritten when the domain is registered. (at)return E_OK on success,
     *   E_UNKNOWN on error     please use pulseAudio as the name to peek domainID. now
     *   all the sources and sinks are defined in domain pulseAudio.
     * Calls peekDomain with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void peekDomain(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_domainID_t &_domainID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls peekDomain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekDomainAsync(const std::string &_name, PeekDomainAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Registers a sink. If the sink is part of a gateway, the list connection formats
     *   are copied to the gateway information (at)return E_OK on success,
     *   E_ALREADY_EXISTENT if already registered E_UNKNOWN on error
     * Calls registerSink with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void registerSink(const ::v3::org::genivi::am_t::am_Sink_s &_sinkData, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls registerSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerSinkAsync(const ::v3::org::genivi::am_t::am_Sink_s &_sinkData, RegisterSinkAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Deregisters a sink. (at)return E_OK on success, E_NON_EXISTENT if not found
     *   E_UNKNOWN on error
     * Calls deregisterSink with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deregisterSink(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deregisterSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterSinkAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, DeregisterSinkAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function returns the ID to the given sink name. If already a sink is
     *   registered with this name, it will return the corresponding ID, if not it will
     *   reserve an ID but not register the sink. The other parameters of the sink will
     *   be overwritten when the sink is registered. (at)return E_OK on success,
     *   E_UNKNOWN on error
     * Calls peekSink with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void peekSink(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls peekSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSinkAsync(const std::string &_name, PeekSinkAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function peeks a sink class ID. It is used by the RoutingPlugins to
     *   determine the sink class IDs of a sink class. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     * Calls peekSinkClassID with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void peekSinkClassID(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sinkClass_t &_sinkClassID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls peekSinkClassID with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSinkClassIDAsync(const std::string &_name, PeekSinkClassIDAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Updates data of a sink. (at)return E_OK on success, E_NON_EXISTENT if the sink
     *   ID is not valid.
     * Calls updateSink with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void updateSink(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_sinkClass_t &_sinkClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls updateSink with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateSinkAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_sinkClass_t &_sinkClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, UpdateSinkAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Registers a source.  If the source is part of a gateway, the list connection
     *   formats are copied to the gateway information (at)return E_OK on success,
     *   E_UNKNOWN on error, E_ALREADY_EXIST if either name or source ID already exists
     * Calls registerSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void registerSource(const ::v3::org::genivi::am_t::am_Source_s &_sourceData, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls registerSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> registerSourceAsync(const ::v3::org::genivi::am_t::am_Source_s &_sourceData, RegisterSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Deregisters a source. (at)return E_OK on success, E_NON_EXISTENT if not found
     *   E_UNKNOWN on error
     * Calls deregisterSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deregisterSource(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deregisterSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deregisterSourceAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, DeregisterSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function returns the ID to the given source name. If already a source is
     *   registered with this name, it will return the corresponding ID, if not it will
     *   reserve an ID but not register the source. The other parameters of the source
     *   will be overwritten when the source is registered. (at)return E_OK on success,
     *   E_UNKNOWN on error
     * Calls peekSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void peekSource(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls peekSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSourceAsync(const std::string &_name, PeekSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Peeks a source class ID. It is used by the RoutingPlugins to determine the
     *   source class IDs of a source class. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     * Calls peekSourceClassID with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void peekSourceClassID(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sourceClass_t &_sourceClassID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls peekSourceClassID with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> peekSourceClassIDAsync(const std::string &_name, PeekSourceClassIDAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Updates data of a source. (at)return E_OK on success, E_NON_EXISTENT if the
     *   source ID in the struct is not valid.  Please note that only the following
     *   data out of am_Source_s have effect when they are changed: sourceClassID,
     *   listSoundProperties, listConnectionFormats, listMainSoundProperties
     * Calls updateSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void updateSource(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sourceClass_t &_sourceClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls updateSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateSourceAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sourceClass_t &_sourceClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, UpdateSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Is called when a low level interrupt changes it status.
     * Calls hookInterruptStatusChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookInterruptStatusChange(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_InterruptState_e &_interruptState, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hookInterruptStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookInterruptStatusChangeAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_InterruptState_e &_interruptState, HookInterruptStatusChangeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This hook is called when all elements from a domain are registered. Is used by
     *   the Controller to know when all expected domains are finally registered.
     * Calls hookDomainRegistrationComplete with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookDomainRegistrationComplete(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hookDomainRegistrationComplete with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookDomainRegistrationCompleteAsync(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, HookDomainRegistrationCompleteAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Is called when a sink changes its availability.
     * Calls hookSinkAvailablityStatusChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookSinkAvailablityStatusChange(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hookSinkAvailablityStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSinkAvailablityStatusChangeAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, HookSinkAvailablityStatusChangeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Is called when a source changes its availability.
     * Calls hookSourceAvailablityStatusChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookSourceAvailablityStatusChange(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hookSourceAvailablityStatusChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookSourceAvailablityStatusChangeAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, HookSourceAvailablityStatusChangeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Is called when a domain changes its status. This used for early domains only.
     * Calls hookDomainStateChange with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hookDomainStateChange(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, const ::v3::org::genivi::am_t::am_DomainState_e &_domainState, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hookDomainStateChange with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hookDomainStateChangeAsync(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, const ::v3::org::genivi::am_t::am_DomainState_e &_domainState, HookDomainStateChangeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function is used to send out all data that has been changed in an early
     *   state.
     * Calls sendChangedData with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendChangedData(const ::v3::org::genivi::am_t::am_EarlyData_L &_earlyData, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendChangedData with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendChangedDataAsync(const ::v3::org::genivi::am_t::am_EarlyData_L &_earlyData, SendChangedDataAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls writeToDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void writeToDevice(const uint32_t &_devAddr, const uint32_t &_dataSize, const CommonAPI::ByteBuffer &_data, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls writeToDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> writeToDeviceAsync(const uint32_t &_devAddr, const uint32_t &_dataSize, const CommonAPI::ByteBuffer &_data, WriteToDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls readFromDevice with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void readFromDevice(const uint32_t &_devAddr, const uint32_t &_dataSize, CommonAPI::CallStatus &_internalCallStatus, CommonAPI::ByteBuffer &_data, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls readFromDevice with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> readFromDeviceAsync(const uint32_t &_devAddr, const uint32_t &_dataSize, ReadFromDeviceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setFilter with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setFilter(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, const CommonAPI::ByteBuffer &_data, const uint32_t &_dataSize, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setFilter with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setFilterAsync(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, const CommonAPI::ByteBuffer &_data, const uint32_t &_dataSize, SetFilterAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getFilter with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getFilter(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, CommonAPI::CallStatus &_internalCallStatus, CommonAPI::ByteBuffer &_data, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getFilter with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getFilterAsync(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, GetFilterAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setLimiter with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setLimiter(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, const CommonAPI::ByteBuffer &_data, const uint32_t &_dataSize, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setLimiter with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setLimiterAsync(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, const CommonAPI::ByteBuffer &_data, const uint32_t &_dataSize, SetLimiterAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getLimiter with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getLimiter(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, CommonAPI::CallStatus &_internalCallStatus, CommonAPI::ByteBuffer &_data, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getLimiter with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getLimiterAsync(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, GetLimiterAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setVolume with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setVolume(const uint16_t &_sinkID, const uint8_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setVolumeAsync(const uint16_t &_sinkID, const uint8_t &_volume, SetVolumeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getVolume with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getVolume(CommonAPI::CallStatus &_internalCallStatus, uint8_t &_volume, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getVolumeAsync(GetVolumeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setChannelMute with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setChannelMute(const uint8_t &_channelIndex, const ::v3::org::genivi::am_t::am_MuteState_e &_muteState, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setChannelMute with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setChannelMuteAsync(const uint8_t &_channelIndex, const ::v3::org::genivi::am_t::am_MuteState_e &_muteState, SetChannelMuteAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setChannelPhase with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setChannelPhase(const uint8_t &_channelIndex, const bool &_phase, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setChannelPhase with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setChannelPhaseAsync(const uint8_t &_channelIndex, const bool &_phase, SetChannelPhaseAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setBMT with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setBMT(const int8_t &_bass, const int8_t &_mid, const int8_t &_treble, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setBMT with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setBMTAsync(const int8_t &_bass, const int8_t &_mid, const int8_t &_treble, SetBMTAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBMT with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getBMT(CommonAPI::CallStatus &_internalCallStatus, int8_t &_bass, int8_t &_mid, int8_t &_treble, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBMT with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getBMTAsync(GetBMTAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function send parameters of limiter. If there is no error it will return
     *   0. If not it will return -1.
     * Calls sendLimiter with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendLimiter(const ::v3::org::genivi::am_t::hq_limiterStruct_param &_limiter, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_hqError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendLimiter with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendLimiterAsync(const ::v3::org::genivi::am_t::hq_limiterStruct_param &_limiter, SendLimiterAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function send parameters of EQ filter. If there is no error it will return
     *   0. If not it will return -1.
     * Calls sendEQFilter with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendEQFilter(const ::v3::org::genivi::am_t::hq_eqFilterStruct_param &_bsFilter, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendEQFilter with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendEQFilterAsync(const ::v3::org::genivi::am_t::hq_eqFilterStruct_param &_bsFilter, SendEQFilterAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function send parameters of delay time. If there is no error it will
     *   return 0. If not it will return -1.
     * Calls sendDelayTime with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendDelayTime(const ::v3::org::genivi::am_t::hq_delayTimeStruct_param &_delayTime, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendDelayTime with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendDelayTimeAsync(const ::v3::org::genivi::am_t::hq_delayTimeStruct_param &_delayTime, SendDelayTimeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function send parameters of ClariFi. If there is no error it will return
     *   0. If not it will return -1.
     * Calls sendClariFi with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendClariFi(const ::v3::org::genivi::am_t::hq_ClariFiStruct_param &_bs, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendClariFi with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendClariFiAsync(const ::v3::org::genivi::am_t::hq_ClariFiStruct_param &_bs, SendClariFiAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function send parameters of loudness. If there is no error it will return
     *   0. If not it will return -1.
     * Calls sendLoudness with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendLoudness(const ::v3::org::genivi::am_t::hq_londnessStruct_param &_bs, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendLoudness with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendLoudnessAsync(const ::v3::org::genivi::am_t::hq_londnessStruct_param &_bs, SendLoudnessAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function send parameters of channel gain. If there is no error it will
     *   return 0. If not it will return -1.
     * Calls sendChannelGain with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendChannelGain(const ::v3::org::genivi::am_t::hq_channelGainStruct_param &_bs, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendChannelGain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendChannelGainAsync(const ::v3::org::genivi::am_t::hq_channelGainStruct_param &_bs, SendChannelGainAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function send parameters of maximum volume of source. If there is no error
     *   it will return 0. If not it will return -1.
     * Calls sendVolumeMax with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendVolumeMax(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendVolumeMax with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendVolumeMaxAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeMaxAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function send parameters of minimum volume of source. If there is no error
     *   it will return 0. If not it will return -1.
     * Calls sendVolumeMin with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendVolumeMin(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendVolumeMin with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendVolumeMinAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeMinAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function send parameters of absolute volume of source. If there is no
     *   error it will return 0. If not it will return -1.
     * Calls sendVolumeAbs with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendVolumeAbs(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendVolumeAbs with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendVolumeAbsAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeAbsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function send parameters of ratio volume of source. If there is no error
     *   it will return 0. If not it will return -1.
     * Calls sendVolumeRatio with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendVolumeRatio(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendVolumeRatio with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendVolumeRatioAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeRatioAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function save tuning data into configuration file. If there is no error it
     *   will return 0. If not it will return -1.
     * Calls saveDataToFile with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void saveDataToFile(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls saveDataToFile with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> saveDataToFileAsync(SaveDataToFileAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<RoutingControlObserverProxyBase> delegate_;
};

typedef RoutingControlObserverProxy<> RoutingControlObserverProxyDefault;

namespace RoutingControlObserverExtensions {
    /**
     * description: This attribute signals the current routing state to the clients. A client
     *   should notify himself to this attribute in order to know the current state and
     *   act accordingly.
     */
    template <template <typename > class _ExtensionType>
    class RoutingReadyAttributeExtension {
     public:
        typedef _ExtensionType<RoutingControlObserverProxyBase::RoutingReadyAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<RoutingControlObserverProxyBase::RoutingReadyAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        RoutingReadyAttributeExtension() {}
    #endif
    
        RoutingReadyAttributeExtension(RoutingControlObserverProxyBase& proxy): attributeExtension_(proxy.getRoutingReadyAttribute()) {
        }
    
        inline extension_type& getRoutingReadyAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace RoutingControlObserverExtensions

//
// RoutingControlObserverProxy Implementation
//
template <typename ... _AttributeExtensions>
RoutingControlObserverProxy<_AttributeExtensions...>::RoutingControlObserverProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<RoutingControlObserverProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
RoutingControlObserverProxy<_AttributeExtensions...>::~RoutingControlObserverProxy() {
}

/**
 * description: Registers a domain. (at)return E_OK on success, E_ALREADY_EXISTENT if already
 *   registered E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerDomain(const ::v3::org::genivi::am_t::am_Domain_s &_domainData, const std::string &_returnBusname, const std::string &_returnInterface, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_domainID_t &_domainID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->registerDomain(_domainData, _returnBusname, _returnInterface, _internalCallStatus, _domainID, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerDomainAsync(const ::v3::org::genivi::am_t::am_Domain_s &_domainData, const std::string &_returnBusname, const std::string &_returnInterface, RegisterDomainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->registerDomainAsync(_domainData, _returnBusname, _returnInterface, _callback, _info);
}
/**
 * description: Deregisters a domain. All sources, sinks, gateways and crossfaders from that
 *   domain will be removed as well. (at)return E_OK on success, E_NON_EXISTENT if
 *   not found E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterDomain(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->deregisterDomain(_domainID, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterDomainAsync(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, DeregisterDomainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deregisterDomainAsync(_domainID, _callback, _info);
}
/**
 * description: This function returns the ID to the given domain name. If already a domain is
 *   registered with this name, it will return the corresponding ID, if not it will
 *   reserve an ID but not register the domain. The other parameters of the domain
 *   will be overwritten when the domain is registered. (at)return E_OK on success,
 *   E_UNKNOWN on error     please use pulseAudio as the name to peek domainID. now
 *   all the sources and sinks are defined in domain pulseAudio.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekDomain(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_domainID_t &_domainID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->peekDomain(_name, _internalCallStatus, _domainID, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekDomainAsync(const std::string &_name, PeekDomainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->peekDomainAsync(_name, _callback, _info);
}
/**
 * description: Registers a sink. If the sink is part of a gateway, the list connection formats
 *   are copied to the gateway information (at)return E_OK on success,
 *   E_ALREADY_EXISTENT if already registered E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerSink(const ::v3::org::genivi::am_t::am_Sink_s &_sinkData, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->registerSink(_sinkData, _internalCallStatus, _sinkID, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerSinkAsync(const ::v3::org::genivi::am_t::am_Sink_s &_sinkData, RegisterSinkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->registerSinkAsync(_sinkData, _callback, _info);
}
/**
 * description: Deregisters a sink. (at)return E_OK on success, E_NON_EXISTENT if not found
 *   E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSink(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->deregisterSink(_sinkID, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSinkAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, DeregisterSinkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deregisterSinkAsync(_sinkID, _callback, _info);
}
/**
 * description: This function returns the ID to the given sink name. If already a sink is
 *   registered with this name, it will return the corresponding ID, if not it will
 *   reserve an ID but not register the sink. The other parameters of the sink will
 *   be overwritten when the sink is registered. (at)return E_OK on success,
 *   E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSink(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->peekSink(_name, _internalCallStatus, _sinkID, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkAsync(const std::string &_name, PeekSinkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->peekSinkAsync(_name, _callback, _info);
}
/**
 * description: This function peeks a sink class ID. It is used by the RoutingPlugins to
 *   determine the sink class IDs of a sink class. (at)return E_OK on success,
 *   E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkClassID(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sinkClass_t &_sinkClassID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->peekSinkClassID(_name, _internalCallStatus, _sinkClassID, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSinkClassIDAsync(const std::string &_name, PeekSinkClassIDAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->peekSinkClassIDAsync(_name, _callback, _info);
}
/**
 * description: Updates data of a sink. (at)return E_OK on success, E_NON_EXISTENT if the sink
 *   ID is not valid.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::updateSink(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_sinkClass_t &_sinkClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->updateSink(_sinkID, _sinkClassID, _listSoundProperties, _listConnectionFormats, _listMainSoundProperties, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateSinkAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_sinkClass_t &_sinkClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, UpdateSinkAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->updateSinkAsync(_sinkID, _sinkClassID, _listSoundProperties, _listConnectionFormats, _listMainSoundProperties, _callback, _info);
}
/**
 * description: Registers a source.  If the source is part of a gateway, the list connection
 *   formats are copied to the gateway information (at)return E_OK on success,
 *   E_UNKNOWN on error, E_ALREADY_EXIST if either name or source ID already exists
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::registerSource(const ::v3::org::genivi::am_t::am_Source_s &_sourceData, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->registerSource(_sourceData, _internalCallStatus, _sourceID, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::registerSourceAsync(const ::v3::org::genivi::am_t::am_Source_s &_sourceData, RegisterSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->registerSourceAsync(_sourceData, _callback, _info);
}
/**
 * description: Deregisters a source. (at)return E_OK on success, E_NON_EXISTENT if not found
 *   E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSource(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->deregisterSource(_sourceID, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::deregisterSourceAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, DeregisterSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deregisterSourceAsync(_sourceID, _callback, _info);
}
/**
 * description: This function returns the ID to the given source name. If already a source is
 *   registered with this name, it will return the corresponding ID, if not it will
 *   reserve an ID but not register the source. The other parameters of the source
 *   will be overwritten when the source is registered. (at)return E_OK on success,
 *   E_UNKNOWN on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSource(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->peekSource(_name, _internalCallStatus, _sourceID, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceAsync(const std::string &_name, PeekSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->peekSourceAsync(_name, _callback, _info);
}
/**
 * description: Peeks a source class ID. It is used by the RoutingPlugins to determine the
 *   source class IDs of a source class. (at)return E_OK on success,
 *   E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceClassID(const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_sourceClass_t &_sourceClassID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->peekSourceClassID(_name, _internalCallStatus, _sourceClassID, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::peekSourceClassIDAsync(const std::string &_name, PeekSourceClassIDAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->peekSourceClassIDAsync(_name, _callback, _info);
}
/**
 * description: Updates data of a source. (at)return E_OK on success, E_NON_EXISTENT if the
 *   source ID in the struct is not valid.  Please note that only the following
 *   data out of am_Source_s have effect when they are changed: sourceClassID,
 *   listSoundProperties, listConnectionFormats, listMainSoundProperties
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::updateSource(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sourceClass_t &_sourceClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->updateSource(_sourceID, _sourceClassID, _listSoundProperties, _listConnectionFormats, _listMainSoundProperties, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::updateSourceAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sourceClass_t &_sourceClassID, const ::v3::org::genivi::am_t::am_SoundProperty_L &_listSoundProperties, const ::v3::org::genivi::am_t::am_ConnectionFormat_L &_listConnectionFormats, const ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listMainSoundProperties, UpdateSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->updateSourceAsync(_sourceID, _sourceClassID, _listSoundProperties, _listConnectionFormats, _listMainSoundProperties, _callback, _info);
}
/**
 * description: Is called when a low level interrupt changes it status.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookInterruptStatusChange(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_InterruptState_e &_interruptState, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_interruptState.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->hookInterruptStatusChange(_sourceID, _interruptState, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookInterruptStatusChangeAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_InterruptState_e &_interruptState, HookInterruptStatusChangeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_interruptState.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->hookInterruptStatusChangeAsync(_sourceID, _interruptState, _callback, _info);
}
/**
 * description: This hook is called when all elements from a domain are registered. Is used by
 *   the Controller to know when all expected domains are finally registered.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainRegistrationComplete(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->hookDomainRegistrationComplete(_domainID, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainRegistrationCompleteAsync(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, HookDomainRegistrationCompleteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->hookDomainRegistrationCompleteAsync(_domainID, _callback, _info);
}
/**
 * description: Is called when a sink changes its availability.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkAvailablityStatusChange(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->hookSinkAvailablityStatusChange(_sinkID, _availability, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSinkAvailablityStatusChangeAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, HookSinkAvailablityStatusChangeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->hookSinkAvailablityStatusChangeAsync(_sinkID, _availability, _callback, _info);
}
/**
 * description: Is called when a source changes its availability.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceAvailablityStatusChange(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->hookSourceAvailablityStatusChange(_sourceID, _availability, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookSourceAvailablityStatusChangeAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_Availability_s &_availability, HookSourceAvailablityStatusChangeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->hookSourceAvailablityStatusChangeAsync(_sourceID, _availability, _callback, _info);
}
/**
 * description: Is called when a domain changes its status. This used for early domains only.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainStateChange(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, const ::v3::org::genivi::am_t::am_DomainState_e &_domainState, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_domainState.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->hookDomainStateChange(_domainID, _domainState, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::hookDomainStateChangeAsync(const ::v3::org::genivi::am_t::am_domainID_t &_domainID, const ::v3::org::genivi::am_t::am_DomainState_e &_domainState, HookDomainStateChangeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_domainState.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->hookDomainStateChangeAsync(_domainID, _domainState, _callback, _info);
}
/**
 * description: This function is used to send out all data that has been changed in an early
 *   state.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendChangedData(const ::v3::org::genivi::am_t::am_EarlyData_L &_earlyData, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->sendChangedData(_earlyData, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendChangedDataAsync(const ::v3::org::genivi::am_t::am_EarlyData_L &_earlyData, SendChangedDataAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendChangedDataAsync(_earlyData, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::writeToDevice(const uint32_t &_devAddr, const uint32_t &_dataSize, const CommonAPI::ByteBuffer &_data, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->writeToDevice(_devAddr, _dataSize, _data, _internalCallStatus, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::writeToDeviceAsync(const uint32_t &_devAddr, const uint32_t &_dataSize, const CommonAPI::ByteBuffer &_data, WriteToDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->writeToDeviceAsync(_devAddr, _dataSize, _data, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::readFromDevice(const uint32_t &_devAddr, const uint32_t &_dataSize, CommonAPI::CallStatus &_internalCallStatus, CommonAPI::ByteBuffer &_data, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->readFromDevice(_devAddr, _dataSize, _internalCallStatus, _data, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::readFromDeviceAsync(const uint32_t &_devAddr, const uint32_t &_dataSize, ReadFromDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->readFromDeviceAsync(_devAddr, _dataSize, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::setFilter(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, const CommonAPI::ByteBuffer &_data, const uint32_t &_dataSize, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->setFilter(_paramData, _paramSize, _data, _dataSize, _internalCallStatus, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::setFilterAsync(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, const CommonAPI::ByteBuffer &_data, const uint32_t &_dataSize, SetFilterAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setFilterAsync(_paramData, _paramSize, _data, _dataSize, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::getFilter(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, CommonAPI::CallStatus &_internalCallStatus, CommonAPI::ByteBuffer &_data, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->getFilter(_paramData, _paramSize, _internalCallStatus, _data, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::getFilterAsync(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, GetFilterAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getFilterAsync(_paramData, _paramSize, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::setLimiter(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, const CommonAPI::ByteBuffer &_data, const uint32_t &_dataSize, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->setLimiter(_paramData, _paramSize, _data, _dataSize, _internalCallStatus, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::setLimiterAsync(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, const CommonAPI::ByteBuffer &_data, const uint32_t &_dataSize, SetLimiterAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setLimiterAsync(_paramData, _paramSize, _data, _dataSize, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::getLimiter(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, CommonAPI::CallStatus &_internalCallStatus, CommonAPI::ByteBuffer &_data, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->getLimiter(_paramData, _paramSize, _internalCallStatus, _data, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::getLimiterAsync(const CommonAPI::ByteBuffer &_paramData, const uint32_t &_paramSize, GetLimiterAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getLimiterAsync(_paramData, _paramSize, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::setVolume(const uint16_t &_sinkID, const uint8_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->setVolume(_sinkID, _volume, _internalCallStatus, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::setVolumeAsync(const uint16_t &_sinkID, const uint8_t &_volume, SetVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setVolumeAsync(_sinkID, _volume, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::getVolume(CommonAPI::CallStatus &_internalCallStatus, uint8_t &_volume, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->getVolume(_internalCallStatus, _volume, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::getVolumeAsync(GetVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getVolumeAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::setChannelMute(const uint8_t &_channelIndex, const ::v3::org::genivi::am_t::am_MuteState_e &_muteState, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    if (!_muteState.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setChannelMute(_channelIndex, _muteState, _internalCallStatus, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::setChannelMuteAsync(const uint8_t &_channelIndex, const ::v3::org::genivi::am_t::am_MuteState_e &_muteState, SetChannelMuteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_muteState.validate()) {
        ::v3::org::genivi::am_t::am_Error_e eqToolError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, eqToolError);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setChannelMuteAsync(_channelIndex, _muteState, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::setChannelPhase(const uint8_t &_channelIndex, const bool &_phase, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->setChannelPhase(_channelIndex, _phase, _internalCallStatus, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::setChannelPhaseAsync(const uint8_t &_channelIndex, const bool &_phase, SetChannelPhaseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setChannelPhaseAsync(_channelIndex, _phase, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::setBMT(const int8_t &_bass, const int8_t &_mid, const int8_t &_treble, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->setBMT(_bass, _mid, _treble, _internalCallStatus, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::setBMTAsync(const int8_t &_bass, const int8_t &_mid, const int8_t &_treble, SetBMTAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setBMTAsync(_bass, _mid, _treble, _callback, _info);
}
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::getBMT(CommonAPI::CallStatus &_internalCallStatus, int8_t &_bass, int8_t &_mid, int8_t &_treble, ::v3::org::genivi::am_t::am_Error_e &_eqToolError, const CommonAPI::CallInfo *_info) {
    delegate_->getBMT(_internalCallStatus, _bass, _mid, _treble, _eqToolError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::getBMTAsync(GetBMTAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getBMTAsync(_callback, _info);
}
/**
 * description: This function send parameters of limiter. If there is no error it will return
 *   0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendLimiter(const ::v3::org::genivi::am_t::hq_limiterStruct_param &_limiter, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_hqError, const CommonAPI::CallInfo *_info) {
    delegate_->sendLimiter(_limiter, _internalCallStatus, _hqError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendLimiterAsync(const ::v3::org::genivi::am_t::hq_limiterStruct_param &_limiter, SendLimiterAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendLimiterAsync(_limiter, _callback, _info);
}
/**
 * description: This function send parameters of EQ filter. If there is no error it will return
 *   0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendEQFilter(const ::v3::org::genivi::am_t::hq_eqFilterStruct_param &_bsFilter, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
    delegate_->sendEQFilter(_bsFilter, _internalCallStatus, _qhError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendEQFilterAsync(const ::v3::org::genivi::am_t::hq_eqFilterStruct_param &_bsFilter, SendEQFilterAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendEQFilterAsync(_bsFilter, _callback, _info);
}
/**
 * description: This function send parameters of delay time. If there is no error it will
 *   return 0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendDelayTime(const ::v3::org::genivi::am_t::hq_delayTimeStruct_param &_delayTime, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
    delegate_->sendDelayTime(_delayTime, _internalCallStatus, _qhError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendDelayTimeAsync(const ::v3::org::genivi::am_t::hq_delayTimeStruct_param &_delayTime, SendDelayTimeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendDelayTimeAsync(_delayTime, _callback, _info);
}
/**
 * description: This function send parameters of ClariFi. If there is no error it will return
 *   0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendClariFi(const ::v3::org::genivi::am_t::hq_ClariFiStruct_param &_bs, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
    delegate_->sendClariFi(_bs, _internalCallStatus, _qhError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendClariFiAsync(const ::v3::org::genivi::am_t::hq_ClariFiStruct_param &_bs, SendClariFiAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendClariFiAsync(_bs, _callback, _info);
}
/**
 * description: This function send parameters of loudness. If there is no error it will return
 *   0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendLoudness(const ::v3::org::genivi::am_t::hq_londnessStruct_param &_bs, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
    delegate_->sendLoudness(_bs, _internalCallStatus, _qhError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendLoudnessAsync(const ::v3::org::genivi::am_t::hq_londnessStruct_param &_bs, SendLoudnessAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendLoudnessAsync(_bs, _callback, _info);
}
/**
 * description: This function send parameters of channel gain. If there is no error it will
 *   return 0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendChannelGain(const ::v3::org::genivi::am_t::hq_channelGainStruct_param &_bs, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
    delegate_->sendChannelGain(_bs, _internalCallStatus, _qhError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendChannelGainAsync(const ::v3::org::genivi::am_t::hq_channelGainStruct_param &_bs, SendChannelGainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendChannelGainAsync(_bs, _callback, _info);
}
/**
 * description: This function send parameters of maximum volume of source. If there is no error
 *   it will return 0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendVolumeMax(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
    delegate_->sendVolumeMax(_sourceID, _volume, _internalCallStatus, _qhError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendVolumeMaxAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeMaxAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendVolumeMaxAsync(_sourceID, _volume, _callback, _info);
}
/**
 * description: This function send parameters of minimum volume of source. If there is no error
 *   it will return 0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendVolumeMin(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
    delegate_->sendVolumeMin(_sourceID, _volume, _internalCallStatus, _qhError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendVolumeMinAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeMinAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendVolumeMinAsync(_sourceID, _volume, _callback, _info);
}
/**
 * description: This function send parameters of absolute volume of source. If there is no
 *   error it will return 0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendVolumeAbs(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
    delegate_->sendVolumeAbs(_sourceID, _volume, _internalCallStatus, _qhError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendVolumeAbsAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeAbsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendVolumeAbsAsync(_sourceID, _volume, _callback, _info);
}
/**
 * description: This function send parameters of ratio volume of source. If there is no error
 *   it will return 0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::sendVolumeRatio(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
    delegate_->sendVolumeRatio(_sourceID, _volume, _internalCallStatus, _qhError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::sendVolumeRatioAsync(const ::v3::org::genivi::am_t::hq_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::hq_volume_t &_volume, SendVolumeRatioAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendVolumeRatioAsync(_sourceID, _volume, _callback, _info);
}
/**
 * description: This function save tuning data into configuration file. If there is no error it
 *   will return 0. If not it will return -1.
 */
template <typename ... _AttributeExtensions>
void RoutingControlObserverProxy<_AttributeExtensions...>::saveDataToFile(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_qhError, const CommonAPI::CallInfo *_info) {
    delegate_->saveDataToFile(_internalCallStatus, _qhError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingControlObserverProxy<_AttributeExtensions...>::saveDataToFileAsync(SaveDataToFileAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->saveDataToFileAsync(_callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &RoutingControlObserverProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool RoutingControlObserverProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool RoutingControlObserverProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& RoutingControlObserverProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& RoutingControlObserverProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace routinginterface
} // namespace am
} // namespace genivi
} // namespace org
} // namespace v3

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v3::org::genivi::am::routinginterface::RoutingControlObserverProxy,
    _AttributeExtension> {
    typedef typename ::v3::org::genivi::am::routinginterface::RoutingControlObserverProxy<
            ::v3::org::genivi::am::routinginterface::RoutingControlObserverExtensions::RoutingReadyAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v3_7 = v3;

#endif // V3_ORG_GENIVI_AM_ROUTINGINTERFACE_Routing_Control_Observer_PROXY_HPP_
