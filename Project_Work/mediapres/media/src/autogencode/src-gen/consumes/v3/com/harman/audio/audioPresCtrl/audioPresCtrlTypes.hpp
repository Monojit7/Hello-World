/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V3_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Types_HPP_
#define V3_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v3 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

struct audioPresCtrlTypes {
    typedef uint16_t SourceId;
    
    struct eEntertainmentSrcs : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SRC_ENT_UNKNOWN = 0,
            SRC_TUNER_FM = 35,
            SRC_TUNER_AM = 36,
            SRC_TUNER_DAB = 37,
            SRC_TUNER_LW = 39,
            SRC_TUNER_MW = 40,
            SRC_TUNER_SW = 41,
            SRC_TUNER_WB = 42,
            SRC_TUNER_SDARS = 43,
            SRC_CDA = 45,
            SRC_DVDA = 48,
            SRC_DVDV = 50,
            SRC_USB1 = 55,
            SRC_USB2 = 56,
            SRC_SD_CARD = 57,
            SRC_AUDIO_AUX = 60,
            SRC_BT_A2DP1 = 65,
            SRC_BT_A2DP2 = 66,
            SRC_CARPLAY_MEDIA = 76,
            SRC_GAL_MEDIA = 77,
            SRC_CARLIFE_MEDIA = 78,
            SRC_MIRRORLINK_MEDIA = 79,
            SRC_IPOD1 = 82,
            SRC_APPLINK_MEDIA = 88,
            SRC_AUDIO_OFF = 97,
            SRC_TUNER_DRM = 98,
            SRC_SAL_MEDIA = 100,
            SRC_SAL_MEDIA_USB = 105,
            SRC_IPOD2 = 108,
            SRC_APP1 = 501,
            SRC_APP2 = 502,
            SRC_APP3 = 503,
            SRC_APP4 = 504,
            SRC_APP5 = 505,
            SRC_APP6 = 506,
            SRC_APP7 = 507,
            SRC_APP8 = 508,
            SRC_APP9 = 509,
            SRC_APP10 = 510,
            SRC_APP11 = 511,
            SRC_APP12 = 512,
            SRC_APP13 = 513,
            SRC_APP14 = 514,
            SRC_APP15 = 515,
            SRC_APP16 = 516,
            SRC_APP17 = 517,
            SRC_APP18 = 518,
            SRC_APP19 = 519,
            SRC_APP20 = 520,
            SRC_APP21 = 521,
            SRC_APP22 = 522,
            SRC_APP23 = 523,
            SRC_APP24 = 524,
            SRC_APP25 = 525,
            SRC_APP26 = 526,
            SRC_APP27 = 527,
            SRC_APP28 = 528,
            SRC_APP29 = 529,
            SRC_APP30 = 530,
            SRC_APP31 = 531,
            SRC_APP32 = 532,
            SRC_APP33 = 533,
            SRC_APP34 = 534,
            SRC_APP35 = 535,
            SRC_APP36 = 536,
            SRC_APP37 = 537,
            SRC_APP38 = 538,
            SRC_APP39 = 539,
            SRC_APP40 = 540,
            SRC_APP41 = 541,
            SRC_APP42 = 542,
            SRC_APP43 = 543,
            SRC_APP44 = 544,
            SRC_APP45 = 545,
            SRC_APP46 = 546,
            SRC_APP47 = 547,
            SRC_APP48 = 548,
            SRC_APP49 = 549,
            SRC_APP50 = 550
        };
        
        eEntertainmentSrcs() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SRC_ENT_UNKNOWN)) {}
        eEntertainmentSrcs(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SRC_ENT_UNKNOWN):
                case static_cast<int32_t>(Literal::SRC_TUNER_FM):
                case static_cast<int32_t>(Literal::SRC_TUNER_AM):
                case static_cast<int32_t>(Literal::SRC_TUNER_DAB):
                case static_cast<int32_t>(Literal::SRC_TUNER_LW):
                case static_cast<int32_t>(Literal::SRC_TUNER_MW):
                case static_cast<int32_t>(Literal::SRC_TUNER_SW):
                case static_cast<int32_t>(Literal::SRC_TUNER_WB):
                case static_cast<int32_t>(Literal::SRC_TUNER_SDARS):
                case static_cast<int32_t>(Literal::SRC_CDA):
                case static_cast<int32_t>(Literal::SRC_DVDA):
                case static_cast<int32_t>(Literal::SRC_DVDV):
                case static_cast<int32_t>(Literal::SRC_USB1):
                case static_cast<int32_t>(Literal::SRC_USB2):
                case static_cast<int32_t>(Literal::SRC_SD_CARD):
                case static_cast<int32_t>(Literal::SRC_AUDIO_AUX):
                case static_cast<int32_t>(Literal::SRC_BT_A2DP1):
                case static_cast<int32_t>(Literal::SRC_BT_A2DP2):
                case static_cast<int32_t>(Literal::SRC_CARPLAY_MEDIA):
                case static_cast<int32_t>(Literal::SRC_GAL_MEDIA):
                case static_cast<int32_t>(Literal::SRC_CARLIFE_MEDIA):
                case static_cast<int32_t>(Literal::SRC_MIRRORLINK_MEDIA):
                case static_cast<int32_t>(Literal::SRC_IPOD1):
                case static_cast<int32_t>(Literal::SRC_APPLINK_MEDIA):
                case static_cast<int32_t>(Literal::SRC_AUDIO_OFF):
                case static_cast<int32_t>(Literal::SRC_TUNER_DRM):
                case static_cast<int32_t>(Literal::SRC_SAL_MEDIA):
                case static_cast<int32_t>(Literal::SRC_SAL_MEDIA_USB):
                case static_cast<int32_t>(Literal::SRC_IPOD2):
                case static_cast<int32_t>(Literal::SRC_APP1):
                case static_cast<int32_t>(Literal::SRC_APP2):
                case static_cast<int32_t>(Literal::SRC_APP3):
                case static_cast<int32_t>(Literal::SRC_APP4):
                case static_cast<int32_t>(Literal::SRC_APP5):
                case static_cast<int32_t>(Literal::SRC_APP6):
                case static_cast<int32_t>(Literal::SRC_APP7):
                case static_cast<int32_t>(Literal::SRC_APP8):
                case static_cast<int32_t>(Literal::SRC_APP9):
                case static_cast<int32_t>(Literal::SRC_APP10):
                case static_cast<int32_t>(Literal::SRC_APP11):
                case static_cast<int32_t>(Literal::SRC_APP12):
                case static_cast<int32_t>(Literal::SRC_APP13):
                case static_cast<int32_t>(Literal::SRC_APP14):
                case static_cast<int32_t>(Literal::SRC_APP15):
                case static_cast<int32_t>(Literal::SRC_APP16):
                case static_cast<int32_t>(Literal::SRC_APP17):
                case static_cast<int32_t>(Literal::SRC_APP18):
                case static_cast<int32_t>(Literal::SRC_APP19):
                case static_cast<int32_t>(Literal::SRC_APP20):
                case static_cast<int32_t>(Literal::SRC_APP21):
                case static_cast<int32_t>(Literal::SRC_APP22):
                case static_cast<int32_t>(Literal::SRC_APP23):
                case static_cast<int32_t>(Literal::SRC_APP24):
                case static_cast<int32_t>(Literal::SRC_APP25):
                case static_cast<int32_t>(Literal::SRC_APP26):
                case static_cast<int32_t>(Literal::SRC_APP27):
                case static_cast<int32_t>(Literal::SRC_APP28):
                case static_cast<int32_t>(Literal::SRC_APP29):
                case static_cast<int32_t>(Literal::SRC_APP30):
                case static_cast<int32_t>(Literal::SRC_APP31):
                case static_cast<int32_t>(Literal::SRC_APP32):
                case static_cast<int32_t>(Literal::SRC_APP33):
                case static_cast<int32_t>(Literal::SRC_APP34):
                case static_cast<int32_t>(Literal::SRC_APP35):
                case static_cast<int32_t>(Literal::SRC_APP36):
                case static_cast<int32_t>(Literal::SRC_APP37):
                case static_cast<int32_t>(Literal::SRC_APP38):
                case static_cast<int32_t>(Literal::SRC_APP39):
                case static_cast<int32_t>(Literal::SRC_APP40):
                case static_cast<int32_t>(Literal::SRC_APP41):
                case static_cast<int32_t>(Literal::SRC_APP42):
                case static_cast<int32_t>(Literal::SRC_APP43):
                case static_cast<int32_t>(Literal::SRC_APP44):
                case static_cast<int32_t>(Literal::SRC_APP45):
                case static_cast<int32_t>(Literal::SRC_APP46):
                case static_cast<int32_t>(Literal::SRC_APP47):
                case static_cast<int32_t>(Literal::SRC_APP48):
                case static_cast<int32_t>(Literal::SRC_APP49):
                case static_cast<int32_t>(Literal::SRC_APP50):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eEntertainmentSrcs &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eEntertainmentSrcs &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eEntertainmentSrcs &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eEntertainmentSrcs &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eEntertainmentSrcs &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eEntertainmentSrcs &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eSourceAvailablity : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            A_UNKNOWN = 0,
            A_AVAILABLE = 1,
            A_UNAVAILABLE = 2,
            A_INSERTED = 4
        };
        
        eSourceAvailablity() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::A_UNKNOWN)) {}
        eSourceAvailablity(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::A_UNKNOWN):
                case static_cast<int32_t>(Literal::A_AVAILABLE):
                case static_cast<int32_t>(Literal::A_UNAVAILABLE):
                case static_cast<int32_t>(Literal::A_INSERTED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eSourceAvailablity &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eSourceAvailablity &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eSourceAvailablity &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eSourceAvailablity &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eSourceAvailablity &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eSourceAvailablity &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eEntSourceType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            TYPE_TUNER = 0,
            TYPE_USB_STORAGE = 1,
            TYPE_USB_MTP = 2,
            TYPE_IPOD = 3,
            TYPE_MEDIA = 4,
            TYPE_PROJECTION = 5,
            TYPE_APPS = 6
        };
        
        eEntSourceType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::TYPE_TUNER)) {}
        eEntSourceType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::TYPE_TUNER):
                case static_cast<int32_t>(Literal::TYPE_USB_STORAGE):
                case static_cast<int32_t>(Literal::TYPE_USB_MTP):
                case static_cast<int32_t>(Literal::TYPE_IPOD):
                case static_cast<int32_t>(Literal::TYPE_MEDIA):
                case static_cast<int32_t>(Literal::TYPE_PROJECTION):
                case static_cast<int32_t>(Literal::TYPE_APPS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eEntSourceType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eEntSourceType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eEntSourceType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eEntSourceType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eEntSourceType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eEntSourceType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Data structure holding information of an entertainment source (For sources
     *   check eEntertainmentSrcs) 	NOTE: Below fields may not be applicable for all
     *   devices 	for ex:FM/AM as a source has no name unlike usb device
     */
    struct sSourceInfo : CommonAPI::Struct<eEntertainmentSrcs, eSourceAvailablity, std::string, eEntSourceType, uint8_t, std::string> {
    	
    	sSourceInfo() {
    	}
    	sSourceInfo(const eEntertainmentSrcs &_sourceID, const eSourceAvailablity &_availability, const std::string &_name, const eEntSourceType &_sourceType, const uint8_t &_id, const std::string &_info)
    	{
    		std::get<0>(values_) = _sourceID;
    		std::get<1>(values_) = _availability;
    		std::get<2>(values_) = _name;
    		std::get<3>(values_) = _sourceType;
    		std::get<4>(values_) = _id;
    		std::get<5>(values_) = _info;
    	}
    	/**
    	 * description: This is the ID of the source, it is unique in the system 	This id is used for
    	 *   all interactions with Audio pres
    	 */
    	inline const eEntertainmentSrcs &getSourceID() const { return std::get<0>(values_); }
    	inline void setSourceID(const eEntertainmentSrcs &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The availability of the source.
    	 */
    	inline const eSourceAvailablity &getAvailability() const { return std::get<1>(values_); }
    	inline void setAvailability(const eSourceAvailablity &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Source name if applicable. for example 	Media/ Projection / Apps names 	Note :
    	 *   This fields holds no significance for non media sources
    	 */
    	inline const std::string &getName() const { return std::get<2>(values_); }
    	inline void setName(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Type of the entertainemnt source , this could be used to group 	or display an
    	 *   icon
    	 */
    	inline const eEntSourceType &getSourceType() const { return std::get<3>(values_); }
    	inline void setSourceType(const eEntSourceType &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: This is the logical id of the device. if applicable. for example 	Note : 
    	 *   	1.For media devices (Usb / IPOD etc) - It is slot ID provided by the media
    	 *   pres.That way clients can 	correlate the audio src id and the device id for
    	 *   browsing use cases 	2.This has no relevance for tuner / projection / app
    	 *   sources yet
    	 */
    	inline const uint8_t &getId() const { return std::get<4>(values_); }
    	inline void setId(const uint8_t &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: This holds any extra information of the device. if applicable. for example
    	 *   	Note :  	For projection apps - It is App Id provided by projection.
    	 */
    	inline const std::string &getInfo() const { return std::get<5>(values_); }
    	inline void setInfo(const std::string &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const sSourceInfo& _other) const {
                return (getSourceID() == _other.getSourceID() && getAvailability() == _other.getAvailability() && getName() == _other.getName() && getSourceType() == _other.getSourceType() && getId() == _other.getId() && getInfo() == _other.getInfo());
        }
    	inline bool operator!=(const sSourceInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::unordered_map<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceInfo, CommonAPI::EnumHasher<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs>> mEntSrcsInfo;
    typedef std::unordered_map<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId, bool> mBeepStatus;
    
    struct eAudioPresErrors : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SUCCESS = 0,
            FAILURE = 1,
            INVALID_REQUEST = 2,
            SOURCE_UNAVAILABLE = 3,
            SOURCE_ALREADY_ACTIVE = 4
        };
        
        eAudioPresErrors() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SUCCESS)) {}
        eAudioPresErrors(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SUCCESS):
                case static_cast<int32_t>(Literal::FAILURE):
                case static_cast<int32_t>(Literal::INVALID_REQUEST):
                case static_cast<int32_t>(Literal::SOURCE_UNAVAILABLE):
                case static_cast<int32_t>(Literal::SOURCE_ALREADY_ACTIVE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eAudioPresErrors &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eAudioPresErrors &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eAudioPresErrors &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eAudioPresErrors &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eAudioPresErrors &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eAudioPresErrors &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eInterruptSrcs : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SRC_SERVICE_CALL = 1,
            SRC_VOICERECORDER = 2,
            SRC_TTS = 4,
            SRC_NAV = 5,
            SRC_ETC_WARNING = 6,
            SRC_ETC_INFO = 7,
            SRC_TEL_HANDSFREE = 8,
            SRC_TEL_RINGING = 9,
            SRC_CARPLAY_PHONE = 10,
            SRC_CARPLAYPHONE_RINGING = 11,
            SRC_CARPLAY_SIRI = 12,
            SRC_CARPLAY_ALT = 13,
            SRC_GAL_VOICE = 16,
            SRC_GAL_NAVI = 17,
            SRC_GAL_UI = 18,
            SRC_GAL_VR = 19,
            SRC_CARLIFE_NAVI = 22,
            SRC_CARLIFE_VR = 23,
            SRC_MIRRORLINK_VR = 24,
            SRC_APPLINK_NAVI = 89,
            SRC_APPLINK_VR = 90,
            SRC_APPLINK_TTS = 99,
            SRC_TUNER_TA = 33,
            SRC_TUNER_DAB_TA = 34,
            SRC_MANUAL_MUTE = 87,
            SRC_KEYPADTOUCH = 30,
            SRC_ECALL_PHONE = 91,
            SRC_ECALL_PROMPT = 92,
            SRC_MIC = 95,
            SRC_TESTTONE = 96,
            SRC_TOUCHBEEP = 31,
            SRC_CONFIRMATION = 27,
            SRC_INDICATION = 28,
            SRC_WARNING = 29,
            SRC_RECORDED_PLAYBACK = 104,
            SRC_TUNER_PTY_NEWS = 106,
            SRC_INTERRUPT_UNKNOWN = 562
        };
        
        eInterruptSrcs() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SRC_SERVICE_CALL)) {}
        eInterruptSrcs(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SRC_SERVICE_CALL):
                case static_cast<int32_t>(Literal::SRC_VOICERECORDER):
                case static_cast<int32_t>(Literal::SRC_TTS):
                case static_cast<int32_t>(Literal::SRC_NAV):
                case static_cast<int32_t>(Literal::SRC_ETC_WARNING):
                case static_cast<int32_t>(Literal::SRC_ETC_INFO):
                case static_cast<int32_t>(Literal::SRC_TEL_HANDSFREE):
                case static_cast<int32_t>(Literal::SRC_TEL_RINGING):
                case static_cast<int32_t>(Literal::SRC_CARPLAY_PHONE):
                case static_cast<int32_t>(Literal::SRC_CARPLAYPHONE_RINGING):
                case static_cast<int32_t>(Literal::SRC_CARPLAY_SIRI):
                case static_cast<int32_t>(Literal::SRC_CARPLAY_ALT):
                case static_cast<int32_t>(Literal::SRC_GAL_VOICE):
                case static_cast<int32_t>(Literal::SRC_GAL_NAVI):
                case static_cast<int32_t>(Literal::SRC_GAL_UI):
                case static_cast<int32_t>(Literal::SRC_GAL_VR):
                case static_cast<int32_t>(Literal::SRC_CARLIFE_NAVI):
                case static_cast<int32_t>(Literal::SRC_CARLIFE_VR):
                case static_cast<int32_t>(Literal::SRC_MIRRORLINK_VR):
                case static_cast<int32_t>(Literal::SRC_APPLINK_NAVI):
                case static_cast<int32_t>(Literal::SRC_APPLINK_VR):
                case static_cast<int32_t>(Literal::SRC_APPLINK_TTS):
                case static_cast<int32_t>(Literal::SRC_TUNER_TA):
                case static_cast<int32_t>(Literal::SRC_TUNER_DAB_TA):
                case static_cast<int32_t>(Literal::SRC_MANUAL_MUTE):
                case static_cast<int32_t>(Literal::SRC_KEYPADTOUCH):
                case static_cast<int32_t>(Literal::SRC_ECALL_PHONE):
                case static_cast<int32_t>(Literal::SRC_ECALL_PROMPT):
                case static_cast<int32_t>(Literal::SRC_MIC):
                case static_cast<int32_t>(Literal::SRC_TESTTONE):
                case static_cast<int32_t>(Literal::SRC_TOUCHBEEP):
                case static_cast<int32_t>(Literal::SRC_CONFIRMATION):
                case static_cast<int32_t>(Literal::SRC_INDICATION):
                case static_cast<int32_t>(Literal::SRC_WARNING):
                case static_cast<int32_t>(Literal::SRC_RECORDED_PLAYBACK):
                case static_cast<int32_t>(Literal::SRC_TUNER_PTY_NEWS):
                case static_cast<int32_t>(Literal::SRC_INTERRUPT_UNKNOWN):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eInterruptSrcs &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eInterruptSrcs &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eInterruptSrcs &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eInterruptSrcs &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eInterruptSrcs &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eInterruptSrcs &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eToggleDirection : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            PREVIOUS = 0,
            NEXT = 1
        };
        
        eToggleDirection() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::PREVIOUS)) {}
        eToggleDirection(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::PREVIOUS):
                case static_cast<int32_t>(Literal::NEXT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eToggleDirection &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eToggleDirection &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eToggleDirection &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eToggleDirection &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eToggleDirection &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eToggleDirection &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eUserOption : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            EQ_LIST = 0,
            TOUCH_BEEP_LIST = 1,
            KEYPAD_BEEP_LIST = 2
        };
        
        eUserOption() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::EQ_LIST)) {}
        eUserOption(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::EQ_LIST):
                case static_cast<int32_t>(Literal::TOUCH_BEEP_LIST):
                case static_cast<int32_t>(Literal::KEYPAD_BEEP_LIST):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eUserOption &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eUserOption &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eUserOption &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eUserOption &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eUserOption &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eUserOption &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct sSourceType : CommonAPI::Struct<eEntertainmentSrcs, eSourceAvailablity> {
    	
    	sSourceType() {
    	}
    	sSourceType(const eEntertainmentSrcs &_sourceID, const eSourceAvailablity &_availability)
    	{
    		std::get<0>(values_) = _sourceID;
    		std::get<1>(values_) = _availability;
    	}
    	/**
    	 * description: This is the ID of the source, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sourceID_e.
    	 */
    	inline const eEntertainmentSrcs &getSourceID() const { return std::get<0>(values_); }
    	inline void setSourceID(const eEntertainmentSrcs &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The availability of the source.
    	 */
    	inline const eSourceAvailablity &getAvailability() const { return std::get<1>(values_); }
    	inline void setAvailability(const eSourceAvailablity &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const sSourceType& _other) const {
                return (getSourceID() == _other.getSourceID() && getAvailability() == _other.getAvailability());
        }
    	inline bool operator!=(const sSourceType &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct sSourceVolume : CommonAPI::Struct<uint16_t, SourceId> {
    	
    	sSourceVolume() {
    	}
    	sSourceVolume(const uint16_t &_absoluteVolume, const SourceId &_sourceID)
    	{
    		std::get<0>(values_) = _absoluteVolume;
    		std::get<1>(values_) = _sourceID;
    	}
    	/**
    	 * description: Absolute volume of requested Source.
    	 */
    	inline const uint16_t &getAbsoluteVolume() const { return std::get<0>(values_); }
    	inline void setAbsoluteVolume(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: This is the ID of the source, it is unique in the system. we have list all the
    	 *   sourceID enumeration in am_sourceID_e.
    	 */
    	inline const SourceId &getSourceID() const { return std::get<1>(values_); }
    	inline void setSourceID(const SourceId &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const sSourceVolume& _other) const {
                return (getAbsoluteVolume() == _other.getAbsoluteVolume() && getSourceID() == _other.getSourceID());
        }
    	inline bool operator!=(const sSourceVolume &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct eSampleRateType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            RATE_11025 = 0,
            x0 = 1,
            RATE_22050 = 0,
            x1 = 3,
            RATE_44100 = 0,
            x2 = 5
        };
        
        eSampleRateType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::RATE_11025)) {}
        eSampleRateType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::RATE_11025):
                case static_cast<int32_t>(Literal::x0):
                //case static_cast<int32_t>(Literal::RATE_22050):
                case static_cast<int32_t>(Literal::x1):
                //case static_cast<int32_t>(Literal::RATE_44100):
                case static_cast<int32_t>(Literal::x2):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eSampleRateType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eSampleRateType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eSampleRateType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eSampleRateType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eSampleRateType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eSampleRateType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef std::vector<std::string> ListItems;
    
    struct eAudioAttribute : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            FADE = 0,
            BALANCE = 1,
            BASS = 2,
            MID = 3,
            TREBLE = 4,
            EQUALIZER = 5,
            CLARIFI = 6,
            LOUDNESS = 7,
            AVCMODE = 8,
            AUXOFFSETGAIN = 9,
            MIDLOW = 10,
            MIDHIGH = 11,
            A2DPOFFSET = 12,
            MICGAIN = 13,
            ACTIVESRC_MUTE = 14,
            MASTERMUTE = 15,
            MICMUTE = 16,
            OCCUPANCY_MODE = 17,
            BEEPSTATUS = 18,
            USBAUTOPLAYSTATUS = 19
        };
        
        eAudioAttribute() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::FADE)) {}
        eAudioAttribute(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::FADE):
                case static_cast<int32_t>(Literal::BALANCE):
                case static_cast<int32_t>(Literal::BASS):
                case static_cast<int32_t>(Literal::MID):
                case static_cast<int32_t>(Literal::TREBLE):
                case static_cast<int32_t>(Literal::EQUALIZER):
                case static_cast<int32_t>(Literal::CLARIFI):
                case static_cast<int32_t>(Literal::LOUDNESS):
                case static_cast<int32_t>(Literal::AVCMODE):
                case static_cast<int32_t>(Literal::AUXOFFSETGAIN):
                case static_cast<int32_t>(Literal::MIDLOW):
                case static_cast<int32_t>(Literal::MIDHIGH):
                case static_cast<int32_t>(Literal::A2DPOFFSET):
                case static_cast<int32_t>(Literal::MICGAIN):
                case static_cast<int32_t>(Literal::ACTIVESRC_MUTE):
                case static_cast<int32_t>(Literal::MASTERMUTE):
                case static_cast<int32_t>(Literal::MICMUTE):
                case static_cast<int32_t>(Literal::OCCUPANCY_MODE):
                case static_cast<int32_t>(Literal::BEEPSTATUS):
                case static_cast<int32_t>(Literal::USBAUTOPLAYSTATUS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eAudioAttribute &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eAudioAttribute &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eAudioAttribute &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eAudioAttribute &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eAudioAttribute &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eAudioAttribute &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eResetType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            FACTORY_RESET = 0,
            SOURCE_RESET = 1
        };
        
        eResetType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::FACTORY_RESET)) {}
        eResetType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::FACTORY_RESET):
                case static_cast<int32_t>(Literal::SOURCE_RESET):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eResetType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eResetType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eResetType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eResetType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eResetType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eResetType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eDiagModeType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SPEAKER_WALKAROUND = 0,
            SPEAKER_TESTTONE = 1,
            DIAG_VOLUME_CONTROL = 2,
            SPEAKER_EXIT = 3
        };
        
        eDiagModeType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SPEAKER_WALKAROUND)) {}
        eDiagModeType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SPEAKER_WALKAROUND):
                case static_cast<int32_t>(Literal::SPEAKER_TESTTONE):
                case static_cast<int32_t>(Literal::DIAG_VOLUME_CONTROL):
                case static_cast<int32_t>(Literal::SPEAKER_EXIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eDiagModeType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eDiagModeType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eDiagModeType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eDiagModeType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eDiagModeType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eDiagModeType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eDiagSpeakerMask : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DIAG_SPEAKER_UNKNOWN = 0,
            SPEAKER_FL = 1,
            SPEAKER_FR = 2,
            SPEAKER_RL = 4,
            SPEAKER_RR = 8
        };
        
        eDiagSpeakerMask() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DIAG_SPEAKER_UNKNOWN)) {}
        eDiagSpeakerMask(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DIAG_SPEAKER_UNKNOWN):
                case static_cast<int32_t>(Literal::SPEAKER_FL):
                case static_cast<int32_t>(Literal::SPEAKER_FR):
                case static_cast<int32_t>(Literal::SPEAKER_RL):
                case static_cast<int32_t>(Literal::SPEAKER_RR):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eDiagSpeakerMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eDiagSpeakerMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eDiagSpeakerMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eDiagSpeakerMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eDiagSpeakerMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eDiagSpeakerMask &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eOccupancyModeType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            OCCUPANCY_INACTIVE = 0,
            OCCUPANCY_ALL_SEATS = 1,
            OCCUPANCY_DRIVER_SEAT = 2,
            OCCUPANCY_PASSENGER = 3,
            OCCUPANCY_FRONT_SEATS = 7,
            OCCUPANCY_REAR_SEATS = 8
        };
        
        eOccupancyModeType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::OCCUPANCY_INACTIVE)) {}
        eOccupancyModeType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::OCCUPANCY_INACTIVE):
                case static_cast<int32_t>(Literal::OCCUPANCY_ALL_SEATS):
                case static_cast<int32_t>(Literal::OCCUPANCY_DRIVER_SEAT):
                case static_cast<int32_t>(Literal::OCCUPANCY_PASSENGER):
                case static_cast<int32_t>(Literal::OCCUPANCY_FRONT_SEATS):
                case static_cast<int32_t>(Literal::OCCUPANCY_REAR_SEATS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eOccupancyModeType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eOccupancyModeType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eOccupancyModeType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eOccupancyModeType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eOccupancyModeType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eOccupancyModeType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eVolumeGroup : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            VU_UNKNOWN = 0,
            VU_UPDATE = 1,
            VU_NOUPDATE = 2,
            VU_ENT_UPDATE = 3,
            VU_VR_UPDATE = 4,
            VU_PROMPT_UPDATE = 5,
            VU_PHONE_UPDATE = 6,
            VU_TA_UPDATE = 7
        };
        
        eVolumeGroup() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::VU_UNKNOWN)) {}
        eVolumeGroup(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::VU_UNKNOWN):
                case static_cast<int32_t>(Literal::VU_UPDATE):
                case static_cast<int32_t>(Literal::VU_NOUPDATE):
                case static_cast<int32_t>(Literal::VU_ENT_UPDATE):
                case static_cast<int32_t>(Literal::VU_VR_UPDATE):
                case static_cast<int32_t>(Literal::VU_PROMPT_UPDATE):
                case static_cast<int32_t>(Literal::VU_PHONE_UPDATE):
                case static_cast<int32_t>(Literal::VU_TA_UPDATE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eVolumeGroup &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eVolumeGroup &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eVolumeGroup &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eVolumeGroup &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eVolumeGroup &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eVolumeGroup &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Holds possible data types of an attribute defined in settings fidl
     */
    typedef CommonAPI::Variant<int16_t, uint16_t, bool, std::string, mBeepStatus, eOccupancyModeType>  uAttributeValue;
    /**
     * description: map consisting of a type and value of attributes to be set
     */
    typedef std::unordered_map<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioAttribute, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::uAttributeValue, CommonAPI::EnumHasher<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioAttribute>> mAttribute;



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.audio.audioPresCtrl.audioPresCtrlTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(3, 5);
}

}; // struct audioPresCtrlTypes

} // namespace audioPresCtrl
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v3

namespace CommonAPI {
}


namespace std {
    //Hash for eAudioPresErrors
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors& eAudioPresErrors) const {
            return static_cast<int32_t>(eAudioPresErrors);
        }
    };
    //Hash for eEntertainmentSrcs
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs& eEntertainmentSrcs) const {
            return static_cast<int32_t>(eEntertainmentSrcs);
        }
    };
    //Hash for eInterruptSrcs
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs& eInterruptSrcs) const {
            return static_cast<int32_t>(eInterruptSrcs);
        }
    };
    //Hash for eSourceAvailablity
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSourceAvailablity> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSourceAvailablity& eSourceAvailablity) const {
            return static_cast<int32_t>(eSourceAvailablity);
        }
    };
    //Hash for eEntSourceType
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntSourceType> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntSourceType& eEntSourceType) const {
            return static_cast<int32_t>(eEntSourceType);
        }
    };
    //Hash for eToggleDirection
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection& eToggleDirection) const {
            return static_cast<int32_t>(eToggleDirection);
        }
    };
    //Hash for eUserOption
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption& eUserOption) const {
            return static_cast<int32_t>(eUserOption);
        }
    };
    //Hash for eSampleRateType
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType& eSampleRateType) const {
            return static_cast<int32_t>(eSampleRateType);
        }
    };
    //Hash for eAudioAttribute
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioAttribute> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioAttribute& eAudioAttribute) const {
            return static_cast<int32_t>(eAudioAttribute);
        }
    };
    //Hash for eResetType
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eResetType> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eResetType& eResetType) const {
            return static_cast<int32_t>(eResetType);
        }
    };
    //Hash for eDiagModeType
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType& eDiagModeType) const {
            return static_cast<int32_t>(eDiagModeType);
        }
    };
    //Hash for eDiagSpeakerMask
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagSpeakerMask> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagSpeakerMask& eDiagSpeakerMask) const {
            return static_cast<int32_t>(eDiagSpeakerMask);
        }
    };
    //Hash for eOccupancyModeType
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eOccupancyModeType> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eOccupancyModeType& eOccupancyModeType) const {
            return static_cast<int32_t>(eOccupancyModeType);
        }
    };
    //Hash for eVolumeGroup
    template<>
    struct hash<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eVolumeGroup> {
        inline size_t operator()(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eVolumeGroup& eVolumeGroup) const {
            return static_cast<int32_t>(eVolumeGroup);
        }
    };
}


// Compatibility
namespace v3_5 = v3;

#endif // V3_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Types_HPP_
