/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: The interface towards the Controlling Instance (e.g. HMI). It handles the
 *   communication towards the HMI and other system components who need to interact
 *   with the audio management. There are two rules that have to be kept in mind
 *   when implementing against this interface:
 * author: Christian Linke
 */
#ifndef V3_ORG_GENIVI_AM_COMMANDINTERFACE_Command_Control_PROXY_HPP_
#define V3_ORG_GENIVI_AM_COMMANDINTERFACE_Command_Control_PROXY_HPP_

#include <v3/org/genivi/am/commandinterface/CommandControlProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v3 {
namespace org {
namespace genivi {
namespace am {
namespace commandinterface {

template <typename ... _AttributeExtensions>
class CommandControlProxy
    : virtual public CommandControl, 
      virtual public CommandControlProxyBase,
      virtual public _AttributeExtensions... {
public:
    CommandControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~CommandControlProxy();

    typedef CommandControl InterfaceType;


    /**
     * description: This attribute reflects the current State of all existing main connections. 
     *   You can notify on this attribute in order to get always a consistent update of
     *   all main connections in case of a change.
     */
    /**
     * Returns the wrapper class that provides access to the attribute listOfMainConnetions.
     */
    virtual ListOfMainConnetionsAttribute& getListOfMainConnetionsAttribute() {
        return delegate_->getListOfMainConnetionsAttribute();
    }

    /**
     * description: Callback that is called when the number of connections change.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast newMainConnection.
     */
    virtual NewMainConnectionEvent& getNewMainConnectionEvent() {
        return delegate_->getNewMainConnectionEvent();
    }
    /**
     * description: Callback that is called when the number of connections change.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast removedMainConnection.
     */
    virtual RemovedMainConnectionEvent& getRemovedMainConnectionEvent() {
        return delegate_->getRemovedMainConnectionEvent();
    }
    /**
     * description: Callback that is called when the number of sinks change.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast newSink.
     */
    virtual NewSinkEvent& getNewSinkEvent() {
        return delegate_->getNewSinkEvent();
    }
    /**
     * description: Callback that is called when the number of sinks change.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast removedSink.
     */
    virtual RemovedSinkEvent& getRemovedSinkEvent() {
        return delegate_->getRemovedSinkEvent();
    }
    /**
     * description: Callback that is called when the number of sources change.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast newSource.
     */
    virtual NewSourceEvent& getNewSourceEvent() {
        return delegate_->getNewSourceEvent();
    }
    /**
     * description: Callback that is called when the number of sources change.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast removedSource.
     */
    virtual RemovedSourceEvent& getRemovedSourceEvent() {
        return delegate_->getRemovedSourceEvent();
    }
    /**
     * description: This callback is called if the number of sink classes has changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast numberOfSinkClassesChanged.
     */
    virtual NumberOfSinkClassesChangedEvent& getNumberOfSinkClassesChangedEvent() {
        return delegate_->getNumberOfSinkClassesChangedEvent();
    }
    /**
     * description: This callback is fired, if the number of source classes has changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast numberOfSourceClassesChanged.
     */
    virtual NumberOfSourceClassesChangedEvent& getNumberOfSourceClassesChangedEvent() {
        return delegate_->getNumberOfSourceClassesChangedEvent();
    }
    /**
     * description: This callback is called when the connection state of a connection changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mainConnectionStateChanged.
     */
    virtual MainConnectionStateChangedEvent& getMainConnectionStateChangedEvent() {
        return delegate_->getMainConnectionStateChangedEvent();
    }
    /**
     * description: This callback indicates that a sink sound property has changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mainSinkSoundPropertyChanged.
     */
    virtual MainSinkSoundPropertyChangedEvent& getMainSinkSoundPropertyChangedEvent() {
        return delegate_->getMainSinkSoundPropertyChangedEvent();
    }
    /**
     * description: This callback indicates that a source sound property has changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mainSourceSoundPropertyChanged.
     */
    virtual MainSourceSoundPropertyChangedEvent& getMainSourceSoundPropertyChangedEvent() {
        return delegate_->getMainSourceSoundPropertyChangedEvent();
    }
    /**
     * description: This callback is called when the availability of a sink has changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sinkAvailabilityChanged.
     */
    virtual SinkAvailabilityChangedEvent& getSinkAvailabilityChangedEvent() {
        return delegate_->getSinkAvailabilityChangedEvent();
    }
    /**
     * description: This callback is called when the availability of source has changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sourceAvailabilityChanged.
     */
    virtual SourceAvailabilityChangedEvent& getSourceAvailabilityChangedEvent() {
        return delegate_->getSourceAvailabilityChangedEvent();
    }
    /**
     * description: This callback indicates a volume change on the indicated sink.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast volumeChanged.
     */
    virtual VolumeChangedEvent& getVolumeChangedEvent() {
        return delegate_->getVolumeChangedEvent();
    }
    /**
     * description: This callback indicates a mute state change on a sink.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sinkMuteStateChanged.
     */
    virtual SinkMuteStateChangedEvent& getSinkMuteStateChangedEvent() {
        return delegate_->getSinkMuteStateChangedEvent();
    }
    /**
     * description: Is called if a system property changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast systemPropertyChanged.
     */
    virtual SystemPropertyChangedEvent& getSystemPropertyChangedEvent() {
        return delegate_->getSystemPropertyChangedEvent();
    }
    /**
     * description: This callback is called, if the timing information for a main connection ID
     *   have changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast timingInformationChanged.
     */
    virtual TimingInformationChangedEvent& getTimingInformationChangedEvent() {
        return delegate_->getTimingInformationChangedEvent();
    }
    /**
     * description: This callback is called when a sink is updated.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sinkUpdated.
     */
    virtual SinkUpdatedEvent& getSinkUpdatedEvent() {
        return delegate_->getSinkUpdatedEvent();
    }
    /**
     * description: This callback is called when a source is updated.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sourceUpdated.
     */
    virtual SourceUpdatedEvent& getSourceUpdatedEvent() {
        return delegate_->getSourceUpdatedEvent();
    }
    /**
     * description: This callback is called when a notified value of a sink changes.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sinkNotification.
     */
    virtual SinkNotificationEvent& getSinkNotificationEvent() {
        return delegate_->getSinkNotificationEvent();
    }
    /**
     * description: This callback is called when a notified value of a source changes.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sourceNotification.
     */
    virtual SourceNotificationEvent& getSourceNotificationEvent() {
        return delegate_->getSourceNotificationEvent();
    }
    /**
     * description: This callback is triggered when a main notification configuration is changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mainSinkNotificationConfigurationChanged.
     */
    virtual MainSinkNotificationConfigurationChangedEvent& getMainSinkNotificationConfigurationChangedEvent() {
        return delegate_->getMainSinkNotificationConfigurationChangedEvent();
    }
    /**
     * description: This callback is triggered when a main notification configuration is changed.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast mainSourceNotificationConfigurationChanged.
     */
    virtual MainSourceNotificationConfigurationChangedEvent& getMainSourceNotificationConfigurationChangedEvent() {
        return delegate_->getMainSourceNotificationConfigurationChangedEvent();
    }

    /**
     * description: Connects a source to sink. (at)return E_OK on success, E_NOT_POSSIBLE on
     *   failure, E_ALREADY_EXISTS if the connection does already exists
     * Calls connect with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void connect(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls connect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> connectAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, ConnectAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Disconnects a main connection. (at)return E_OK on successes, E_NON_EXISTENT if
     *   the connection does not exist, E_NOT_POSSIBLE on error.
     * Calls disconnect with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void disconnect(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls disconnect with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> disconnectAsync(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, DisconnectAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Sets the volume for a sink. (at)return E_OK on success, E_UNKNOWN on error,
     *   E_OUT_OF_RANGE in case the value is out of range
     * Calls setVolume with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setVolume(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_mainVolume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setVolumeAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_mainVolume_t &_volume, SetVolumeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This function is used to increment or decrement the current volume for a sink.
     *   (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the value
     *   is not in the given volume range.
     * Calls volumeStep with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void volumeStep(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const int16_t &_step, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls volumeStep with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> volumeStepAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const int16_t &_step, VolumeStepAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Sets the mute state of a sink. (at)return E_OK on success, E_UNKNOWN on error.
     *   If the mute state is already the desired one, the Daemon will return E_OK
     * Calls setSinkMuteState with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSinkMuteState(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MuteState_e &_muteState, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSinkMuteState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSinkMuteStateAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MuteState_e &_muteState, SetSinkMuteStateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to set sound properties, e.g. equalizer values. Since the
     *   capabilities of the system can differ, the exact key value pairs can be
     *   extended in each product. (at)return E_OK on success, E_OUT_OF_RANGE if value
     *   exceeds range, E_UNKNOWN in case of an error
     * Calls setMainSinkSoundProperty with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMainSinkSoundProperty(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMainSinkSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSinkSoundPropertyAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, SetMainSinkSoundPropertyAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to set sound properties, e.g. equalizer values. Since the
     *   capabilities of the system can differ, the exact key value pairs can be
     *   extended in each product. (at)return E_OK on success, E_OUT_OF_RANGE if value
     *   exceeds range, E_UNKNOWN in case of an error
     * Calls setMainSourceSoundProperty with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMainSourceSoundProperty(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMainSourceSoundProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSourceSoundPropertyAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, SetMainSourceSoundPropertyAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Sets a specific system property. (at)return E_OK on success, E_OUT_OF_RANGE if
     *   value exceeds range, E_UNKNOWN in case of an error
     * Calls setSystemProperty with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSystemProperty(const ::v3::org::genivi::am_t::am_SystemProperty_s &_property, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSystemProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSystemPropertyAsync(const ::v3::org::genivi::am_t::am_SystemProperty_s &_property, SetSystemPropertyAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Returns the current list of main connections. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     * Calls getListMainConnections with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainConnections(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_MainConnection_L &_listConnections, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListMainConnections with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Returns the current list of sinks. (at)return E_OK on success, E_DATABASE_ERROR
     *   on error
     * Calls getListMainSinks with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSinks(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SinkType_L &_listMainSinks, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListMainSinks with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSinksAsync(GetListMainSinksAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Returns the current list of sources. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     * Calls getListMainSources with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSources(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SourceType_L &_listMainSources, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListMainSources with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSourcesAsync(GetListMainSourcesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This is used to retrieve all sink sound properties related to a sink. Returns a
     *   vector of the sound properties and values as pair. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     * Calls getListMainSinkSoundProperties with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSinkSoundProperties(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listSoundProperties, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListMainSinkSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSinkSoundPropertiesAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, GetListMainSinkSoundPropertiesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This is used to retrieve all source sound properties related to a source.
     *   Returns a vector of the sound properties and values as pair. (at)return E_OK
     *   on success, E_DATABASE_ERROR on error
     * Calls getListMainSourceSoundProperties with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSourceSoundProperties(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listSoundProperties, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListMainSourceSoundProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSourceSoundPropertiesAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, GetListMainSourceSoundPropertiesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This is used to retrieve sink class information of all sink classes. (at)return
     *   E_OK on success, E_DATABASE_ERROR on error
     * Calls getListSinkClasses with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListSinkClasses(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SinkClass_L &_listSinkClasses, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListSinkClasses with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListSinkClassesAsync(GetListSinkClassesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This is used to retrieve source class information of all source classes.
     *   (at)return E_OK on success, E_DATABASE_ERROR on error
     * Calls getListSourceClasses with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListSourceClasses(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SourceClass_L &_listSourceClasses, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListSourceClasses with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListSourceClassesAsync(GetListSourceClassesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Retrieves a complete list of all system properties. (at)return E_OK on success,
     *   E_DATABASE_ERROR on error
     * Calls getListSystemProperties with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListSystemProperties(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SystemProperty_L &_listSystemProperties, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListSystemProperties with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Returns the delay in ms that the audio path for the given main connection.
     *   (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not yet
     *   retrieved, E_DATABASE_ERROR on read error on the database
     * Calls getTimingInformation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getTimingInformation(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_timeSync_t &_delay, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getTimingInformation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getTimingInformationAsync(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, GetTimingInformationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Retrieves the list of main notifications for a sink. Does not return the
     *   possible ones.
     * Calls getListMainSinkNotificationConfigurations with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSinkNotificationConfigurations(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_NotificationConfiguration_L &_listMainNotificationConfigurations, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListMainSinkNotificationConfigurations with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSinkNotificationConfigurationsAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Retrieves the list of main notifications for a source. Does not return the
     *   possible ones.
     * Calls getListMainSourceNotificationConfigurations with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getListMainSourceNotificationConfigurations(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_NotificationConfiguration_L &_listMainNotificationConfigurations, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getListMainSourceNotificationConfigurations with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getListMainSourceNotificationConfigurationsAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Sets a MainNotificationConfiuration. This can be used to turn on an off
     *   notifications an to change the mode of the configuration. (at)return E_OK on
     *   success, E_NON_EXISTENT if sink ID does not exists, E_DATABASE_ERROR on error
     * Calls setMainSinkNotificationConfiguration with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMainSinkNotificationConfiguration(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMainSinkNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSinkNotificationConfigurationAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Sets a MainNotificationConfiuration. This can be used to turn on an off
     *   notifications an to change the mode of the configuration. (at)return E_OK on
     *   success, E_NON_EXISTENT if source ID does not exists, E_DATABASE_ERROR on error
     * Calls setMainSourceNotificationConfiguration with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMainSourceNotificationConfiguration(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMainSourceNotificationConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMainSourceNotificationConfigurationAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<CommandControlProxyBase> delegate_;
};

typedef CommandControlProxy<> CommandControlProxyDefault;

namespace CommandControlExtensions {
    /**
     * description: This attribute reflects the current State of all existing main connections. 
     *   You can notify on this attribute in order to get always a consistent update of
     *   all main connections in case of a change.
     */
    template <template <typename > class _ExtensionType>
    class ListOfMainConnetionsAttributeExtension {
     public:
        typedef _ExtensionType<CommandControlProxyBase::ListOfMainConnetionsAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<CommandControlProxyBase::ListOfMainConnetionsAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ListOfMainConnetionsAttributeExtension() {}
    #endif
    
        ListOfMainConnetionsAttributeExtension(CommandControlProxyBase& proxy): attributeExtension_(proxy.getListOfMainConnetionsAttribute()) {
        }
    
        inline extension_type& getListOfMainConnetionsAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace CommandControlExtensions

//
// CommandControlProxy Implementation
//
template <typename ... _AttributeExtensions>
CommandControlProxy<_AttributeExtensions...>::CommandControlProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<CommandControlProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
CommandControlProxy<_AttributeExtensions...>::~CommandControlProxy() {
}

/**
 * description: Connects a source to sink. (at)return E_OK on success, E_NOT_POSSIBLE on
 *   failure, E_ALREADY_EXISTS if the connection does already exists
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::connect(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->connect(_sourceID, _sinkID, _internalCallStatus, _mainConnectionID, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::connectAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, ConnectAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->connectAsync(_sourceID, _sinkID, _callback, _info);
}
/**
 * description: Disconnects a main connection. (at)return E_OK on successes, E_NON_EXISTENT if
 *   the connection does not exist, E_NOT_POSSIBLE on error.
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::disconnect(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->disconnect(_mainConnectionID, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::disconnectAsync(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, DisconnectAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->disconnectAsync(_mainConnectionID, _callback, _info);
}
/**
 * description: Sets the volume for a sink. (at)return E_OK on success, E_UNKNOWN on error,
 *   E_OUT_OF_RANGE in case the value is out of range
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setVolume(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_mainVolume_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->setVolume(_sinkID, _volume, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setVolumeAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_mainVolume_t &_volume, SetVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setVolumeAsync(_sinkID, _volume, _callback, _info);
}
/**
 * description: This function is used to increment or decrement the current volume for a sink.
 *   (at)return E_OK on success, E_UNKNOWN on error and E_OUT_OF_RANGE if the value
 *   is not in the given volume range.
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::volumeStep(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const int16_t &_step, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->volumeStep(_sinkID, _step, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::volumeStepAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const int16_t &_step, VolumeStepAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->volumeStepAsync(_sinkID, _step, _callback, _info);
}
/**
 * description: Sets the mute state of a sink. (at)return E_OK on success, E_UNKNOWN on error.
 *   If the mute state is already the desired one, the Daemon will return E_OK
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setSinkMuteState(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MuteState_e &_muteState, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    if (!_muteState.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setSinkMuteState(_sinkID, _muteState, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setSinkMuteStateAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MuteState_e &_muteState, SetSinkMuteStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_muteState.validate()) {
        ::v3::org::genivi::am_t::am_Error_e amError = ::v3::org::genivi::am_t::am_Error_e::E_OK;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, amError);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setSinkMuteStateAsync(_sinkID, _muteState, _callback, _info);
}
/**
 * description: This method is used to set sound properties, e.g. equalizer values. Since the
 *   capabilities of the system can differ, the exact key value pairs can be
 *   extended in each product. (at)return E_OK on success, E_OUT_OF_RANGE if value
 *   exceeds range, E_UNKNOWN in case of an error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSinkSoundProperty(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->setMainSinkSoundProperty(_sinkID, _soundProperty, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSinkSoundPropertyAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, SetMainSinkSoundPropertyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMainSinkSoundPropertyAsync(_sinkID, _soundProperty, _callback, _info);
}
/**
 * description: This method is used to set sound properties, e.g. equalizer values. Since the
 *   capabilities of the system can differ, the exact key value pairs can be
 *   extended in each product. (at)return E_OK on success, E_OUT_OF_RANGE if value
 *   exceeds range, E_UNKNOWN in case of an error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSourceSoundProperty(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->setMainSourceSoundProperty(_sourceID, _soundProperty, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSourceSoundPropertyAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_MainSoundProperty_s &_soundProperty, SetMainSourceSoundPropertyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMainSourceSoundPropertyAsync(_sourceID, _soundProperty, _callback, _info);
}
/**
 * description: Sets a specific system property. (at)return E_OK on success, E_OUT_OF_RANGE if
 *   value exceeds range, E_UNKNOWN in case of an error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setSystemProperty(const ::v3::org::genivi::am_t::am_SystemProperty_s &_property, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->setSystemProperty(_property, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setSystemPropertyAsync(const ::v3::org::genivi::am_t::am_SystemProperty_s &_property, SetSystemPropertyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setSystemPropertyAsync(_property, _callback, _info);
}
/**
 * description: Returns the current list of main connections. (at)return E_OK on success,
 *   E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainConnections(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_MainConnection_L &_listConnections, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getListMainConnections(_internalCallStatus, _listConnections, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainConnectionsAsync(GetListMainConnectionsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListMainConnectionsAsync(_callback, _info);
}
/**
 * description: Returns the current list of sinks. (at)return E_OK on success, E_DATABASE_ERROR
 *   on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSinks(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SinkType_L &_listMainSinks, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getListMainSinks(_internalCallStatus, _listMainSinks, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinksAsync(GetListMainSinksAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListMainSinksAsync(_callback, _info);
}
/**
 * description: Returns the current list of sources. (at)return E_OK on success,
 *   E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSources(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SourceType_L &_listMainSources, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getListMainSources(_internalCallStatus, _listMainSources, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourcesAsync(GetListMainSourcesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListMainSourcesAsync(_callback, _info);
}
/**
 * description: This is used to retrieve all sink sound properties related to a sink. Returns a
 *   vector of the sound properties and values as pair. (at)return E_OK on success,
 *   E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSinkSoundProperties(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listSoundProperties, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getListMainSinkSoundProperties(_sinkID, _internalCallStatus, _listSoundProperties, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinkSoundPropertiesAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, GetListMainSinkSoundPropertiesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListMainSinkSoundPropertiesAsync(_sinkID, _callback, _info);
}
/**
 * description: This is used to retrieve all source sound properties related to a source.
 *   Returns a vector of the sound properties and values as pair. (at)return E_OK
 *   on success, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSourceSoundProperties(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_MainSoundProperty_L &_listSoundProperties, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getListMainSourceSoundProperties(_sourceID, _internalCallStatus, _listSoundProperties, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourceSoundPropertiesAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, GetListMainSourceSoundPropertiesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListMainSourceSoundPropertiesAsync(_sourceID, _callback, _info);
}
/**
 * description: This is used to retrieve sink class information of all sink classes. (at)return
 *   E_OK on success, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListSinkClasses(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SinkClass_L &_listSinkClasses, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getListSinkClasses(_internalCallStatus, _listSinkClasses, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSinkClassesAsync(GetListSinkClassesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListSinkClassesAsync(_callback, _info);
}
/**
 * description: This is used to retrieve source class information of all source classes.
 *   (at)return E_OK on success, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListSourceClasses(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SourceClass_L &_listSourceClasses, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getListSourceClasses(_internalCallStatus, _listSourceClasses, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSourceClassesAsync(GetListSourceClassesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListSourceClassesAsync(_callback, _info);
}
/**
 * description: Retrieves a complete list of all system properties. (at)return E_OK on success,
 *   E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListSystemProperties(CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_SystemProperty_L &_listSystemProperties, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getListSystemProperties(_internalCallStatus, _listSystemProperties, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListSystemPropertiesAsync(GetListSystemPropertiesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListSystemPropertiesAsync(_callback, _info);
}
/**
 * description: Returns the delay in ms that the audio path for the given main connection.
 *   (at)return E_OK on success, E_NOT_POSSIBLE if timing information is not yet
 *   retrieved, E_DATABASE_ERROR on read error on the database
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getTimingInformation(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_timeSync_t &_delay, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getTimingInformation(_mainConnectionID, _internalCallStatus, _delay, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getTimingInformationAsync(const ::v3::org::genivi::am_t::am_mainConnectionID_t &_mainConnectionID, GetTimingInformationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getTimingInformationAsync(_mainConnectionID, _callback, _info);
}
/**
 * description: Retrieves the list of main notifications for a sink. Does not return the
 *   possible ones.
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSinkNotificationConfigurations(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_NotificationConfiguration_L &_listMainNotificationConfigurations, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getListMainSinkNotificationConfigurations(_sinkID, _internalCallStatus, _listMainNotificationConfigurations, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSinkNotificationConfigurationsAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, GetListMainSinkNotificationConfigurationsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListMainSinkNotificationConfigurationsAsync(_sinkID, _callback, _info);
}
/**
 * description: Retrieves the list of main notifications for a source. Does not return the
 *   possible ones.
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::getListMainSourceNotificationConfigurations(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_NotificationConfiguration_L &_listMainNotificationConfigurations, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->getListMainSourceNotificationConfigurations(_sourceID, _internalCallStatus, _listMainNotificationConfigurations, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::getListMainSourceNotificationConfigurationsAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, GetListMainSourceNotificationConfigurationsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getListMainSourceNotificationConfigurationsAsync(_sourceID, _callback, _info);
}
/**
 * description: Sets a MainNotificationConfiuration. This can be used to turn on an off
 *   notifications an to change the mode of the configuration. (at)return E_OK on
 *   success, E_NON_EXISTENT if sink ID does not exists, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSinkNotificationConfiguration(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->setMainSinkNotificationConfiguration(_sinkID, _mainNotificationConfiguration, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSinkNotificationConfigurationAsync(const ::v3::org::genivi::am_t::am_sinkID_t &_sinkID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, SetMainSinkNotificationConfigurationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMainSinkNotificationConfigurationAsync(_sinkID, _mainNotificationConfiguration, _callback, _info);
}
/**
 * description: Sets a MainNotificationConfiuration. This can be used to turn on an off
 *   notifications an to change the mode of the configuration. (at)return E_OK on
 *   success, E_NON_EXISTENT if source ID does not exists, E_DATABASE_ERROR on error
 */
template <typename ... _AttributeExtensions>
void CommandControlProxy<_AttributeExtensions...>::setMainSourceNotificationConfiguration(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, CommonAPI::CallStatus &_internalCallStatus, ::v3::org::genivi::am_t::am_Error_e &_amError, const CommonAPI::CallInfo *_info) {
    delegate_->setMainSourceNotificationConfiguration(_sourceID, _mainNotificationConfiguration, _internalCallStatus, _amError, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> CommandControlProxy<_AttributeExtensions...>::setMainSourceNotificationConfigurationAsync(const ::v3::org::genivi::am_t::am_sourceID_t &_sourceID, const ::v3::org::genivi::am_t::am_NotificationConfiguration_s &_mainNotificationConfiguration, SetMainSourceNotificationConfigurationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setMainSourceNotificationConfigurationAsync(_sourceID, _mainNotificationConfiguration, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &CommandControlProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool CommandControlProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool CommandControlProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& CommandControlProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& CommandControlProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace commandinterface
} // namespace am
} // namespace genivi
} // namespace org
} // namespace v3

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v3::org::genivi::am::commandinterface::CommandControlProxy,
    _AttributeExtension> {
    typedef typename ::v3::org::genivi::am::commandinterface::CommandControlProxy<
            ::v3::org::genivi::am::commandinterface::CommandControlExtensions::ListOfMainConnetionsAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v3_1 = v3;

#endif // V3_ORG_GENIVI_AM_COMMANDINTERFACE_Command_Control_PROXY_HPP_
