/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1/com/harman/mmpres/MediaPlayerStubDefault.hpp>
#include <assert.h>

namespace v1 {
namespace com {
namespace harman {
namespace mmpres {

MediaPlayerStubDefault::MediaPlayerStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(MediaPlayer::getInterfaceVersion()) {
}

const CommonAPI::Version& MediaPlayerStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

MediaPlayerStubRemoteEvent* MediaPlayerStubDefault::initStubAdapter(const std::shared_ptr<MediaPlayerStubAdapter> &_adapter) {
    CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}

const uint64_t& MediaPlayerStubDefault::getCurrentPlayTimeAttribute() {
    return currentPlayTimeAttributeValue_;
}

const uint64_t& MediaPlayerStubDefault::getCurrentPlayTimeAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getCurrentPlayTimeAttribute();
}

void MediaPlayerStubDefault::setCurrentPlayTimeAttribute(uint64_t _value) {
    const bool valueChanged = trySetCurrentPlayTimeAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireCurrentPlayTimeAttributeChanged(currentPlayTimeAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetCurrentPlayTimeAttribute(uint64_t _value) {
    if (!validateCurrentPlayTimeAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (currentPlayTimeAttributeValue_ != _value);
    currentPlayTimeAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateCurrentPlayTimeAttributeRequestedValue(const uint64_t &_value) {
    (void)_value;
	return true;
}


const uint64_t& MediaPlayerStubDefault::getTotalPlayDurationAttribute() {
    return totalPlayDurationAttributeValue_;
}

const uint64_t& MediaPlayerStubDefault::getTotalPlayDurationAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getTotalPlayDurationAttribute();
}

void MediaPlayerStubDefault::setTotalPlayDurationAttribute(uint64_t _value) {
    const bool valueChanged = trySetTotalPlayDurationAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireTotalPlayDurationAttributeChanged(totalPlayDurationAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetTotalPlayDurationAttribute(uint64_t _value) {
    if (!validateTotalPlayDurationAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (totalPlayDurationAttributeValue_ != _value);
    totalPlayDurationAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateTotalPlayDurationAttributeRequestedValue(const uint64_t &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::tTrackState& MediaPlayerStubDefault::getTrackStateAttribute() {
    return trackStateAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::tTrackState& MediaPlayerStubDefault::getTrackStateAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getTrackStateAttribute();
}

void MediaPlayerStubDefault::setTrackStateAttribute(::v3::com::harman::mmpres::MMPresTypes::tTrackState _value) {
    const bool valueChanged = trySetTrackStateAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireTrackStateAttributeChanged(trackStateAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetTrackStateAttribute(::v3::com::harman::mmpres::MMPresTypes::tTrackState _value) {
    if (!validateTrackStateAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (trackStateAttributeValue_ != _value);
    trackStateAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateTrackStateAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::tTrackState &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::tNowPlayingInfo& MediaPlayerStubDefault::getNowPlayingDataAttribute() {
    return nowPlayingDataAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::tNowPlayingInfo& MediaPlayerStubDefault::getNowPlayingDataAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getNowPlayingDataAttribute();
}

void MediaPlayerStubDefault::setNowPlayingDataAttribute(::v3::com::harman::mmpres::MMPresTypes::tNowPlayingInfo _value) {
    const bool valueChanged = trySetNowPlayingDataAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireNowPlayingDataAttributeChanged(nowPlayingDataAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetNowPlayingDataAttribute(::v3::com::harman::mmpres::MMPresTypes::tNowPlayingInfo _value) {
    if (!validateNowPlayingDataAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (nowPlayingDataAttributeValue_ != _value);
    nowPlayingDataAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateNowPlayingDataAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::tNowPlayingInfo &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::ePlayState& MediaPlayerStubDefault::getPlayStateAttribute() {
    return playStateAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::ePlayState& MediaPlayerStubDefault::getPlayStateAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getPlayStateAttribute();
}

void MediaPlayerStubDefault::setPlayStateAttribute(::v3::com::harman::mmpres::MMPresTypes::ePlayState _value) {
    const bool valueChanged = trySetPlayStateAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->firePlayStateAttributeChanged(playStateAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetPlayStateAttribute(::v3::com::harman::mmpres::MMPresTypes::ePlayState _value) {
    if (!validatePlayStateAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (playStateAttributeValue_ != _value);
    playStateAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validatePlayStateAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::ePlayState &_value) {
    (void)_value;
	return _value.validate();
}


const ::v3::com::harman::mmpres::MMPresTypes::eTrackSeekSpeed& MediaPlayerStubDefault::getSpeedAttribute() {
    return speedAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::eTrackSeekSpeed& MediaPlayerStubDefault::getSpeedAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getSpeedAttribute();
}

void MediaPlayerStubDefault::setSpeedAttribute(::v3::com::harman::mmpres::MMPresTypes::eTrackSeekSpeed _value) {
    const bool valueChanged = trySetSpeedAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireSpeedAttributeChanged(speedAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetSpeedAttribute(::v3::com::harman::mmpres::MMPresTypes::eTrackSeekSpeed _value) {
    if (!validateSpeedAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (speedAttributeValue_ != _value);
    speedAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateSpeedAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::eTrackSeekSpeed &_value) {
    (void)_value;
	return _value.validate();
}


const ::v3::com::harman::mmpres::MMPresTypes::eRepeatMode& MediaPlayerStubDefault::getRepeatModeAttribute() {
    return repeatModeAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::eRepeatMode& MediaPlayerStubDefault::getRepeatModeAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getRepeatModeAttribute();
}

void MediaPlayerStubDefault::setRepeatModeAttribute(::v3::com::harman::mmpres::MMPresTypes::eRepeatMode _value) {
    const bool valueChanged = trySetRepeatModeAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireRepeatModeAttributeChanged(repeatModeAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetRepeatModeAttribute(::v3::com::harman::mmpres::MMPresTypes::eRepeatMode _value) {
    if (!validateRepeatModeAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (repeatModeAttributeValue_ != _value);
    repeatModeAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateRepeatModeAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::eRepeatMode &_value) {
    (void)_value;
	return _value.validate();
}


const ::v3::com::harman::mmpres::MMPresTypes::eShuffleMode& MediaPlayerStubDefault::getShuffleModeAttribute() {
    return shuffleModeAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::eShuffleMode& MediaPlayerStubDefault::getShuffleModeAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getShuffleModeAttribute();
}

void MediaPlayerStubDefault::setShuffleModeAttribute(::v3::com::harman::mmpres::MMPresTypes::eShuffleMode _value) {
    const bool valueChanged = trySetShuffleModeAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireShuffleModeAttributeChanged(shuffleModeAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetShuffleModeAttribute(::v3::com::harman::mmpres::MMPresTypes::eShuffleMode _value) {
    if (!validateShuffleModeAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (shuffleModeAttributeValue_ != _value);
    shuffleModeAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateShuffleModeAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::eShuffleMode &_value) {
    (void)_value;
	return _value.validate();
}


const ::v3::com::harman::mmpres::MMPresTypes::tPlaybackSpeed& MediaPlayerStubDefault::getPlaybackSpeedAttribute() {
    return playbackSpeedAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::tPlaybackSpeed& MediaPlayerStubDefault::getPlaybackSpeedAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getPlaybackSpeedAttribute();
}

void MediaPlayerStubDefault::setPlaybackSpeedAttribute(::v3::com::harman::mmpres::MMPresTypes::tPlaybackSpeed _value) {
    const bool valueChanged = trySetPlaybackSpeedAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->firePlaybackSpeedAttributeChanged(playbackSpeedAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetPlaybackSpeedAttribute(::v3::com::harman::mmpres::MMPresTypes::tPlaybackSpeed _value) {
    if (!validatePlaybackSpeedAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (playbackSpeedAttributeValue_ != _value);
    playbackSpeedAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validatePlaybackSpeedAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::tPlaybackSpeed &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::PlaySessionStateMap& MediaPlayerStubDefault::getPlaysessionStateAttribute() {
    return playsessionStateAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::PlaySessionStateMap& MediaPlayerStubDefault::getPlaysessionStateAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getPlaysessionStateAttribute();
}

void MediaPlayerStubDefault::setPlaysessionStateAttribute(::v3::com::harman::mmpres::MMPresTypes::PlaySessionStateMap _value) {
    const bool valueChanged = trySetPlaysessionStateAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->firePlaysessionStateAttributeChanged(playsessionStateAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetPlaysessionStateAttribute(::v3::com::harman::mmpres::MMPresTypes::PlaySessionStateMap _value) {
    if (!validatePlaysessionStateAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (playsessionStateAttributeValue_ != _value);
    playsessionStateAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validatePlaysessionStateAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::PlaySessionStateMap &_value) {
    (void)_value;
	return true;
}


const bool& MediaPlayerStubDefault::getActiveDeviceBTLinkLossAttribute() {
    return activeDeviceBTLinkLossAttributeValue_;
}

const bool& MediaPlayerStubDefault::getActiveDeviceBTLinkLossAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getActiveDeviceBTLinkLossAttribute();
}

void MediaPlayerStubDefault::setActiveDeviceBTLinkLossAttribute(bool _value) {
    const bool valueChanged = trySetActiveDeviceBTLinkLossAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireActiveDeviceBTLinkLossAttributeChanged(activeDeviceBTLinkLossAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetActiveDeviceBTLinkLossAttribute(bool _value) {
    if (!validateActiveDeviceBTLinkLossAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (activeDeviceBTLinkLossAttributeValue_ != _value);
    activeDeviceBTLinkLossAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateActiveDeviceBTLinkLossAttributeRequestedValue(const bool &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::eArtWorkAvailabilityStatus& MediaPlayerStubDefault::getNowPlayingArtworkStatusAttribute() {
    return nowPlayingArtworkStatusAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::eArtWorkAvailabilityStatus& MediaPlayerStubDefault::getNowPlayingArtworkStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getNowPlayingArtworkStatusAttribute();
}

void MediaPlayerStubDefault::setNowPlayingArtworkStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::eArtWorkAvailabilityStatus _value) {
    const bool valueChanged = trySetNowPlayingArtworkStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireNowPlayingArtworkStatusAttributeChanged(nowPlayingArtworkStatusAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetNowPlayingArtworkStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::eArtWorkAvailabilityStatus _value) {
    if (!validateNowPlayingArtworkStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (nowPlayingArtworkStatusAttributeValue_ != _value);
    nowPlayingArtworkStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateNowPlayingArtworkStatusAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::eArtWorkAvailabilityStatus &_value) {
    (void)_value;
	return _value.validate();
}


const ::v3::com::harman::mmpres::MMPresTypes::MetadataItemList& MediaPlayerStubDefault::getPlaybackPreviewAttribute() {
    return playbackPreviewAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::MetadataItemList& MediaPlayerStubDefault::getPlaybackPreviewAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getPlaybackPreviewAttribute();
}

void MediaPlayerStubDefault::setPlaybackPreviewAttribute(::v3::com::harman::mmpres::MMPresTypes::MetadataItemList _value) {
    const bool valueChanged = trySetPlaybackPreviewAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->firePlaybackPreviewAttributeChanged(playbackPreviewAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetPlaybackPreviewAttribute(::v3::com::harman::mmpres::MMPresTypes::MetadataItemList _value) {
    if (!validatePlaybackPreviewAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (playbackPreviewAttributeValue_ != _value);
    playbackPreviewAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validatePlaybackPreviewAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::MetadataItemList &_value) {
    (void)_value;
	return true;
}


const bool& MediaPlayerStubDefault::getVideoPlayStatusAttribute() {
    return videoPlayStatusAttributeValue_;
}

const bool& MediaPlayerStubDefault::getVideoPlayStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getVideoPlayStatusAttribute();
}

void MediaPlayerStubDefault::setVideoPlayStatusAttribute(bool _value) {
    const bool valueChanged = trySetVideoPlayStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireVideoPlayStatusAttributeChanged(videoPlayStatusAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetVideoPlayStatusAttribute(bool _value) {
    if (!validateVideoPlayStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (videoPlayStatusAttributeValue_ != _value);
    videoPlayStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateVideoPlayStatusAttributeRequestedValue(const bool &_value) {
    (void)_value;
	return true;
}


const uint32_t& MediaPlayerStubDefault::getRemotePlayerChangedAttribute() {
    return remotePlayerChangedAttributeValue_;
}

const uint32_t& MediaPlayerStubDefault::getRemotePlayerChangedAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getRemotePlayerChangedAttribute();
}

void MediaPlayerStubDefault::setRemotePlayerChangedAttribute(uint32_t _value) {
    const bool valueChanged = trySetRemotePlayerChangedAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireRemotePlayerChangedAttributeChanged(remotePlayerChangedAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetRemotePlayerChangedAttribute(uint32_t _value) {
    if (!validateRemotePlayerChangedAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (remotePlayerChangedAttributeValue_ != _value);
    remotePlayerChangedAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateRemotePlayerChangedAttributeRequestedValue(const uint32_t &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::tRemotePlayerCapability& MediaPlayerStubDefault::getRemotePlayerCapabilityAttribute() {
    return remotePlayerCapabilityAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::tRemotePlayerCapability& MediaPlayerStubDefault::getRemotePlayerCapabilityAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getRemotePlayerCapabilityAttribute();
}

void MediaPlayerStubDefault::setRemotePlayerCapabilityAttribute(::v3::com::harman::mmpres::MMPresTypes::tRemotePlayerCapability _value) {
    const bool valueChanged = trySetRemotePlayerCapabilityAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireRemotePlayerCapabilityAttributeChanged(remotePlayerCapabilityAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetRemotePlayerCapabilityAttribute(::v3::com::harman::mmpres::MMPresTypes::tRemotePlayerCapability _value) {
    if (!validateRemotePlayerCapabilityAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (remotePlayerCapabilityAttributeValue_ != _value);
    remotePlayerCapabilityAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateRemotePlayerCapabilityAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::tRemotePlayerCapability &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::MediaErrorMap& MediaPlayerStubDefault::getMediaErrorAttribute() {
    return mediaErrorAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::MediaErrorMap& MediaPlayerStubDefault::getMediaErrorAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getMediaErrorAttribute();
}

void MediaPlayerStubDefault::setMediaErrorAttribute(::v3::com::harman::mmpres::MMPresTypes::MediaErrorMap _value) {
    const bool valueChanged = trySetMediaErrorAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireMediaErrorAttributeChanged(mediaErrorAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetMediaErrorAttribute(::v3::com::harman::mmpres::MMPresTypes::MediaErrorMap _value) {
    if (!validateMediaErrorAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (mediaErrorAttributeValue_ != _value);
    mediaErrorAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateMediaErrorAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::MediaErrorMap &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::SyncMap& MediaPlayerStubDefault::getSyncStatusAttribute() {
    return syncStatusAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::SyncMap& MediaPlayerStubDefault::getSyncStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getSyncStatusAttribute();
}

void MediaPlayerStubDefault::setSyncStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::SyncMap _value) {
    const bool valueChanged = trySetSyncStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireSyncStatusAttributeChanged(syncStatusAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetSyncStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::SyncMap _value) {
    if (!validateSyncStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (syncStatusAttributeValue_ != _value);
    syncStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateSyncStatusAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::SyncMap &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::tTrackListSupport& MediaPlayerStubDefault::getTrackListSupportAttribute() {
    return trackListSupportAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::tTrackListSupport& MediaPlayerStubDefault::getTrackListSupportAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getTrackListSupportAttribute();
}

void MediaPlayerStubDefault::setTrackListSupportAttribute(::v3::com::harman::mmpres::MMPresTypes::tTrackListSupport _value) {
    const bool valueChanged = trySetTrackListSupportAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireTrackListSupportAttributeChanged(trackListSupportAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetTrackListSupportAttribute(::v3::com::harman::mmpres::MMPresTypes::tTrackListSupport _value) {
    if (!validateTrackListSupportAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (trackListSupportAttributeValue_ != _value);
    trackListSupportAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateTrackListSupportAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::tTrackListSupport &_value) {
    (void)_value;
	return true;
}


const bool& MediaPlayerStubDefault::getPromoteStatusAttribute() {
    return promoteStatusAttributeValue_;
}

const bool& MediaPlayerStubDefault::getPromoteStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getPromoteStatusAttribute();
}

void MediaPlayerStubDefault::setPromoteStatusAttribute(bool _value) {
    const bool valueChanged = trySetPromoteStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->firePromoteStatusAttributeChanged(promoteStatusAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetPromoteStatusAttribute(bool _value) {
    if (!validatePromoteStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (promoteStatusAttributeValue_ != _value);
    promoteStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validatePromoteStatusAttributeRequestedValue(const bool &_value) {
    (void)_value;
	return true;
}


const bool& MediaPlayerStubDefault::getDemoteStatusAttribute() {
    return demoteStatusAttributeValue_;
}

const bool& MediaPlayerStubDefault::getDemoteStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getDemoteStatusAttribute();
}

void MediaPlayerStubDefault::setDemoteStatusAttribute(bool _value) {
    const bool valueChanged = trySetDemoteStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireDemoteStatusAttributeChanged(demoteStatusAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetDemoteStatusAttribute(bool _value) {
    if (!validateDemoteStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (demoteStatusAttributeValue_ != _value);
    demoteStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateDemoteStatusAttributeRequestedValue(const bool &_value) {
    (void)_value;
	return true;
}


const bool& MediaPlayerStubDefault::getAddToWishListStatusAttribute() {
    return addToWishListStatusAttributeValue_;
}

const bool& MediaPlayerStubDefault::getAddToWishListStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getAddToWishListStatusAttribute();
}

void MediaPlayerStubDefault::setAddToWishListStatusAttribute(bool _value) {
    const bool valueChanged = trySetAddToWishListStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireAddToWishListStatusAttributeChanged(addToWishListStatusAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetAddToWishListStatusAttribute(bool _value) {
    if (!validateAddToWishListStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (addToWishListStatusAttributeValue_ != _value);
    addToWishListStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateAddToWishListStatusAttributeRequestedValue(const bool &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::eRemoteCDDiscStatus& MediaPlayerStubDefault::getMRemoteCDDiscStatusAttribute() {
    return mRemoteCDDiscStatusAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::eRemoteCDDiscStatus& MediaPlayerStubDefault::getMRemoteCDDiscStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getMRemoteCDDiscStatusAttribute();
}

void MediaPlayerStubDefault::setMRemoteCDDiscStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::eRemoteCDDiscStatus _value) {
    const bool valueChanged = trySetMRemoteCDDiscStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireMRemoteCDDiscStatusAttributeChanged(mRemoteCDDiscStatusAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetMRemoteCDDiscStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::eRemoteCDDiscStatus _value) {
    if (!validateMRemoteCDDiscStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (mRemoteCDDiscStatusAttributeValue_ != _value);
    mRemoteCDDiscStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateMRemoteCDDiscStatusAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::eRemoteCDDiscStatus &_value) {
    (void)_value;
	return _value.validate();
}


const ::v3::com::harman::mmpres::MMPresTypes::RemoteCDErrorStatus& MediaPlayerStubDefault::getMRemoteCDErrorStatusAttribute() {
    return mRemoteCDErrorStatusAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::RemoteCDErrorStatus& MediaPlayerStubDefault::getMRemoteCDErrorStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getMRemoteCDErrorStatusAttribute();
}

void MediaPlayerStubDefault::setMRemoteCDErrorStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::RemoteCDErrorStatus _value) {
    const bool valueChanged = trySetMRemoteCDErrorStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireMRemoteCDErrorStatusAttributeChanged(mRemoteCDErrorStatusAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetMRemoteCDErrorStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::RemoteCDErrorStatus _value) {
    if (!validateMRemoteCDErrorStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (mRemoteCDErrorStatusAttributeValue_ != _value);
    mRemoteCDErrorStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateMRemoteCDErrorStatusAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::RemoteCDErrorStatus &_value) {
    (void)_value;
	return true;
}


const bool& MediaPlayerStubDefault::getMRemoteCDEjectChimesWarningAttribute() {
    return mRemoteCDEjectChimesWarningAttributeValue_;
}

const bool& MediaPlayerStubDefault::getMRemoteCDEjectChimesWarningAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getMRemoteCDEjectChimesWarningAttribute();
}

void MediaPlayerStubDefault::setMRemoteCDEjectChimesWarningAttribute(bool _value) {
    const bool valueChanged = trySetMRemoteCDEjectChimesWarningAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireMRemoteCDEjectChimesWarningAttributeChanged(mRemoteCDEjectChimesWarningAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetMRemoteCDEjectChimesWarningAttribute(bool _value) {
    if (!validateMRemoteCDEjectChimesWarningAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (mRemoteCDEjectChimesWarningAttributeValue_ != _value);
    mRemoteCDEjectChimesWarningAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateMRemoteCDEjectChimesWarningAttributeRequestedValue(const bool &_value) {
    (void)_value;
	return true;
}


const ::v3::com::harman::mmpres::MMPresTypes::eCDEOLStatus& MediaPlayerStubDefault::getMCDEOLStatusAttribute() {
    return mCDEOLStatusAttributeValue_;
}

const ::v3::com::harman::mmpres::MMPresTypes::eCDEOLStatus& MediaPlayerStubDefault::getMCDEOLStatusAttribute(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return getMCDEOLStatusAttribute();
}

void MediaPlayerStubDefault::setMCDEOLStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::eCDEOLStatus _value) {
    const bool valueChanged = trySetMCDEOLStatusAttribute(std::move(_value));
    if (valueChanged) {
        auto stubAdapter = CommonAPI::Stub<MediaPlayerStubAdapter, MediaPlayerStubRemoteEvent>::stubAdapter_.lock();
        if (stubAdapter)
            stubAdapter->fireMCDEOLStatusAttributeChanged(mCDEOLStatusAttributeValue_);
    }
}

bool MediaPlayerStubDefault::trySetMCDEOLStatusAttribute(::v3::com::harman::mmpres::MMPresTypes::eCDEOLStatus _value) {
    if (!validateMCDEOLStatusAttributeRequestedValue(_value))
        return false;

    const bool valueChanged = (mCDEOLStatusAttributeValue_ != _value);
    mCDEOLStatusAttributeValue_ = std::move(_value);
    return valueChanged;
}

bool MediaPlayerStubDefault::validateMCDEOLStatusAttributeRequestedValue(const ::v3::com::harman::mmpres::MMPresTypes::eCDEOLStatus &_value) {
    (void)_value;
	return _value.validate();
}



/**
 * description: Method to send the button events received from HMI
 */
void MediaPlayerStubDefault::sendIAP2KeyEvent(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::com::harman::mmpres::MMPresTypes::IAP2ButtonType _buttonType, bool _pressed, sendIAP2KeyEventReply_t _reply) {
    (void)_client;
    (void) _buttonType;
    (void) _pressed;
    _reply();
}

/**
 * description: Method to initiate the playback of all items of a specific object type in the
 *   device
 */
void MediaPlayerStubDefault::playAll(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _slotId, ::v3::com::harman::mmpres::MMPresTypes::eMetadataType _objectType, playAllReply_t _reply) {
    (void)_client;
    (void) _slotId;
    (void) _objectType;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::next(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _step, nextReply_t _reply) {
    (void)_client;
    (void) _step;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::previous(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _step, previousReply_t _reply) {
    (void)_client;
    (void) _step;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::pause(const std::shared_ptr<CommonAPI::ClientId> _client, pauseReply_t _reply) {
    (void)_client;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::resume(const std::shared_ptr<CommonAPI::ClientId> _client, resumeReply_t _reply) {
    (void)_client;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::seekToTime(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _timePosition, seekToTimeReply_t _reply) {
    (void)_client;
    (void) _timePosition;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::fastForward(const std::shared_ptr<CommonAPI::ClientId> _client, fastForwardReply_t _reply) {
    (void)_client;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::fastReverse(const std::shared_ptr<CommonAPI::ClientId> _client, fastReverseReply_t _reply) {
    (void)_client;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::setRepeat(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::com::harman::mmpres::MMPresTypes::eRepeatMode _mode, setRepeatReply_t _reply) {
    (void)_client;
    (void) _mode;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::setShuffle(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::com::harman::mmpres::MMPresTypes::eShuffleMode _mode, setShuffleReply_t _reply) {
    (void)_client;
    (void) _mode;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::getNowPlayingAlbumArtInformation(const std::shared_ptr<CommonAPI::ClientId> _client, getNowPlayingAlbumArtInformationReply_t _reply) {
    (void)_client;
    ::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation albumArtInfo = {};
    _reply(albumArtInfo);
}

void MediaPlayerStubDefault::getNowPlayingAlbumArtPath(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _imageNumber, getNowPlayingAlbumArtPathReply_t _reply) {
    (void)_client;
    (void) _imageNumber;
    std::string path = "";
    _reply(path);
}

void MediaPlayerStubDefault::getNowPlayingAlbumArtData(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _imageNumber, getNowPlayingAlbumArtDataReply_t _reply) {
    (void)_client;
    (void) _imageNumber;
    std::vector<uint8_t> albumArtData = {};
    _reply(albumArtData);
}

void MediaPlayerStubDefault::getAlbumArtInformationForTrack(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _trackId, getAlbumArtInformationForTrackReply_t _reply) {
    (void)_client;
    (void) _trackId;
    ::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation albumArtInfo = {};
    _reply(albumArtInfo);
}

void MediaPlayerStubDefault::getAlbumArtPathForTrack(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _trackId, uint8_t _imageNumber, getAlbumArtPathForTrackReply_t _reply) {
    (void)_client;
    (void) _trackId;
    (void) _imageNumber;
    std::string path = "";
    _reply(path);
}

void MediaPlayerStubDefault::getAlbumArtDataForTrack(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _trackId, uint8_t _imageNumber, getAlbumArtDataForTrackReply_t _reply) {
    (void)_client;
    (void) _trackId;
    (void) _imageNumber;
    std::vector<uint8_t> albumArtData = {};
    _reply(albumArtData);
}

void MediaPlayerStubDefault::setSpeed(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _slotId, ::v3::com::harman::mmpres::MMPresTypes::eMetadataType _type, ::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed _speed, setSpeedReply_t _reply) {
    (void)_client;
    (void) _slotId;
    (void) _type;
    (void) _speed;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

void MediaPlayerStubDefault::getSpeed(const std::shared_ptr<CommonAPI::ClientId> _client, uint8_t _slotId, ::v3::com::harman::mmpres::MMPresTypes::eMetadataType _type, getSpeedReply_t _reply) {
    (void)_client;
    (void) _slotId;
    (void) _type;
    ::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed speed = ::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed::SLOWER;
    if (!speed.validate()) {
        return;
    }
    _reply(speed);
}

/**
 * description: Promote the track
 * param: fileId is the fileID of the iTunes Station to be promoted. 0 can be used for
 *   current station
 */
void MediaPlayerStubDefault::promote(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _fileId, promoteReply_t _reply) {
    (void)_client;
    (void) _fileId;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

/**
 * description: demote the track
 * param: fileId is the fileID of the iTunes Station to be demoted. 0 can be used for
 *   current station
 */
void MediaPlayerStubDefault::demote(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _fileId, demoteReply_t _reply) {
    (void)_client;
    (void) _fileId;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}

/**
 * description: add iTunes station to a WishList
 * param: fileId is the fileID of the iTunes Station to be added to the wishlist. 0 can
 *   be used for current station
 */
void MediaPlayerStubDefault::addToWishList(const std::shared_ptr<CommonAPI::ClientId> _client, uint64_t _fileId, addToWishListReply_t _reply) {
    (void)_client;
    (void) _fileId;
    ::v3::com::harman::mmpres::MMPresTypes::eCallResult result = ::v3::com::harman::mmpres::MMPresTypes::eCallResult::CALLRESULT_OK;
    if (!result.validate()) {
        return;
    }
    _reply(result);
}




MediaPlayerStubDefault::RemoteEventHandler::RemoteEventHandler(MediaPlayerStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace mmpres
} // namespace harman
} // namespace com
} // namespace v1
