/**
 * generated by Voice CodeGen Version: R1_v1.3.0
 * generated on: Sun Sep 11 19:00:26 IST 2016
 */

#include"RoutingControlStubImpl.hpp"

namespace v1 {
namespace org {
namespace genivi {
namespace am {
namespace routinginterface {

RoutingControlStubImpl::RoutingControlStubImpl()
{
   LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::RoutingControlStubImpl");
   registerAsyncSetSourceStateFunction();
}

RoutingControlStubImpl::~RoutingControlStubImpl()
{

}
/*
void RoutingControlStubImpl::asyncSetSourceState(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_Handle_s handle, ::v3::org::genivi::am_t::am_sourceID_t sourceID, ::v3::org::genivi::am_t::am_SourceState_e state, asyncSetSourceStateReply_t reply)
{
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState-sourceID=%d,source state=%d,source handle type=%d,source handle value=%d",(int)sourceID,(int)state,(int)(handle.getHandleType()),(int)(handle.getHandle()));

switch (state)
{
case am_t::am_SourceState_e::SS_ON:
if (mSourceSwitch->getSCI_Media())
{
mAudioManager->updateRequestInfo(sourceID, handle, state);
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_ON - before event invoke");
mSourceSwitch->getSCI_Media()->raise_reqPlay(sourceID);
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_ON -after event invoke");
mSourceSwitch->runCycle();
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_ON -after run cycle");
}
else
{
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_ON -event can't be raised");
}
break;
case am_t::am_SourceState_e::SS_PAUSED:
if (mSourceSwitch->getSCI_Media())
{
mAudioManager->updateRequestInfo(sourceID, handle, state);
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_PAUSED - before event invoke");
mSourceSwitch->getSCI_Media()->raise_reqPause(sourceID);
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_PAUSED-after event invoke");
mSourceSwitch->runCycle();
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_PAUSED-after run cycle");
}
else
{
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_PAUSED -event can't be raised");
}
break;
case am_t::am_SourceState_e::SS_OFF:
if (mSourceSwitch->getSCI_Media())
{
mAudioManager->updateRequestInfo(sourceID, handle, state);
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_OFF - before event invoke");
mSourceSwitch->getSCI_Media()->raise_reqOff(sourceID);
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_OFF-after event invoke");
mSourceSwitch->runCycle();
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_OFF-after run cycle");
}
else
{
LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState for SS_OFF-event can't be raised");
}
break;
default:
break;
}// end of switch
reply();
}
*/

void RoutingControlStubImpl::asyncSetSourceState(const std::shared_ptr<CommonAPI::ClientId> _client, ::v3::org::genivi::am_t::am_Handle_s handle, ::v3::org::genivi::am_t::am_sourceID_t sourceID, ::v3::org::genivi::am_t::am_SourceState_e state, asyncSetSourceStateReply_t reply)
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::asyncSetSourceState-sourceID=%d,source state=%d,source handle type=%d,source handle value=%d", (int)sourceID, (int)state, (int)(handle.getHandleType()), (int)(handle.getHandle()));

	switch (state)
	{
	case am_t::am_SourceState_e::SS_ON:
			mAudioManager->updateRequestInfo(sourceID, handle, state);
			mSourceSwitch->doPlay(sourceID);
		break;
	case am_t::am_SourceState_e::SS_PAUSED:
			mAudioManager->updateRequestInfo(sourceID, handle, state);	
			mSourceSwitch->doPause(sourceID);
		break;
	case am_t::am_SourceState_e::SS_OFF:
		    mAudioManager->updateRequestInfo(sourceID, handle, state);
			mSourceSwitch->doOff(sourceID);
		break;
	default:
		break;
	}// end of switch
	reply();
}

void RoutingControlStubImpl::fireAckSetSourceStateSelective(const ::v3::org::genivi::am_t::am_Handle_s &_handle, const ::v3::org::genivi::am_t::am_Error_e &_amError, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) 
{
	LOG_INFO(LOG_CONTEXT_MEDIA, ">>> RoutingControlStubImpl::fireAckSetSourceStateSelective-source handle type=%d,source handle value=%d,error value=%d", _handle.getHandleType(), (int)(_handle.getHandle()),(int)_amError);
	RoutingControlStubDefault::fireAckSetSourceStateSelective(_handle,_amError,nullptr);
}

void RoutingControlStubImpl::registerAsyncSetSourceStateFunction()
{
	mAudioManager->setAsyncSetSourceStateFunction(std::bind(&RoutingControlStubImpl::fireAckSetSourceStateSelective,this,std::placeholders::_1,std::placeholders::_2,std::placeholders::_3));
}


} // namespace routinginterface
} // namespace am
} // namespace genivi
} // namespace org
} // namespace v1


