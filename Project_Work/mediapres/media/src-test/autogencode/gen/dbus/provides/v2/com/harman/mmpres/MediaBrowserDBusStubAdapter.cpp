/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v2/com/harman/mmpres/MediaBrowser.hpp>
#include <v2/com/harman/mmpres/MediaBrowserDBusStubAdapter.hpp>

namespace v2 {
namespace com {
namespace harman {
namespace mmpres {

std::shared_ptr<CommonAPI::DBus::DBusStubAdapter> createMediaBrowserDBusStubAdapter(
                   const CommonAPI::DBus::DBusAddress &_address,
                   const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
                   const std::shared_ptr<CommonAPI::StubBase> &_stub) {
    return std::make_shared<MediaBrowserDBusStubAdapter>(_address, _connection, _stub);
}

INITIALIZER(registerMediaBrowserDBusStubAdapter) {
    CommonAPI::DBus::Factory::get()->registerStubAdapterCreateMethod(
    	MediaBrowser::getInterface(), &createMediaBrowserDBusStubAdapter);
}

MediaBrowserDBusStubAdapterInternal::~MediaBrowserDBusStubAdapterInternal() {
    deactivateManagedInstances();
    MediaBrowserDBusStubAdapterHelper::deinit();
}

void MediaBrowserDBusStubAdapterInternal::deactivateManagedInstances() {

}

const char* MediaBrowserDBusStubAdapterInternal::getMethodsDBusIntrospectionXmlData() const {
    static const std::string introspectionData =
        "<method name=\"getInterfaceVersion\">\n"
            "<arg name=\"value\" type=\"uu\" direction=\"out\" />"
        "</method>\n"
        "<method name=\"getSearchCandidatesAttribute\">\n"
            "<arg name=\"value\" type=\"as\" direction=\"out\" />"
        "</method>\n"
        "<signal name=\"onSearchCandidatesAttributeChanged\">\n"
            "<arg name=\"changedValue\" type=\"as\" />\n"
        "</signal>\n"
        /**
         * description: Will only be posted to the respective listeners if the session query parameters
         *   have changed.  					  For example, for externally played back devices, the
         *   number of items in the currently playing list might change.  Will be published
         *    					  only if auto update was enabled when setting the query.  	            
         *      returns  sessionID:      The Session ID alloted.          returns 
         *   sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
         *   particular session query/filter for retrieving data in a session and it has to
         *   be passed                                        for furthur setting the
         *   sessionQuery window and retrieving the contents of that window.               
         *       returns  numItems:		   The updated number of items for the
         *   sessionID/sessionQueryID.
         */
        "<signal name=\"sessionQueryUpdate\">\n"
            "<arg name=\"sessionID\" type=\"u\" />\n"
            "<arg name=\"sessionQueryID\" type=\"u\" />\n"
            "<arg name=\"numResults\" type=\"t\" />\n"
        "</signal>\n"
        /**
         * description: Publishes the query status to all clients. The client can get the data once the
         *   query is "finished" 	 	     returns  sessionID: 	   The Session ID alloted.   
         *         returns  sessionQueryID:  The sessionQueryID allotted.This uniquely
         *   identifies a particular session query/filter for retrieving data in a session
         *   and it has to be passed                                        for furthur
         *   setting the sessionQuery window and retrieving the contents of that window.   
         *                 returns  eQueryStatus:    query status of the window update.    
         *        returns  startIndex:	   The index to start fetching.            returns 
         *   numItems:		   The number of items to fetch.          returns  itemList:       
         *    List of tMetadataItems.                    returns
         *   windowContainsCurrentlyPlayingTrack: This will be true if one of the
         *   tMetadataItems is the currently playing track.                   returns
         *   itemIndexTobeHighlighted: // index of the item to be highlighted in the
         *   returned nowPlaying list. If the                                              
         *    currently playing item is not part of the returned window, then this will be
         *   assigned 0.
         */
        "<signal name=\"sessionQueryWindowUpdate\">\n"
            "<arg name=\"sessionID\" type=\"u\" />\n"
            "<arg name=\"sessionQueryID\" type=\"u\" />\n"
            "<arg name=\"status\" type=\"i\" />\n"
            "<arg name=\"startIndex\" type=\"t\" />\n"
            "<arg name=\"numItems\" type=\"t\" />\n"
            "<arg name=\"itemList\" type=\"a(tsbbiia{it}a{is}i)\" />\n"
            "<arg name=\"windowContainsCurrentlyPlayingTrack\" type=\"b\" />\n"
            "<arg name=\"itemIndexTobeHighlighted\" type=\"t\" />\n"
        "</signal>\n"
        /**
         * description: Publishes the thumbnaillistUpdate to all clients. The client can get the data
         *   once the query is "finished". Applicable only for Video browsing              
         *              returns  sessionID:        The Session ID alloted.          returns
         *    sessionQueryID:     The sessionQueryID allotted.This uniquely identifies a
         *   particular session query/filter for retrieving data in a session and it has to
         *   be passed                                        for furthur setting the
         *   sessionQuery window and retrieving the contents of that window.               
         *     returns  startIndex:         The index to start fetching.            returns
         *    numItems:           The number of items to fetch.          returns 
         *   thumbnailist:       List of thumbNail paths.
         */
        "<signal name=\"thumbnailListUpdate\">\n"
            "<arg name=\"sessionID\" type=\"u\" />\n"
            "<arg name=\"sessionQueryID\" type=\"u\" />\n"
            "<arg name=\"startIndex\" type=\"t\" />\n"
            "<arg name=\"numItems\" type=\"t\" />\n"
            "<arg name=\"thumbnaiList\" type=\"as\" />\n"
        "</signal>\n"
        /**
         * description: Publishes the query status to all clients. The client can get the data once the
         *   query is "finished" 	 	     returns  sessionID: 	   The Session ID alloted.   
         *         returns  sessionQueryID:  The sessionQueryID for the Alphajump reply    
         *                 returns ajList: 		   an array of structure containing Alphabets
         *   and their index
         */
        "<signal name=\"sessionQueryAlphaJumpUpdate\">\n"
            "<arg name=\"sessionID\" type=\"u\" />\n"
            "<arg name=\"sessionQueryID\" type=\"u\" />\n"
            "<arg name=\"ajList\" type=\"a(su)\" />\n"
        "</signal>\n"
        /**
         * description: Opens a session for the client communication. This session will be used
         *   internally to uniquely identify a client, and to maintain client specific
         *   caches. 					  The client need not create a new session for every request,
         *   this is rather used to identify different instances of clients.               
         *          returns:     sessionID: Session identifier allocated to the client.
         */
        "<method name=\"openSession\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"out\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Close a client session and release all associated resources. Once HMI calls
         *   closeSession,they cannot use the same sessionId 	for furthur browsing. For
         *   this, they have to again invoke a openSession to get a new sessionId for
         *   furthur browsing.
         * param: sessionID: The Session ID to close.
         */
        "<method name=\"closeSession\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Essentially Stops all background tasks in the specified session. But unlike
         *   closeSession, the sessionID 	 is valid and can be used for furthur browsing.
         * param: sessionID: The Session ID alloted.
         */
        "<method name=\"cancelSession\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Sets a session query. This api handles all requests to fetch metadata browse
         *   results, database searches, file system browse etc.  	 	  	 	 Note: iF HMI
         *   wants to show the categories like ARTISTS,ALBUMS,FOLDERS,GENRES etc on
         *   clicking browse icon,they need not 	 	 use the setSessionQuery. They can
         *   instead use the tSlotUpdate broadcast which contains the tDevice structure.In 
         *   	 	 this, browse capabilities will be provided as a bitmask of different
         *   eMetadataTypes.If HMI is interested in 	 	 the count of these categories,then
         *   HMI can use the MetadataCountMap which is a map of different
         *   eMetadataCountType. 	 	  	 	  	 	 1st Example:  	 	  	 	 Get a list of all
         *   available artists. The filterID's' and filter's' will be empty, and the result
         *   type would be set to artist id.  	 	 Presentation control would return a list
         *   of all available artists / artist id for the medium. 	 	 sessionQueryType will
         *   be METADATA_BROWSE  	 	  	 	 2nd Example: 	 	  	 	 Get a list of all available
         *   artists. Also for each artist,get the count of songs.For this, input
         *   parameters will be same as first example 	 	 but now HMI should pass
         *   metadataCountTypes=eMetadataType::METADATATYPE_SONG. 	 	  	 	 If HMI wants
         *   album count also along with songs count, then metadataCountTypes= bitmask
         *   combination of  	 	 eMetadataType::METADATATYPE_SONG +
         *   eMetadataType::METADATATYPE_ALBUM. 	 	  	 	 sessionQueryType will be
         *   METADATA_BROWSE  	 	  	 	 3rd Example :  	 	  	 	 Get a list of all available
         *   albums by the artist "Pink Floyd". HMI would know the artist id for "Pink
         *   Floyd" because of the previous returned result.  	 	  	 	 In the session
         *   query, HMI sets the filterIDMap as: 	 	  	 	
         *   key=eMetadataType::METADATATYPE_ARTIST,value="artist id" for Pink Floyd  	 	 
         *   	 	 resultType=eMetadataType::METADATATYPE_ALBUM.  	 	  	 	 Presentation
         *   Controller understands what needs to be done here. This can be further
         *   extended by setting 	 	 artist id and album id returned in the previous steps,
         *   and a query for songs can be done.  	 	  	 	 sessionQueryType will be
         *   METADATA_BROWSE. 	 	  	 	 Suppose we need the list of songs inside the artist
         *   "Pink Floyd" but for eah song song, we also need to pass the artist,album  	 	
         *   and genre values. Then this can be done by providing the "metadataAttributes"
         *   input parameter as a bit mask combination of
         *   eMetadataType::METADATATYPE_ARTIST + 	 	 eMetadataType::METADATATYPE_ALBUM &
         *   eMetadataType::METADATATYPE_GENRE. 	 	  	 	 Note that metadataAttributes will
         *   be considered only if the resultType="song". 	 	  	 	 4th Example :  	 	  	 	
         *   Get a list of all available albums by "Pink Floyd", which begin with the
         *   letters "The".  	 	 This is same as the 3rd example, but in addition, the
         *   filter "album" must be set to "The" 	 	  	 	 sessionQueryType will be
         *   METADATA_BROWSE  	 	  	 	 5th example: 	 	  	 	 usage of resetPrevious
         *   parameter. 	 	  	 	 Assume resetPrevious=false: 	 	  	 	 In the first
         *   example,HMI obtained the list of albums for artist "Pink Floyed". Now if HMI
         *   wants list of songs for 	 	 artist "Pink Floyed", then in the filters,HMi need
         *   not mention anything again.  	 	 They can just set
         *   resultype=eMetadataType::METADATATYPE_SONG . 	 	  	 	 Now pres will remember
         *   that artist "Pink Floyd" was already selected. So pres will supply the song
         *   list for artist pink floyd. 	 	  	 	 If resetPrevious=true,pres would not
         *   remeber that Artist Pink Floyd was already selected. In that case, 	 	 HMI has
         *   to set the filterIDMap again by providing the artist id for pink Floyd. 	 	  	
         *   	 Now in the use cases, where the resultType is
         *   "eMetadataType::METADATATYPE_SONG", if the requirement is to show only AUDIO 	
         *   	 or VIDEO or both AUDIO + VIDEO, this can be done by setting "ContentMask"
         *   param as a bit mask of "eTitleContentType". 	 	  	 	
         *   eTitleContentType::TITLETYPE_IMAGE will be applicable for filesystem browse. 
         *   	 	  	 	 6th Example: 	 	  	 	 Do a fileSystem or FOLDER browse.This is
         *   applicable for mass storage devices like USB.At any level, we are  	 	 allowed
         *   to show both folders, files or playlists depending on project requirements. 	
         *   	  	 	 sessionQueryType will be SESSION_QUERY_FS_BROWSE. 	 	  	 	 First go to
         *   root level and show only folders and files but not playlists. For this, the
         *   filterID's and filters are empty, but the resultType will be  	 	 combination
         *   of eMetadataType::METADATATYPE_FOLDER + eMetadataType::METADATATYPE_FILE.With
         *   this query,HMI can get 	 	 the folders and file at a given level in
         *   filesystem. When HMI gets the individual items, they can check the
         *   eMetadataType 	 	 of that item to see if it is a file or folder. 	 	  	 	 Now
         *   HMI wants to go inside one more level by selecting a folder obtained in the
         *   previous step.For this,HMI can set the filterID as  	 	
         *   key=METADATAID_FOLDER_ID and value=(folder id or item id) of folder
         *   communicated in previous step. 	 	  	 	 If at every level, there is a
         *   requirement to list folders first and only then followed by audio files,image
         *   files etc, then 	 	 these will be maintained by pres as project specific
         *   config parameters.  	 	  	 	 Now HMI wants to go inside one of the folders
         *   named "Folder1" listed at the root level.For this,HMI can set the FilterIDMap
         *   as: 	 	  	 	 key: "eMetadataType::METADATATYPE_FOLDER" and value: folder id of
         *   "folder 1" from the result of the first query to  	 	       show the root
         *   level contents. 	 	  	 	 Also if HMI wants the level ID (depth of folder) in
         *   file system browse, such as 4th folder depth or fifth folder depth etc, 	 	
         *   then they can use the sessionQueryID as an indicator of level ID. Each
         *   sessionQueryID will correspond to a 	 	 particular folder depth in file system
         *   browse. 	 	  	 	 7th example: 	 	  	 	 If HMI wants the list of songs from the
         *   recently played list. 	 	  	 	 The can set the sessionQueryType will be
         *   SESSION_QUERY_RECENTLYPLAYED and resultype=eMetadataType::METADATATYPE_SONG 	 
         *      other parameters can be empty.
         * param: filterIDs: The previously communicated numeric identifiers of the different
         *   filter categories.
         * param: filters:	 The string filters which should be applied to the result.
         * param: resultType: The data which is expected from the query.
         * param: sessionID: The Session ID alloted.
         * param: slotId:	 The identifier for the slot.
         * param: type:		 The type of session query.
         * param: metadataAttributes: [TODO]:Pres ctrl can return the required attributes for
         *   each metadata item based on the                                           
         *   client requirements.This is a bitmask combination of eMetadataType values.
         *   This will be                                            supported only for the
         *   song category.
         * param: metadataCountTypes: Pres Ctrl can count the number of items present in a
         *   subcategory. For example, while retreving a list of all artists,          
         *   								  Pres Ctrl can also count how many albums/songs are available for
         *   each artist. (Might be a costly operation depending on Media Type.          
         *   								  	Select this option only if really required )
         * param: resetPrevious: Whether to use old history or not. Pres Ctrl has internal
         *   history mechanism. For example          							 if in the first session query,
         *   the list of all available artists was obtained.In the 2nd browse level, HMI
         *   requested for          							 all albums by a specific artist. If now HMI
         *   wants a list of all songs by the artist, it need not tell the selected artist 
         *            							 again. However if this flag is reset, it will override this
         *   behavior.
         * param: AutoUpdateEnabled: 	This is applicable for result sets which might update
         *   dynamically, for example the current playing list for external         
         *   								devices might update on its own.
         * param: ContentMask      //Bitmask combination of eTitleContentType. Bitmask
         *   combination for what content is expected - Audio/Video/Image.                 
         *    returns:	  numResults: The number of records matching the search criteria.
         *   (The number of results might not be accurate for ipod iAP1 like devices)      
         *                returns      sessionQueryID:The sessionQueryID allotted.This
         *   uniquely identifies a particular session query/filter for retrieving data in a
         *   session and it has to be passed                                        for
         *   furthur setting the sessionQuery window and retrieving the contents of that
         *   window.
         */
        "<method name=\"setSessionQuery\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_slotId\" type=\"y\" direction=\"in\" />\n"
            "<arg name=\"_filterIDs\" type=\"a{it}\" direction=\"in\" />\n"
            "<arg name=\"_filters\" type=\"a{is}\" direction=\"in\" />\n"
            "<arg name=\"_resultType\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"_metadataAttributes\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_metadataCountTypes\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_type\" type=\"i\" direction=\"in\" />\n"
            "<arg name=\"_resetPrevious\" type=\"b\" direction=\"in\" />\n"
            "<arg name=\"_AutoUpdateEnabled\" type=\"b\" direction=\"in\" />\n"
            "<arg name=\"_ContentMask\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_numResults\" type=\"t\" direction=\"out\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"u\" direction=\"out\" />\n"
            "<arg name=\"_breadcrumbpath\" type=\"s\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Ask presentation control to fetch the desired set of entries for a particular
         *   session query. This call does not block for the result to complete, and will
         *   override 					  the last request given to Pres Ctrl.
         * param: sessionID: 	The Session ID alloted.
         * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
         *   particular session query/filter for retrieving data in a session and it has to
         *   be passed                                        for furthur setting the
         *   sessionQuery window and retrieving the contents of that window.
         * param: startIndex:	The index to start fetching.
         * param: numItems:		The number of items to fetch.
         */
        "<method name=\"setSessionQueryWindow\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_startIndex\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"_numItems\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Reselects the previous selected session query criteria. The previously shared
         *   sessionQueryID  will be returned.
         */
        "<method name=\"gotoPreviousSessionQuery\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_numResults\" type=\"t\" direction=\"out\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"u\" direction=\"out\" />\n"
            "<arg name=\"_browselevel\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_breadcrumbpath\" type=\"s\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: HMI Can use this to do a direct jump to any previous query ids
         */
        "<method name=\"jumpToSessionQuery\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_numResults\" type=\"t\" direction=\"out\" />\n"
            "<arg name=\"_breadcrumbpath\" type=\"s\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: Play session category. This api handles all requests to play metadata browse
         *   results, database searches, etc .                                             
         *      For this API, HMI should have initially done a openSession used the
         *   setSessionQuery to browse something. Then playSession                will play
         *   the currently selected browse context.                                1st
         *   Example:                               If the HMI wanted to play a list of all
         *   available songs.                                Initially HMI would have got
         *   the list of songs using setSessionQuery.                                Now
         *   playSession will just play the songs of that session.                         
         *      If HMI wants to play a particular song from the list of songs, then HMI can
         *   set the filterID map by:                                passing the id of the
         *   praticular song.                                But if there is a rquirement
         *   that on selecting the partiuclar song, the entire collection has to be played
         *   with the                 selected song maintaining its position/offset, then
         *   this type of playback will be maintained in pres ctrl project               
         *   configuration.                                         2nd Example :          
         *                        We are in the root level of file system and HMI screen
         *   has the list of folders and files.Now HMI selects a file.               We
         *   want to play only that file.                               Then HMI can pass
         *   the fileID in filterIDMap.                               But if the project
         *   requirement is to play that file + other files in the same level together, or
         *   even incude the files from subfolders,then this will               be
         *   maintained as a config parameter in pres.                               or if
         *   there is a button in HMI called "playAll" at each level of file system browse
         *   and on clicking that, we               need to play all the files in that
         *   level. Now for these cases, HMI can just pass the sessionID as an input       
         *          based on project requirements,we can play all the files in the current
         *   folder browse level or include the                 subfolders.
         * param: sessionID: The Session ID alloted.
         * param: filterIDs: The previously communicated numeric identifiers of the different
         *   filter categories.                                     Should be zero for
         *   playAll for the Folderlevel else the file index for playing the particular file
         */
        "<method name=\"playSession\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_filterIDs\" type=\"a{it}\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: This requests the Media pres to play the track of a given position from the
         *   NowPlaying list 	                     trackPosition: Postion of the track from
         *   the NowPlaying list to jump to.
         */
        "<method name=\"gotoTrack\">\n"
            "<arg name=\"_trackPosition\" type=\"t\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
        "</method>\n"
        /**
         * description: This requests the pres to directly jump to the file system level or metadata
         *   browse path level which                     contains the currently playing
         *   track and returns the number of items in that level matching the filter       
         *                 criteria.  	                     For example, after connecting
         *   the USB and selecting it for playback and it starts playing some file         
         *               (which is at the 4th nested level from root).  	                  
         *     Now clicking on browse icon, based on project requirement , we can directly
         *   jump to the 4th nested level                     (assuming it is the
         *   nowplaying level) by calling this API.                     [TODO]:The
         *   interface input & output parameters are yet to be finalized. To check if the
         *   interface can be                     combined with setSessionQuery.
         */
        "<method name=\"gotoNowplayingLevel\">\n"
            "<arg name=\"_sessionID\" type=\"u\" direction=\"in\" />\n"
            "<arg name=\"_slotId\" type=\"y\" direction=\"in\" />\n"
            "<arg name=\"_result\" type=\"i\" direction=\"out\" />\n"
            "<arg name=\"_numItems\" type=\"t\" direction=\"out\" />\n"
            "<arg name=\"_sessionQueryID\" type=\"u\" direction=\"out\" />\n"
        "</method>\n"

    ;
    return introspectionData.c_str();
}

CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v2::com::harman::mmpres::MediaBrowserStub,
        CommonAPI::Version
        > MediaBrowserDBusStubAdapterInternal::getMediaBrowserInterfaceVersionStubDispatcher(&MediaBrowserStub::getInterfaceVersion, "uu");

CommonAPI::DBus::DBusGetAttributeStubDispatcher<
        ::v2::com::harman::mmpres::MediaBrowserStub,
        std::vector<std::string>,
        CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>
        > MediaBrowserDBusStubAdapterInternal::getSearchCandidatesAttributeStubDispatcher(
            &::v2::com::harman::mmpres::MediaBrowserStub::getSearchCandidatesAttribute
            , "as"
            );



/**
 * description: Opens a session for the client communication. This session will be used
 *   internally to uniquely identify a client, and to maintain client specific
 *   caches. 					  The client need not create a new session for every request,
 *   this is rather used to identify different instances of clients.               
 *          returns:     sessionID: Session identifier allocated to the client.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    std::tuple<>,
    std::tuple<uint32_t, ::v2::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::openSessionStubDispatcher(
    &MediaBrowserStub::openSession, "ui",
					std::make_tuple(),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Close a client session and release all associated resources. Once HMI calls
 *   closeSession,they cannot use the same sessionId 	for furthur browsing. For
 *   this, they have to again invoke a openSession to get a new sessionId for
 *   furthur browsing.
 * param: sessionID: The Session ID to close.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t>,
    std::tuple<::v2::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::closeSessionStubDispatcher(
    &MediaBrowserStub::closeSession, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Essentially Stops all background tasks in the specified session. But unlike
 *   closeSession, the sessionID 	 is valid and can be used for furthur browsing.
 * param: sessionID: The Session ID alloted.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t>,
    std::tuple<::v2::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::cancelSessionStubDispatcher(
    &MediaBrowserStub::cancelSession, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Sets a session query. This api handles all requests to fetch metadata browse
 *   results, database searches, file system browse etc.  	 	  	 	 Note: iF HMI
 *   wants to show the categories like ARTISTS,ALBUMS,FOLDERS,GENRES etc on
 *   clicking browse icon,they need not 	 	 use the setSessionQuery. They can
 *   instead use the tSlotUpdate broadcast which contains the tDevice structure.In 
 *   	 	 this, browse capabilities will be provided as a bitmask of different
 *   eMetadataTypes.If HMI is interested in 	 	 the count of these categories,then
 *   HMI can use the MetadataCountMap which is a map of different
 *   eMetadataCountType. 	 	  	 	  	 	 1st Example:  	 	  	 	 Get a list of all
 *   available artists. The filterID's' and filter's' will be empty, and the result
 *   type would be set to artist id.  	 	 Presentation control would return a list
 *   of all available artists / artist id for the medium. 	 	 sessionQueryType will
 *   be METADATA_BROWSE  	 	  	 	 2nd Example: 	 	  	 	 Get a list of all available
 *   artists. Also for each artist,get the count of songs.For this, input
 *   parameters will be same as first example 	 	 but now HMI should pass
 *   metadataCountTypes=eMetadataType::METADATATYPE_SONG. 	 	  	 	 If HMI wants
 *   album count also along with songs count, then metadataCountTypes= bitmask
 *   combination of  	 	 eMetadataType::METADATATYPE_SONG +
 *   eMetadataType::METADATATYPE_ALBUM. 	 	  	 	 sessionQueryType will be
 *   METADATA_BROWSE  	 	  	 	 3rd Example :  	 	  	 	 Get a list of all available
 *   albums by the artist "Pink Floyd". HMI would know the artist id for "Pink
 *   Floyd" because of the previous returned result.  	 	  	 	 In the session
 *   query, HMI sets the filterIDMap as: 	 	  	 	
 *   key=eMetadataType::METADATATYPE_ARTIST,value="artist id" for Pink Floyd  	 	 
 *   	 	 resultType=eMetadataType::METADATATYPE_ALBUM.  	 	  	 	 Presentation
 *   Controller understands what needs to be done here. This can be further
 *   extended by setting 	 	 artist id and album id returned in the previous steps,
 *   and a query for songs can be done.  	 	  	 	 sessionQueryType will be
 *   METADATA_BROWSE. 	 	  	 	 Suppose we need the list of songs inside the artist
 *   "Pink Floyd" but for eah song song, we also need to pass the artist,album  	 	
 *   and genre values. Then this can be done by providing the "metadataAttributes"
 *   input parameter as a bit mask combination of
 *   eMetadataType::METADATATYPE_ARTIST + 	 	 eMetadataType::METADATATYPE_ALBUM &
 *   eMetadataType::METADATATYPE_GENRE. 	 	  	 	 Note that metadataAttributes will
 *   be considered only if the resultType="song". 	 	  	 	 4th Example :  	 	  	 	
 *   Get a list of all available albums by "Pink Floyd", which begin with the
 *   letters "The".  	 	 This is same as the 3rd example, but in addition, the
 *   filter "album" must be set to "The" 	 	  	 	 sessionQueryType will be
 *   METADATA_BROWSE  	 	  	 	 5th example: 	 	  	 	 usage of resetPrevious
 *   parameter. 	 	  	 	 Assume resetPrevious=false: 	 	  	 	 In the first
 *   example,HMI obtained the list of albums for artist "Pink Floyed". Now if HMI
 *   wants list of songs for 	 	 artist "Pink Floyed", then in the filters,HMi need
 *   not mention anything again.  	 	 They can just set
 *   resultype=eMetadataType::METADATATYPE_SONG . 	 	  	 	 Now pres will remember
 *   that artist "Pink Floyd" was already selected. So pres will supply the song
 *   list for artist pink floyd. 	 	  	 	 If resetPrevious=true,pres would not
 *   remeber that Artist Pink Floyd was already selected. In that case, 	 	 HMI has
 *   to set the filterIDMap again by providing the artist id for pink Floyd. 	 	  	
 *   	 Now in the use cases, where the resultType is
 *   "eMetadataType::METADATATYPE_SONG", if the requirement is to show only AUDIO 	
 *   	 or VIDEO or both AUDIO + VIDEO, this can be done by setting "ContentMask"
 *   param as a bit mask of "eTitleContentType". 	 	  	 	
 *   eTitleContentType::TITLETYPE_IMAGE will be applicable for filesystem browse. 
 *   	 	  	 	 6th Example: 	 	  	 	 Do a fileSystem or FOLDER browse.This is
 *   applicable for mass storage devices like USB.At any level, we are  	 	 allowed
 *   to show both folders, files or playlists depending on project requirements. 	
 *   	  	 	 sessionQueryType will be SESSION_QUERY_FS_BROWSE. 	 	  	 	 First go to
 *   root level and show only folders and files but not playlists. For this, the
 *   filterID's and filters are empty, but the resultType will be  	 	 combination
 *   of eMetadataType::METADATATYPE_FOLDER + eMetadataType::METADATATYPE_FILE.With
 *   this query,HMI can get 	 	 the folders and file at a given level in
 *   filesystem. When HMI gets the individual items, they can check the
 *   eMetadataType 	 	 of that item to see if it is a file or folder. 	 	  	 	 Now
 *   HMI wants to go inside one more level by selecting a folder obtained in the
 *   previous step.For this,HMI can set the filterID as  	 	
 *   key=METADATAID_FOLDER_ID and value=(folder id or item id) of folder
 *   communicated in previous step. 	 	  	 	 If at every level, there is a
 *   requirement to list folders first and only then followed by audio files,image
 *   files etc, then 	 	 these will be maintained by pres as project specific
 *   config parameters.  	 	  	 	 Now HMI wants to go inside one of the folders
 *   named "Folder1" listed at the root level.For this,HMI can set the FilterIDMap
 *   as: 	 	  	 	 key: "eMetadataType::METADATATYPE_FOLDER" and value: folder id of
 *   "folder 1" from the result of the first query to  	 	       show the root
 *   level contents. 	 	  	 	 Also if HMI wants the level ID (depth of folder) in
 *   file system browse, such as 4th folder depth or fifth folder depth etc, 	 	
 *   then they can use the sessionQueryID as an indicator of level ID. Each
 *   sessionQueryID will correspond to a 	 	 particular folder depth in file system
 *   browse. 	 	  	 	 7th example: 	 	  	 	 If HMI wants the list of songs from the
 *   recently played list. 	 	  	 	 The can set the sessionQueryType will be
 *   SESSION_QUERY_RECENTLYPLAYED and resultype=eMetadataType::METADATATYPE_SONG 	 
 *      other parameters can be empty.
 * param: filterIDs: The previously communicated numeric identifiers of the different
 *   filter categories.
 * param: filters:	 The string filters which should be applied to the result.
 * param: resultType: The data which is expected from the query.
 * param: sessionID: The Session ID alloted.
 * param: slotId:	 The identifier for the slot.
 * param: type:		 The type of session query.
 * param: metadataAttributes: [TODO]:Pres ctrl can return the required attributes for
 *   each metadata item based on the                                           
 *   client requirements.This is a bitmask combination of eMetadataType values.
 *   This will be                                            supported only for the
 *   song category.
 * param: metadataCountTypes: Pres Ctrl can count the number of items present in a
 *   subcategory. For example, while retreving a list of all artists,          
 *   								  Pres Ctrl can also count how many albums/songs are available for
 *   each artist. (Might be a costly operation depending on Media Type.          
 *   								  	Select this option only if really required )
 * param: resetPrevious: Whether to use old history or not. Pres Ctrl has internal
 *   history mechanism. For example          							 if in the first session query,
 *   the list of all available artists was obtained.In the 2nd browse level, HMI
 *   requested for          							 all albums by a specific artist. If now HMI
 *   wants a list of all songs by the artist, it need not tell the selected artist 
 *            							 again. However if this flag is reset, it will override this
 *   behavior.
 * param: AutoUpdateEnabled: 	This is applicable for result sets which might update
 *   dynamically, for example the current playing list for external         
 *   								devices might update on its own.
 * param: ContentMask      //Bitmask combination of eTitleContentType. Bitmask
 *   combination for what content is expected - Audio/Video/Image.                 
 *    returns:	  numResults: The number of records matching the search criteria.
 *   (The number of results might not be accurate for ipod iAP1 like devices)      
 *                returns      sessionQueryID:The sessionQueryID allotted.This
 *   uniquely identifies a particular session query/filter for retrieving data in a
 *   session and it has to be passed                                        for
 *   furthur setting the sessionQuery window and retrieving the contents of that
 *   window.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t, uint8_t, ::v2::com::harman::mmpres::MMPresTypes::FilterIDMap, ::v2::com::harman::mmpres::MMPresTypes::FilterMap, ::v2::com::harman::mmpres::MMPresTypes::eMetadataType, uint32_t, uint32_t, ::v2::com::harman::mmpres::MMPresTypes::eSessionQueryTypes, bool, bool, uint32_t>,
    std::tuple<::v2::com::harman::mmpres::MMPresTypes::eCallResult, uint64_t, uint32_t, std::string>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, ::v2::com::harman::mmpres::MMPresTypes_::FilterIDMapDeployment_t, ::v2::com::harman::mmpres::MMPresTypes_::FilterMapDeployment_t, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::DBus::StringDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::setSessionQueryStubDispatcher(
    &MediaBrowserStub::setSessionQuery, "itus",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v2::com::harman::mmpres::MMPresTypes_::FilterIDMapDeployment_t*>(nullptr), static_cast<::v2::com::harman::mmpres::MMPresTypes_::FilterMapDeployment_t*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)));

/**
 * description: Ask presentation control to fetch the desired set of entries for a particular
 *   session query. This call does not block for the result to complete, and will
 *   override 					  the last request given to Pres Ctrl.
 * param: sessionID: 	The Session ID alloted.
 * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed                                        for furthur setting the
 *   sessionQuery window and retrieving the contents of that window.
 * param: startIndex:	The index to start fetching.
 * param: numItems:		The number of items to fetch.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t, uint32_t, uint64_t, uint64_t>,
    std::tuple<::v2::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::setSessionQueryWindowStubDispatcher(
    &MediaBrowserStub::setSessionQueryWindow, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: Reselects the previous selected session query criteria. The previously shared
 *   sessionQueryID  will be returned.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t>,
    std::tuple<::v2::com::harman::mmpres::MMPresTypes::eCallResult, uint64_t, uint32_t, ::v2::com::harman::mmpres::MMPresTypes::ePrevBrowseLevel, std::string>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::DBus::StringDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::gotoPreviousSessionQueryStubDispatcher(
    &MediaBrowserStub::gotoPreviousSessionQuery, "ituis",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)));

/**
 * description: HMI Can use this to do a direct jump to any previous query ids
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t, uint32_t>,
    std::tuple<::v2::com::harman::mmpres::MMPresTypes::eCallResult, uint64_t, std::string>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::DBus::StringDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::jumpToSessionQueryStubDispatcher(
    &MediaBrowserStub::jumpToSessionQuery, "its",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)));

/**
 * description: Play session category. This api handles all requests to play metadata browse
 *   results, database searches, etc .                                             
 *      For this API, HMI should have initially done a openSession used the
 *   setSessionQuery to browse something. Then playSession                will play
 *   the currently selected browse context.                                1st
 *   Example:                               If the HMI wanted to play a list of all
 *   available songs.                                Initially HMI would have got
 *   the list of songs using setSessionQuery.                                Now
 *   playSession will just play the songs of that session.                         
 *      If HMI wants to play a particular song from the list of songs, then HMI can
 *   set the filterID map by:                                passing the id of the
 *   praticular song.                                But if there is a rquirement
 *   that on selecting the partiuclar song, the entire collection has to be played
 *   with the                 selected song maintaining its position/offset, then
 *   this type of playback will be maintained in pres ctrl project               
 *   configuration.                                         2nd Example :          
 *                        We are in the root level of file system and HMI screen
 *   has the list of folders and files.Now HMI selects a file.               We
 *   want to play only that file.                               Then HMI can pass
 *   the fileID in filterIDMap.                               But if the project
 *   requirement is to play that file + other files in the same level together, or
 *   even incude the files from subfolders,then this will               be
 *   maintained as a config parameter in pres.                               or if
 *   there is a button in HMI called "playAll" at each level of file system browse
 *   and on clicking that, we               need to play all the files in that
 *   level. Now for these cases, HMI can just pass the sessionID as an input       
 *          based on project requirements,we can play all the files in the current
 *   folder browse level or include the                 subfolders.
 * param: sessionID: The Session ID alloted.
 * param: filterIDs: The previously communicated numeric identifiers of the different
 *   filter categories.                                     Should be zero for
 *   playAll for the Folderlevel else the file index for playing the particular file
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t, ::v2::com::harman::mmpres::MMPresTypes::FilterIDMap>,
    std::tuple<::v2::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<CommonAPI::EmptyDeployment, ::v2::com::harman::mmpres::MMPresTypes_::FilterIDMapDeployment_t>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::playSessionStubDispatcher(
    &MediaBrowserStub::playSession, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<::v2::com::harman::mmpres::MMPresTypes_::FilterIDMapDeployment_t*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: This requests the Media pres to play the track of a given position from the
 *   NowPlaying list 	                     trackPosition: Postion of the track from
 *   the NowPlaying list to jump to.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint64_t>,
    std::tuple<::v2::com::harman::mmpres::MMPresTypes::eCallResult>,
    std::tuple<CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::gotoTrackStubDispatcher(
    &MediaBrowserStub::gotoTrack, "i",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)));

/**
 * description: This requests the pres to directly jump to the file system level or metadata
 *   browse path level which                     contains the currently playing
 *   track and returns the number of items in that level matching the filter       
 *                 criteria.  	                     For example, after connecting
 *   the USB and selecting it for playback and it starts playing some file         
 *               (which is at the 4th nested level from root).  	                  
 *     Now clicking on browse icon, based on project requirement , we can directly
 *   jump to the 4th nested level                     (assuming it is the
 *   nowplaying level) by calling this API.                     [TODO]:The
 *   interface input & output parameters are yet to be finalized. To check if the
 *   interface can be                     combined with setSessionQuery.
 */
CommonAPI::DBus::DBusMethodWithReplyStubDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    std::tuple<uint32_t, uint8_t>,
    std::tuple<::v2::com::harman::mmpres::MMPresTypes::eCallResult, uint64_t, uint32_t>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>,
    std::tuple<CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment, CommonAPI::EmptyDeployment>
    
    > MediaBrowserDBusStubAdapterInternal::gotoNowplayingLevelStubDispatcher(
    &MediaBrowserStub::gotoNowplayingLevel, "itu",
					std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
                	std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)));


void MediaBrowserDBusStubAdapterInternal::fireSearchCandidatesAttributeChanged(const std::vector<std::string>& value) {
    CommonAPI::Deployable<std::vector<std::string>, CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>> deployedValue(value, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>*>(nullptr));
    CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
    CommonAPI::Deployable<
        std::vector<std::string>,
        CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>
    >
    >>
        ::sendSignal(
            *this,
            "onSearchCandidatesAttributeChanged",
            "as",
            deployedValue
    
    );
}

/**
 * description: Will only be posted to the respective listeners if the session query parameters
 *   have changed.  					  For example, for externally played back devices, the
 *   number of items in the currently playing list might change.  Will be published
 *    					  only if auto update was enabled when setting the query.  	            
 *      returns  sessionID:      The Session ID alloted.          returns 
 *   sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed                                        for furthur setting the
 *   sessionQuery window and retrieving the contents of that window.               
 *       returns  numItems:		   The updated number of items for the
 *   sessionID/sessionQueryID.
 */
CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<bool>
    > MediaBrowserDBusStubAdapterInternal::subscribeSessionQueryUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::subscribeForsessionQueryUpdateSelective, "b");

CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<>
    > MediaBrowserDBusStubAdapterInternal::unsubscribeSessionQueryUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::unsubscribeFromsessionQueryUpdateSelective, "");

void MediaBrowserDBusStubAdapterInternal::fireSessionQueryUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> _client, const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const uint64_t &_numResults) {
    std::shared_ptr<CommonAPI::DBus::DBusClientId> dbusClient = std::dynamic_pointer_cast<CommonAPI::DBus::DBusClientId, CommonAPI::ClientId>(_client);

    if(dbusClient)
    {
        CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
        uint32_t,
        uint32_t,
        uint64_t
        >>::sendSignal(
                dbusClient->getDBusId(),
                *this,
                "sessionQueryUpdate",
                "uut",
        _sessionID,
        _sessionQueryID,
        _numResults
        );
    }
}

void MediaBrowserDBusStubAdapterInternal::sendSessionQueryUpdateSelective(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const uint64_t &_numResults, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    std::shared_ptr<CommonAPI::ClientIdList> actualReceiverList = _receivers;

    if (!_receivers)
        actualReceiverList = subscribersForSessionQueryUpdateSelective_;

    for (auto clientIdIterator = actualReceiverList->cbegin(); clientIdIterator != actualReceiverList->cend(); clientIdIterator++) {
        if (!_receivers || subscribersForSessionQueryUpdateSelective_->find(*clientIdIterator) != subscribersForSessionQueryUpdateSelective_->end()) {
            fireSessionQueryUpdateSelective(*clientIdIterator, _sessionID, _sessionQueryID, _numResults);
        }
    }
}

void MediaBrowserDBusStubAdapterInternal::subscribeForsessionQueryUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId, bool& success) {
    bool ok = MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryUpdateSelectiveSubscriptionRequested(clientId);
    if (ok) {
        subscribersForSessionQueryUpdateSelective_->insert(clientId);
        MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::SUBSCRIBED);
        success = true;
    } else {
        success = false;
    }
}

void MediaBrowserDBusStubAdapterInternal::unsubscribeFromsessionQueryUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId) {
    subscribersForSessionQueryUpdateSelective_->erase(clientId);
    MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::UNSUBSCRIBED);
}

std::shared_ptr<CommonAPI::ClientIdList> const MediaBrowserDBusStubAdapterInternal::getSubscribersForSessionQueryUpdateSelective() {
    return subscribersForSessionQueryUpdateSelective_;
}
/**
 * description: Publishes the query status to all clients. The client can get the data once the
 *   query is "finished" 	 	     returns  sessionID: 	   The Session ID alloted.   
 *         returns  sessionQueryID:  The sessionQueryID allotted.This uniquely
 *   identifies a particular session query/filter for retrieving data in a session
 *   and it has to be passed                                        for furthur
 *   setting the sessionQuery window and retrieving the contents of that window.   
 *                 returns  eQueryStatus:    query status of the window update.    
 *        returns  startIndex:	   The index to start fetching.            returns 
 *   numItems:		   The number of items to fetch.          returns  itemList:       
 *    List of tMetadataItems.                    returns
 *   windowContainsCurrentlyPlayingTrack: This will be true if one of the
 *   tMetadataItems is the currently playing track.                   returns
 *   itemIndexTobeHighlighted: // index of the item to be highlighted in the
 *   returned nowPlaying list. If the                                              
 *    currently playing item is not part of the returned window, then this will be
 *   assigned 0.
 */
CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<bool>
    > MediaBrowserDBusStubAdapterInternal::subscribeSessionQueryWindowUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::subscribeForsessionQueryWindowUpdateSelective, "b");

CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<>
    > MediaBrowserDBusStubAdapterInternal::unsubscribeSessionQueryWindowUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::unsubscribeFromsessionQueryWindowUpdateSelective, "");

void MediaBrowserDBusStubAdapterInternal::fireSessionQueryWindowUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> _client, const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const ::v2::com::harman::mmpres::MMPresTypes::eQueryStatus &_status, const uint64_t &_startIndex, const uint64_t &_numItems, const ::v2::com::harman::mmpres::MMPresTypes::MetadataItemList &_itemList, const bool &_windowContainsCurrentlyPlayingTrack, const uint64_t &_itemIndexTobeHighlighted) {
    std::shared_ptr<CommonAPI::DBus::DBusClientId> dbusClient = std::dynamic_pointer_cast<CommonAPI::DBus::DBusClientId, CommonAPI::ClientId>(_client);

    if(dbusClient)
    {
        CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
        uint32_t,
        uint32_t,
        ::v2::com::harman::mmpres::MMPresTypes::eQueryStatus,
        uint64_t,
        uint64_t,
        CommonAPI::Deployable<::v2::com::harman::mmpres::MMPresTypes::MetadataItemList, ::v2::com::harman::mmpres::MMPresTypes_::MetadataItemListDeployment_t>,
        bool,
        uint64_t
        >>::sendSignal(
                dbusClient->getDBusId(),
                *this,
                "sessionQueryWindowUpdate",
                "uuitta(tsbbiia{it}a{is}i)bt",
        _sessionID,
        _sessionQueryID,
        _status,
        _startIndex,
        _numItems,
        CommonAPI::Deployable<::v2::com::harman::mmpres::MMPresTypes::MetadataItemList, ::v2::com::harman::mmpres::MMPresTypes_::MetadataItemListDeployment_t>(_itemList, static_cast<::v2::com::harman::mmpres::MMPresTypes_::MetadataItemListDeployment_t*>(nullptr)),
        _windowContainsCurrentlyPlayingTrack,
        _itemIndexTobeHighlighted
        );
    }
}

void MediaBrowserDBusStubAdapterInternal::sendSessionQueryWindowUpdateSelective(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const ::v2::com::harman::mmpres::MMPresTypes::eQueryStatus &_status, const uint64_t &_startIndex, const uint64_t &_numItems, const ::v2::com::harman::mmpres::MMPresTypes::MetadataItemList &_itemList, const bool &_windowContainsCurrentlyPlayingTrack, const uint64_t &_itemIndexTobeHighlighted, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    std::shared_ptr<CommonAPI::ClientIdList> actualReceiverList = _receivers;

    if (!_receivers)
        actualReceiverList = subscribersForSessionQueryWindowUpdateSelective_;

    for (auto clientIdIterator = actualReceiverList->cbegin(); clientIdIterator != actualReceiverList->cend(); clientIdIterator++) {
        if (!_receivers || subscribersForSessionQueryWindowUpdateSelective_->find(*clientIdIterator) != subscribersForSessionQueryWindowUpdateSelective_->end()) {
            fireSessionQueryWindowUpdateSelective(*clientIdIterator, _sessionID, _sessionQueryID, _status, _startIndex, _numItems, _itemList, _windowContainsCurrentlyPlayingTrack, _itemIndexTobeHighlighted);
        }
    }
}

void MediaBrowserDBusStubAdapterInternal::subscribeForsessionQueryWindowUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId, bool& success) {
    bool ok = MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryWindowUpdateSelectiveSubscriptionRequested(clientId);
    if (ok) {
        subscribersForSessionQueryWindowUpdateSelective_->insert(clientId);
        MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryWindowUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::SUBSCRIBED);
        success = true;
    } else {
        success = false;
    }
}

void MediaBrowserDBusStubAdapterInternal::unsubscribeFromsessionQueryWindowUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId) {
    subscribersForSessionQueryWindowUpdateSelective_->erase(clientId);
    MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryWindowUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::UNSUBSCRIBED);
}

std::shared_ptr<CommonAPI::ClientIdList> const MediaBrowserDBusStubAdapterInternal::getSubscribersForSessionQueryWindowUpdateSelective() {
    return subscribersForSessionQueryWindowUpdateSelective_;
}
/**
 * description: Publishes the thumbnaillistUpdate to all clients. The client can get the data
 *   once the query is "finished". Applicable only for Video browsing              
 *              returns  sessionID:        The Session ID alloted.          returns
 *    sessionQueryID:     The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed                                        for furthur setting the
 *   sessionQuery window and retrieving the contents of that window.               
 *     returns  startIndex:         The index to start fetching.            returns
 *    numItems:           The number of items to fetch.          returns 
 *   thumbnailist:       List of thumbNail paths.
 */
CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<bool>
    > MediaBrowserDBusStubAdapterInternal::subscribeThumbnailListUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::subscribeForthumbnailListUpdateSelective, "b");

CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<>
    > MediaBrowserDBusStubAdapterInternal::unsubscribeThumbnailListUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::unsubscribeFromthumbnailListUpdateSelective, "");

void MediaBrowserDBusStubAdapterInternal::fireThumbnailListUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> _client, const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const uint64_t &_startIndex, const uint64_t &_numItems, const std::vector<std::string> &_thumbnaiList) {
    std::shared_ptr<CommonAPI::DBus::DBusClientId> dbusClient = std::dynamic_pointer_cast<CommonAPI::DBus::DBusClientId, CommonAPI::ClientId>(_client);

    if(dbusClient)
    {
        CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
        uint32_t,
        uint32_t,
        uint64_t,
        uint64_t,
        CommonAPI::Deployable<std::vector<std::string>, CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>>
        >>::sendSignal(
                dbusClient->getDBusId(),
                *this,
                "thumbnailListUpdate",
                "uuttas",
        _sessionID,
        _sessionQueryID,
        _startIndex,
        _numItems,
        CommonAPI::Deployable<std::vector<std::string>, CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>>(_thumbnaiList, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>*>(nullptr))
        );
    }
}

void MediaBrowserDBusStubAdapterInternal::sendThumbnailListUpdateSelective(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const uint64_t &_startIndex, const uint64_t &_numItems, const std::vector<std::string> &_thumbnaiList, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    std::shared_ptr<CommonAPI::ClientIdList> actualReceiverList = _receivers;

    if (!_receivers)
        actualReceiverList = subscribersForThumbnailListUpdateSelective_;

    for (auto clientIdIterator = actualReceiverList->cbegin(); clientIdIterator != actualReceiverList->cend(); clientIdIterator++) {
        if (!_receivers || subscribersForThumbnailListUpdateSelective_->find(*clientIdIterator) != subscribersForThumbnailListUpdateSelective_->end()) {
            fireThumbnailListUpdateSelective(*clientIdIterator, _sessionID, _sessionQueryID, _startIndex, _numItems, _thumbnaiList);
        }
    }
}

void MediaBrowserDBusStubAdapterInternal::subscribeForthumbnailListUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId, bool& success) {
    bool ok = MediaBrowserDBusStubAdapterHelper::stub_->onThumbnailListUpdateSelectiveSubscriptionRequested(clientId);
    if (ok) {
        subscribersForThumbnailListUpdateSelective_->insert(clientId);
        MediaBrowserDBusStubAdapterHelper::stub_->onThumbnailListUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::SUBSCRIBED);
        success = true;
    } else {
        success = false;
    }
}

void MediaBrowserDBusStubAdapterInternal::unsubscribeFromthumbnailListUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId) {
    subscribersForThumbnailListUpdateSelective_->erase(clientId);
    MediaBrowserDBusStubAdapterHelper::stub_->onThumbnailListUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::UNSUBSCRIBED);
}

std::shared_ptr<CommonAPI::ClientIdList> const MediaBrowserDBusStubAdapterInternal::getSubscribersForThumbnailListUpdateSelective() {
    return subscribersForThumbnailListUpdateSelective_;
}
/**
 * description: Publishes the query status to all clients. The client can get the data once the
 *   query is "finished" 	 	     returns  sessionID: 	   The Session ID alloted.   
 *         returns  sessionQueryID:  The sessionQueryID for the Alphajump reply    
 *                 returns ajList: 		   an array of structure containing Alphabets
 *   and their index
 */
CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<bool>
    > MediaBrowserDBusStubAdapterInternal::subscribeSessionQueryAlphaJumpUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::subscribeForsessionQueryAlphaJumpUpdateSelective, "b");

CommonAPI::DBus::DBusMethodWithReplyAdapterDispatcher<
    ::v2::com::harman::mmpres::MediaBrowserStub,
    MediaBrowserStubAdapter,
    std::tuple<>,
    std::tuple<>
    > MediaBrowserDBusStubAdapterInternal::unsubscribeSessionQueryAlphaJumpUpdateSelectiveStubDispatcher(&MediaBrowserStubAdapter::unsubscribeFromsessionQueryAlphaJumpUpdateSelective, "");

void MediaBrowserDBusStubAdapterInternal::fireSessionQueryAlphaJumpUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> _client, const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const ::v2::com::harman::mmpres::MMPresTypes::arAlphaIndex &_ajList) {
    std::shared_ptr<CommonAPI::DBus::DBusClientId> dbusClient = std::dynamic_pointer_cast<CommonAPI::DBus::DBusClientId, CommonAPI::ClientId>(_client);

    if(dbusClient)
    {
        CommonAPI::DBus::DBusStubSignalHelper<CommonAPI::DBus::DBusSerializableArguments<
        uint32_t,
        uint32_t,
        CommonAPI::Deployable<::v2::com::harman::mmpres::MMPresTypes::arAlphaIndex, ::v2::com::harman::mmpres::MMPresTypes_::arAlphaIndexDeployment_t>
        >>::sendSignal(
                dbusClient->getDBusId(),
                *this,
                "sessionQueryAlphaJumpUpdate",
                "uua(su)",
        _sessionID,
        _sessionQueryID,
        CommonAPI::Deployable<::v2::com::harman::mmpres::MMPresTypes::arAlphaIndex, ::v2::com::harman::mmpres::MMPresTypes_::arAlphaIndexDeployment_t>(_ajList, static_cast<::v2::com::harman::mmpres::MMPresTypes_::arAlphaIndexDeployment_t*>(nullptr))
        );
    }
}

void MediaBrowserDBusStubAdapterInternal::sendSessionQueryAlphaJumpUpdateSelective(const uint32_t &_sessionID, const uint32_t &_sessionQueryID, const ::v2::com::harman::mmpres::MMPresTypes::arAlphaIndex &_ajList, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    std::shared_ptr<CommonAPI::ClientIdList> actualReceiverList = _receivers;

    if (!_receivers)
        actualReceiverList = subscribersForSessionQueryAlphaJumpUpdateSelective_;

    for (auto clientIdIterator = actualReceiverList->cbegin(); clientIdIterator != actualReceiverList->cend(); clientIdIterator++) {
        if (!_receivers || subscribersForSessionQueryAlphaJumpUpdateSelective_->find(*clientIdIterator) != subscribersForSessionQueryAlphaJumpUpdateSelective_->end()) {
            fireSessionQueryAlphaJumpUpdateSelective(*clientIdIterator, _sessionID, _sessionQueryID, _ajList);
        }
    }
}

void MediaBrowserDBusStubAdapterInternal::subscribeForsessionQueryAlphaJumpUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId, bool& success) {
    bool ok = MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryAlphaJumpUpdateSelectiveSubscriptionRequested(clientId);
    if (ok) {
        subscribersForSessionQueryAlphaJumpUpdateSelective_->insert(clientId);
        MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryAlphaJumpUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::SUBSCRIBED);
        success = true;
    } else {
        success = false;
    }
}

void MediaBrowserDBusStubAdapterInternal::unsubscribeFromsessionQueryAlphaJumpUpdateSelective(const std::shared_ptr<CommonAPI::ClientId> clientId) {
    subscribersForSessionQueryAlphaJumpUpdateSelective_->erase(clientId);
    MediaBrowserDBusStubAdapterHelper::stub_->onSessionQueryAlphaJumpUpdateSelectiveSubscriptionChanged(clientId, CommonAPI::SelectiveBroadcastSubscriptionEvent::UNSUBSCRIBED);
}

std::shared_ptr<CommonAPI::ClientIdList> const MediaBrowserDBusStubAdapterInternal::getSubscribersForSessionQueryAlphaJumpUpdateSelective() {
    return subscribersForSessionQueryAlphaJumpUpdateSelective_;
}


const MediaBrowserDBusStubAdapterHelper::StubDispatcherTable& MediaBrowserDBusStubAdapterInternal::getStubDispatcherTable() {
    return stubDispatcherTable_;
}

const CommonAPI::DBus::StubAttributeTable& MediaBrowserDBusStubAdapterInternal::getStubAttributeTable() {
    return stubAttributeTable_;
}

MediaBrowserDBusStubAdapterInternal::MediaBrowserDBusStubAdapterInternal(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection,
        const std::shared_ptr<CommonAPI::StubBase> &_stub)
	: CommonAPI::DBus::DBusStubAdapter(_address, _connection,false),
      MediaBrowserDBusStubAdapterHelper(_address, _connection, std::dynamic_pointer_cast<MediaBrowserStub>(_stub), false),
      stubDispatcherTable_({
            { { "getSearchCandidatesAttribute", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::getSearchCandidatesAttributeStubDispatcher }
            ,
            /**
             * description: Opens a session for the client communication. This session will be used
             *   internally to uniquely identify a client, and to maintain client specific
             *   caches. 					  The client need not create a new session for every request,
             *   this is rather used to identify different instances of clients.               
             *          returns:     sessionID: Session identifier allocated to the client.
             */
            { { "openSession", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::openSessionStubDispatcher },
            /**
             * description: Close a client session and release all associated resources. Once HMI calls
             *   closeSession,they cannot use the same sessionId 	for furthur browsing. For
             *   this, they have to again invoke a openSession to get a new sessionId for
             *   furthur browsing.
             * param: sessionID: The Session ID to close.
             */
            { { "closeSession", "u" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::closeSessionStubDispatcher },
            /**
             * description: Essentially Stops all background tasks in the specified session. But unlike
             *   closeSession, the sessionID 	 is valid and can be used for furthur browsing.
             * param: sessionID: The Session ID alloted.
             */
            { { "cancelSession", "u" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::cancelSessionStubDispatcher },
            /**
             * description: Sets a session query. This api handles all requests to fetch metadata browse
             *   results, database searches, file system browse etc.  	 	  	 	 Note: iF HMI
             *   wants to show the categories like ARTISTS,ALBUMS,FOLDERS,GENRES etc on
             *   clicking browse icon,they need not 	 	 use the setSessionQuery. They can
             *   instead use the tSlotUpdate broadcast which contains the tDevice structure.In 
             *   	 	 this, browse capabilities will be provided as a bitmask of different
             *   eMetadataTypes.If HMI is interested in 	 	 the count of these categories,then
             *   HMI can use the MetadataCountMap which is a map of different
             *   eMetadataCountType. 	 	  	 	  	 	 1st Example:  	 	  	 	 Get a list of all
             *   available artists. The filterID's' and filter's' will be empty, and the result
             *   type would be set to artist id.  	 	 Presentation control would return a list
             *   of all available artists / artist id for the medium. 	 	 sessionQueryType will
             *   be METADATA_BROWSE  	 	  	 	 2nd Example: 	 	  	 	 Get a list of all available
             *   artists. Also for each artist,get the count of songs.For this, input
             *   parameters will be same as first example 	 	 but now HMI should pass
             *   metadataCountTypes=eMetadataType::METADATATYPE_SONG. 	 	  	 	 If HMI wants
             *   album count also along with songs count, then metadataCountTypes= bitmask
             *   combination of  	 	 eMetadataType::METADATATYPE_SONG +
             *   eMetadataType::METADATATYPE_ALBUM. 	 	  	 	 sessionQueryType will be
             *   METADATA_BROWSE  	 	  	 	 3rd Example :  	 	  	 	 Get a list of all available
             *   albums by the artist "Pink Floyd". HMI would know the artist id for "Pink
             *   Floyd" because of the previous returned result.  	 	  	 	 In the session
             *   query, HMI sets the filterIDMap as: 	 	  	 	
             *   key=eMetadataType::METADATATYPE_ARTIST,value="artist id" for Pink Floyd  	 	 
             *   	 	 resultType=eMetadataType::METADATATYPE_ALBUM.  	 	  	 	 Presentation
             *   Controller understands what needs to be done here. This can be further
             *   extended by setting 	 	 artist id and album id returned in the previous steps,
             *   and a query for songs can be done.  	 	  	 	 sessionQueryType will be
             *   METADATA_BROWSE. 	 	  	 	 Suppose we need the list of songs inside the artist
             *   "Pink Floyd" but for eah song song, we also need to pass the artist,album  	 	
             *   and genre values. Then this can be done by providing the "metadataAttributes"
             *   input parameter as a bit mask combination of
             *   eMetadataType::METADATATYPE_ARTIST + 	 	 eMetadataType::METADATATYPE_ALBUM &
             *   eMetadataType::METADATATYPE_GENRE. 	 	  	 	 Note that metadataAttributes will
             *   be considered only if the resultType="song". 	 	  	 	 4th Example :  	 	  	 	
             *   Get a list of all available albums by "Pink Floyd", which begin with the
             *   letters "The".  	 	 This is same as the 3rd example, but in addition, the
             *   filter "album" must be set to "The" 	 	  	 	 sessionQueryType will be
             *   METADATA_BROWSE  	 	  	 	 5th example: 	 	  	 	 usage of resetPrevious
             *   parameter. 	 	  	 	 Assume resetPrevious=false: 	 	  	 	 In the first
             *   example,HMI obtained the list of albums for artist "Pink Floyed". Now if HMI
             *   wants list of songs for 	 	 artist "Pink Floyed", then in the filters,HMi need
             *   not mention anything again.  	 	 They can just set
             *   resultype=eMetadataType::METADATATYPE_SONG . 	 	  	 	 Now pres will remember
             *   that artist "Pink Floyd" was already selected. So pres will supply the song
             *   list for artist pink floyd. 	 	  	 	 If resetPrevious=true,pres would not
             *   remeber that Artist Pink Floyd was already selected. In that case, 	 	 HMI has
             *   to set the filterIDMap again by providing the artist id for pink Floyd. 	 	  	
             *   	 Now in the use cases, where the resultType is
             *   "eMetadataType::METADATATYPE_SONG", if the requirement is to show only AUDIO 	
             *   	 or VIDEO or both AUDIO + VIDEO, this can be done by setting "ContentMask"
             *   param as a bit mask of "eTitleContentType". 	 	  	 	
             *   eTitleContentType::TITLETYPE_IMAGE will be applicable for filesystem browse. 
             *   	 	  	 	 6th Example: 	 	  	 	 Do a fileSystem or FOLDER browse.This is
             *   applicable for mass storage devices like USB.At any level, we are  	 	 allowed
             *   to show both folders, files or playlists depending on project requirements. 	
             *   	  	 	 sessionQueryType will be SESSION_QUERY_FS_BROWSE. 	 	  	 	 First go to
             *   root level and show only folders and files but not playlists. For this, the
             *   filterID's and filters are empty, but the resultType will be  	 	 combination
             *   of eMetadataType::METADATATYPE_FOLDER + eMetadataType::METADATATYPE_FILE.With
             *   this query,HMI can get 	 	 the folders and file at a given level in
             *   filesystem. When HMI gets the individual items, they can check the
             *   eMetadataType 	 	 of that item to see if it is a file or folder. 	 	  	 	 Now
             *   HMI wants to go inside one more level by selecting a folder obtained in the
             *   previous step.For this,HMI can set the filterID as  	 	
             *   key=METADATAID_FOLDER_ID and value=(folder id or item id) of folder
             *   communicated in previous step. 	 	  	 	 If at every level, there is a
             *   requirement to list folders first and only then followed by audio files,image
             *   files etc, then 	 	 these will be maintained by pres as project specific
             *   config parameters.  	 	  	 	 Now HMI wants to go inside one of the folders
             *   named "Folder1" listed at the root level.For this,HMI can set the FilterIDMap
             *   as: 	 	  	 	 key: "eMetadataType::METADATATYPE_FOLDER" and value: folder id of
             *   "folder 1" from the result of the first query to  	 	       show the root
             *   level contents. 	 	  	 	 Also if HMI wants the level ID (depth of folder) in
             *   file system browse, such as 4th folder depth or fifth folder depth etc, 	 	
             *   then they can use the sessionQueryID as an indicator of level ID. Each
             *   sessionQueryID will correspond to a 	 	 particular folder depth in file system
             *   browse. 	 	  	 	 7th example: 	 	  	 	 If HMI wants the list of songs from the
             *   recently played list. 	 	  	 	 The can set the sessionQueryType will be
             *   SESSION_QUERY_RECENTLYPLAYED and resultype=eMetadataType::METADATATYPE_SONG 	 
             *      other parameters can be empty.
             * param: filterIDs: The previously communicated numeric identifiers of the different
             *   filter categories.
             * param: filters:	 The string filters which should be applied to the result.
             * param: resultType: The data which is expected from the query.
             * param: sessionID: The Session ID alloted.
             * param: slotId:	 The identifier for the slot.
             * param: type:		 The type of session query.
             * param: metadataAttributes: [TODO]:Pres ctrl can return the required attributes for
             *   each metadata item based on the                                           
             *   client requirements.This is a bitmask combination of eMetadataType values.
             *   This will be                                            supported only for the
             *   song category.
             * param: metadataCountTypes: Pres Ctrl can count the number of items present in a
             *   subcategory. For example, while retreving a list of all artists,          
             *   								  Pres Ctrl can also count how many albums/songs are available for
             *   each artist. (Might be a costly operation depending on Media Type.          
             *   								  	Select this option only if really required )
             * param: resetPrevious: Whether to use old history or not. Pres Ctrl has internal
             *   history mechanism. For example          							 if in the first session query,
             *   the list of all available artists was obtained.In the 2nd browse level, HMI
             *   requested for          							 all albums by a specific artist. If now HMI
             *   wants a list of all songs by the artist, it need not tell the selected artist 
             *            							 again. However if this flag is reset, it will override this
             *   behavior.
             * param: AutoUpdateEnabled: 	This is applicable for result sets which might update
             *   dynamically, for example the current playing list for external         
             *   								devices might update on its own.
             * param: ContentMask      //Bitmask combination of eTitleContentType. Bitmask
             *   combination for what content is expected - Audio/Video/Image.                 
             *    returns:	  numResults: The number of records matching the search criteria.
             *   (The number of results might not be accurate for ipod iAP1 like devices)      
             *                returns      sessionQueryID:The sessionQueryID allotted.This
             *   uniquely identifies a particular session query/filter for retrieving data in a
             *   session and it has to be passed                                        for
             *   furthur setting the sessionQuery window and retrieving the contents of that
             *   window.
             */
            { { "setSessionQuery", "uya{it}a{is}iuuibbu" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::setSessionQueryStubDispatcher },
            /**
             * description: Ask presentation control to fetch the desired set of entries for a particular
             *   session query. This call does not block for the result to complete, and will
             *   override 					  the last request given to Pres Ctrl.
             * param: sessionID: 	The Session ID alloted.
             * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
             *   particular session query/filter for retrieving data in a session and it has to
             *   be passed                                        for furthur setting the
             *   sessionQuery window and retrieving the contents of that window.
             * param: startIndex:	The index to start fetching.
             * param: numItems:		The number of items to fetch.
             */
            { { "setSessionQueryWindow", "uutt" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::setSessionQueryWindowStubDispatcher },
            /**
             * description: Reselects the previous selected session query criteria. The previously shared
             *   sessionQueryID  will be returned.
             */
            { { "gotoPreviousSessionQuery", "u" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::gotoPreviousSessionQueryStubDispatcher },
            /**
             * description: HMI Can use this to do a direct jump to any previous query ids
             */
            { { "jumpToSessionQuery", "uu" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::jumpToSessionQueryStubDispatcher },
            /**
             * description: Play session category. This api handles all requests to play metadata browse
             *   results, database searches, etc .                                             
             *      For this API, HMI should have initially done a openSession used the
             *   setSessionQuery to browse something. Then playSession                will play
             *   the currently selected browse context.                                1st
             *   Example:                               If the HMI wanted to play a list of all
             *   available songs.                                Initially HMI would have got
             *   the list of songs using setSessionQuery.                                Now
             *   playSession will just play the songs of that session.                         
             *      If HMI wants to play a particular song from the list of songs, then HMI can
             *   set the filterID map by:                                passing the id of the
             *   praticular song.                                But if there is a rquirement
             *   that on selecting the partiuclar song, the entire collection has to be played
             *   with the                 selected song maintaining its position/offset, then
             *   this type of playback will be maintained in pres ctrl project               
             *   configuration.                                         2nd Example :          
             *                        We are in the root level of file system and HMI screen
             *   has the list of folders and files.Now HMI selects a file.               We
             *   want to play only that file.                               Then HMI can pass
             *   the fileID in filterIDMap.                               But if the project
             *   requirement is to play that file + other files in the same level together, or
             *   even incude the files from subfolders,then this will               be
             *   maintained as a config parameter in pres.                               or if
             *   there is a button in HMI called "playAll" at each level of file system browse
             *   and on clicking that, we               need to play all the files in that
             *   level. Now for these cases, HMI can just pass the sessionID as an input       
             *          based on project requirements,we can play all the files in the current
             *   folder browse level or include the                 subfolders.
             * param: sessionID: The Session ID alloted.
             * param: filterIDs: The previously communicated numeric identifiers of the different
             *   filter categories.                                     Should be zero for
             *   playAll for the Folderlevel else the file index for playing the particular file
             */
            { { "playSession", "ua{it}" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::playSessionStubDispatcher },
            /**
             * description: This requests the Media pres to play the track of a given position from the
             *   NowPlaying list 	                     trackPosition: Postion of the track from
             *   the NowPlaying list to jump to.
             */
            { { "gotoTrack", "t" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::gotoTrackStubDispatcher },
            /**
             * description: This requests the pres to directly jump to the file system level or metadata
             *   browse path level which                     contains the currently playing
             *   track and returns the number of items in that level matching the filter       
             *                 criteria.  	                     For example, after connecting
             *   the USB and selecting it for playback and it starts playing some file         
             *               (which is at the 4th nested level from root).  	                  
             *     Now clicking on browse icon, based on project requirement , we can directly
             *   jump to the 4th nested level                     (assuming it is the
             *   nowplaying level) by calling this API.                     [TODO]:The
             *   interface input & output parameters are yet to be finalized. To check if the
             *   interface can be                     combined with setSessionQuery.
             */
            { { "gotoNowplayingLevel", "uy" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::gotoNowplayingLevelStubDispatcher }
            ,
            { { "subscribeForsessionQueryUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::subscribeSessionQueryUpdateSelectiveStubDispatcher }
            ,
            { { "unsubscribeFromsessionQueryUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::unsubscribeSessionQueryUpdateSelectiveStubDispatcher },
            { { "subscribeForsessionQueryWindowUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::subscribeSessionQueryWindowUpdateSelectiveStubDispatcher }
            ,
            { { "unsubscribeFromsessionQueryWindowUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::unsubscribeSessionQueryWindowUpdateSelectiveStubDispatcher },
            { { "subscribeForthumbnailListUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::subscribeThumbnailListUpdateSelectiveStubDispatcher }
            ,
            { { "unsubscribeFromthumbnailListUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::unsubscribeThumbnailListUpdateSelectiveStubDispatcher },
            { { "subscribeForsessionQueryAlphaJumpUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::subscribeSessionQueryAlphaJumpUpdateSelectiveStubDispatcher }
            ,
            { { "unsubscribeFromsessionQueryAlphaJumpUpdateSelective", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::unsubscribeSessionQueryAlphaJumpUpdateSelectiveStubDispatcher }
            }),
        stubAttributeTable_() {
    subscribersForSessionQueryUpdateSelective_ = std::make_shared<CommonAPI::ClientIdList>();
    subscribersForSessionQueryWindowUpdateSelective_ = std::make_shared<CommonAPI::ClientIdList>();
    subscribersForThumbnailListUpdateSelective_ = std::make_shared<CommonAPI::ClientIdList>();
    subscribersForSessionQueryAlphaJumpUpdateSelective_ = std::make_shared<CommonAPI::ClientIdList>();

    stubDispatcherTable_.insert({ { "getInterfaceVersion", "" }, &com::harman::mmpres::MediaBrowserDBusStubAdapterInternal::getMediaBrowserInterfaceVersionStubDispatcher });
}

bool MediaBrowserDBusStubAdapterInternal::hasFreedesktopProperties() {
    return false;
}

} // namespace mmpres
} // namespace harman
} // namespace com
} // namespace v2
