/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1/com/harman/mmpres/MediaPlayerDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace mmpres {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createMediaPlayerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<MediaPlayerDBusProxy>(_address, _connection);
}

INITIALIZER(registerMediaPlayerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		MediaPlayer::getInterface(),
		&createMediaPlayerDBusProxy);
}

MediaPlayerDBusProxy::MediaPlayerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		currentPlayTime_(*this, "onCurrentPlayTimeAttributeChanged", "t", "getCurrentPlayTimeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		totalPlayDuration_(*this, "onTotalPlayDurationAttributeChanged", "t", "getTotalPlayDurationAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		trackState_(*this, "onTrackStateAttributeChanged", "(tt)", "getTrackStateAttribute", static_cast<::v3::com::harman::mmpres::MMPresTypes_::tTrackStateDeployment_t*>(nullptr)),
		nowPlayingData_(*this, "onNowPlayingDataAttributeChanged", "(sssssssssstbtttbi)", "getNowPlayingDataAttribute", static_cast<::v3::com::harman::mmpres::MMPresTypes_::tNowPlayingInfoDeployment_t*>(nullptr)),
		playState_(*this, "onPlayStateAttributeChanged", "i", "getPlayStateAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		speed_(*this, "onSpeedAttributeChanged", "i", "getSpeedAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		repeatMode_(*this, "onRepeatModeAttributeChanged", "i", "getRepeatModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		shuffleMode_(*this, "onShuffleModeAttributeChanged", "i", "getShuffleModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		playbackSpeed_(*this, "onPlaybackSpeedAttributeChanged", "(yii)", "getPlaybackSpeedAttribute", static_cast<::v3::com::harman::mmpres::MMPresTypes_::tPlaybackSpeedDeployment_t*>(nullptr)),
		playsessionState_(*this, "onPlaysessionStateAttributeChanged", "a{yb}", "getPlaysessionStateAttribute", static_cast<::v3::com::harman::mmpres::MMPresTypes_::PlaySessionStateMapDeployment_t*>(nullptr)),
		activeDeviceBTLinkLoss_(*this, "onActiveDeviceBTLinkLossAttributeChanged", "b", "getActiveDeviceBTLinkLossAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		nowPlayingArtworkStatus_(*this, "onNowPlayingArtworkStatusAttributeChanged", "i", "getNowPlayingArtworkStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		playbackPreview_(*this, "onPlaybackPreviewAttributeChanged", "a(tsbbiia{it}a{is}i)", "getPlaybackPreviewAttribute", static_cast<::v3::com::harman::mmpres::MMPresTypes_::MetadataItemListDeployment_t*>(nullptr)),
		videoPlayStatus_(*this, "onVideoPlayStatusAttributeChanged", "b", "getVideoPlayStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		remotePlayerCapability_(*this, "onRemotePlayerCapabilityAttributeChanged", "(yu)", "getRemotePlayerCapabilityAttribute", static_cast<::v3::com::harman::mmpres::MMPresTypes_::tRemotePlayerCapabilityDeployment_t*>(nullptr)),
		mediaError_(*this, "onMediaErrorAttributeChanged", "a{yi}", "getMediaErrorAttribute", static_cast<::v3::com::harman::mmpres::MMPresTypes_::MediaErrorMapDeployment_t*>(nullptr)),
		syncStatus_(*this, "onSyncStatusAttributeChanged", "a{yi}", "getSyncStatusAttribute", static_cast<::v3::com::harman::mmpres::MMPresTypes_::SyncMapDeployment_t*>(nullptr)),
		trackListSupport_(*this, "onTrackListSupportAttributeChanged", "(yb)", "getTrackListSupportAttribute", static_cast<::v3::com::harman::mmpres::MMPresTypes_::tTrackListSupportDeployment_t*>(nullptr)),
		mRemoteCDDiscStatus_(*this, "onMRemoteCDDiscStatusAttributeChanged", "i", "getMRemoteCDDiscStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		mRemoteCDErrorStatus_(*this, "onMRemoteCDErrorStatusAttributeChanged", "(ii)", "getMRemoteCDErrorStatusAttribute", static_cast<::v3::com::harman::mmpres::MMPresTypes_::RemoteCDErrorStatusDeployment_t*>(nullptr)),
		mCDEOLStatus_(*this, "onMCDEOLStatusAttributeChanged", "i", "getMCDEOLStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr))
{
}

      MediaPlayerDBusProxy::CurrentPlayTimeAttribute& MediaPlayerDBusProxy::getCurrentPlayTimeAttribute() {
          return currentPlayTime_;
      }
      MediaPlayerDBusProxy::TotalPlayDurationAttribute& MediaPlayerDBusProxy::getTotalPlayDurationAttribute() {
          return totalPlayDuration_;
      }
      MediaPlayerDBusProxy::TrackStateAttribute& MediaPlayerDBusProxy::getTrackStateAttribute() {
          return trackState_;
      }
      MediaPlayerDBusProxy::NowPlayingDataAttribute& MediaPlayerDBusProxy::getNowPlayingDataAttribute() {
          return nowPlayingData_;
      }
      MediaPlayerDBusProxy::PlayStateAttribute& MediaPlayerDBusProxy::getPlayStateAttribute() {
          return playState_;
      }
      MediaPlayerDBusProxy::SpeedAttribute& MediaPlayerDBusProxy::getSpeedAttribute() {
          return speed_;
      }
      MediaPlayerDBusProxy::RepeatModeAttribute& MediaPlayerDBusProxy::getRepeatModeAttribute() {
          return repeatMode_;
      }
      MediaPlayerDBusProxy::ShuffleModeAttribute& MediaPlayerDBusProxy::getShuffleModeAttribute() {
          return shuffleMode_;
      }
      MediaPlayerDBusProxy::PlaybackSpeedAttribute& MediaPlayerDBusProxy::getPlaybackSpeedAttribute() {
          return playbackSpeed_;
      }
      MediaPlayerDBusProxy::PlaysessionStateAttribute& MediaPlayerDBusProxy::getPlaysessionStateAttribute() {
          return playsessionState_;
      }
      MediaPlayerDBusProxy::ActiveDeviceBTLinkLossAttribute& MediaPlayerDBusProxy::getActiveDeviceBTLinkLossAttribute() {
          return activeDeviceBTLinkLoss_;
      }
      MediaPlayerDBusProxy::NowPlayingArtworkStatusAttribute& MediaPlayerDBusProxy::getNowPlayingArtworkStatusAttribute() {
          return nowPlayingArtworkStatus_;
      }
      MediaPlayerDBusProxy::PlaybackPreviewAttribute& MediaPlayerDBusProxy::getPlaybackPreviewAttribute() {
          return playbackPreview_;
      }
      MediaPlayerDBusProxy::VideoPlayStatusAttribute& MediaPlayerDBusProxy::getVideoPlayStatusAttribute() {
          return videoPlayStatus_;
      }
      MediaPlayerDBusProxy::RemotePlayerCapabilityAttribute& MediaPlayerDBusProxy::getRemotePlayerCapabilityAttribute() {
          return remotePlayerCapability_;
      }
      MediaPlayerDBusProxy::MediaErrorAttribute& MediaPlayerDBusProxy::getMediaErrorAttribute() {
          return mediaError_;
      }
      MediaPlayerDBusProxy::SyncStatusAttribute& MediaPlayerDBusProxy::getSyncStatusAttribute() {
          return syncStatus_;
      }
      MediaPlayerDBusProxy::TrackListSupportAttribute& MediaPlayerDBusProxy::getTrackListSupportAttribute() {
          return trackListSupport_;
      }
      MediaPlayerDBusProxy::MRemoteCDDiscStatusAttribute& MediaPlayerDBusProxy::getMRemoteCDDiscStatusAttribute() {
          return mRemoteCDDiscStatus_;
      }
      MediaPlayerDBusProxy::MRemoteCDErrorStatusAttribute& MediaPlayerDBusProxy::getMRemoteCDErrorStatusAttribute() {
          return mRemoteCDErrorStatus_;
      }
      MediaPlayerDBusProxy::MCDEOLStatusAttribute& MediaPlayerDBusProxy::getMCDEOLStatusAttribute() {
          return mCDEOLStatus_;
      }

    
    /**
     * description: Method to initiate the playback of all items of a specific object type in the
     *   device
     */
    void MediaPlayerDBusProxy::playAll(const uint8_t &_slotId, const ::v3::com::harman::mmpres::MMPresTypes::eMetadataType &_objectType, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_objectType(_objectType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "playAll",
        "yi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_slotId, deploy_objectType,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::playAllAsync(const uint8_t &_slotId, const ::v3::com::harman::mmpres::MMPresTypes::eMetadataType &_objectType, PlayAllAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_objectType(_objectType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "playAll",
        "yi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_slotId, deploy_objectType,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::next(const uint64_t &_step, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "next",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_step,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::nextAsync(const uint64_t &_step, NextAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "next",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_step,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::previous(const uint64_t &_step, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "previous",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_step,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::previousAsync(const uint64_t &_step, PreviousAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "previous",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_step,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::pause(CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "pause",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::pauseAsync(PauseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "pause",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::resume(CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "resume",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::resumeAsync(ResumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "resume",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::seekToTime(const uint64_t &_timePosition, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_timePosition(_timePosition, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "seekToTime",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_timePosition,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::seekToTimeAsync(const uint64_t &_timePosition, SeekToTimeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_timePosition(_timePosition, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "seekToTime",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_timePosition,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::fastForward(CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "fastForward",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::fastForwardAsync(FastForwardAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "fastForward",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::fastReverse(CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "fastReverse",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::fastReverseAsync(FastReverseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "fastReverse",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::setRepeat(const ::v3::com::harman::mmpres::MMPresTypes::eRepeatMode &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setRepeat",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mode,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::setRepeatAsync(const ::v3::com::harman::mmpres::MMPresTypes::eRepeatMode &_mode, SetRepeatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setRepeat",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::setShuffle(const ::v3::com::harman::mmpres::MMPresTypes::eShuffleMode &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setShuffle",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mode,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::setShuffleAsync(const ::v3::com::harman::mmpres::MMPresTypes::eShuffleMode &_mode, SetShuffleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setShuffle",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::getNowPlayingAlbumArtInformation(CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation &_albumArtInfo, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getNowPlayingAlbumArtInformation",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_albumArtInfo);
_albumArtInfo = deploy_albumArtInfo.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getNowPlayingAlbumArtInformationAsync(GetNowPlayingAlbumArtInformationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getNowPlayingAlbumArtInformation",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> _albumArtInfo) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtInfo.getValue());
        },
        std::make_tuple(deploy_albumArtInfo));
    }
    void MediaPlayerDBusProxy::getNowPlayingAlbumArtPath(const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::string &_path, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getNowPlayingAlbumArtPath",
        "y",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_imageNumber,
_internalCallStatus,
deploy_path);
_path = deploy_path.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getNowPlayingAlbumArtPathAsync(const uint8_t &_imageNumber, GetNowPlayingAlbumArtPathAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getNowPlayingAlbumArtPath",
        "y",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _path) {
        	if (_callback)
        		_callback(_internalCallStatus, _path.getValue());
        },
        std::make_tuple(deploy_path));
    }
    void MediaPlayerDBusProxy::getNowPlayingAlbumArtData(const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::vector<uint8_t> &_albumArtData, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getNowPlayingAlbumArtData",
        "y",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_imageNumber,
_internalCallStatus,
deploy_albumArtData);
_albumArtData = deploy_albumArtData.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getNowPlayingAlbumArtDataAsync(const uint8_t &_imageNumber, GetNowPlayingAlbumArtDataAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getNowPlayingAlbumArtData",
        "y",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _albumArtData) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtData.getValue());
        },
        std::make_tuple(deploy_albumArtData));
    }
    void MediaPlayerDBusProxy::getAlbumArtInformationForTrack(const uint64_t &_trackId, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation &_albumArtInfo, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getAlbumArtInformationForTrack",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_trackId,
_internalCallStatus,
deploy_albumArtInfo);
_albumArtInfo = deploy_albumArtInfo.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getAlbumArtInformationForTrackAsync(const uint64_t &_trackId, GetAlbumArtInformationForTrackAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getAlbumArtInformationForTrack",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_trackId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v3::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> _albumArtInfo) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtInfo.getValue());
        },
        std::make_tuple(deploy_albumArtInfo));
    }
    void MediaPlayerDBusProxy::getAlbumArtPathForTrack(const uint64_t &_trackId, const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::string &_path, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getAlbumArtPathForTrack",
        "ty",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_trackId, deploy_imageNumber,
_internalCallStatus,
deploy_path);
_path = deploy_path.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getAlbumArtPathForTrackAsync(const uint64_t &_trackId, const uint8_t &_imageNumber, GetAlbumArtPathForTrackAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getAlbumArtPathForTrack",
        "ty",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_trackId, deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _path) {
        	if (_callback)
        		_callback(_internalCallStatus, _path.getValue());
        },
        std::make_tuple(deploy_path));
    }
    void MediaPlayerDBusProxy::getAlbumArtDataForTrack(const uint64_t &_trackId, const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::vector<uint8_t> &_albumArtData, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getAlbumArtDataForTrack",
        "ty",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_trackId, deploy_imageNumber,
_internalCallStatus,
deploy_albumArtData);
_albumArtData = deploy_albumArtData.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getAlbumArtDataForTrackAsync(const uint64_t &_trackId, const uint8_t &_imageNumber, GetAlbumArtDataForTrackAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getAlbumArtDataForTrack",
        "ty",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_trackId, deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _albumArtData) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtData.getValue());
        },
        std::make_tuple(deploy_albumArtData));
    }
    void MediaPlayerDBusProxy::setSpeed(const uint8_t &_slotId, const ::v3::com::harman::mmpres::MMPresTypes::eMetadataType &_type, const ::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed &_speed, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment> deploy_speed(_speed, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setSpeed",
        "yii",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_slotId, deploy_type, deploy_speed,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::setSpeedAsync(const uint8_t &_slotId, const ::v3::com::harman::mmpres::MMPresTypes::eMetadataType &_type, const ::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed &_speed, SetSpeedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment> deploy_speed(_speed, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setSpeed",
        "yii",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_slotId, deploy_type, deploy_speed,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::getSpeed(const uint8_t &_slotId, const ::v3::com::harman::mmpres::MMPresTypes::eMetadataType &_type, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed &_speed, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment> deploy_speed(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getSpeed",
        "yi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_slotId, deploy_type,
_internalCallStatus,
deploy_speed);
_speed = deploy_speed.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getSpeedAsync(const uint8_t &_slotId, const ::v3::com::harman::mmpres::MMPresTypes::eMetadataType &_type, GetSpeedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment> deploy_speed(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getSpeed",
        "yi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_slotId, deploy_type,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment> _speed) {
        	if (_callback)
        		_callback(_internalCallStatus, _speed.getValue());
        },
        std::make_tuple(deploy_speed));
    }
    /**
     * description: Promote the track
     * param: fileId is the fileID of the iTunes Station to be promoted. 0 can be used for
     *   current station
     */
    void MediaPlayerDBusProxy::promote(const uint64_t &_fileId, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_fileId(_fileId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "promote",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_fileId,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::promoteAsync(const uint64_t &_fileId, PromoteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_fileId(_fileId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "promote",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_fileId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    /**
     * description: demote the track
     * param: fileId is the fileID of the iTunes Station to be demoted. 0 can be used for
     *   current station
     */
    void MediaPlayerDBusProxy::demote(const uint64_t &_fileId, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_fileId(_fileId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "demote",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_fileId,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::demoteAsync(const uint64_t &_fileId, DemoteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_fileId(_fileId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "demote",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_fileId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    /**
     * description: add iTunes station to a WishList
     * param: fileId is the fileID of the iTunes Station to be added to the wishlist. 0 can
     *   be used for current station
     */
    void MediaPlayerDBusProxy::addToWishList(const uint64_t &_fileId, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_fileId(_fileId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "addToWishList",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_fileId,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::addToWishListAsync(const uint64_t &_fileId, AddToWishListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_fileId(_fileId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "addToWishList",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_fileId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }


void MediaPlayerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 1;
      }

      } // namespace mmpres
      } // namespace harman
      } // namespace com
      } // namespace v1
