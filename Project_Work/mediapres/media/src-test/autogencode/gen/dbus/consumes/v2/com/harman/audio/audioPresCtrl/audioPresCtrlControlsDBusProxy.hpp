/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus .
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: This is a Common API DBUS control interface of audio presentation controller
 *   for Orinoco 2.0
 * author: AYatheesh
 */
#ifndef V2_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_DBUS_PROXY_HPP_
#define V2_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_DBUS_PROXY_HPP_

#include <v2/com/harman/audio/audioPresCtrl/audioPresCtrlControlsProxyBase.hpp>
#include "v2/com/harman/audio/audioPresCtrl/audioPresCtrlControlsDBusDeployment.hpp"

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/DBus/DBusAddress.hpp>
#include <CommonAPI/DBus/DBusFactory.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/DBus/DBusAttribute.hpp>
#include <CommonAPI/DBus/DBusEvent.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

#include <string>

namespace v2 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

class audioPresCtrlControlsDBusProxy
    : virtual public audioPresCtrlControlsProxyBase, 
      virtual public CommonAPI::DBus::DBusProxy {
public:
    audioPresCtrlControlsDBusProxy(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection);

    virtual ~audioPresCtrlControlsDBusProxy() { }

    virtual ActiveAudioSourcesAttribute& getActiveAudioSourcesAttribute();
    virtual ActiveEntSourceAttribute& getActiveEntSourceAttribute();
    virtual EntSourceListAttribute& getEntSourceListAttribute();

    virtual EntertainmentSrcStatusEvent& getEntertainmentSrcStatusEvent();

    /**
     * description: This method is used to set audio entertainment sources
    	(at)attribute update
     *   activeAudioSource and activeEntSrc
     */
    virtual void SetEntertainmentSrc(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> SetEntertainmentSrcAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceId, SetEntertainmentSrcAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is used to switch Audio Context to the source in the given
     *   group
    	Group needs to be first mentioned in the audiopres.cfg
    	Project may
     *   choose any naming strategy as long as it doesnt conflict with another json key
     *   in the cfg
    	(at)attribute update activeAudioSource and activeEntSrc if a
     *   source switch has happened
    	(at)return eAudioPresErrors
     */
    virtual void SetSourceGroup(const std::string &_sourceGroupName, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> SetSourceGroupAsync(const std::string &_sourceGroupName, SetSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is used to toggle source in the source group
    	SetSourceGroup needs
     *   to be invoked in order to select an active group
    	(at)attribute update
     *   activeAudioSource and activeEntSrc if a source switch has happened
    	(at)return
     *   eAudioPresErrors
     */
    virtual void ToggleInSourceGroup(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> ToggleInSourceGroupAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleInSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is used to toggle source in the order specified in
     *   "toggleNextPreviousStrategy" in audiopes.cfg
    	If no cfg item
     *   toggleNextPreviousStrategy with value is defined , method return an
     *   error
    	toggleNextPreviousStrategy should be used to capture the toggle
     *   sequence of entertainment sources in a project
    	(at)attribute update
     *   activeAudioSource and activeEntSrc if a source switch has
     *   happened	
    	(at)return eAudioPresErrors
     */
    virtual void ToggleSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> ToggleSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eToggleDirection &_direction, ToggleSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: to activate interrupt source with given SourceID
    	Only touchbeep and keytouch
     *   srcs will be supported through requestinformationsource interface
    	as these
     *   are the only sources that will be requested by HMIs
    	Other sources will be
     *   invoked for switch by respective pres ctrl (ex btpres for hfp , projectionpres
     *   for alt audio sources etc)
    	Other sources are kept just so that HMI can track
     *   the active source through attribute activeAudioSource    
    	(at)return
     *   eAudioPresErrors
     */
    virtual void RequestInformationSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> RequestInformationSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, RequestInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: to deactivate interrupt source with given SourceID
    	(at)return eAudioPresErrors
     */
    virtual void ReleaseInformationSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> ReleaseInformationSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eInterruptSrcs &_sourceID, ReleaseInformationSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: to deactivate entertainment source from HMI with given SourceID for example
     *   AudioOff
    	(at)return eAudioPresErrors
     */
    virtual void ReleaseEntertainmentSource(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> ReleaseEntertainmentSourceAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eEntertainmentSrcs &_sourceID, ReleaseEntertainmentSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info);


    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;

private:
   
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<ActiveAudioSourcesAttribute, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>> activeAudioSources_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<ActiveEntSourceAttribute, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceInfoDeployment_t>> activeEntSource_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<EntSourceListAttribute, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::mEntSrcsInfoDeployment_t>> entSourceList_;

    CommonAPI::DBus::DBusEvent<EntertainmentSrcStatusEvent, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceInfo, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes_::sSourceInfoDeployment_t>> entertainmentSrcStatus_;

};

} // namespace audioPresCtrl
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v2

#endif // V2_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Controls_DBUS_PROXY_HPP_

